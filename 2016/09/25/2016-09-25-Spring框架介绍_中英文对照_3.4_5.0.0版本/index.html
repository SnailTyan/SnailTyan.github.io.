<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Spring," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Dependencies">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring框架介绍_中英文对照_3.4_5.0.0版本">
<meta property="og:url" content="http://noahsnail.com/2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/index.html">
<meta property="og:site_name" content="SnailTyan">
<meta property="og:description" content="Dependencies">
<meta property="og:updated_time" content="2016-09-25T13:27:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring框架介绍_中英文对照_3.4_5.0.0版本">
<meta name="twitter:description" content="Dependencies">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://noahsnail.com/2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/"/>





  <title>Spring框架介绍_中英文对照_3.4_5.0.0版本 | SnailTyan</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-83591315-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SnailTyan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://noahsnail.com/2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tyan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SnailTyan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring框架介绍_中英文对照_3.4_5.0.0版本</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  Dependencies
              </div>
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a></p>
<h3 id="3-4-Dependencies"><a href="#3-4-Dependencies" class="headerlink" title="3.4 Dependencies"></a>3.4 Dependencies</h3><p>A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.</p>
<p>标准企业应用不会由一个对象（或Spring用语中的bean）组成。即使是最简单的应用也是由一些对象共同工作，呈现给终端用户用户看到的是一个连续的应用。接下来的一节阐述了如何从定义许多独立的bean定义到完全实现的应用，它是一个通过对象协作来实现目标的过程。</p>
<h4 id="3-4-1-Dependency-Injection"><a href="#3-4-1-Dependency-Injection" class="headerlink" title="3.4.1 Dependency Injection"></a>3.4.1 Dependency Injection</h4><p><em>Dependency injection (DI)</em> is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then <em>injects</em> those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name <em>Inversion of Control (IoC)</em>, of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes, or the Service Locator pattern.</p>
<p><em>依赖注入（DI）</em>是一个处理过程，凭借对象之间依赖关系，也就是和它们一起工作的其它对象，只能通过构造函数参数，传递参数给工厂方法，在构造完成或工厂方法返回对象实例之后再设置对象实例的属性。当创建bean时容器再将这些依赖对象注入进去。这个过程从根本上颠倒了bean本身通过直接构建类或通过一种机制例如服务定位模式来控制依赖对象的实例化或定位，因此命名为<em>控制反转（IoC）</em>。</p>
<p>Code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies, and does not know the location or class of the dependencies. As such, your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.</p>
<p>使用依赖注入原则会使代码更简洁，当对象由依赖关系提供时解耦更有效。对象不会查找它的依赖，不知道依赖的位置和依赖关系的类别。同样的，你的类也变的更容易测试，尤其是依赖关系在接口或抽象基类之间的时候，这种情况下单元测试中会要求存桩或模拟实现。（注：Stub和Mock都是软件测试中使用的东西，如有疑问请自行google或百度）。</p>
<p>DI exists in two major variants, Constructor-based dependency injection and Setter-based dependency injection.</p>
<p>依赖有两个主要变种，基于构造函数的依赖注入和基于Setter的依赖注入。</p>
<p><strong>Constructor-based dependency injection</strong></p>
<p><em>Constructor-based DI</em> is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a <code>static</code> factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a <code>static</code> factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection. Notice that there is nothing <em>special</em> about this class, it is a POJO that has no dependencies on container specific interfaces, base classes or annotations.</p>
<p><em>基于构造函数的依赖注入</em>通过容器调用有参数的构造函数来实现，每个参数表示一个依赖。调用指定参数的静态工厂方法来构造bean是近似等价的，这里的讨论将给构造函数和静态工厂方法传参看成是类似的。接下来的例子展示了一个类仅能通过构建函数注入进行依赖注入。注意这个类没什么特别的，它是一个POJO，不依赖于容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Constructor argument resolution</strong></p>
<p>Constructor argument resolution matching occurs using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, then the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class:</p>
<p>构造函数参数解析使用参数类型进行匹配。如果bean定义的构造函数参数中不存在潜在的歧义，bean定义中定义构造函数参数的顺序为bean实例化时提供给恰当构造函数的参数顺序。细想下面的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> x.y;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>No potential ambiguity exists, assuming that <code>Bar</code> and <code>Baz</code> classes are not related by inheritance. Thus the following configuration works fine, and you do not need to specify the constructor argument indexes and/or types explicitly in the <code>&lt;constructor-arg/&gt;</code> element.</p>
<p>不存在潜在的歧义，假设<code>Bar</code>类和<code>Baz</code>类之间不存在继承关系。因此下面的配置会工作良好，你不必在<code>&lt;constructor-arg/&gt;</code>元素中显式的指定构造函数参数索引的与/或类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as <code>&lt;value&gt;true&lt;/value&gt;</code>, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class:</p>
<p>当引用另一个bean时，类型已知，匹配正确（像上面的例子一样）。当使用简单类型时，例如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring不能决定值的类型，因此没有帮助不能按类型匹配。考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</div><div class="line"></div><div class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></div><div class="line">    <span class="keyword">private</span> String ultimateAnswer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument using the type attribute. For example:</p>
<p>在上面的场景中，如果你用<code>type</code>属性显式的指定了构造参数的类型，对于简单类型容器可以使用类型匹配。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Use the <code>index</code> attribute to specify explicitly the index of constructor arguments. For example:</p>
<p>使用<code>index</code>属性来显式的指定构造函数参数的索引，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type. Note that the index is 0 based.</p>
<p>除了要解析多个简单值的歧义性之外，当构造函数有两个相同类型的的参数时，指定索引可以解决歧义问题。注意索引是从0开始的。</p>
<p>You can also use the constructor parameter name for value disambiguation:</p>
<p>你也可以使用构造函数参数名字解决值的歧义问题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you can’t compile your code with debug flag (or don’t want to) you can use <code>@ConstructorProperties</code> JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:</p>
<p>记住，要使这个起作用你的代码必须使用调试模式进行编译，这样Spring可以从构造函数中查找参数名称。如果你不能用调试模式进行编译（或不想），你可以使用JDK注解<code>@ConstructorProperties</code>显式的命名你的构造函数参数。样板类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Fields omitted</span></div><div class="line"></div><div class="line">    <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Setter-based dependency injection</strong></p>
<p><em>Setter-based DI</em> is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.</p>
<p><em>基于Setter的依赖注入</em>在容器调用无参构造函数或无参静态工厂方法之后，通过调用bean的setter方法来实现依赖注入。</p>
<p>The following example shows a class that can only be dependency-injected using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.</p>
<p>下面的例子显示了一个类只能通过纯粹的setter注入进行依赖注入。这个类是常见的Java类。它是一个不依赖于容器中特定接口、基类或注解的POJO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <code>ApplicationContext</code> supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a <code>BeanDefinition</code>, which you use in conjunction with <code>PropertyEditor</code> instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (i.e., programmatically) but rather with XML bean definitions, annotated components (i.e., classes annotated with <code>@Component</code>, <code>@Controller</code>, etc.), or <code>@Bean</code> methods in Java-based <code>@Configuration</code> classes. These sources are then converted internally into instances of <code>BeanDefinition</code> and used to load an entire Spring IoC container instance.</p>
<p><code>ApplicationContext</code>支持基于构造函数和基于setter对它管理的bean进行依赖注入。它也支持一些依赖通过构造函数方法注入之后，使用基于setter的依赖注入。使用<code>BeanDefinition</code>形式配置依赖项，结合<code>PropertyEditor</code>实例可以将属性从一种形式转成另一种形式。然而大多数Spring用户直接使用这些类（例如以编程形式），而使用XML定义bean，注解组件（例如类中使用 <code>@Component</code>,，<code>@Controller</code>注解等等），或在基于Java的<code>@Configuration</code>类使用<code>@Bean</code>方法。</p>
<blockquote>
<p>Constructor-based or setter-based DI?</p>
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for <em>mandatory dependencies</em> and setter methods or configuration methods for <em>optional dependencies</em>. Note that use of the <code>@Required</code> annotation on a setter method can be used to make the property a required dependency.</p>
<p>The Spring team generally advocates constructor injection as it enables one to implement application components as <em>immutable objects</em> and to ensure that required dependencies are not <code>null</code>. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through <code>JMX MBeans</code> is therefore a compelling use case for setter injection.</p>
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>使用基于构造函数的依赖注入还是基于setter的依赖注入？</strong></p>
<p>你可以混合使用基于构造函数的依赖注入和基于setter的依赖注入，<em>强制依赖</em>使用构造函数注入，<em>可选依赖</em>使用setter方法或配置方法注入是一个很好的经验法则。注意在setter方法上使用<code>@Required</code>注解会检查依赖是否注入。</p>
<p>当实现的应用组件是<em>不可变对象</em>时，Spring团队通常主张构造函数注入，这样可以确保所需的依赖非空。此外，基于构造函数注入的组件总是以完全初始化状态返回客户（调用）代码。作为附注，含有许多构造函数参数的代码给人的感觉很差，这意味着类可能有很多职责，应该进行重构以便更好的处理关注问题的分离。</p>
<p>setter注入应该主要用来可选依赖上，在类内可以给可选依赖指定合理的默认值。此外，在每处使用依赖的代码都要进行非空检查。setter注入的一个好处就是setter方法使类的对象在后面可以进行再配置或再注入。<code>JMX MBeans</code>的管理是setter注入一个非常好的案例。</p>
<p>使用依赖注入的类型对于特定的类是最有意义的。有时候，当处理没有源码的第三方类时，使用哪种方式取决于你。例如，如果第三方库没有提供任何setter方法，构造函数注入可能是依赖注入唯一可行的方式。</p>
</blockquote>
<p><strong>Dependency resolution process</strong></p>
<p>The container performs bean dependency resolution as follows:</p>
<ul>
<li><p>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified via XML, Java code, or annotations.</p>
</li>
<li><p>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor. These dependencies are provided to the bean, when the bean is actually created.</p>
</li>
<li><p>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</p>
</li>
<li><p>Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument. By default Spring can convert a value supplied in string format to all built-in types, such as int, long, String, boolean, etc.</p>
</li>
</ul>
<p>容器按下面的过程处理bean依赖解析：</p>
<ul>
<li><p>创建<code>ApplicationContext</code>并使用描述所有bean的配置元数据初始化<code>ApplicationContext</code>，配置元数据可以通过XML，Java代码或注解指定。</p>
</li>
<li><p>对于每一个bean，它的依赖通过属性、构造函数参数、或静态工厂方法参数的形式表示，静态工厂方法可以替代标准的构造函数。当bean在实际创建时，这些依赖会提供给bean。</p>
</li>
<li><p>每个属性或构造函数参数或者是根据实际定义设置的值，或者是容器中另一个bean的引用。</p>
</li>
<li><p>每个属性或构造函数参数是一个从指定形式转成实际类型的属性或构造函数参数的值。</p>
</li>
</ul>
<p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean <em>is actually created</em>. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in Section 3.5, “Bean scopes”. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late, i.e. on first creation of the affected bean.</p>
<p>当容器创建后Spring容器会验证每个bean的配置。然而，bean属性本身只有bean创建时才会进行设置。bean是单例的并且当容器创建时会进行提前实例化（默认情况）。作用范围是在3.5 小节”Bean scopes”中定义的。此外，只有需要时候才会创建bean。bean的创建可能会引起beans图的创建，当bean的依赖和它的依赖的依赖（等等）创建和指定的时候。注意这些依赖中解析不匹配可能会在后面出现，例如，受影响的bean第一次创建时。</p>
<blockquote>
<p><strong>Circular dependencies</strong></p>
<p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p>
<p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code>BeanCurrentlyInCreationException</code>.</p>
<p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p>
<p>Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>循环依赖</strong></p>
<p>如果你主要使用构造函数注入，有可能会出现一个不能解决的循环依赖状况。</p>
<p>例如，类A需要通过构造函数注入得到一个类B的实例，而类B需要通过构造函数获得一个类A的实例。如果你为类A和类B配置了互相注入的bean，Spring IoC容器在运行时检测到循环引用，会抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>一个可能的解决方案是编译某个类的源代码使其通过setter注入而不是构造函数注入。或者，避免构造函数注入仅用setter注入。换句话说，尽管是不被推荐的，但你可以通过setter注入配置循环依赖。</p>
<p>不像通常的情况（没有循环依赖），bean A和bean B之间的循环依赖可以强制其中的一个bean优先注入另一个bean中，可以使其完全初始化（古老的鸡/蛋场景）。</p>
</blockquote>
<p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies. For example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why ApplicationContext implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated.</p>
<p>通常情况下你可以信任Spring去做正确的事情。在容器加载时它检测配置问题，例如引用不存在的beans和循环依赖。当bean实际创建时，Spring设置属性和解析依赖尽可能的晚。这意味着Spring容器正确加载但后面可能会产生异常，当你请求一个对象时，创建对象或它的某个依赖时出现问题，这时容器就会抛出异常。例如，由于缺失或存在无效属性，bean会抛出异常。在真正需要这些beans之前创建它们，会花费一些前期时间和内存，但当<code>ApplicationContext</code>创建时你会发现配置问题，而不是在创建之后。为了单例bean延迟初始化而不是预先实例化，你仍需要重写这个默认行为。</p>
<p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a configured init method or the InitializingBean callback method) are invoked.</p>
<p>如果没有循环依赖存在，当一个或更多协作beans注入到一个独立的bean中，在注入独立bean之前，每个协作bean都是完全配置的。这意味着如果bean A有个依赖为bean B，Spring IoC容器在调用bean A的setter方法之前会完整的配置bean B。换句话说，bean被实例化（不是预先实例化的单例），设置依赖和相关的生命周期方法（例如配置初始化方法或初始化bean回调方法）被调用。</p>
<p><strong>Examples of dependency injection</strong></p>
<p>The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:</p>
<p>下面的例子使用基于XML的配置元数据进行setter注入。Spring XML配置文件中的一小部分指定了一些bean的定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = beanOne;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:</p>
<p>在上面的例子中，setter声明匹配XML文件中指定的属性。下面的例子使用了基于构造函数的依赖注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</div><div class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The constructor arguments specified in the bean definition will be used as arguments to the constructor of the <code>ExampleBean</code>.</p>
<p>bean定义中指定的构造函数参数将作为<code>ExampleBean</code>的构造函数参数使用。</p>
<p>Now consider a variant of this example, where instead of using a constructor, Spring is told to call a static factory method to return an instance of the object:</p>
<p>现在考虑这个例子的一个变种，不使用构造函数，而是Spring调用静态工厂方法返回对象的一个实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// a private constructor</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></div><div class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></div><div class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line"></div><div class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</div><div class="line">        <span class="comment">// some other operations...</span></div><div class="line">        <span class="keyword">return</span> eb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Arguments to the <code>static</code> factory method are supplied via <code>&lt;constructor-arg/&gt;</code> elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the <code>static</code> factory method, although in this example it is. An instance (non-static) factory method would be used in an essentially identical fashion (aside from the use of the <code>factory-bean</code> attribute instead of the <code>class</code> attribute), so details will not be discussed here.</p>
<p>静态工厂方法的参数通过<code>&lt;constructor-arg/&gt;</code>元素提供，与构造函数使用的完全一样。虽然这个例子中工厂方法返回值的类型与包含静态工厂方法的类的类型一样，但它们可以不一样。工厂方法的实例（非静态）的使用本质上样式完全一样（除了使用<code>factory-bean</code>属性代替<code>class</code>属性之外），因此这儿不讨论这些细节。</p>
<h4 id="3-4-2-Dependencies-and-configuration-in-detail"><a href="#3-4-2-Dependencies-and-configuration-in-detail" class="headerlink" title="3.4.2 Dependencies and configuration in detail"></a>3.4.2 Dependencies and configuration in detail</h4><p>As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators), or as values defined inline. Spring’s XML-based configuration metadata supports sub-element types within its <code>&lt;property/&gt;</code> and <code>&lt;constructor-arg/&gt;</code> elements for this purpose.</p>
<p>正如上一节提到的那样，你可以通过引用其它被管理bean（协作者）来定义bean的属性和构造函数参数，或者在行内定义值。为了实现这个功能，Spring的基于XML的配置元数据在它的<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>中支持子元素类型。</p>
<p><strong>Straight values (primitives, Strings, and so on)</strong></p>
<p>The <code>value</code> attribute of the <code>&lt;property/&gt;</code> element specifies a property or constructor argument as a human-readable string representation. Spring’s conversion service is used to convert these values from a <code>String</code> to the actual type of the property or argument.</p>
<p><code>&lt;property/&gt;</code>元素的<code>value</code>属性指定了一个属性或构造函数参数作为可读的字符串表示。使用Spring的转换服务将这些值从<code>String</code>转成属性或参数的真实类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The following example uses the p-namespace for even more succinct XML configuration.</p>
<p>下面的例子为了更简洁的XML配置使用了p命名空间.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"close"</span></div><div class="line">        <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">        <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></div><div class="line">        <span class="attr">p:username</span>=<span class="string">"root"</span></div><div class="line">        <span class="attr">p:password</span>=<span class="string">"masterkaoli"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The preceding XML is more succinct; however, typos are discovered at runtime rather than design time, unless you use an IDE such as <code>IntelliJ IDEA</code> or the <code>Spring Tool Suite (STS)</code> that support automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.</p>
<p>上面的XML是更简洁的；然而，错别字是在运行时发现而不是在设计时，除非你使用IDE例如<code>IntelliJ IDEA</code>或<code>Spring Tool Suite (STS)</code>，当你创建bean定义时它们支持自动的属性补全。IDE辅助是强烈推荐的。</p>
<p>You can also configure a <code>java.util.Properties</code> instance as:</p>
<p>你也可以配置<code>java.util.Properties</code>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappings"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</div><div class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</div><div class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The Spring container converts the text inside the <code>&lt;value/&gt;</code>element into a <code>java.util.Properties</code> instance by using the JavaBeans <code>PropertyEditor</code> mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <code>&lt;value/&gt;</code> element over the <code>value</code> attribute style.</p>
<p>Spring容器通过JavaBeans的<code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素内部的文本转成<code>java.util.Properties</code>实例。这是一个很好的捷径，使用嵌入的<code>&lt;value/&gt;</code>元素而不是使用<code>value</code>属性的方式，是Spring团队支持的几个地方之一。</p>
<p><strong>The idref element</strong></p>
<p>The <code>idref</code> element is simply an error-proof way to pass the id (string value - not a reference) of another bean in the container to a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code> element.</p>
<p>在容器中传递另一个bean的id（字符串值，不是引用）到<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素时，<code>idref</code>元素是一种简单的的误差检验方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The above bean definition snippet is exactly equivalent (at runtime) to the following snippet:</p>
<p>上面的bean定义片段与下面的代码片段是等价的（运行时）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The first form is preferable to the second, because using the <code>idref</code> tag allows the container to validate <em>at deployment time</em> that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the <code>targetName</code> property of the <code>client</code> bean. Typos are only discovered (with most likely fatal results) when the <code>client</code> bean is actually instantiated. If the <code>client</code> bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.</p>
<p>第一种形式优于第二种形式，因为<code>idref</code>标签允许容器在部署时验证引用的bean，即命名的bean实际存在。在第二种形式中，当值传给<code>client</code>的<code>targetName</code>时没有进行验证。拼写错误只有在<code>client</code>bean实际创建时才会发现（最可能有严重后果）。如果<code>client</code> bean是原型bean，拼写错误和产生的异常可能只有在容器部署很长时间之后才会发现。</p>
<blockquote>
<p>The <code>local</code> attribute on the <code>idref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular bean reference anymore. Simply change your existing <code>idref local</code> references to <code>idref bean</code> when upgrading to the 4.0 schema.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>idref</code>元素的<code>local</code>属性在4.0 beans xsd中不再支持，因为它不再为合格的bean引用提供值。简单将你现有的<code>idref local</code>引用改成<code>idref bean</code>当更新到4.0 schema时。</p>
</blockquote>
<p>A common place (at least in versions earlier than Spring 2.0) where the <code>&lt;idref/&gt;</code> element brings value is in the configuration of AOP interceptors in a <code>ProxyFactoryBean</code> bean definition. Using <code>&lt;idref/&gt;</code> elements when you specify the interceptor names prevents you from misspelling an interceptor id.</p>
<p><code>&lt;idref/&gt;</code>元素带来值的通常位置（至少在Spring 2.0之前）是在<code>ProxyFactoryBean</code> bean定义中的AOP拦截器配置中。当你指定拦截器名字时使用<code>&lt;idref/&gt;</code>元素来防止误拼拦截器id。</p>
<p><strong>References to other beans (collaborators)</strong></p>
<p>The <code>ref</code> element is the final element inside a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code> definition element. Here you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property will be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may be initialized already by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the id/name of the other object through the <code>bean</code>, <code>local</code>, or <code>parent</code> attributes.</p>
<p><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素的最终的元素。在这个元素中设置bean的指定属性的值，值为容器管理的另一个bean（协作bean）的引用。引用的bean是设置属性bean的依赖，在属性设置之前引用bean需要进行初始化。（如果协作bean是一个单例模式的bean，它可能已经被容器初始化了。）所有引用bean根本上都是另一个对象的引用。作用域和验证是根据你是否通过<code>bean</code>，<code>local</code>，或<code>parent</code>属性指定了另一个对象的id/name来决定的。 </p>
<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the <code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean, or as one of the values in the <code>name</code> attribute of the target bean.</p>
<p>通过<code>&lt;ref/&gt;</code>标签的<code>bean</code>属性指定目标bean是最常用的形式，允许创建同容器或父容器中任何bean的引用，不管它是否是在同一个XML文件中。<code>bean</code>属性的值可能与目标bean的<code>id</code>属性值相同，或与目标bean的<code>name</code>属性值相同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"someBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean that is in a parent container of the current container. The value of the <code>parent</code> attribute may be the same as either the <code>id</code> attribute of the target bean, or one of the values in the <code>name</code> attribute of the target bean, and the target bean must be in a parent container of the current one. You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.</p>
<p>通过<code>parent</code>属性指定目标bean会引用当前容器的父容器中的bean。<code>parent</code>属性的值可能与目标bean的<code>id</code>值或<code>name</code>值相同，目标bean必须在当前容器的父容器中。当你有一个容器分层的时候你可以使用<code>parent</code>，你想将现有bean包裹在有代理的父容器中且现有bean与父容器中的bean同名，你可以使用<code>parent</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- in the parent context --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleAccountService"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- in the child (descendant) context --&gt;</div><div class="line">&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;</div><div class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</div><div class="line">    &lt;property name="target"&gt;</div><div class="line">        &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- insert other configuration and dependencies as required here --&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>The <code>local</code> attribute on the <code>ref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular <code>bean</code> reference anymore. Simply change your existing <code>ref local</code> references to <code>ref bean</code> when upgrading to the 4.0 schema.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>idref</code>元素的<code>local</code>属性在4.0 beans xsd中不再支持，因为它不再为合格的bean引用提供值。简单将你现有的<code>idref local</code>引用改成<code>idref bean</code>当更新到4.0 schema时。</p>
</blockquote>
<p><strong>Inner beans</strong></p>
<p>A <code>&lt;bean/&gt;</code> element inside the <code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines a so-called inner bean.</p>
<p><code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素内的<code>&lt;bean/&gt;</code>元素中定义bean称为内部bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>An inner bean definition does not require a defined id or name; if specified, the container does not use such a value as an identifier. The container also ignores the <code>scope</code> flag on creation: Inner beans are always anonymous and they are always created with the outer bean. It is not possible to inject inner beans into collaborating beans other than into the enclosing bean or to access them independently.</p>
<p>内部bean定义不要求定义id或name；如果指定了，容器不用用这个值作为标识符。容器创建时也忽略<code>scope</code>标记：内部bean总是匿名的且它们总是由外部bean创建。除了注入到封闭bean中或独立的访问它们，不可能将内部bean注入到协作bean中。</p>
<p>As a corner case, it is possible to receive destruction callbacks from a custom scope, e.g. for a request-scoped inner bean contained within a singleton bean: The creation of the inner bean instance will be tied to its containing bean, but destruction callbacks allow it to participate in the request scope’s lifecycle. This is not a common scenario; inner beans typically simply share their containing bean’s scope.</p>
<p>作为一种很少出现的情况，从特定的域中有可能会收到销毁回调函数，例如，对于请求域内的内部bean包含单例bean：内部bean实例的创建会绑定到它的包含bean，但销毁回调函数允许它进入到请求域的生命周期中。这不是一个常见的场景；内部bean通常简单的共享它们的包含bean的作用域。</p>
<p><strong>Collections</strong></p>
<p>In the <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code> elements, you set the properties and arguments of the Java <code>Collection</code> types <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>, respectively.</p>
<p>在<code>&lt;list/&gt;</code>，<code>&lt;set/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素中，你要分别设置Java <code>Collection</code>类型<code>list</code>，<code>set</code>，<code>map</code>和<code>Properties</code>的属性和参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><em>The value of a map key or value, or a set value, can also again be any of the following elements:</em></p>
<p>map的key或value，或者是set value的值也可以是下面元素中的任何一个：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bean | ref | idref | list | set | map | props | value | null</div></pre></td></tr></table></figure>
<p><strong>Collection merging</strong></p>
<p>The Spring container also supports the <em>merging</em> of collections. An application developer can define a parent-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> element, and have child-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> elements inherit and override values from the parent collection. That is, the child collection’s values are the result of merging the elements of the parent and child collections, with the child’s collection elements overriding values specified in the parent collection.</p>
<p>Spring也支持集合的合并。应用开发者可以定义父类型<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，可以有继承和覆盖父集合的子类型元素<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>。也就是说，子集合的值是父集合和子集合中元素合并的结果，子集合元素覆盖了父集合元素的值。</p>
<p>This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the relevant section before continuing.</p>
<p>关于合并的这节讨论了父子bean机制。对父子bean定义不熟悉的读者可以去读相关的章节。</p>
<p>The following example demonstrates collection merging:</p>
<p>下面的例子示范了集合合并：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Notice the use of the <code>merge=true</code> attribute on the <code>&lt;props/&gt;</code> element of the <code>adminEmails</code> property of the <code>child</code> bean definition. When the <code>child</code> bean is resolved and instantiated by the container, the resulting instance has an <code>adminEmails</code> <code>Properties</code> collection that contains the result of the merging of the child’s <code>adminEmails</code> collection with the parent’s <code>adminEmails</code> collection.</p>
<p>注意<code>child</code> bean定义中的<code>adminEmails</code>属性下的<code>&lt;props/&gt;</code>元素使用了<code>merge=true</code>属性。当容器解析并实例化<code>child</code> bean时，最终的实例含有<code>adminEmails</code> <code>Properties</code>集合，集合中的值是子<code>adminEmails</code>集合和父<code>adminEmails</code>集合合并的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">administrator=administrator@example.com</div><div class="line">sales=sales@example.com</div><div class="line">support=support@example.co.uk</div></pre></td></tr></table></figure>
<p>The child <code>Properties</code> collection’s value set inherits all property elements from the parent <code>&lt;props/&gt;</code>, and the child’s value for the <code>support</code> value overrides the value in the parent collection.</p>
<p>子<code>Properties</code>集合的值继承了父<code>&lt;props/&gt;</code>中的所有属性元素，子集合中的<code>support</code>值覆盖了父集合中的值。</p>
<p>This merging behavior applies similarly to the <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;set/&gt;</code> collection types. In the specific case of the <code>&lt;list/&gt;</code> element, the semantics associated with the <code>List</code> collection type, that is, the notion of an <code>ordered</code> collection of values, is maintained; the parent’s values precede all of the child list’s values. In the case of the <code>Map</code>, <code>Set</code>, and <code>Properties</code> collection types, no ordering exists. Hence no ordering semantics are in effect for the collection types that underlie the associated <code>Map</code>, <code>Set</code>, and <code>Properties</code> implementation types that the container uses internally.</p>
<p><code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型中的合并与上面类似。在特定的<code>&lt;list/&gt;</code>元素情况下，关于<code>List</code>集合类型的语义，也就是说，有序集合值的概念仍然是保留的；父list中的值领先于所有子list中的值。在<code>Map</code>，<code>Set</code>和<code>Properties</code>集合类型，不存在顺序。因此，无序语义在容器内部使用的集合类型<code>Map</code>，<code>Set</code>和<code>Properties</code>的实现基础上是有效的。</p>
<p><strong>Limitations of collection merging</strong></p>
<p>You cannot merge different collection types (such as a <code>Map</code> and a <code>List</code>), and if you do attempt to do so an appropriate <code>Exception</code> is thrown. The <code>merge</code> attribute must be specified on the lower, inherited, child definition; specifying the <code>merge</code> attribute on a parent collection definition is redundant and will not result in the desired merging.</p>
<p>你不能合并不同的集合类型（例如<code>Map</code>和<code>List</code>），如果你试图合并不同的集合类型会有适当的抛出<code>Exception</code>。<code>merge</code>属性必须在更低的、继承的子定义中；在父集合定义中指定<code>merge</code>属性是多余的并且不会进行合并。</p>
<p><strong>Strongly-typed collection</strong></p>
<p>With the introduction of generic types in Java 5, you can use strongly typed collections. That is, it is possible to declare a <code>Collection</code> type such that it can only contain <code>String</code> elements (for example). If you are using Spring to dependency-inject a strongly-typed <code>Collection</code> into a bean, you can take advantage of Spring’s type-conversion support such that the elements of your strongly-typed <code>Collection</code> instances are converted to the appropriate type prior to being added to the <code>Collection</code>.</p>
<p>随着Java 5中泛型的引入，你可以使用强类型集合。也就是说，你可以声明一个<code>Collection</code>类型但它只能包含<code>String</code>元素（例子）。如果你使用Spring将一个强类型的<code>Collection</code>注入到bean中，你可以利用Spring的类型转换支持，例如在将元素添加到<code>Collection</code>之前，将你的强类型<code>Collection</code>实例中的元素转成恰当的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.accounts = accounts;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>When the <code>accounts</code> property of the <code>foo</code> bean is prepared for injection, the generics information about the element type of the strongly-typed <code>Map&lt;String, Float&gt;</code> is available by reflection. Thus Spring’s type conversion infrastructure recognizes the various value elements as being of type <code>Float</code>, and the string values <code>9.99, 2.75</code>, and <code>3.99</code> are converted into an actual <code>Float</code> type.</p>
<p>当注入<code>foo</code> bean的<code>accounts</code>属性时，强类型<code>Map&lt;String, Float&gt;</code>中元素类型的泛型信息可以通过反射得到。因此Spring的类型转换结构能识别各种值元素的类型为<code>Float</code>，字符串<code>9.99, 2.75</code>和<code>3.99</code>会被转换成实际的<code>Float</code>类型。</p>
<p><strong>Null and empty string values</strong></p>
<p>Spring treats empty arguments for properties and the like as empty <code>Strings</code>. The following XML-based configuration metadata snippet sets the email property to the empty <code>String</code> value (“”).</p>
<p>Spring把属性的空参数都处理为空<code>Strings</code>。下面基于XML的配置元数据片段将email属性设为空<code>String</code>值(“”)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The preceding example is equivalent to the following Java code:</p>
<p>上面的例子与下面的Java代码是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exampleBean.setEmail(<span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>The <code>&lt;null/&gt;</code> element handles <code>null</code> values. For example:</p>
<p><code>&lt;null/&gt;</code>元素处理<code>null</code>值。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The above configuration is equivalent to the following Java code:</p>
<p>上面的配置与下面的Java代码等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exampleBean.setEmail(<span class="keyword">null</span>)</div></pre></td></tr></table></figure>
<p><strong>XML shortcut with the p-namespace</strong></p>
<p>The p-namespace enables you to use the <code>bean</code> element’s attributes, instead of nested <code>&lt;property/&gt;</code> elements, to describe your property values and/or collaborating beans.</p>
<p>p命名空间可以让你不需要嵌入<code>&lt;property/&gt;</code>元素便能使用<code>bean</code>元素的属性来描述你的属性值以及/或协作beans。</p>
<p>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
<p>Spring支持含有命名空间的扩展配置形式，命名控件是基于XML Schema定义的。本章讨论的beans配置形式是在XML Schema文档中定义的。但是p命名空间不能在XSD文件中定义并且只在Spring core中存在。</p>
<p>The following example shows two XML snippets that resolve to the same result: The first uses standard XML format and the second uses the p-namespace.</p>
<p>下面的例子显示了两个XML片段，解析结果是相同的：第一个是标准的XML形式，第二个使用了p命名空间。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></div><div class="line">        <span class="attr">p:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The example shows an attribute in the p-namespace called email in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.</p>
<p>这个例子显示了bean定义中p命名空间中有个一个叫email的属性。这会通知Spring包含属性声明。如前面所述，p命名空间没有schema定义，因此你可以将特性值（attribute）设到属性值（property）上。</p>
<p>This next example includes two more bean definitions that both have a reference to another bean:</p>
<p>下面的例子包括两个bean定义，且它们都引用了另一个bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-classic"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"John Doe"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spouse"</span> <span class="attr">ref</span>=<span class="string">"jane"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-modern"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"com.example.Person"</span></div><div class="line">        <span class="attr">p:name</span>=<span class="string">"John Doe"</span></div><div class="line">        <span class="attr">p:spouse-ref</span>=<span class="string">"jane"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>As you can see, this example includes not only a property value using the p-namespace, but also uses a special format to declare property references. Whereas the first bean definition uses <code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code> to create a reference from bean <code>john</code> to bean <code>jane</code>, the second bean definition uses <code>p:spouse-ref=&quot;jane&quot;</code> as an attribute to do the exact same thing. In this case <code>spouse</code> is the property name, whereas the <code>-ref</code> part indicates that this is not a straight value but rather a reference to another bean.</p>
<p>正如你所看到的，这个例子不仅包括使用了p命名空间的属性值，而且使用了一种特定的形式来声明属性引用。然而第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>创建了一个从bean <code>john</code>到bean <code>jane</code>的引用，第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为一个特性同样定义了从bean <code>john</code>到bean <code>jane</code>的引用。在<code>spouse</code>是属性名的情况下，<code>-ref</code>部分表示这不是一个直接的值而是另一个bean的引用。</p>
<blockquote>
<p>The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in <code>Ref</code>, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>p命名空间不是标准的XML格式，例如，声明的属性引用会与以<code>Ref</code>结尾的属性相冲突，而标准XML格式则不会。我们建议你仔细的选择你的方法并与你的团队成员交流，避免生成的XML文档同时使用了三种方式。</p>
</blockquote>
<p><strong>XML shortcut with the c-namespace</strong></p>
<p>Similar to the the section called “XML shortcut with the p-namespace”, the c-namespace, newly introduced in Spring 3.1, allows usage of inlined attributes for configuring the constructor arguments rather then nested <code>constructor-arg</code> elements.</p>
<p>与“XML shortcut with the p-namespace”小节类似，在Spring 3.1新引入的c命名空间允许使用行内属性配置构造函数参数而不用嵌入<code>constructor-arg</code>元素。</p>
<p>Let’s review the examples from the section called “Constructor-based dependency injection” with the <code>c:</code> namespace:</p>
<p>让我们重新回顾一下“Constructor-based dependency injection”小节中的例子并使用<code>c:</code>命名空间：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- traditional declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- c-namespace declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:bar-ref</span>=<span class="string">"bar"</span> <span class="attr">c:baz-ref</span>=<span class="string">"baz"</span> <span class="attr">c:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>c:</code> namespace uses the same conventions as the <code>p:</code> one (trailing <code>-ref</code> for bean references) for setting the constructor arguments by their names. And just as well, it needs to be declared even though it is not defined in an XSD schema (but it exists inside the Spring core).</p>
<p><code>c:</code>命名空间遵循与<code>p:</code>命名空间相同的约定在通过名字设置构造函数参数时。同样的，它也需要进行声明，虽然它不能在XSD schema中使用（但在Spring core中存在）。</p>
<p>For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can use fallback to the argument indexes:</p>
<p>对于很少出现的不能找到构造函数参数名字的情况（通常如果编译字节码且没有调试信息），可以使用参数索引：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:_0-ref</span>=<span class="string">"bar"</span> <span class="attr">c:_1-ref</span>=<span class="string">"baz"</span>/&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Due to the XML grammar, the index notation requires the presence of the leading <code>_</code> as XML attribute names cannot start with a number (even though some IDE allow it).</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>由于XML语法，索引符号需要前面加上<code>_</code>，因为XML属性名字不能以数字开头（即使一些IDE允许）。</p>
</blockquote>
<p>In practice, the constructor resolution mechanism is quite efficient in matching arguments so unless one really needs to, we recommend using the name notation through-out your configuration.</p>
<p>在实践中，构造函数解析机制能有效匹配参数，因此除非真的需要，否则我们推荐在配置中使用名字符号。</p>
<p><strong>Compound property names</strong></p>
<p>You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not <code>null</code>. Consider the following bean definition.</p>
<p>当你设置bean属性时，你可以使用混合的或嵌入的属性名字，只要路径中除了最后的属性名之外所有组件都是非<code>null</code>。考虑下面的bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"foo.Bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>foo</code> bean has a <code>fred</code> property, which has a <code>bob</code> property, which has a <code>sammy</code> property, and that final <code>sammy</code> property is being set to the value <code>123</code>. In order for this to work, the <code>fred</code> property of <code>foo</code>, and the <code>bob</code> property of <code>fred</code> must not be <code>null</code> after the bean is constructed, or a <code>NullPointerException</code> is thrown.</p>
<p><code>foo</code>bean有一个<code>fred</code>属性，<code>fred</code>有一个<code>sammy</code>属性，<code>bob</code>有一个<code>sammy</code>属性，最后的<code>sammy</code>属性设置值为<code>123</code>。为了这样设置，<code>foo</code>的<code>fred</code>属性，<code>fred</code>的<code>bob</code>属性在bean创建后必须是非<code>null</code>或抛出<code>NullPointerException</code>。</p>
<h4 id="3-4-3-Using-depends-on"><a href="#3-4-3-Using-depends-on" class="headerlink" title="3.4.3 Using depends-on"></a>3.4.3 Using depends-on</h4><p>If a bean is a dependency of another that usually means that one bean is set as a property of another. Typically you accomplish this with the <code>&lt;ref/&gt;</code> element in XML-based configuration metadata. However, sometimes dependencies between beans are less direct; for example, a static initializer in a class needs to be triggered, such as database driver registration. The <code>depends-on</code> attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the <code>depends-on</code> attribute to express a dependency on a single bean:</p>
<p>如果一个bean是另一个bean的一个依赖，这通常意味着一个bean作为另一个bean的一个属性去设置。在基于XML的配置元数据中通常使用<code>&lt;ref/&gt;</code>元素实现。然而有时beans之间的依赖关系是间接的；例如，类中的静态初始化程序需要触发，例如数据驱动注册。<code>depends-on</code>特性能显示的强制一个bean或多个beans在使用这个元素的bean初始化之前进行初始化。下面的例子使用<code>depends-on</code>特性表示一个单一bean的一个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>To express a dependency on multiple beans, supply a list of bean names as the value of the <code>depends-on</code> attribute, with commas, whitespace and semicolons, used as valid delimiters:</p>
<p>为了表示多个bean上的依赖关系，提供一个bean名字列表作为<code>depends-on</code>特性的值，用逗号，空格或分号作为有效分隔符：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>The <code>depends-on</code> attribute in the bean definition can specify both an initialization time dependency and, in the case of singleton beans only, a corresponding destroy time dependency. Dependent beans that define a <code>depends-on</code> relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus <code>depends-on</code> can also control shutdown order.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>depends-on</code>特性在bean定义中可以指定初始化时的依赖和对应的销毁时依赖（仅在单例情况下）。依赖beans与给定bean之间定义了一个<code>depends-on</code>关系，依赖beans在给定bean本身被销毁之前首先被销毁。因此<code>depends-on</code>也可以控制销毁顺序。</p>
</blockquote>
<h4 id="3-4-4-Lazy-initialized-beans"><a href="#3-4-4-Lazy-initialized-beans" class="headerlink" title="3.4.4 Lazy-initialized beans"></a>3.4.4 Lazy-initialized beans</h4><p>By default, <code>ApplicationContext</code> implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.</p>
<p>默认情况下，作为初始化过程的一部分，<code>ApplicationContext</code>实现时渴望创建并配置所有的单例beans。通常情况下，预实例化是必要的，因为配置中或周围环境中的错误可以立即发现，与几小时或几天后发现截然相反。当预实例化是不必要的时候，你可通过标记bean定义为延迟初始化来阻止单例bean的预实例化。延迟初始化的bean会通知IoC容器当第一次请求bean时创建一个bean实例，而不是在启动时创建。</p>
<p>In XML, this behavior is controlled by the <code>lazy-init</code> attribute on the <code>&lt;bean/&gt;</code> element; for example:</p>
<p>在XML中，延迟初始化通过<code>&lt;bean/&gt;</code>元素中的<code>lazy-init</code>特性来控制；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.AnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>When the preceding configuration is consumed by an <code>ApplicationContext</code>, the bean named <code>lazy</code> is not eagerly pre-instantiated when the <code>ApplicationContext</code> is starting up, whereas the <code>not.lazy</code> bean is eagerly pre-instantiated.</p>
<p>当<code>ApplicationContext</code>读取到上面的配置，<code>ApplicationContext</code>启动时名字为<code>lazy</code>的bean不会进行预实例化，而名字为<code>not.lazy</code>的bean会进行预实例化。</p>
<p>However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the <code>ApplicationContext</code> creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.</p>
<p>然而，当延迟初始化的bean是一个非延迟初始化的单例bean的依赖时，<code>ApplicationContext</code>会在启动时创建延迟初始化的bean，因为它必须提供单例bean的依赖。延迟初始化的bean会注入到单例bean中，而在其它地方它是非延迟初始化的。</p>
<p>You can also control lazy-initialization at the container level by using the <code>default-lazy-init</code> attribute on the <code>&lt;beans/&gt;</code> element; for example:</p>
<p>你也可以在容器中通过<code>&lt;beans/&gt;</code>中的<code>default-lazy-init</code>特性控制延迟初始化；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-4-5-Autowiring-collaborators"><a href="#3-4-5-Autowiring-collaborators" class="headerlink" title="3.4.5 Autowiring collaborators"></a>3.4.5 Autowiring collaborators</h4><p>The Spring container can <em>autowire relationships</em> between collaborating beans. You can allow Spring to resolve collaborators (other beans) automatically for your bean by inspecting the contents of the <code>ApplicationContext</code>. Autowiring has the following advantages:</p>
<ul>
<li><p>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</li>
<li><p>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</li>
</ul>
<p>Spring容器能自动装配协作beans之间的关联关系。你可以允许Spring通过检查<code>ApplicationContext</code>中的内容自动的为你的bean解析协作者（其它bean）。自动装配有以下优势：</p>
<ul>
<li><p>自动装配能明显减少指定属性或构造函数参数的需要。（其它的机制例如在本章其它地方讨论的bean模板在这一点上也是非常重要的。）</p>
</li>
<li><p>当对象变化时自动装配能更新配置。例如，如果你需要增加一个类的依赖项，依赖项可以是满足自动装配的而不需要你去修改配置。因此自动装配在开发时尤其有用，当代码基础变的更稳定时可以改为显式装配。</p>
</li>
</ul>
<p>When using XML-based configuration metadata, you specify autowire mode for a bean definition with the <code>autowire</code> attribute of the <code>&lt;bean/&gt;</code> element. The autowiring functionality has four modes. You specify autowiring per bean and thus can choose which ones to autowire.</p>
<p>当使用基于XML的配置元数据时，通过使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>特性你可以指定一个bean定义的自动装配模式。自动注入功能有四种模式。你可以指定每个bean的自动装配模式，因此你可以选择使用哪一种模式。</p>
<p><strong>Table 3.2. Autowiring modes</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Mode</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no</td>
<td style="text-align:left">(Default) No autowiring. Bean references must be defined via a <code>ref</code> element. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name, and it contains a <em>master</em> property (that is, it has a <em>setMaster(..)</em> method), Spring looks for a bean definition named <code>master</code>, and uses it to set the property.</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">Allows a property to be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use <em>byType</em> autowiring for that bean. If there are no matching beans, nothing happens; the property is not set.</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">Analogous to <code>byType</code>, but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.</td>
</tr>
</tbody>
</table>
<p><strong>表 3.2 自动装配模式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no</td>
<td style="text-align:left">（默认）无自动装配。引用bean必须通过<code>ref</code>元素定义。对于更大的部署，不推荐更改默认设置，因为显式指定协作者更清晰并且更易控制。在某种程度上来说，它记录了系统的结构。</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">通过属性名称自动装配。Spring寻找与需要自动装配的属性同名的bean。例如，如果一个bean定义设置为通过名称自动装配，它有一个<code>master</code>属性（也就是说，它有一个<code>setMaster(..)</code>方法），Spring寻找名字为<code>master</code>的bean定义，使用它设置属性值。</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">如果容器中含有属性类型已知的一个bean，那么可以允许按类型自动装配属性。如果此类型的bean不止一个，则会抛出致命的异常，这意味着你可能不能使用<code>byType</code>来注入那个bean。如果没有匹配的bean，则什么也不做；属性没有被设置。</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">与<code>byType</code>类似，但是应用到构造函数参数上的。如果容器中没有一个构造函数参数bean的确定类型，将会抛出一个致命的异常。</td>
</tr>
</tbody>
</table>
<p>With <em>byType</em> or constructor autowiring mode, you can wire arrays and typed-collections. In such cases all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed Maps if the expected key type is <code>String</code>. An autowired Maps values will consist of all bean instances that match the expected type, and the Maps keys will contain the corresponding bean names.</p>
<p>通过<code>byType</code>或构造函数自动装配模式，你可以配置数组和集合类型。在这种情况下容器内所有能匹配期望类型的自动装配候选对象将被提供合适的依赖项。如果期望的<code>key</code>类型是<code>String</code>类型，你可以自动装配强类型的<code>Maps</code>。自动装配的<code>Maps</code>的值将有所有匹配期望类型的bean组成，<code>Maps</code>的键将包含对应的bean名称。</p>
<p>You can combine autowire behavior with dependency checking, which is performed after autowiring completes.</p>
<p>你可以将依赖检查与自动装配相结合，它将在自动装配完成之后执行。</p>
<p><strong>Limitations and disadvantages of autowiring</strong></p>
<p>Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.</p>
<p>当自动装配在整个工程中一致的使用时其效果最好。如果通常情况下不使用自动装配，仅在一两个bean定义中使用自动装配开发人员可能感到非常困惑。</p>
<p>Consider the limitations and disadvantages of autowiring:</p>
<ul>
<li><p>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override autowiring. You cannot autowire so-called simple properties such as primitives, <code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is by-design.</p>
</li>
<li><p>Autowiring is less exact than explicit wiring. Although, as noted in the above table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.</p>
</li>
<li><p>Wiring information may not be available to tools that may generate documentation from a Spring container.</p>
</li>
<li><p>Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.</p>
</li>
</ul>
<p>考虑一下自动装配的限制与缺点：</p>
<ul>
<li><p><code>property</code>和<code>constructor-arg</code>中显式依赖的设置总是会覆盖自动装配。你不能自动装配所谓的简单属性例如基本类型，<code>Strings</code>和<code>Classes</code>（和简单类型的数组）。这是设计上的限制。</p>
</li>
<li><p>与显式配置相比，自动装配是更不确定的。尽管Spring小心的避免猜测以防歧义性引起无法预料的后果，但Spring管理的对象之间的关系不再被显式的记录。</p>
</li>
<li><p>Spring容器中能产生文档的工具可能得不到配置信息。</p>
</li>
<li><p>setter方法或构造函数参数指定的类型进行自动装配时可能匹配到容器中多个bean的定义。对于数组，集合或<code>Maps</code>而言，这是一个不必要的问题。然而对于只期望一个值的依赖而言，这个歧义性不能任意解决。如果不能获得唯一的bean定义，会抛出异常。</p>
</li>
</ul>
<p>In the latter scenario, you have several options:</p>
<ul>
<li><p>Abandon autowiring in favor of explicit wiring.</p>
</li>
<li><p>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes to <code>false</code> as described in the next section.</p>
</li>
<li><p>Designate a single bean definition as the <em>primary</em> candidate by setting the <code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</p>
</li>
<li><p>Implement the more fine-grained control available with annotation-based configuration, as described in Section 3.9, “Annotation-based container configuration”.</p>
</li>
</ul>
<p>后面的方案中，你有一些选择：</p>
<ul>
<li><p>放弃自动装配支持显式配置。</p>
</li>
<li><p>通过设置bean的<code>autowire-candidate</code>特性为<code>false</code>来避免自动装配。</p>
</li>
<li><p>通过设置<code>&lt;bean/&gt;</code>元素的<code>primary</code>特性为<code>true</code>来指定一个单例bean定义作为主要的候选bean。</p>
</li>
<li><p>通过基于注解的配置实现更多细颗粒的控制，如3.9小节 “基于注解的容器配置”。</p>
</li>
</ul>
<p><strong>Excluding a bean from autowiring</strong></p>
<p>On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the <code>autowire-candidate</code> attribute of the <code>&lt;bean/&gt;</code> element to <code>false</code>; the container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as <code>@Autowired</code>).</p>
<p>在单个bean的基础上，你可以排除bean在自动装配之外。在Spring的XML形式中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>特性为<code>false</code>；容器会使自动装配基础框架不能得到指定bean定义（包括注解类型的配置，例如<code>@Autowired</code>）。</p>
<p>You can also limit autowire candidates based on pattern-matching against bean names. The top-level <code>&lt;beans/&gt;</code> element accepts one or more patterns within its <code>default-autowire-candidates</code> attribute. For example, to limit autowire candidate status to any bean whose name ends with <em>Repository</em>, provide a value of <code>*Repository</code>. To provide multiple patterns, define them in a comma-separated list. An explicit value of <code>true</code> or <code>false</code> for a bean definitions <code>autowire-candidate</code> attribute always takes precedence, and for such beans, the pattern matching rules do not apply.</p>
<p>你也可以根据bean名称的匹配模式限制自动装配的候选目标。顶层的<code>&lt;beans/&gt;</code>元素可以接收<code>default-autowire-candidates</code>特性中的一个或多个模式。例如，为了限制自动装配候选目标匹配任何名字以<code>Repository</code>结尾的bean，可以提供一个<code>*Repository</code>值。为了提供多种模式，可以定义一个以逗号为分隔符的列表。bean定义中<code>autowire-candidate</code>特性显示的值<code>true</code>或<code>false</code>最是优先起作用的，对于这些bean而言，模式匹配规则不起作用。</p>
<p>These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p>
<p>这些技术对于那些你从不想通过自动装配方式注入到其它bean中的beans而言是很有用的。这不意味着一个排除的bean它本身不能通过自动装配进行配置。更确切的说，bean本身不是一个进行其它bean进行自动装配的候选者。</p>
<h4 id="3-4-6-Method-injection"><a href="#3-4-6-Method-injection" class="headerlink" title="3.4.6 Method injection"></a>3.4.6 Method injection</h4><p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean, or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container only creates the singleton bean A once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
<p>在大多数应用场景中，容器中的大多数bean是单例的。当一个单例bean需要与另一个单例bean协作时，或一个非单例bean需要与另一个非单例bean协作时，你通常通过定义一个bean作为另一个bean的一个属性来处理这个依赖关系。当bean的生命周期不同时问题就出现了。假设一个单例bean A需要使用非单例（标准）bean B时，也许A中的每一个方法调用都要使用bean B。容器仅创建单例bean A一次，因此仅有一次设置属性的机会。容器不能在每次需要bean B时提供一个bean B的新的实例。</p>
<p>A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the <code>ApplicationContextAware</code> interface, and by making a getBean(“B”) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following is an example of this approach:</p>
<p>一个解决方案是放弃一些控制反转。你可以使bean A通过实现<code>ApplicationContextAware</code>接口感知到容器，每个bean A需要的时候就通过<code>getBean(&quot;B&quot;)</code>调用向容器请求（通常是新的）一个bean B的实例。下面是这种方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></div><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// Spring-API imports</span></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// notice the Spring API dependency!</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></div><div class="line">            ApplicationContext applicationContext) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, allows this use case to be handled in a clean fashion.</p>
<p>前面所讲的不是让人满意的，因为业务代码能感知并耦合了Spring框架。方法注入，Spring IoC容器的一个有点高级的特性，允许使用一种干净的方式来处理这个案例。</p>
<blockquote>
<p>You can read more about the motivation for Method Injection in this blog entry.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>你可以在blog entry中了解更多关于方法注入的动机。</p>
</blockquote>
<p><strong>Lookup method injection</strong></p>
<p>Lookup method injection is the ability of the container to override methods on container managed beans, to return the lookup result for another named bean in the container. The lookup typically involves a prototype bean as in the scenario described in the preceding section. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method.</p>
<p>查找方法注入是容器的一种覆盖其管理的beans中的方法的能力，可以返回容器中另一个命名bean查找结果。查找通常会涉及到一个标准bean，如前一小节中讲的那样。Spring框架实现了查找方法注入，它是通过使用CGLIB库生成的字节码来动态的产生一个覆盖这个方法的子类。</p>
<blockquote>
<ul>
<li><p>For this dynamic subclassing to work, the class that the Spring bean container will subclass cannot be final, and the method to be overridden cannot be final either.</p>
</li>
<li><p>Unit-testing a class that has an abstract method requires you to subclass the class yourself and to supply a stub implementation of the abstract method.</p>
</li>
<li><p>Concrete methods are also necessary for component scanning which requires concrete classes to pick up.</p>
</li>
<li><p>A further key limitation is that lookup methods won’t work with factory methods and in particular not with <code>@Bean</code> methods in configuration classes, since the container is not in charge of creating the instance in that case and therefore cannot create a runtime-generated subclass on the fly.</p>
</li>
<li><p>Finally, objects that have been the target of method injection cannot be serialized.</p>
</li>
</ul>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<ul>
<li><p>为了使动态子类化起作用，Spring bean容器要进行子类化的类不能是最终的类，要进行重写的方法也不是最终的方法。</p>
</li>
<li><p>单元测试一个含有抽象方法的类需要你自己对这个类进行子类化，并且提供这个抽象方法的<code>stub</code>实现。</p>
</li>
<li><p>实体方法对于要求获得实体类的组件扫描也是必需的。</p>
</li>
<li><p>一个更关键的限制是查找方法不能与工厂方法一起工作，尤其是在配置类中不能与<code>@Bean</code>方法同时起作用，由于那种情况下容器不能控制实例的创建，因此不能在飞速写入中创建一个运行时产生的子类。</p>
</li>
<li><p>最后，方法注入的目标对象不能被序列化。</p>
</li>
</ul>
</blockquote>
<p>Looking at the <code>CommandManager</code> class in the previous code snippet, you see that the Spring container will dynamically override the implementation of the <code>createCommand()</code> method. Your <code>CommandManager</code> class will not have any Spring dependencies, as can be seen in the reworked example:</p>
<p>看一下前面代码片中的<code>CommandManager</code>类，你可以看到Spring容器将会动态的覆盖<code>createCommand()</code>方法的实现。<code>CommandManager</code>类不会有任何Spring依赖，重写的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// no more Spring imports!</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the client class containing the method to be injected (the <code>CommandManager</code> in this case), the method to be injected requires a signature of the following form:</p>
<p>客户类中包含要注入的方法（在这个例子中是<code>CommandManager</code>），要注入的方法需要下面形式的一个签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</div></pre></td></tr></table></figure>
<p>If the method is abstract, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. For example:</p>
<p>如果这个方法是抽象的，动态产生的子类会实现这个方法。另外，动态产生的子类会覆盖原来的类中定义的实体方法。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"command"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"command"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The bean identified as <em>commandManager</em> calls its own method <code>createCommand()</code> whenever it needs a new instance of the <code>command</code> bean. You must be careful to deploy the <code>command</code> bean as a prototype, if that is actually what is needed. If it is deployed as a singleton, the same instance of the <code>command</code> bean is returned each time.</p>
<p>无论什么时候识别为<code>commandManager</code>的bean需要一个<code>command</code> bean的新实例，它都会调用它的<code>createCommand()</code>方法。如果真的需要的话，你必须小心的部署<code>command</code> bean为一个原型。如果它被部署为一个单例，每次都会返回同一个<code>command</code>实例。</p>
<blockquote>
<p>The interested reader may also find the <code>ServiceLocatorFactoryBean</code> (in the <code>org.springframework.beans.factory.config</code> package) to be of use. The approach used in <code>ServiceLocatorFactoryBean</code> is similar to that of another utility class, <code>ObjectFactoryCreatingFactoryBean</code>, but it allows you to specify your own lookup interface as opposed to a Spring-specific lookup interface. Consult the javadocs of these classes for additional information.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>感兴趣的读者可能也会发现<code>ServiceLocatorFactoryBean</code>（在<code>org.springframework.beans.factory.config</code>包中）使用这种方法。<code>ServiceLocatorFactoryBean</code>中使用的方法与另一个工具类<code>ObjectFactoryCreatingFactoryBean</code>中的方法类似，但它允许你指定你自己的查找接口，与Spring特定的查找接口相反。这些类的额外信息请查询Java文档。</p>
</blockquote>
<p><strong>Arbitrary method replacement</strong></p>
<p>A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. Users may safely skip the rest of this section until the functionality is actually needed.</p>
<p>一种比查找方法注入更少使用的形式是用另一种方法实现替换管理的bean中任意方法的能力。用户可以安全跳过本节剩下的部分，直到这个方法真正需要的时候再看。</p>
<p>With XML-based configuration metadata, you can use the <code>replaced-method</code> element to replace an existing method implementation with another, for a deployed bean. Consider the following class, with a method <code>computeValue</code>, which we want to override:</p>
<p>在基于XML的配置元数据中，对于一个部署的bean，你可以通过<code>replaced-method</code>元素用另一个方法实现替换现有的方法实现。考虑下面的类，有一个我们想覆盖的<code>computeValue</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">        <span class="comment">// some real code...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// some other methods...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A class implementing the <code>org.springframework.beans.factory.support.MethodReplacer</code> interface provides the new method definition.</p>
<p>实现了<code>org.springframework.beans.factory.support.MethodReplacer</code>接口的类提供了一种新的方法定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * meant to be used to override the existing computeValue(String)</div><div class="line"> * implementation in MyValueCalculator</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></div><div class="line">        String input = (String) args[<span class="number">0</span>];</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> ...;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The bean definition to deploy the original class and specify the method override would look like this:</p>
<p>部署最初的类的bean定义和指定的重写方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>You can use one or more contained <code>&lt;arg-type/&gt;</code> elements within the <code>&lt;replaced-method/&gt;</code> element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match <code>java.lang.String</code>:</p>
<p>你可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个包含<code>&lt;arg-type/&gt;</code>元素来指出要覆盖的方法的方法签名。只有类中进行了方法重载且有多个重载变种的时候，参数的签名才是必需的。为了简便，字符串类型的参数可能是全拼类型名称的一个子串。例如，下面的所有写法都能匹配<code>java.lang.String</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.String</div><div class="line">String</div><div class="line">Str</div></pre></td></tr></table></figure>
<p>Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by allowing you to type only the shortest string that will match an argument type.</p>
<p>因为参数数目经常是足够区分每个可能的选择的，通过允许定义匹配参数类型的最短字符串类型，这个缩写可以保存许多类型。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>如果有收获，可以请我喝杯咖啡！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="https://user-images.githubusercontent.com/21311442/54660728-7c650300-4b12-11e9-9b0a-1a5c09323afe.png" alt="Tyan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="https://user-images.githubusercontent.com/21311442/54660740-87b82e80-4b12-11e9-96e4-911014779bdc.png" alt="Tyan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/22/2016-09-22-Docker理论与实践3/" rel="next" title="Docker理论与实践（三）">
                <i class="fa fa-chevron-left"></i> Docker理论与实践（三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/25/2016-09-25-Spring框架介绍_中文版_3.4_5.0.0版本/" rel="prev" title="Spring 5.0.0框架介绍_中文版_3.4">
                Spring 5.0.0框架介绍_中文版_3.4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tyan" />
          <p class="site-author-name" itemprop="name">Tyan</p>
           
              <p class="site-description motion-element" itemprop="description">工作中的技术总结</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">824</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Dependencies"><span class="nav-number">1.</span> <span class="nav-text">3.4 Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-Dependency-Injection"><span class="nav-number">1.1.</span> <span class="nav-text">3.4.1 Dependency Injection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-Dependencies-and-configuration-in-detail"><span class="nav-number">1.2.</span> <span class="nav-text">3.4.2 Dependencies and configuration in detail</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-Using-depends-on"><span class="nav-number">1.3.</span> <span class="nav-text">3.4.3 Using depends-on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-Lazy-initialized-beans"><span class="nav-number">1.4.</span> <span class="nav-text">3.4.4 Lazy-initialized beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-Autowiring-collaborators"><span class="nav-number">1.5.</span> <span class="nav-text">3.4.5 Autowiring collaborators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-Method-injection"><span class="nav-number">1.6.</span> <span class="nav-text">3.4.6 Method injection</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyan</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  
    <script id="dsq-count-scr" src="https://snailtyan.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://noahsnail.com/2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/';
        this.page.identifier = '2016/09/25/2016-09-25-Spring框架介绍_中英文对照_3.4_5.0.0版本/';
        this.page.title = 'Spring框架介绍_中英文对照_3.4_5.0.0版本';
      };
      var d = document, s = d.createElement('script');
      s.src = 'https://snailtyan.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    </script>
  




	





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
