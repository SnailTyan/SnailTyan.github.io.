<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Spring," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Spring框架Spring框架是一个轻量级的解决方案，对于构建一个企业级应用来说，Spring框架也是一种可能的一站式服务。Spring是模块化的，允许你仅使用你需要的那部分功能，而不必引入其它的部分。你可以在任何web框架上使用IoC容器，也可以只使用Hibernate集成代码或JDBC抽象层。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 5.0.0框架介绍_中英文对照_持续更新">
<meta property="og:url" content="noahsnail.com/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/index.html">
<meta property="og:site_name" content="SnailTyan">
<meta property="og:description" content="Spring框架Spring框架是一个轻量级的解决方案，对于构建一个企业级应用来说，Spring框架也是一种可能的一站式服务。Spring是模块化的，允许你仅使用你需要的那部分功能，而不必引入其它的部分。你可以在任何web框架上使用IoC容器，也可以只使用Hibernate集成代码或JDBC抽象层。">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.1.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.2.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.3.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.4.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.5.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_table_2.1.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/log4j_samle.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_work.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_singleton.png">
<meta property="og:image" content="http://ocs628urt.bkt.clouddn.com/spring_prototype.png">
<meta property="og:updated_time" content="2016-12-10T12:12:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring 5.0.0框架介绍_中英文对照_持续更新">
<meta name="twitter:description" content="Spring框架Spring框架是一个轻量级的解决方案，对于构建一个企业级应用来说，Spring框架也是一种可能的一站式服务。Spring是模块化的，允许你仅使用你需要的那部分功能，而不必引入其它的部分。你可以在任何web框架上使用IoC容器，也可以只使用Hibernate集成代码或JDBC抽象层。">
<meta name="twitter:image" content="http://ocs628urt.bkt.clouddn.com/spring_figure_2.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="noahsnail.com/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/"/>





  <title> Spring 5.0.0框架介绍_中英文对照_持续更新 | SnailTyan </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-83591315-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SnailTyan</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="noahsnail.com/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tyan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="SnailTyan">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="SnailTyan" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Spring 5.0.0框架介绍_中英文对照_持续更新
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-07T18:05:21+08:00">
              2016-09-07
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2016-12-10T20:12:56+08:00">
              2016-12-10
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring框架参考手册-5-0-0/" itemprop="url" rel="index">
                    <span itemprop="name">Spring框架参考手册_5.0.0</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
          
          
              <div class="post-description">
                  Spring框架Spring框架是一个轻量级的解决方案，对于构建一个企业级应用来说，Spring框架也是一种可能的一站式服务。Spring是模块化的，允许你仅使用你需要的那部分功能，而不必引入其它的部分。你可以在任何web框架上使用IoC容器，也可以只使用Hibernate集成代码或JDBC抽象层。
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a></p>
<h1 id="Part-I-Overview-of-Spring-Framework"><a href="#Part-I-Overview-of-Spring-Framework" class="headerlink" title="Part I. Overview of Spring Framework"></a>Part I. Overview of Spring Framework</h1><p>The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications. However, Spring is modular, allowing you to use only those parts that you need, without having to bring in the rest. You can use the IoC container, with any web framework on top, but you can also use only theHibernate integration code or the JDBC abstraction layer. The Spring Framework supports declarative transaction management, remote access to your logic through RMI or web services, and various options for persisting your data. It offers a full-featured MVC framework, and enables you to integrate AOP transparently into your software.</p>
<p>Spring框架是一个轻量级的解决方案，对于构建一个企业级应用来说，Spring框架也是一种可能的一站式服务。Spring是模块化的，允许你仅使用你需要的那部分功能，而不必引入其它的部分。你可以在任何web框架上使用IoC容器，也可以只使用Hibernate集成代码或JDBC抽象层。Spring框架支持声明式的业务管理，支持通过RMI或web service来远程访问你的逻辑，并且支持多种持久化数据的方式。Spring提供了一个包含所有功能的MVC框架，使你能将AOP透明的集成到软件中。</p>
<p>Spring is designed to be non-intrusive, meaning that your domain logic code generally has no dependencies on the framework itself. In your integration layer (such as the data access layer), some dependencies on the data access technology and the Spring libraries will exist. However, it should be easy to isolate these dependencies from the rest of your code base.</p>
<p>Spring被设计为非侵入式的，这意味着你自己的逻辑代码通常情况下不依赖于框架本身。在你的集成层（例如数据访问层），将会存在一些数据访问技术的依赖和Spring的库。不管怎样，从你其余的代码中分离这些依赖应该是很容易的。</p>
<p>This document is a reference guide to Spring Framework features. If you have any requests, comments, or questions on this document, please post them on the user mailing list. Questions on the Framework itself should be asked on StackOverflow (see <a href="https://spring.io/questions" target="_blank" rel="external">https://spring.io/questions</a>).</p>
<p>这篇文档是Spring框架功能的参考手册。如果你有任何关于这篇文档的要求、评论或问题，请向用户邮寄列表中的人发邮件。关于框架本身的问题可以在StackOverflow上提问。</p>
<h2 id="1-Getting-Started-with-Spring"><a href="#1-Getting-Started-with-Spring" class="headerlink" title="1.Getting Started with Spring"></a>1.Getting Started with Spring</h2><p>This reference guide provides detailed information about the Spring Framework. It provides comprehensive documentation for all features, as well as some background about the underlying concepts (such as “Dependency Injection”) that Spring has embraced.</p>
<p>这本参考手册提供了关于Spring框架的详细信息，它提供了关于所有功能的全面文档，也介绍了Spring中的基本概念（例如依赖注入）的一些背景。</p>
<p>If you are just getting started with Spring, you may want to begin using the Spring Framework by creating a Spring Boot based application. Spring Boot provides a quick (and opinionated) way to create a production-ready Spring based application. It is based on the Spring Framework, favors convention over configuration, and is designed to get you up and running as quickly as possible.</p>
<p>如果你刚开始学习Spring，你可能想创建一个基于Spring Boot的应用，Spring Boot提供了一个快速（和武断的）方式来创建一个用于生产环境的基于Spring的应用。它是基于Spring框架的，<strong>支持约定大于配置</strong>，被设计为可以快速启动并且尽可能快的运行起来。</p>
<p>You can use start.spring.io to generate a basic project or follow one of the “Getting Started” guides like the Getting Started Building a RESTful Web Service one. As well as being easier to digest, these guides are very task focused, and most of them are based on Spring Boot. They also cover other projects from the Spring portfolio that you might want to consider when solving a particular problem.</p>
<p>你可以用start.spring.io 来生产一个基本的工程或遵循『Getting Started』指南中的一个，例如『Started Building a RESTful Web Service』指南。除了容易理解吸收之外，这些指南主要是基于任务的，它们中的大多数是基于Spring Boot的。它们也包含了Spring的其它工程，当解决一个特定问题时你可能会考虑它们。</p>
<h2 id="2-Introduction-to-the-Spring-Framework"><a href="#2-Introduction-to-the-Spring-Framework" class="headerlink" title="2.Introduction to the Spring Framework"></a>2.Introduction to the Spring Framework</h2><p>The Spring Framework is a Java platform that provides comprehensive infrastructure support for developing Java applications. Spring handles the infrastructure so you can focus on your application.</p>
<p>Spring框架是一个为支持开发Java应用提供全面基础架构的Java平台。Spring处理基础架构，因此你可以集中精力在你有应用上。</p>
<p>Spring enables you to build applications from “plain old Java objects” (POJOs) and to apply enterprise services non-invasively to POJOs. This capability applies to the Java SE programming model and to full and partial Java EE.</p>
<p>Spring使你能创建普通Java对象(POJO)并能非侵入式的将企业服务应用到普通Java对象(POJO)上。</p>
<p>Examples of how you, as an application developer, can benefit from the Spring platform:</p>
<ul>
<li>Make a Java method execute in a database transaction without having to deal with transaction APIs.</li>
<li>Make a local Java method a remote procedure without having to deal with remote APIs.</li>
<li>Make a local Java method a management operation without having to deal with JMX APIs.</li>
<li>Make a local Java method a message handler without having to deal with JMS APIs.</li>
</ul>
<p>作为一个应用开发者，下面是一些你能从Spring平台受益的例子：</p>
<ul>
<li>在一个数据库业务中执行一个Java方法而不必处理业务APIs</li>
<li>使一个本地的Java方法可以远程调用而不必处理远程APIs</li>
<li>使一个本地Java方法变为管理操作而不必处理JMX APIs</li>
<li>使一个本地Java方法变为消息处理器而不必处理JMS APIs</li>
</ul>
<h3 id="2-1-Dependency-Injection-and-Inversion-of-Control"><a href="#2-1-Dependency-Injection-and-Inversion-of-Control" class="headerlink" title="2.1 Dependency Injection and Inversion of Control"></a>2.1 Dependency Injection and Inversion of Control</h3><p>A Java application — a loose term that runs the gamut from constrained, embedded applications to n-tier, server-side enterprise applications — typically consists of objects that collaborate to form the application proper. Thus the objects in an application have <strong><em>dependencies</em></strong> on each other.</p>
<p>Java应用——一个不精确的术语，既可以表示受限制的嵌入式应用又可以表示N层服务端的企业级应用——通常由许多对象构成，这些对象协作形成完整的应用程序。因此一个应用程序中的对象是相互<strong><em>依赖</em></strong>的。</p>
<p>Although the Java platform provides a wealth of application development functionality, it lacks the means to organize the basic building blocks into a coherent whole, leaving that task to architects and developers. Although you can use design patterns such as <strong><em>Factory, Abstract Factory, Builder, Decorator, and Service Locator</em></strong> to compose the various classes and object instances that make up an application, these patterns are simply that: best practices given a name, with a description of what the pattern does, where to apply it, the problems it addresses, and so forth. Patterns are formalized best practices that <strong><em>you must implement yourself</em></strong> in your application.</p>
<p>尽管Java平台提供了大量的应用开发功能，但是它缺少把这些基本构建模块组织成一个连贯整体的方法，并把组织基本构建模块的任务留给了架构师和开发者。虽然你可以使用设计模式例如<strong><em>工厂模式、抽象工厂模式、生成器模式、装饰模式、服务定位模式</em></strong>来创建构成应用的各种类和对象实例，但这些设计模式很简单：命名的最佳方法、模式的作用描述、应用模式的位置、模式解决的问题等等。模式使最佳实践形式化了，这意味着你必须在你的应用中<strong><em>自己实现它</em></strong>。</p>
<p>The Spring Framework <strong><em>Inversion of Control</em></strong> (IoC) component addresses this concern by providing a formalized means of composing disparate components into a fully working application ready for use. The Spring Framework codifies formalized design patterns as first-class objects that you can integrate into your own application(s). Numerous organizations and institutions use the Spring Framework in this manner to engineer robust, <strong><em>maintainable</em></strong> applications.</p>
<p>Spring框架中的<strong><em>控制反转</em></strong>(IoC)组件通过提供一种形式化方法解决了这个问题，这个形式化方法将不同的组件创建到一个随时可用的完整的工作应用中。Spring框架将形式化的设计模式编码成了你可以集成到你自己的应用中的最好对象。许多组织和机构用这种方式应用Spring框架来构建鲁棒的、<strong><em>可维护</em></strong>的应用。</p>
<blockquote>
<p><strong>Background</strong><br>“The question is, what aspect of control are [they] inverting?” Martin Fowler posed this question about Inversion of Control (IoC) on his site in 2004. Fowler suggested renaming the principle to make it more self-explanatory and came up with <strong><em>Dependency Injection</em></strong>.                     </p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>背景</strong><br>“问题是什么是控制反转？” 2004年Martin Fowler在他的网站上提出了这个关于控制反转(IoC)问题。Fowler建议重新命名这个原理使它更一目了然并且提出了<strong><em>依赖注入</em></strong>。</p>
</blockquote>
<h3 id="2-2-Modules"><a href="#2-2-Modules" class="headerlink" title="2.2 Modules"></a>2.2 Modules</h3><p>The Spring Framework consists of features organized into about 20 modules. These modules are grouped into Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming), Instrumentation, Messaging, and Test, as shown in the following diagram.</p>
<p>Spring框架包含的功能大约由20个模块组成。这些模块按组可分为核心容器、数据访问/集成，Web，AOP(面向切面编程)、设备、消息和测试，如下图所示。</p>
<p><strong>Figure 2.1. Overview of the Spring Framework</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_figure_2.1.png" alt="image"></p>
<p>The following sections list the available modules for each feature along with their artifact names and the topics they cover. Artifact names correlate to <strong><em>artifact IDs</em></strong> used in Dependency Management tools.</p>
<p>接下来的章节列出了每个功能可用的模块、它们的工件名字以及它们包含的主题。工件名字与依赖管理工具中使用的<strong><em>artifact IDs</em></strong>有关。</p>
<h4 id="2-2-1-Core-Container"><a href="#2-2-1-Core-Container" class="headerlink" title="2.2.1 Core Container"></a>2.2.1 Core Container</h4><p>The Core Container consists of the <code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code>, <code>spring-context-support</code>, and <code>spring-expression</code> (Spring Expression Language) modules.</p>
<p>核心容器功能包括<code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code>, <code>spring-context-support</code>, and <code>spring-expression</code>(Spring表现语言)模块。</p>
<p>The <code>spring-core</code> and <code>spring-beans</code> modules provide the fundamental parts of the framework, including the IoC and Dependency Injection features. The <code>BeanFactory</code> is a sophisticated implementation of the factory pattern. It removes the need for programmatic singletons and allows you to decouple the configuration and specification of dependencies from your actual program logic.</p>
<p><code>spring-core</code>和<code>spring-beans</code>模块提供了框架的基础结构部分，包含控制反转(IoC)和依赖注入(DI)功能。<code>BeanFactory</code>是工厂模式的高级实现。它去掉了程序单例模式的需求并且允许你从实际的程序逻辑中解耦配置和依赖关系。</p>
<p>The Context (<code>spring-context</code>) module builds on the solid base provided by the Core and Beans modules: it is a means to access objects in a framework-style manner that is similar to a JNDI registry. The Context module inherits its features from the Beans module and adds support for internationalization (using, for example, resource bundles), event propagation, resource loading, and the transparent creation of contexts by, for example, a Servlet container. The Context module also supports Java EE features such as EJB, JMX, and basic remoting. The <code>ApplicationContext</code> interface is the focal point of the Context module.<code>spring-context-support</code> provides support for integrating common third-party libraries into a Spring application context, in particular for caching (EhCache, JCache) and scheduling (CommonJ, Quartz).</p>
<p>上下文(<code>spring-context</code>)模块建立在由Core模块和Beans模块提供的坚实基础上：它是在类似于JNDI注册表式的框架风格模式中访问对象的一种方法。上下文模块继承了Beans模块的功能，并添加了对国际化（例如使用资源捆绑）、事件传播、资源加载和上下文透明创建（例如通过Servlet容器）的支持。上下文模块也支持Java EE功能例如EJB，JMX和基本的远程。<code>ApplicationContext</code>接口是上下文模块的焦点。<code>spring-context-support</code>支持将第三方库集成进Spring应用程序上下文中，特别是缓存(EhCache, JCache)和定时执行(CommonJ, Quartz)。</p>
<p>The <code>spring-expression</code> module provides a powerful <strong><em>Expression Language</em></strong> for querying and manipulating an object graph at runtime. It is an extension of the unified expression language (unified EL) as specified in the JSP 2.1 specification. The language supports setting and getting property values, property assignment, method invocation, accessing the content of arrays, collections and indexers, logical and arithmetic operators, named variables, and retrieval of objects by name from Spring’s IoC container. It also supports list projection and selection as well as common list aggregations.</p>
<p><code>spring-expression</code>模块提供了强大的<strong><em>表达式语言</em></strong>用来在运行时查询和操作对象图。它是JSP 2.1规范中统一表达式语言(unified EL)的扩展。这个语言支持setting和getting属性值，属性分配，方法调用，访问数组、集合和索引器的内容，逻辑和算术操作，变量命名，从Spring Ioc容器中通过名字检索对象。它也支持它还支持列表投影、选择以及常见的列表聚合。</p>
<h4 id="2-2-2-AOP-and-Instrumentation"><a href="#2-2-2-AOP-and-Instrumentation" class="headerlink" title="2.2.2 AOP and Instrumentation"></a>2.2.2 AOP and Instrumentation</h4><p>The <code>spring-aop</code> module provides an <strong><em>AOP</em></strong> Alliance-compliant aspect-oriented programming implementation allowing you to define, for example, method interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated. Using source-level metadata functionality, you can also incorporate behavioral information into your code, in a manner similar to that of .NET attributes.</p>
<p><code>spring-aop</code>模块提供了<strong><em>AOP</em></strong> Alliance-compliant(AOP联盟)面向切面编程的实现，例如允许你自定义方法拦截器和切入点来清晰的解耦功能实现上应该分开的代码。使用源码级的元数据功能，你也可以将行为信息合并到你的代码中，在某种程度上这类似于.NET的属性值。</p>
<p>The separate <code>spring-aspects</code> module provides integration with AspectJ.</p>
<p>独立的<code>spring-aspects</code>模块提供了与AspectJ的集成。</p>
<p>The <code>spring-instrument</code> module provides class instrumentation support and classloader implementations to be used in certain application servers. The <code>spring-instrument-tomcat</code> module contains Spring’s instrumentation agent for Tomcat.</p>
<p><code>spring-instrument</code>模块提供了类设备支持和类加载器的实现，它们可以在某些应用服务器中使用。<code>spring-instrument-tomcat</code>模块包含了Tomcat的Spring设备代理。</p>
<h4 id="2-2-3-Messaging"><a href="#2-2-3-Messaging" class="headerlink" title="2.2.3 Messaging"></a>2.2.3 Messaging</h4><p>Spring Framework 4 includes a <code>spring-messaging</code> module with key abstractions from the <strong><em>Spring Integration</em></strong> project such as <code>Message</code>, <code>MessageChannel</code>, <code>MessageHandler</code>, and others to serve as a foundation for messaging-based applications. The module also includes a set of annotations for mapping messages to methods, similar to the Spring MVC annotation based programming model.</p>
<p>Spring 4框架中包含了<code>spring-messaging</code>模块，它对<strong><em>Spring集成</em></strong>项目例如<code>Message</code>, <code>MessageChannel</code>, <code>MessageHandler</code>和其它作为消息应用服务基础的项目进行了重要的抽象。这个模块也包含了一系列将消息映射到方法上的注解，这个注解与基于编程模型Spring MVC注解类似。</p>
<h4 id="2-2-4-Data-Access-Integration"><a href="#2-2-4-Data-Access-Integration" class="headerlink" title="2.2.4 Data Access/Integration"></a>2.2.4 Data Access/Integration</h4><p>The <strong><em>Data Access/Integration</em></strong> layer consists of the JDBC, ORM, OXM, JMS, and Transaction modules.</p>
<p><strong><em>数据访问/集成</em></strong>层包括JDBC,ORM,OXM,JMS和业务模块。</p>
<p>The <code>spring-jdbc</code> module provides a JDBC-abstraction layer that removes the need to do tedious JDBC coding and parsing of database-vendor specific error codes.</p>
<p><code>spring-jdbc</code>模块提供了JDBC抽象层，不需要再编写单调的JDBC代码，解析数据库提供商指定的错误编码。</p>
<p>The <code>spring-tx</code> module supports programmatic and declarative transaction management for classes that implement special interfaces and for <strong><em>all your POJOs (Plain Old Java Objects)</em></strong>.</p>
<p><code>spring-tx</code>模块为实现指定接口和所有的普通Java对象(POJOs)的类提供编程式(programmatic)和声明式(declarative)的业务管理。</p>
<p>The <code>spring-orm</code> module provides integration layers for popular object-relational mapping APIs, including JPA and Hibernate. Using the <code>spring-orm</code> module you can use these O/R-mapping frameworks in combination with all of the other features Spring offers, such as the simple declarative transaction management feature mentioned previously.</p>
<p><code>spring-orm</code>模块提供流行的对象关系映射APIs的集成层，包括JPA和Hibernate。在使用<code>spring-orm</code>模块时，你可以将Spring的其它功能与这些O/R-mapping框架结合起来使用，例如前面提到的简单声明式业务管理的功能。</p>
<p>The <code>spring-oxm</code> module provides an abstraction layer that supports Object/XML mapping implementations such as JAXB, Castor, JiBX and XStream.</p>
<p><code>spring-oxm</code>模块提供对Object/XML映射实现例如JAXB，Castor，JiBx和XStream的抽象层。</p>
<p>The <code>spring-jms</code> module (Java Messaging Service) contains features for producing and consuming messages. Since Spring Framework 4.1, it provides integration with the <code>spring-messaging</code> module.</p>
<p><code>spring-jms</code>模块（Java消息服务）包含产生和处理消息的功能。从Spring 4.1框架开始它提供了与<code>spring-messaging</code>的集成。</p>
<h4 id="2-2-5-Web"><a href="#2-2-5-Web" class="headerlink" title="2.2.5 Web"></a>2.2.5 Web</h4><p>The Web layer consists of the <code>spring-web</code>, <code>spring-webmvc</code> and <code>spring-websocket</code> modules.</p>
<p>网络层包含<code>spring-web</code>, <code>spring-webmvc</code>和<code>spring-websocket</code>模块。</p>
<p>The <code>spring-web</code> module provides basic web-oriented integration features such as multipart file upload functionality and the initialization of the IoC container using Servlet listeners and a web-oriented application context. It also contains an HTTP client and the web-related parts of Spring’s remoting support.</p>
<p><code>spring-web</code>模块提供基本的面向网络集成功能，例如multipart文件上传功能，使用Servlet监听器来初始化Ioc容器和面向网络的应用程序上下文。它也包含了HTTP客户端和Spring远程支持中网络相关的部分。</p>
<p>The <code>spring-webmvc</code> module (also known as the <strong><em>Web-Servlet</em></strong> module) contains Spring’s model-view-controller (MVC) and REST Web Services implementation for web applications. Spring’s MVC framework provides a clean separation between domain model code and web forms and integrates with all of the other features of the Spring Framework.</p>
<p><code>spring-webmvc</code>模块（也被称为<strong><em>Web-Servlet</em></strong>模块）包含了Spring的model-view-controller(MVC)和REST Web Services的网络应用实现。Spring的MVC框架提供了对领域模型代码，web表单，Spring框架其他功能的完全分离。</p>
<h4 id="2-2-6-Test"><a href="#2-2-6-Test" class="headerlink" title="2.2.6 Test"></a>2.2.6 Test</h4><p>The <code>spring-test</code> module supports the unit testing and integration testing of Spring components with JUnit or TestNG. It provides consistent loading of Spring <code>ApplicationContexts</code> and caching of those contexts. It also provides mock objects that you can use to test your code in isolation.</p>
<p><code>spring-test</code>模块支持单元测试，Spring组件和JUnit或TestNG的集成测试。它提供了Spring的<code>ApplicationContexts</code>加载和这些上下文缓存的一致。它也提供了可以单独测试代码的模拟对象。</p>
<h3 id="2-3-Usage-scenarios"><a href="#2-3-Usage-scenarios" class="headerlink" title="2.3 Usage scenarios"></a>2.3 Usage scenarios</h3><p>The building blocks described previously make Spring a logical choice in many scenarios, from embedded applications that run on resource-constrained devices to full-fledged enterprise applications that use Spring’s transaction management functionality and web framework integration.</p>
<p>前面描述的搭积木方式使Spring在许多场景中都有一个合理选择，从运行在资源受限的嵌入式应用到全面成熟的企业级应用都在使用Spring的业务管理功能和网络框架集成。</p>
<p><strong>Figure 2.2. Typical full-fledged Spring web application</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_figure_2.2.png" alt="image"></p>
<p>Spring’s declarative transaction management features make the web application fully transactional, just as it would be if you used EJB container-managed transactions. All your custom business logic can be implemented with simple POJOs and managed by Spring’s IoC container. Additional services include support for sending email and validation that is independent of the web layer, which lets you choose where to execute validation rules. Spring’s ORM support is integrated with JPA and Hibernate; for example, when using Hibernate, you can continue to use your existing mapping files and standard Hibernate <code>SessionFactory</code> configuration. Form controllers seamlessly integrate the web-layer with the domain model, removing the need for <code>ActionForms</code> or other classes that transform HTTP parameters to values for your domain model.</p>
<p>Spring的声明式业务管理功能使web应用全面的业务化，如果你用过EJB容器管理业务的话你会发现它们基本一样。你所有自定义的业务逻辑都可以用POJOs实现并通过Spring的IoC容器管理。附加业务包括支持邮件发送和验证，这个是独立于web层之外的，你可以自由选择验证规则执行的位置。Spring对ORM的支持与JPA和Hibernate进行了集成；例如，当你使用Hibernate时，你可以继续使用你现有的映射文件和标准的Hibernate <code>SessionFactory</code>配置。表单控制器被无缝的将web层和领域模型进行了集成，对于你的领域模型来讲不再需要<code>ActionForms</code>或其它的将HTTP参数转换成值的</p>
<p><strong>Figure 2.3. Spring middle-tier using a third-party web framework</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_figure_2.3.png" alt="image"></p>
<p>Sometimes circumstances do not allow you to completely switch to a different framework. The Spring Framework does not force you to use everything within it; it is not an <strong><em>all-or-nothing</em></strong> solution. Existing front-ends built with Struts, Tapestry, JSF or other UI frameworks can be integrated with a Spring-based middle-tier, which allows you to use Spring transaction features. You simply need to wire up your business logic using an <code>ApplicationContext</code> and use a <code>WebApplicationContext</code> to integrate your web layer.</p>
<p>有时候环境不允许你完全转成一个不同的框架。Spring框架<strong><em>不</em></strong>强迫你都采用它内部的东西；它不是一个<strong><em>要么全有要么全无</em></strong>的解决方案。现有的采用Struts,Tapestry,JSF或其它UI框架构建的前端可以与基于Spring的中间层进行集成，这可以让你使用Spring的业务功能。你只需要简单的用<code>ApplicationContext</code>和<code>WebApplicationContext</code>绑定你的业务逻辑然后集成到web层即可。</p>
<p><strong>Figure 2.4. Remoting usage scenario</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_figure_2.4.png" alt="image"></p>
<p>When you need to access existing code through web services, you can use Spring’s <code>Hessian-</code>, <code>Rmi-</code> or <code>HttpInvokerProxyFactoryBean</code> classes. Enabling remote access to existing applications is not difficult.</p>
<p>当你需要通过web服务访问现有代码时，你可以使用Spring的<code>Hessian-</code>, <code>Rmi-</code> 或 <code>HttpInvokerProxyFactoryBean</code>类。这能让远程访问现有应用变得很容易。</p>
<p><strong>Figure 2.5. EJBs - Wrapping existing POJOs</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_figure_2.5.png" alt="image"></p>
<p>The Spring Framework also provides an access and abstraction layer for Enterprise JavaBeans, enabling you to reuse your existing POJOs and wrap them in stateless session beans for use in scalable, fail-safe web applications that might need declarative security.</p>
<p>Spring框架也为企业JavaBeans提供了访问和抽象层，使你能重用你现有的POJOs，为了可扩展使用可以将它们包装成无状态的session beans，自动防故障的web应用可能需要声明安全。</p>
<h4 id="2-3-1-Dependency-Management-and-Naming-Conventions"><a href="#2-3-1-Dependency-Management-and-Naming-Conventions" class="headerlink" title="2.3.1 Dependency Management and Naming Conventions"></a>2.3.1 Dependency Management and Naming Conventions</h4><p>Dependency management and dependency injection are different things. To get those nice features of Spring into your application (like dependency injection) you need to assemble all the libraries needed (jar files) and get them onto your classpath at runtime, and possibly at compile time. These dependencies are not virtual components that are injected, but physical resources in a file system (typically). The process of dependency management involves locating those resources, storing them and adding them to classpaths. Dependencies can be direct (e.g. my application depends on Spring at runtime), or indirect (e.g. my application depends on <code>commons-dbcp</code> which depends on <code>commons-pool</code>). The indirect dependencies are also known as “transitive” and it is those dependencies that are hardest to identify and manage.</p>
<p>依赖管理和依赖注入是完全不同的两件事。为了能你的应用中使用Spring的优秀特性（像依赖注入），你需要收集所有必要的库(jar文件)并在运行时将它们添加到classpath中，有可能在编译时就需要添加。这些依赖不是要被注入的虚拟组建，而是文件系统中的物理资源(通常情况下)。这些依赖管理的过程包括资源的定位、存储和添加到classpath中。依赖可以是直接的（例如：我的应用在运行时依赖Spring），或间接的（例如：我的应用依赖<code>commons-dbcp</code>，而它依赖<code>commons-pool</code>）。间接依赖也被称为”传递式”的，这些依赖也是最难识别和管理的。</p>
<p>If you are going to use Spring you need to get a copy of the jar libraries that comprise the pieces of Spring that you need. To make this easier Spring is packaged as a set of modules that separate the dependencies as much as possible, so for example if you don’t want to write a web application you don’t need the spring-web modules. To refer to Spring library modules in this guide we use a shorthand naming convention <code>spring-*</code> or <code>spring-*.jar</code>, where <code>*</code> represents the short name for the module (e.g. <code>spring-core</code>, <code>spring-webmvc</code>, <code>spring-jms</code>, etc.). The actual jar file name that you use is normally the module name concatenated with the version number (e.g. <code>spring-core-5.0.0.BUILD-SNAPSHOT.jar</code>).</p>
<p>如果你想使用Spring，你需要有包含你需要的Spirng功能的jar库副本。为了使这个更容易，Spring被打包成了一系列尽可能将依赖分离开的模块，例如你不想写web应用那你就不需要spring-web模块。为了在本指南中谈及Spring的库模块，我们使用了一个简写命名约定<code>spring-*</code>或<code>spring-*.jar</code>，<code>*</code>表示模块的简写名字(例如<code>spring-core</code>, <code>spring-webmvc</code>, <code>spring-jms</code>等等)。实际中你使用的jar文件名字通常是模块名加上版本号（例如<code>spring-core-5.0.0.BUILD-SNAPSHOT.jar</code>）。</p>
<p>Each release of the Spring Framework will publish artifacts to the following places:</p>
<ul>
<li>Maven Central, which is the default repository that Maven queries, and does not require any special configuration to use. Many of the common libraries that Spring depends on also are available from Maven Central and a large section of the Spring community uses Maven for dependency management, so this is convenient for them. The names of the jars here are in the form <code>spring-*-&lt;version&gt;.jar</code> and the Maven groupId is <code>org.springframework</code>.</li>
<li>In a public Maven repository hosted specifically for Spring. In addition to the final GA releases, this repository also hosts development snapshots and milestones. The jar file names are in the same form as Maven Central, so this is a useful place to get development versions of Spring to use with other libraries deployed in Maven Central. This repository also contains a bundle distribution zip file that contains all Spring jars bundled together for easy download.<br>So the first thing you need to decide is how to manage your dependencies: we generally recommend the use of an automated system like Maven, Gradle or Ivy, but you can also do it manually by downloading all the jars yourself.</li>
</ul>
<p>Spring框架的每次发布都会下面的地方公布artifacts：</p>
<ul>
<li>Maven Central，Maven查询的默认仓库，使用时不需要任何特定的配置。Spring依赖的许多共通库也可以从Maven Central获得，Spring社区的很大一部分都在使用Maven进行依赖管理，因此这对他们来说是很方便的。jar包的命名形式是<code>spring-*-&lt;version&gt;.jar</code>，Maven GroupId是<code>org.springframework</code>。</li>
<li>由Spring掌管的公开Maven库。除了最终的GA release（公开可获得的版本）之外，这个仓库也有开发版本的快照和milestone版本。jar包的命名形式和Maven Central一样，这是一个可以使用Spring开发版本有用地方，而其它的库部署在Maven Central。这个库也包含的捆绑分布的zip文件，这个zip文件中所有的Spring jar包被捆绑到一起很容易下载。</li>
</ul>
<p>You will find bellow the list of Spring artifacts. For a more complete description of each modules, see Section 2.2, “Modules”.</p>
<p>你将在下面找到Spring artifacts列表。想要每个模块更全面的描述，请看2.2小节。</p>
<p><strong>Table 2.1. Spring Framework Artifacts</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_table_2.1.png" alt="image"><br><!--
| GroupId | ArtifactId | Description |
| :------ | :------ | :------ |
| org.springframework | spring-aop               | Proxy-based AOP support |
| org.springframework | spring-aspects           | AspectJ based aspects |
| org.springframework | spring-beans             | Beans support, including Groovy |
| org.springframework | spring-context           | Application context runtime, including scheduling and remoting abstractions |
| org.springframework | spring-context-support   | Support classes for integrating common third-party libraries into a Spring application context |
| org.springframework | spring-core              | Core utilities, used by many other Spring modules |
| org.springframework | spring-expression        | Spring Expression Language (SpEL) |
| org.springframework | spring-instrument        | Instrumentation agent for JVM bootstrapping |
| org.springframework | spring-instrument-tomcat | Instrumentation agent for Tomcat |
| org.springframework | spring-jdbc              | JDBC support package, including DataSource setup and JDBC access support |
| org.springframework | spring-jms               | JMS support package, including helper classes to send and receive JMS messages |
| org.springframework | spring-messaging         | Support for messaging architectures and protocols |
| org.springframework | spring-orm               | Object/Relational Mapping, including JPA and Hibernate support |
| org.springframework | spring-oxm               | Object/XML Mapping |
| org.springframework | spring-test              | Support for unit testing and integration testing Spring components |
| org.springframework | spring-tx                | Transaction infrastructure, including DAO support and JCA integration |
| org.springframework | spring-web               | Web support packages, including client and web remoting |
| org.springframework | spring-webmvc            | REST Web Services and model-view-controller implementation for web applications |
| org.springframework | spring-websocket         | WebSocket and SockJS implementations, including STOMP support |
--><br><strong>Spring Dependencies and Depending on Spring</strong></p>
<p>Although Spring provides integration and support for a huge range of enterprise and other external tools, it intentionally keeps its mandatory dependencies to an absolute minimum: you shouldn’t have to locate and download (even automatically) a large number of jar libraries in order to use Spring for simple use cases. For basic dependency injection there is only one mandatory external dependency, and that is for logging (see below for a more detailed description of logging options).</p>
<p>虽然Spring提供集成并支持大范围内的企业和其它外部工具，但它有意使它的强制性依赖到一个绝对最小化的程度：对于简单的用例你不应该为了使用Spring而定位和下载（即使是自动的）许多jar库。对于基本的依赖注入仅有一个强制性的外部依赖，那个依赖是关于日志的（在下面可以看到日志选择更详细的描述）。</p>
<p>Next we outline the basic steps needed to configure an application that depends on Spring, first with Maven and then with Gradle and finally using Ivy. In all cases, if anything is unclear, refer to the documentation of your dependency management system, or look at some sample code - Spring itself uses Gradle to manage dependencies when it is building, and our samples mostly use Gradle or Maven.</p>
<p>接下来我们概述配置一个依赖于Spring的应用需要的基本步骤，首先Maven的，其次是Gradle的，最后是Ivy的。在所有的案例中，如果有任何不清楚的地方，请参考你的依赖管理系统的文档，或者看一些示例代码——Spring本身构建时使用Gradle来管理依赖，我们例子中大多数是使用Gradle和Maven的。</p>
<p><strong>Maven Dependency Management</strong></p>
<p>If you are using Maven for dependency management you don’t even need to supply the logging dependency explicitly. For example, to create an application context and use dependency injection to configure an application, your Maven dependencies will look like this:</p>
<p>如果你正在使用Maven来进行依赖管理，那你不必显式的提供日志依赖。例如，为了创建一个应用上下文，使用依赖注入来配置一个应用，你的Maven依赖看上去是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt;</div><div class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>That’s it. Note the scope can be declared as runtime if you don’t need to compile against Spring APIs, which is typically the case for basic dependency injection use cases.</p>
<p>就是它。注意如果你不需要编译Spring APIs，scope可以被声明成rumtime，这是典型的基本依赖注入的情况。</p>
<p>The example above works with the Maven Central repository. To use the Spring Maven repository (e.g. for milestones or developer snapshots), you need to specify the repository location in your Maven configuration. For full releases:</p>
<p>上面的例子是采用Maven中心仓库的。为了使用Spring Maven仓库(例如：使用milestone版本或snapshot版本)，你需要在Maven配置中指定仓库的位置，完整的版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;</div><div class="line">    &lt;repository&gt;</div><div class="line">        &lt;id&gt;io.spring.repo.maven.release&lt;/id&gt;</div><div class="line">        &lt;url&gt;http://repo.spring.io/release/&lt;/url&gt;</div><div class="line">        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">    &lt;/repository&gt;</div><div class="line">&lt;/repositories&gt;</div></pre></td></tr></table></figure>
<p>For milestones:<br>对于milestone版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;</div><div class="line">    &lt;repository&gt;</div><div class="line">        &lt;id&gt;io.spring.repo.maven.milestone&lt;/id&gt;</div><div class="line">        &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt;</div><div class="line">        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">    &lt;/repository&gt;</div><div class="line">&lt;/repositories&gt;</div></pre></td></tr></table></figure>
<p>And for snapshots:<br>对于snapshot版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;   </div><div class="line">    &lt;repository&gt;</div><div class="line">        &lt;id&gt;io.spring.repo.maven.snapshot&lt;/id&gt;</div><div class="line">        &lt;url&gt;http://repo.spring.io/snapshot/&lt;/url&gt;</div><div class="line">        &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">    &lt;/repository&gt;</div><div class="line">&lt;/repositories&gt;</div></pre></td></tr></table></figure>
<p><strong>Maven “Bill Of Materials” Dependency</strong></p>
<p>It is possible to accidentally mix different versions of Spring JARs when using Maven. For example, you may find that a third-party library, or another Spring project, pulls in a transitive dependency to an older release. If you forget to explicitly declare a direct dependency yourself, all sorts of unexpected issues can arise.</p>
<p>在使用Maven时，有可能会偶然的将不同版本的Spring JARs混合起来。例如，你可能找到一个第三方库，或另一个Spring项目，通过传递依赖进入了一个更旧的版本。如果你忘了自己显式的声明一个直接依赖，会产生各种意想不到的问题。</p>
<p>To overcome such problems Maven supports the concept of a “bill of materials” (BOM) dependency. You can import the <code>spring-framework-bom</code> in your <code>dependencyManagement</code> section to ensure that all spring dependencies (both direct and transitive) are at the same version.</p>
<p>为了解决这种问题，Maven支持”材料清单”(BOM)依赖的概念。你可以在你的<code>dependencyManagement</code>部分导入<code>spring-framework-bom</code>来确保所有的Spring依赖（直接和传递的）都是同一个版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependencyManagement&gt;</div><div class="line">    &lt;dependencies&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt;</div><div class="line">            &lt;type&gt;pom&lt;/type&gt;</div><div class="line">            &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line">&lt;/dependencyManagement&gt;</div></pre></td></tr></table></figure>
<p>An added benefit of using the BOM is that you no longer need to specify the <code>&lt;version&gt;</code> attribute when depending on Spring Framework artifacts:</p>
<p>使用BOM的额外好处是当依赖Spring框架的artifacts时你不再需要指定<code>&lt;version&gt;</code>属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;dependencies&gt;</div></pre></td></tr></table></figure>
<p><strong>Gradle Dependency Management</strong></p>
<p>To use the Spring repository with the Gradle build system, include the appropriate URL in the <code>repositories</code> section:</p>
<p>为了在Gradle构建系统中使用Spring仓库，在<code>repositories</code>部分需要包含合适的URL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">    <span class="comment">// and optionally...</span></div><div class="line">    maven &#123; url <span class="string">"http://repo.spring.io/release"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You can change the <code>repositories</code> URL from <code>/release</code> to <code>/milestone</code> or <code>/snapshot</code> as appropriate. Once a repository has been configured, you can declare dependencies in the usual Gradle way:</p>
<p>当合适的时候你可以修改<code>repositories</code>的URL从<code>/release</code>到<code>/milestone</code>或<code>/snapshot</code>。一旦一个仓库被配置了，你可以用通常的Gradle方式声明依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile(<span class="string">"org.springframework:spring-context:5.0.0.BUILD-SNAPSHOT"</span>)</div><div class="line">    testCompile(<span class="string">"org.springframework:spring-test:5.0.0.BUILD-SNAPSHOT"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Ivy Dependency Management</strong></p>
<p>If you prefer to use Ivy to manage dependencies then there are similar configuration options.</p>
<p>如果你更喜欢使用Ivy来管理依赖，这有类似的配置选择。</p>
<p>To configure Ivy to point to the Spring repository add the following resolver to your <code>ivysettings.xml</code>:</p>
<p>为了配置Ivy指定Spring仓库，添加下面的解析器到你的<code>ivysettings.xml</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;resolvers&gt;</div><div class="line">    &lt;ibiblio name="io.spring.repo.maven.release"</div><div class="line">            m2compatible="true"</div><div class="line">            root="http://repo.spring.io/release/"/&gt;</div><div class="line">&lt;/resolvers&gt;</div></pre></td></tr></table></figure>
<p>You can change the root URL from <code>/release/</code> to <code>/milestone/</code> or <code>/snapshot/</code> as appropriate.</p>
<p>当合适的时候你可以更改根URL从<code>repositories</code>的URL从<code>/release</code>到<code>/milestone</code>或<code>/snapshot</code>。</p>
<p>Once configured, you can add dependencies in the usual way. For example (in <code>ivy.xml</code>):</p>
<p>一旦配置了，你可以通过一般的方式添加依赖。例如（在<code>ivy.xml</code>）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;dependency org=<span class="string">"org.springframework"</span></div><div class="line">    name=<span class="string">"spring-core"</span> rev=<span class="string">"5.0.0.BUILD-SNAPSHOT"</span> conf=<span class="string">"compile-&gt;runtime"</span>/&gt;</div></pre></td></tr></table></figure>
<p><strong>Distribution Zip Files</strong></p>
<p>Although using a build system that supports dependency management is the recommended way to obtain the Spring Framework, it is still possible to download a distribution zip file.</p>
<p>尽管使用一个支持依赖管理的构建系统是获得Spring框架的推荐方式，但仍然可以下载发行版的Zip文件。</p>
<p>Distribution zips are published to the Spring Maven Repository (this is just for our convenience, you don’t need Maven or any other build system in order to download them).</p>
<p>发行版的zips是被发布到Spring Maven仓库（这只是为了我们的方便，为了下载它们你不需要Maven或任何其它的构建系统）。</p>
<p>To download a distribution zip open a web browser to <a href="http://repo.spring.io/release/org/springframework/spring" target="_blank" rel="external">http://repo.spring.io/release/org/springframework/spring</a> and select the appropriate subfolder for the version that you want. Distribution files end <code>-dist.zip</code>, for example spring-framework-{spring-version}-RELEASE-dist.zip. Distributions are also published for milestones and snapshots.</p>
<p>为了下载发行版zip，打开浏览器输入<a href="http://repo.spring.io/release/org/springframework/spring" target="_blank" rel="external">http://repo.spring.io/release/org/springframework/spring</a>，然后选择你想要的版本的合适子文件夹。发行版文件以<code>-dist.zip</code>结尾，例如spring-framework-{spring-version}-RELEASE-dist.zip。发行版也可以公布milestone版本或snapshots版本。</p>
<h4 id="2-3-2-Logging"><a href="#2-3-2-Logging" class="headerlink" title="2.3.2 Logging"></a>2.3.2 Logging</h4><p>Logging is a very important dependency for Spring because <em>a)</em> it is the only mandatory external dependency, <em>b)</em> everyone likes to see some output from the tools they are using, and <em>c)</em> Spring integrates with lots of other tools all of which have also made a choice of logging dependency. One of the goals of an application developer is often to have unified logging configured in a central place for the whole application, including all external components. This is more difficult than it might have been since there are so many choices of logging framework.</p>
<p>日志对于Spring来说是一个非常重要的依赖，因为：<em>a)</em>它是唯一的强制性外部依赖，<em>b)</em>每个人都喜欢从他们使用的工具中看到一些输出，<em>c)</em>Spring集成了许多其它的工具，这些工具也选择了日志依赖。应用开发者的一个目标就是对于整个应用来讲，经常要有一个中心地方来进行日志的统一配置，包括所有的外部组件。比它更困难的可能是有太多的日志框架去选择。</p>
<p>The mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL). We compile against JCL and we also make JCL <code>Log</code> objects visible for classes that extend the Spring Framework. It’s important to users that all versions of Spring use the same logging library: migration is easy because backwards compatibility is preserved even with applications that extend Spring. The way we do this is to make one of the modules in Spring depend explicitly on <code>commons-logging</code> (the canonical implementation of JCL), and then make all the other modules depend on that at compile time. If you are using Maven for example, and wondering where you picked up the dependency on <code>commons-logging</code>, then it is from Spring and specifically from the central module called <code>spring-core</code>.</p>
<p>Spring中的强制日志依赖是Jakarta Commons Logging API (JCL)。我们编译JCL并使JCL<code>log</code>对象对类是可见的，这扩展了Spring框架。所有版本的Spring采用同一个日志库：移植是容易的，因为即使应用扩展了Spring但保留了向后兼容性，这一点对用户来说很重要。我们实现这个的方式是让Spring的模块之一显式的依赖<code>commons-logging</code>(JCL的标准实现)，然后使其它模块在编译时依赖这个模块。例如如果你在使用Maven，想找出依赖于<code>commons-logging</code>的依赖在哪，它在Spring中，更确切的说它是在Spring的中心模块<code>spring-core</code>中。</p>
<p>The nice thing about <code>commons-logging</code> is that you don’t need anything else to make your application work. It has a runtime discovery algorithm that looks for other logging frameworks in well known places on the classpath and uses one that it thinks is appropriate (or you can tell it which one if you need to). If nothing else is available you get pretty nice looking logs just from the JDK (java.util.logging or JUL for short). You should find that your Spring application works and logs happily to the console out of the box in most situations, and that’s important.</p>
<p>关于<code>commons-logging</code>的一件好事是要使你的应用工作你不需要任何其它的东西。它有一个运行时发现算法，这个算法能寻找其它的日志框架在知名的classpath中，并使用一个它认为是合适的(或者你告诉它你想用哪个如果你需要的话)。如果找不到任何别的你可以从JDK中找到一个非常美好漂亮的日志(java.util.logging或缩写为JUL)。在大多数环境中你可以发现你的Spring应用恰当地运行并输出日志到控制台输出框中，那是很重要的。</p>
<p><strong>Not Using Commons Logging</strong></p>
<p>Unfortunately, the runtime discovery algorithm in <code>commons-logging</code>, while convenient for the end-user, is problematic. If we could turn back the clock and start Spring now as a new project it would use a different logging dependency. The first choice would probably be the Simple Logging Facade for Java ( SLF4J), which is also used by a lot of other tools that people use with Spring inside their applications.</p>
<p>不幸的是， 虽然<code>commons-logging</code>的运行时发现算法对于终端用户是方便的，但它是有问题的。如果我们将时钟回拨，把Spring作为一个新项目重新开始，将会选择一个不同的日志依赖。第一个选择可能是Simple Logging Facade for Java(SLF4J)，应用内部使用Spring的人使用的许多其它工具也用了SLF4J。</p>
<p>There are basically two ways to switch off <code>commons-logging</code>:</p>
<ol>
<li>Exclude the dependency from the <code>spring-core</code> module (as it is the only module that explicitly depends on <code>commons-logging</code>)</li>
<li>Depend on a special commons-logging dependency that replaces the library with an empty jar (more details can be found in the SLF4J FAQ)</li>
</ol>
<p>这儿有两种方式关掉<code>commons-logging</code>:</p>
<ol>
<li>从<code>spring-core</code>模块排除依赖（因为它是唯一的显式依赖）<code>commons-logging</code>的模块</li>
<li>依赖于一个特定的<code>commons-logging</code>依赖，用一个空jar替换这个依赖（更多细节可以在<a href="http://slf4j.org/faq.html#excludingJCL" target="_blank" rel="external">SLF4J FAQ</a>中找到）。</li>
</ol>
<p>To exclude <code>commons-logging</code>, add the following to your <code>dependencyManagement</code> section:</p>
<p>为了排除<code>commons-logging</code>，把下面的内容加入到你的<code>dependencyManagement</code>部分：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt;</div><div class="line">        &lt;exclusions&gt;</div><div class="line">            &lt;exclusion&gt;</div><div class="line">                &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">            &lt;/exclusion&gt;</div><div class="line">        &lt;/exclusions&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>Now this application is probably broken because there is no implementation of the JCL API on the classpath, so to fix it a new one has to be provided. In the next section we show you how to provide an alternative implementation of JCL using SLF4J as an example.</p>
<p>现在这个应用可能是坏了的，因为在classpath中没有JCL API的实现，为了解决这个问题必须提供一个新的实现。在接下来的部分我们将向你展示怎样提供一个JCL替代实现，使用SLF4J就是一个例子。</p>
<p><strong>Using SLF4J</strong></p>
<p>SLF4J is a cleaner dependency and more efficient at runtime than <code>commons-logging</code> because it uses compile-time bindings instead of runtime discovery of the other logging frameworks it integrates. This also means that you have to be more explicit about what you want to happen at runtime, and declare it or configure it accordingly. SLF4J provides bindings to many common logging frameworks, so you can usually choose one that you already use, and bind to that for configuration and management.</p>
<p>SLF4J是一个更纯净的依赖并且在运行时比<code>commons-logging</code>更有效，因为它使用编译时绑定来代替运行时查找集成的其它日志框架。这也意味着你必须更清楚你想要运行时发生什么，然后相应的声明它或配置它。SLF4J提供跟许多常用日志框架的绑定，因此你通常可以选择一个你正在使用的日志框架，然后绑定到配置和管理上。</p>
<p>SLF4J provides bindings to many common logging frameworks, including JCL, and it also does the reverse: bridges between other logging frameworks and itself. So to use SLF4J with Spring you need to replace the <code>commons-logging</code> dependency with the SLF4J-JCL bridge. Once you have done that then logging calls from within Spring will be translated into logging calls to the SLF4J API, so if other libraries in your application use that API, then you have a single place to configure and manage logging.</p>
<p>SLF4J提供跟许多常用日志框架的绑定，包括JCL，它做的恰恰相反，建立其它日志框架和它自己的纽带。因此为了在Spring中使用SLF4J，你需要用SLF4J-JCL连接器取替换<code>commons-logging</code>依赖。一旦你在Spring内部使用了日志调用，Spring会将日志调用变为调用SLF4J API，如果你应用中其它的库调用了那个API，你将有一个单独的地方配置和管理日志。</p>
<p>A common choice might be to bridge Spring to SLF4J, and then provide explicit binding from SLF4J to Log4J. You need to supply 4 dependencies (and exclude the existing <code>commons-logging</code>): the bridge, the SLF4J API, the binding to Log4J, and the Log4J implementation itself. In Maven you would do that like this</p>
<p>一个常用的选择连接Spring和SLF4J，然后提供SLF4J到Log4J的显式绑定。你需要提供四个依赖(排除现有的<code>commons-logging</code>)：连接、SLF4J API、到Log4J的绑定、Log4J本身的实现。在Maven中你可能这么做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt;</div><div class="line">        &lt;exclusions&gt;</div><div class="line">            &lt;exclusion&gt;</div><div class="line">                &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">            &lt;/exclusion&gt;</div><div class="line">        &lt;/exclusions&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.8&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.8&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.5.8&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2.14&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>That might seem like a lot of dependencies just to get some logging. Well it is, but it <em>is</em> optional, and it should behave better than the vanilla <code>commons-logging</code> with respect to classloader issues, notably if you are in a strict container like an OSGi platform. Allegedly there is also a performance benefit because the bindings are at compile-time not runtime.</p>
<p>这可能看起来为了得到一些日志需要很多依赖。还好它是可选的，比起<code>commons-logging</code>的关于类加载器的问题，尤其是你在一个像OSGi平台那样严格的容器中的时候，它应该更好操作。据说这儿也有一个性能提升，因为绑定是在编译时而不是在运行时。</p>
<p>A more common choice amongst SLF4J users, which uses fewer steps and generates fewer dependencies, is to bind directly to Logback. This removes the extra binding step because Logback implements SLF4J directly, so you only need to depend on two libraries not four ( <code>jcl-over-slf4j</code> and <code>logback</code>). If you do that you might also need to exclude the slf4j-api dependency from other external dependencies (not Spring), because you only want one version of that API on the classpath.</p>
<p>在SLF4J用户中，一个更通用的选择是直接绑定到<a href="http://logback.qos.ch/" target="_blank" rel="external">Logback</a>，这样使用步骤更少且依赖也更少。这去除了外部绑定步骤，因为Logback直接实现了SLF4J，因此你仅需要依赖两个库而不是四个(<code>jcl-over-slf4j</code>和<code>logback</code>)。如果你这样做的话你可能也需要从其它的外部应用中（不是从Spring）排除slf4j-api依赖，因为你在classpath中仅需要一个版本的API。</p>
<p><strong>Using Log4J</strong></p>
<p>Many people use Log4j as a logging framework for configuration and management purposes. It’s efficient and well-established, and in fact it’s what we use at runtime when we build and test Spring. Spring also provides some utilities for configuring and initializing Log4j, so it has an optional compile-time dependency on Log4j in some modules.</p>
<p>许多人使用Log4j作为配置和管理的日志框架。它有效且完善的，当我们构建和测试Spring时，实际上这就是在运行时我们使用的东西。Spring也提供一些配置和初始化Log4j的工具，因此在某些模块有可选的Log4j的编译时依赖。</p>
<p>To make Log4j work with the default JCL dependency (<code>commons-logging</code>) all you need to do is put Log4j on the classpath, and provide it with a configuration file ( <code>log4j.properties</code> or <code>log4j.xml</code> in the root of the classpath). So for Maven users this is your dependency declaration:</p>
<p>为了使Log4j能与默认的JCL依赖(<code>commons-logging</code>)一起工作，所有你需要做的是把Log4j放到classpath中，并提供一个配置文件（<code>log4j.properties</code>或<code>log4j.xml</code>在classpath的根目录）。对于Maven用户依赖声明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;5.0.0.BUILD-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2.14&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>And here’s a sample log4j.properties for logging to the console:</p>
<p>下面是一个log4j.properties输出日志到控制台的样本：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/log4j_samle.png" alt="image"></p>
<p><strong>Runtime Containers with Native JCL</strong></p>
<p>Many people run their Spring applications in a container that itself provides an implementation of JCL. IBM Websphere Application Server (WAS) is the archetype. This often causes problems, and unfortunately there is no silver bullet solution; simply excluding <code>commons-logging</code> from your application is not enough in most situations.</p>
<p>许多人在容器中运行他们的Spring应用，容器本身提供了一个JCL实现。IBM Websphere Application Server (WAS) 是原型。这经常会引起问题，不幸的是没有一劳永逸的解决方案；在大多数环境下简单的执行<code>commons-logging</code>是不够的。</p>
<p>To be clear about this: the problems reported are usually not with JCL per se, or even with <code>commons-logging</code>: rather they are to do with binding <code>commons-logging</code> to another framework (often Log4J). This can fail because <code>commons-logging</code> changed the way they do the runtime discovery in between the older versions (1.0) found in some containers and the modern versions that most people use now (1.1). Spring does not use any unusual parts of the JCL API, so nothing breaks there, but as soon as Spring or your application tries to do any logging you can find that the bindings to Log4J are not working.</p>
<p>为了使这个更清楚：报告的问题本质上一般不是关于JCL的，或关于<code>commons-logging</code>的：而是他们去绑定<code>commons-logging</code>到其它的框架上（通常是Log4j）。这可能会失败因为<code>commons-logging</code>在一些容器的旧版本（1.0）和大多数人使用的现代版本（1.1）中改变了运行时发现方式。Spring不使用JCL API的和任何不常用的部分，因此不会有问题出现，但是一旦Spring或你的应用试图去输出日志，你可能发现到Log4j的绑定是不起作用的。</p>
<p>In such cases with WAS the easiest thing to do is to invert the class loader hierarchy (IBM calls it “parent last”) so that the application controls the JCL dependency, not the container. That option isn’t always open, but there are plenty of other suggestions in the public domain for alternative approaches, and your mileage may vary depending on the exact version and feature set of the container.</p>
<p>在这种情况下使用WAS最容易做的事是逆转类加载层（IBM称为”parent last”），为的是应用能控制依赖，而不是容器。虽然这种选择并非总是公开的，但在公共领域对于替代方法有许多其它的建议，你的解决这个问题花的时间可能是不同的，这取决于确定的版本和容器集合的特性。</p>
<h1 id="Part-II-Core-Technologies"><a href="#Part-II-Core-Technologies" class="headerlink" title="Part II. Core Technologies"></a>Part II. Core Technologies</h1><p>This part of the reference documentation covers all of those technologies that are absolutely integral to the Spring Framework.</p>
<p>这部分参考文档包含了所有完全集成到Spring框架中的那些技术。</p>
<p>Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand, and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.</p>
<p>在这些中最重要的是Spring框架的控制反转（IoC）容器。对Spring框架IoC容器的彻底处理是紧随其后的Spring面向切面编程（AOP）技术的全面覆盖。Spring框架有它自己的AOP框架，这在概念上很容易理解，在Java企业级开发中成功了解决了AOP需求中80%的关键点。</p>
<p>Coverage of Spring’s integration with AspectJ (currently the richest - in terms of features - and certainly most mature AOP implementation in the Java enterprise space) is also provided.</p>
<p>Spring也提供了AspectJ的全面集成（目前是最丰富的-考虑到功能-并且确定在Java企业中是最成熟的AOP实现）。</p>
<ul>
<li>Chapter 3, The IoC container</li>
<li>Chapter 4, Resources</li>
<li>Chapter 5, Validation, Data Binding, and Type Conversion</li>
<li>Chapter 6, Spring Expression Language (SpEL)</li>
<li>Chapter 7, Aspect Oriented Programming with Spring</li>
<li>Chapter 8, Spring AOP APIs</li>
</ul>
<h2 id="3-The-IoC-container"><a href="#3-The-IoC-container" class="headerlink" title="3. The IoC container"></a>3. The IoC container</h2><h3 id="3-1-Introduction-to-the-Spring-IoC-container-and-beans"><a href="#3-1-Introduction-to-the-Spring-IoC-container-and-beans" class="headerlink" title="3.1 Introduction to the Spring IoC container and beans"></a>3.1 Introduction to the Spring IoC container and beans</h3><p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as <em>dependency injection</em> (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern.</p>
<p>这一章包含了Spring框架的控制反转(IoC)原理的实现。IoC也被称为依赖注入(DI)。它是一个处理过程，凭借对象之间依赖关系，也就是和它们一起工作的其它对象，只能通过构造函数参数，传递参数给工厂方法，在构造完成或工厂方法返回的对象实例之后再设置对象实例的属性。当创建bean时容器再将这些依赖对象注入进去。这个过程从根本上颠倒了bean本身通过直接构建类或通过一种机制例如服务定位模式来控制依赖对象的实例化或定位，因此命名为控制反转（IoC）。</p>
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. The <code>BeanFactory</code> interface provides an advanced configuration mechanism capable of managing any type of object. <code>ApplicationContext</code> is a sub-interface of <code>BeanFactory</code>. It adds easier integration with Spring’s AOP features; message resource handling (for use in internationalization), event publication; and application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架控制反转容器的基础。<code>BeanFactory</code>接口提供了一种能管理任何类型对象的高级配置机制。<code>ApplicationContext</code>是<code>BeanFactory</code>的一个子接口。<code>ApplicationContext</code>增加了更容易集成Spring AOP功能；消息资源处理（用在国际化中），事件发布；应用层特定上下文例如<code>WebApplicationContext</code>在web应用中的使用。</p>
<p>In short, the <code>BeanFactory</code> provides the configuration framework and basic functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code>, and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext</code>, refer to Section 3.16, “The BeanFactory”.</p>
<p>总之，<code>BeanFactory</code>提供了配置框架和基本功能，<code>ApplicationContext</code>增加了更多企业专用的功能。<code>ApplicationContext</code>是<code>BeanFactory</code>的一个全面超集，在这章仅仅是用来描述Spring的IoC容器。关于用<code>BeanFactory</code>代替<code>ApplicationContext</code>的更多信息请参考3.16小节”The BeanFactory”。</p>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called <em>beans</em>. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the <em>dependencies</em> among them, are reflected in the <em>configuration metadata</em> used by a container.</p>
<p>在Spring中，被Spring IoC容器管理的那些形成你应用主干的对象被称为<em>beans</em>。bean是实例化、组装、以及其它的都被Spring IoC容器管理的对象。另外，bean仅仅是你应用中许多对象中的一个。Beans和它们之间的<em>依赖关系</em>，通过容器使用的<em>配置元数据</em>可以反映出来。</p>
<h3 id="3-2-Container-overview"><a href="#3-2-Container-overview" class="headerlink" title="3.2 Container overview"></a>3.2 Container overview</h3><p>The interface <code>org.springframework.context.ApplicationContext</code> represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the aforementioned beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It allows you to express the objects that compose your application and the rich interdependencies between such objects.</p>
<p><code>org.springframework.context.ApplicationContext</code>接口代表了Spring IoC容器并且负责实例化、配置和组装前面提到的beans。容器通过读取配置元数据得到说明什么对象要实例化、配置和组装。配置元数据可以用XML、Java注解或Java代码表示。它允许你表示构成应用的对象和对象间丰富的依赖关系。</p>
<p>Several implementations of the <code>ApplicationContext</code> interface are supplied out-of-the-box with Spring. In standalone applications it is common to create an instance of <code>ClassPathXmlApplicationContext</code> or <code>FileSystemXmlApplicationContext</code>. While XML has been the traditional format for defining configuration metadata you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p>
<p>Spring提供了一些可以直接使用的<code>ApplicationContext</code>接口实现。在单独的应用中通常是创建一个 <code>ClassPathXmlApplicationContext</code>实例或<code>FileSystemXmlApplicationContext</code>实例。虽然XML是定义配置元数据的传统格式，但你可以指示容器支持使用Java注解或代码作为元数据的格式并通过提供少量的XML配置声明使容器支持这些额外的元数据格式。</p>
<p>In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the <code>web.xml</code> file of the application will typically suffice (see Section 3.15.4, “Convenient ApplicationContext instantiation for web applications”). If you are using the Spring Tool Suite Eclipse-powered development environment this boilerplate configuration can be easily created with few mouse clicks or keystrokes.</p>
<p>在大多数应用场景中，不会要求用户用显式的代码来实例化一个或多个Spring IoC容器的。例如，在web应用场景中，在应用的<code>web.xml</code>文件中写一个简单的八行左右的样板web描述符XML就足够了（看3.13.4小节，『web应用中ApplicationContext的方便实例化』）。如果你正在使用Eclipse支持的Spring Tool Suite开发环境，可以很容易的通过点几下鼠标或键盘来创建样本配置。</p>
<p>The following diagram is a high-level view of how Spring works. Your application classes are combined with configuration metadata so that after the <code>ApplicationContext</code> is created and initialized, you have a fully configured and executable system or application.</p>
<p>下面的图是从一个高层次的视野来看Spring是如何工作的。你的应用类与配置元数据结合起来为的是在<code>ApplicationContext</code>创建和初始化之后，你有一个完整配置并可执行的系统或应用。</p>
<p><strong>Figure 3.1. The Spring IoC container</strong><br><img src="http://ocs628urt.bkt.clouddn.com/spring_work.png" alt="image"></p>
<h4 id="3-2-1-Configuration-metadata"><a href="#3-2-1-Configuration-metadata" class="headerlink" title="3.2.1 Configuration metadata"></a>3.2.1 Configuration metadata</h4><p>As the preceding diagram shows, the Spring IoC container consumes a form of <em>configuration metadata</em>; this configuration metadata represents how you as an application developer tell the Spring container to instantiate, configure, and assemble the objects in your application.</p>
<p>如上图所示，Spring IoC容器使用了一种<em>配置元数据</em>的方式；配置元数据表示你作为一个应用开发者应该告诉Spring容器怎样去实例化、配置并组装应用中的对象。</p>
<p>Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.</p>
<p>习惯上用简单直观下XML形式来提供配置元数据，这一章大部分使用XML文件来表达Spring IoC容器的核心概念及功能。</p>
<blockquote>
<p>XML-based metadata is <em>not</em> the only allowed form of configuration metadata. The Spring IoC container itself is <em>totally</em> decoupled from the format in which this configuration metadata is actually written. These days many developers choose Java-based configuration for their Spring applications.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>基于XML的元数据<em>不是</em>配置元数据的唯一许可形式。Spring IoC容器本身与配置元数据的实际书写形式是<em>完全</em>解构的。目前许多开发者在他们的Spring应用中选用基于Java配置的元数据形式。</p>
</blockquote>
<p>&nbsp;<br>For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li>Annotation-based configuration: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li>Java-based configuration: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code> and <code>@DependsOn</code> annotations.</li>
</ul>
<p>关于Spring容器中使用其它元数据形式的信息，请看：</p>
<ul>
<li>基于注解的配置：Spring 2.5引入对了基于注解的配置元数据的支持。</li>
<li>基于Java的配置：从Spring 3.0开始，Spring JavaConfig工程提供的许多功能开始成为Spring框架核心中的一部分。因此你可以通过Java而不是XML文件来定义外部应用程序的beans。为了使用这些新功能，请看<code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code>和<code>@DependsOn</code>注解。</li>
</ul>
<p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata shows these beans configured as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java configuration typically uses <code>@Bean</code> annotated methods within a <code>@Configuration</code> class.</p>
<p>Spring配置包括至少一个且通常不止一个容器必须管理的bean定义。基于XML的配置元数据中，这些beans作为<code>&lt;bean&gt;</code>元素被配置在顶层<code>&lt;beans/&gt;</code>元素中。Java配置通常在<code>@Configuration</code>类中使用<code>@Bean</code>注解的方法。</p>
<p>These bean definitions correspond to the actual objects that make up your application. Typically you define service layer objects, data access objects (DAOs), presentation objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate <code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring.</p>
<p>这些bean定义与组成你应用的实际对象相对应。通常你会定义服务层对象，数据访问层对象（DAOs），描述对象例如Struts的<code>Action</code>实例，底层对象例如Hibernate的<code>SessionFactories</code>，JMS的<code>Queues</code>等等。容器中细粒度的领域对象通常是不配置的，因为一般是由DAOs和业务逻辑负责创建和加载领域对象。然而你可以使用Spring集成的AspectJ去配置IoC容器控制之外创建的对象。请看”使用Spring的AspectJ来依赖注入领域对象”。</p>
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
<p>下面的例子展示了基于XML配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>id</code> attribute is a string that you use to identify the individual bean definition. The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname. The value of the <code>id</code> attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example; see Dependencies for more information.</p>
<p><code>id</code>属性是一个你用来识别私有bean定义的字符串。<code>class</code>属性定义了bean的类型并且使用了完全限定类型名称(全限定名称或完全限定名)。<code>id</code>属性的值指的是协作对象。这个例子的中没有展示如何引用协作对象，更多信息请查看『依赖』。</p>
<h4 id="3-2-2-Instantiating-a-container"><a href="#3-2-2-Instantiating-a-container" class="headerlink" title="3.2.2 Instantiating a container"></a>3.2.2 Instantiating a container</h4><p>Instantiating a Spring IoC container is straightforward. The location path or paths supplied to an <code>ApplicationContext</code> constructor are actually resource strings that allow the container to load configuration metadata from a variety of external resources such as the local file system, from the Java <code>CLASSPATH</code>, and so on.</p>
<p>实例化一个Spring IoC容器是简单的。一个或多个提供给<code>ApplicationContext</code>构造函数的定位路径实际上是资源字符串，可以让容器从各种例如局部文件系统，Java的<code>CLASSPATH</code>等外部资源中加载配置元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context =</div><div class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>After you learn about Spring’s IoC container, you may want to know more about Spring’s <code>Resource</code> abstraction, as described in Chapter 4, Resources, which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, <code>Resource</code> paths are used to construct applications contexts as described in Section 4.7, “Application contexts and Resource paths”.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在你学习Spring IoC容器之后，你可能想知道更多关于Spring的<code>Resource</code>抽象信息，介绍信息在『第四章 资源』中，<code>Resource</code>抽象提供了一种方便的机制从URI语法定义的位置中读取输入流。<code>Resource</code>路径通常被用来构建应用程序上下文，正如4.7 小节『应用上下文和资源路径』描述的那样。</p>
</blockquote>
<p>&nbsp;<br>The following example shows the service layer objects (<code>services.xml</code>) configuration file:</p>
<p>下面的例子是服务层对象(<code>services.xml</code>)的配置文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    &lt;!-- services --&gt;</div><div class="line"></div><div class="line">    &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt;</div><div class="line">        &lt;property name="accountDao" ref="accountDao"/&gt;</div><div class="line">        &lt;property name="itemDao" ref="itemDao"/&gt;</div><div class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- more bean definitions for services go here --&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>The following example shows the data access objects <code>daos.xml</code> file:</p>
<p>下面的例子是数据访问对象<code>daos.xml</code>的配置文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    &lt;bean id="accountDao"</div><div class="line">        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt;</div><div class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt;</div><div class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- more bean definitions for data access objects go here --&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>In the preceding example, the service layer consists of the class <code>PetStoreServiceImpl</code>, and two data access objects of the type <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based on the JPA Object/Relational mapping standard). The <code>property name</code> element refers to the name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see Dependencies.</p>
<p>在之前的例子中，服务层包括类<code>PetStoreServiceImpl</code>和两个类型为<code>JpaAccountDao</code>和<code>JpaItemDao</code>数据访问对象（基于JPA对象/关系映射标准）。<code>property name</code>元素指的是JavaBean属性的名称，<code>ref</code>元素指的是另一个bean定义的名称。<code>id</code>和<code>ref</code>之间的连接表明了协作对象之间的关系。配置对象依赖的更详细信息请看『依赖』。</p>
<p><strong>Composing XML-based configuration metadata</strong></p>
<p>It can be useful to have bean definitions span multiple XML files. Often each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>bean定义跨越多个XML文件是非常有用的。通常每一个独立的XML配置文件表示你架构中的一个逻辑层或模块。</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the previous section. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. For example:</p>
<p>你可以使用应用上下文构造函数从所有XML片段中加载bean定义。如上小节所示，构造函数可以接收多个<code>Resource</code>位置。也可以使用一个或同时使用多个<code>&lt;import/&gt;</code>元素从另一个或另一些文件中加载bean定义。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;import resource="services.xml"/&gt;</div><div class="line">    &lt;import resource="resources/messageSource.xml"/&gt;</div><div class="line">    &lt;import resource="/resources/themeSource.xml"/&gt;</div><div class="line"></div><div class="line">    &lt;bean id="bean1" class="..."/&gt;</div><div class="line">    &lt;bean id="bean2" class="..."/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code>and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file. As you can see, a leading slash is ignored, but given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions according to the Spring Schema.</p>
<p>在上面的例子中，外部bean定义从<code>services.xml</code>、<code>messageSource.xml</code>和<code>themeSource.xml</code>三个文件中加载。所有位置路径都是相对于进行导入的定义文件的，因此<code>services.xml</code>必须跟进行导入的文件在同一个目录下或同一个classpath位置下。如你所见，忽略了最前面的反斜杠，但给定的这些路径是相对的，最好是一点都不使用反斜杠。包括顶层的<code>&lt;beans/&gt;</code>元素在内，被导入的文件内容必须是依据Spring Schema有效的XML bean定义。</p>
<blockquote>
<p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for “classpath:” URLs (for example, “classpath:../services.xml”), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
<p>You can always use fully qualified resource locations instead of relative paths: for example, “file:C:/config/services.xml” or “classpath:/config/services.xml”. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations, for example, through “${…​}” placeholders that are resolved against JVM system properties at runtime.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在父目录的引用文件使用”../“相对路径是可以的，但不推荐这样做。这样做会产生一个当前应用之外文件依赖。引用文件特别不推荐在”classpath:” URLs中（例如”classpath:../services.xml”），运行时解析处理会选择”最近的”classpath根目录，然后去寻找它的父目录。Classpath配置的更改可能会导致进入一个不同且不正确的目录。</p>
<p>你可以总是使用完全限定资源位置代替相对路径：例如，”file:C:/config/services.xml”或”classpath:/config/services.xml”。但是要注意你正在将你的应用配置与特定的绝对路径耦合。通常更可取的方式是间接的访问绝对路径，例如，通过”${…​}”占位符在运行时解析JVM系统属性。</p>
</blockquote>
<p>&nbsp;</p>
<h4 id="3-2-3-Using-the-container"><a href="#3-2-3-Using-the-container" class="headerlink" title="3.2.3 Using the container"></a>3.2.3 Using the container</h4><p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. Using the method <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> you can retrieve instances of your beans.</p>
<p><code>ApplicationContext</code>是一个更高级的工厂接口，它能维护不同beans及其依赖的注册表。使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>你可以取回你的beans实例。</p>
<p>The <code>ApplicationContext</code> enables you to read bean definitions and access them as follows:</p>
<p><code>ApplicationContext</code>能让你用下面的方式读取bean定义及访问它们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create and configure beans</span></div><div class="line">ApplicationContext context =</div><div class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// retrieve configured instance</span></div><div class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService.class);</div><div class="line"></div><div class="line"><span class="comment">// use configured instance</span></div><div class="line">List&lt;String&gt; userList = service.getUsernameList();</div></pre></td></tr></table></figure>
<p>You use <code>getBean()</code> to retrieve instances of your beans. The <code>ApplicationContext</code> interface has a few other methods for retrieving beans, but ideally your application code should never use them. Indeed, your application code should have no calls to the <code>getBean()</code> method at all, and thus no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides for dependency injection for various web framework classes such as controllers and JSF-managed beans.</p>
<p>你可以用<code>getBean()</code>取回你的beans实例。<code>ApplicationContext</code>接口有一些其它的方法来取回beans，但理想的应用代码应该绝不使用它们。事实上，你的应用代码应该完全不调用<code>getBean()</code>方法，因此完全不依赖Spring APIs。例如，Spring的集成web框架提供了各种web框架类的依赖注入，例如控制器和JSF管理的beans。</p>
<h3 id="3-3-Bean-overview"><a href="#3-3-Bean-overview" class="headerlink" title="3.3 Bean overview"></a>3.3 Bean overview</h3><p>A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container, for example, in the form of XML <code>&lt;bean/&gt;</code> definitions.</p>
<p>Spring IoC容器管理一个或多个beans。这些beans由提供给容器的配置元数据生成，例如，XML形式的<code>&lt;bean/&gt;</code>定义。</p>
<p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</p>
<ul>
<li><em>A package-qualified class name</em>: typically the actual implementation class of the bean being defined.</li>
<li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).</li>
<li>References to other beans that are needed for the bean to do its work; these references are also called collaborators or dependencies.</li>
<li>Other configuration settings to set in the newly created object, for example, the number of connections to use in a bean that manages a connection pool, or the size limit of the pool.</li>
</ul>
<p>在容器本身内部，这些bean定义被表示成<code>BeanDefinition</code>对象，含有以下元数据：</p>
<ul>
<li>包限定的类名：通常是被定义的bean的实现类。</li>
<li>bean行为配置元素，规定了bean在容器中的行为（作用范围、生命周期回调函数）等等。</li>
<li>bean工作需要的引用的其它bean，这些引用也被称为协作者或依赖。</li>
<li>其它的配置在新创建的对象中设置，例如，bean中使用的连接数量控制着一个连接池，或连接池的大小限制。</li>
</ul>
<p>This metadata translates to a set of properties that make up each bean definition.</p>
<p>元数据转化为一系列的属性，这些属性构成了每个bean的定义。</p>
<p><strong>Table 3.1. The bean definition</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Explained in…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">class</td>
<td style="text-align:left">Section 3.3.2, “Instantiating beans”</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">Section 3.3.1, “Naming beans”</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">Section 3.5, “Bean scopes”</td>
</tr>
<tr>
<td style="text-align:left">constructor arguments</td>
<td style="text-align:left">Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td style="text-align:left">properties</td>
<td style="text-align:left">Section 3.4.1, “Dependency Injection”</td>
</tr>
<tr>
<td style="text-align:left">autowiring mode</td>
<td style="text-align:left">Section 3.4.5, “Autowiring collaborators”</td>
</tr>
<tr>
<td style="text-align:left">lazy-initialization mode</td>
<td style="text-align:left">Section 3.4.4, “Lazy-initialized beans”</td>
</tr>
<tr>
<td style="text-align:left">initialization method</td>
<td style="text-align:left">the section called “Initialization callbacks”</td>
</tr>
<tr>
<td style="text-align:left">destruction method</td>
<td style="text-align:left">the section called “Destruction callbacks”</td>
</tr>
</tbody>
</table>
<p>In addition to bean definitions that contain information on how to create a specific bean, the <code>ApplicationContext</code> implementations also permit the registration of existing objects that are created outside the container, by users. This is done by accessing the ApplicationContext’s BeanFactory via the method getBeanFactory() which returns the BeanFactory implementation <code>DefaultListableBeanFactory</code>. <code>DefaultListableBeanFactory</code> supports this registration through the methods <code>registerSingleton(..)</code> and <code>registerBeanDefinition(..)</code>. However, typical applications work solely with beans defined through metadata bean definitions.</p>
<p>除了bean定义中包含怎么创建一个指定的bean的信息之外，<code>ApplicationContext</code>实现也允许用户注册容器之外创建的现有对象。这是通过调用ApplicationContext’s BeanFactory的getBeanFactory()方法完成的，这个方法会返回BeanFactory的实现类<code>DefaultListableBeanFactory</code>。<code>DefaultListableBeanFactory</code>支持通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法来注册。不管怎样，标准应用仅使用通过元数据bean定义定义的beans。</p>
<blockquote>
<p>Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding of existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to factory) is not officially supported and may lead to concurrent access exceptions and/or inconsistent state in the bean container.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>bean元数据和人工提供的单例需要尽可能早的进行注册，为了使容器在自动注入及其它的内省步骤时能恰当的推理它们。虽然在一定程度上是支持覆盖现有的元数据和单例的，但运行时新beans的注册（并发实时访问工厂）是不被正式支持的，可能会引起并发访问异常，在容器中的与/或状态不一致。</p>
</blockquote>
<p>&nbsp;</p>
<h4 id="3-3-1-Naming-beans"><a href="#3-3-1-Naming-beans" class="headerlink" title="3.3.1 Naming beans"></a>3.3.1 Naming beans</h4><p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier, but if it requires more than one, the extra ones can be considered aliases.</p>
<p>每个bean都有一个或多个标识符。这些托管bean的标识符在容器中必须是唯一的。一个bean通常只有一个标识符，但如果一个bean需要不止一个标识符，其它的标识符会被当成别名。</p>
<p>In XML-based configuration metadata, you use the <code>id</code> and/or <code>name</code> attributes to specify the bean identifier(s). The <code>id</code> attribute allows you to specify exactly one id. Conventionally these names are alphanumeric (‘myBean’, ‘fooService’, etc.), but may contain special characters as well. If you want to introduce other aliases to the bean, you can also specify them in the <code>name</code> attribute, separated by a comma (<code>,</code>), semicolon (<code>;</code>), or white space. As a historical note, in versions prior to Spring 3.1, the <code>id</code> attribute was defined as an <code>xsd:ID</code> type, which constrained possible characters. As of 3.1, it is defined as an <code>xsd:string</code> type. Note that bean <code>id</code> uniqueness is still enforced by the container, though no longer by XML parsers.</p>
<p>在基于XML的配置元数据中，你可以使用<code>id</code>和/或<code>name</code>属性指定bean标识符。<code>id</code>属性允许你指定一个确定的id。按照惯例这些名字是字母数字的(‘myBean’, ‘fooService’等等)，但也可能包含指定字符。如果你想引入bean其它的别名，你可以在<code>name</code>属性中指定别名，用逗号 (<code>,</code>)，分号(<code>;</code>)，或空格分开。作为一个历史注解，在之前的Spring 3.1版本，<code>id</code>属性被定义为一种<code>xsd:ID</code>类型，可以通过合理字符来约束（XML控制<code>id</code>唯一性）。从Spring 3.1开始，它被定义为<code>xsd:string</code>类型。注意bean <code>id</code>的唯一性仍然是容器强制的，虽然不再通过XML解析器来控制（容器控制<code>id</code>唯一性）。</p>
<p>You are not required to supply a name or id for a bean. If no name or id is supplied explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the <code>ref</code> element or Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using inner beans and autowiring collaborators.</p>
<p>bean的id和name不是必须提供的。如果没有明确指定name或id，容器会为bean产生一个唯一的名字。如果你想通过name引用bean，通过使用<code>ref</code>元素或服务定位器模式查找，你必须提供一个名字。不提供name的动机是与内部bean的使用和协作bean的自动装配有关的。</p>
<blockquote>
<p><strong>Bean Naming Conventions</strong></p>
<p>The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter, and are camel-cased from then on. Examples of such names would be (without quotes) ‘accountManager’, ‘accountService’, ‘userDao’, ‘loginController’, and so forth.</p>
<p>Naming beans consistently makes your configuration easier to read and understand, and if you are using Spring AOP it helps a lot when applying advice to a set of beans related by name.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>Bean命名规范</strong></p>
<p>当命名bean时，采用的规范是标准Java实例字段命名规范。bean名称以小写字母开头，采用驼峰式的命名规则。这种命名方式的例子（不带引号）有’accountManager’， ‘accountService’， ‘userDao’， ‘loginController’等等。</p>
<p>一致的命名beans可以使人更容易读懂和理解你的配置，如果你正在使用Spring AOP，使用一致性来命名一系列bean名称是非常有帮助的。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules above: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code>java.beans.Introspector.decapitalize</code> (which Spring is using here).</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在classpath中进行组件扫描，Spring会根据上面的规则为未命名组件产生bean名称，本质上来说，是采用简单的类名并将其首字母改成小写。然而在特殊情况下（不平常的），当类名有不止一个字母且第一二个字母都是大写的情况下，会保留最初始的状态。与<code>java.beans.Introspector.decapitalize</code>定义中的规则是相同的（Spring也采用这个规则）。</p>
</blockquote>
<p><strong>Aliasing a bean outside the bean definition</strong></p>
<p>In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the <code>id</code> attribute, and any number of other names in the <code>name</code> attribute. These names can be equivalent aliases to the same bean, and are useful for some situations, such as allowing each component in an application to refer to a common dependency by using a bean name that is specific to that component itself.</p>
<p>在定义bean时，通过与<code>id</code>属性指定的名称相结合，你可以为bean提供不止一个名字，在<code>name</code>属性中定义任何数量的其它名字。这些名字是同一个bean的等价别名，在一些情况下是非常有用的，例如允许应用中的每个组件通过bean名称引用一个共通的依赖，这个依赖为每个组件本身指定了一个名称。</p>
<p>Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the <code>&lt;alias/&gt;</code> element to accomplish this.</p>
<p>然而在bean实际定义的地方指定所有别名并不总是适当的。有时会要求引入一个在别的地方定义的bean的别名。这通常是在大的系统中而配置被分割在每个子系统中，每个子系统有它知道对象定义集合。在基于XML配置元数据中，你可以使用<code>&lt;alias/&gt;</code>来完成别名的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;alias name=<span class="string">"fromName"</span> alias=<span class="string">"toName"</span>/&gt;</div></pre></td></tr></table></figure>
<p>In this case, a bean in the same container which is named <code>fromName</code>, may also, after the use of this alias definition, be referred to as <code>toName</code>.</p>
<p>在这种情况下，在同一个容器中的bean被命名为<code>fromName</code>，也可能是在别名定义使用之后，被作为<code>toName</code>引用。</p>
<p>For example, the configuration metadata for subsystem A may refer to a DataSource via the name <code>subsystemA-dataSource</code>. The configuration metadata for subsystem B may refer to a DataSource via the name <code>subsystemB-dataSource</code>. When composing the main application that uses both these subsystems the main application refers to the DataSource via the name <code>myApp-dataSource</code>. To have all three names refer to the same object you add to the MyApp configuration metadata the following aliases definitions:</p>
<p>例如，子系统A的配置元数据可能通过名称<code>subsystemA-dataSource</code>引用数据源。子系统B的配置元数据可能通过名称<code>subsystemB-dataSource</code>引用数据源。当构成主应用的时，主应用使用这些子系统并通过名称<code>myApp-dataSource</code>引用数据源。为了使这三个名称引用同一个对象，你可以将如下的别名定义添加到MyApp配置元数据中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;alias name=<span class="string">"subsystemA-dataSource"</span> alias=<span class="string">"subsystemB-dataSource"</span>/&gt;</div><div class="line">&lt;alias name=<span class="string">"subsystemA-dataSource"</span> alias=<span class="string">"myApp-dataSource"</span> /&gt;</div></pre></td></tr></table></figure>
<p>Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean.</p>
<p>现在主应用和每个组件都能通过名称引用数据源，这个名称是唯一的且能保证不与任何其它的定义相冲突（有效的创建了一个命名空间），但它们引用了同一个bean。</p>
<blockquote>
<p><strong>Java-configuration</strong></p>
<p>If you are using Java-configuration, the <code>@Bean</code> annotation can be used to provide aliases see Section 3.12.3, “Using the @Bean annotation” for details.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>Java配置</strong></p>
<p>如果你正在使用Java配置，<code>@Bean</code>注解可以用来提供别名，更多细节请看3.12.3小节， “使用@Bean注解”。</p>
</blockquote>
<h4 id="3-3-2-Instantiating-beans"><a href="#3-3-2-Instantiating-beans" class="headerlink" title="3.3.2 Instantiating beans"></a>3.3.2 Instantiating beans</h4><p>A bean definition essentially is a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked, and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object.</p>
<p>bean定义本质上来说是创建一个或多个对象的方法。当问及一个命名bean时，容器会查看这个方法并使用bean定义中封装的配置元数据创建（或取得）一个实际的对象。</p>
<p>If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the <code>class</code> attribute of the <code>&lt;bean/&gt;</code> element. This <code>class</code> attribute, which internally is a <code>Class</code> property on a <code>BeanDefinition</code> instance, is usually mandatory. (For exceptions, see the section called “Instantiation using an instance factory method” and Section 3.7, “Bean definition inheritance”.) You use the <code>Class</code> property in one of two ways:</p>
<ul>
<li><p>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code using the <code>new</code> operator.</p>
</li>
<li><p>To specify the actual class containing the <code>static</code> factory method that will be invoked to create the object, in the less common case where the container invokes a <code>static</code> factory method on a class to create the bean. The object type returned from the invocation of the <code>static</code> factory method may be the same class or another class entirely.</p>
</li>
</ul>
<p>如果你使用基于XML的配置元数据，你可以指定对象的类型（或类），它将在<code>&lt;bean/&gt;</code>元素中的<code>class</code>属性中进行实例化。<code>class</code>属性，在<code>BeanDefinition</code>实例的内部是<code>Class</code>性质，通常是必需的。（例外的情况，请看”使用实例工厂方法进行实例化”小节和3.7小节，”bean定义继承”）。你可以通过以下两种方式中的一种使用<code>Class</code>属性：</p>
<ul>
<li><p>通常情况下，指定要构造的bean类，容器本身通过反射调用bean的构造方法直接创建bean，这与Java代码中使用<code>new</code>操作符是等价的。</p>
</li>
<li><p>在不常见的情况下，指定包含静态工厂方法的实际类，调用静态工厂方法创建对象，容器在类上调用静态工厂方法创建bean。静态工厂方法调用返回的对象类型可能是同一个类，也可能完全是另一个类。</p>
</li>
</ul>
<blockquote>
<p><strong>Inner class names.</strong>  If you want to configure a bean definition for a <code>static</code> nested class, you have to use the binary name of the nested class.</p>
<p>For example, if you have a class called <code>Foo</code> in the <code>com.example</code> package, and this <code>Foo</code> class has a <code>static</code> nested class called <code>Bar</code>, the value of the <code>&#39;class&#39;</code> attribute on a bean definition would be…​</p>
<p><code>com.example.Foo$Bar</code></p>
<p>Notice the use of the <code>$</code> character in the name to separate the nested class name from the outer class name.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>内部类命名</strong> 如果你想为静态嵌套类配置bean定义，你必须使用嵌套类的二进制名字。</p>
<p>例如，如果你在<code>com.example</code>包中有个类叫<code>Foo</code>，<code>Foo</code>类中有一个静态嵌套类叫<code>Bar</code>，<code>&#39;class&#39;</code>属性在bean定义中的值为</p>
<p><code>com.example.Foo$Bar</code></p>
<p>注意名字中<code>$</code>符号的使用是为了将外部类名与嵌套类名分隔开。</p>
</blockquote>
<p>&nbsp;<br><strong>Instantiation with a constructor</strong></p>
<p>When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.</p>
<p>当你使用构造方法创建bean时，所有的正常类都可以被Spring使用和兼容。也就是说，正在进行开发的类不需要实现任何特定的接口或以特定的方式进行编码。简单的指定bean类就足够了。然而，根据你为指定的bean所使用的IoC类型，你可能需要一个默认的（空的）构造函数。</p>
<p>The Spring IoC container can manage virtually any class you want it to manage; it is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.</p>
<p>事实上，Spring的IoC容器可以管理任何你想让它管理的类；它不受限于管理真实的JavaBeans。大多数Spring用户更喜欢实际的JavaBeans，在容器中它仅有一个默认（无参）的构造函数，并且属性之后有合适的setters，getters方法。在容器中你也可以有更多外来的非bean类型的类。例如，如果你需要使用遗留的连接池，这绝对不符合JavaBean规范，但Spring也可以管理它。</p>
<p>With XML-based configuration metadata you can specify your bean class as follows:</p>
<p>基于XML的配置元数据你可以用如下方式指定你的bean的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"exampleBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"examples.ExampleBean"</span>/&gt;</div><div class="line"></div><div class="line">&lt;bean name=<span class="string">"anotherExample"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"examples.ExampleBeanTwo"</span>/&gt;</div></pre></td></tr></table></figure>
<p>For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see Injecting Dependencies.</p>
<p>更多关于为构造函数提供参数（如果有必要的话）的机制和构造对象之后设置对象实例属性的细节，请看”依赖注入”。</p>
<p><strong>Instantiation with a static factory method</strong></p>
<p>When defining a bean that you create with a static factory method, you use the <code>class</code> attribute to specify the class containing the <code>static</code> factory method and an attribute named <code>factory-method</code> to specify the name of the factory method itself. You should be able to call this method (with optional arguments as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call <code>static</code> factories in legacy code.</p>
<p>当定义的bean用静态工厂方法创建时，你可以使用<code>class</code>属性指定包含静态工厂方法的类，用<code>factory-method</code>属性指定工厂方法本身的名字。你应该能调用这个方法（用后面描述的可选参数）并且返回一个实时对象，随后对这个对象进行处理，就好像这个对象是通过构造函数创建的一样。这种bean定义的一个用法是在遗留代码（旧代码）中调用静态工厂方法。</p>
<p>The following bean definition specifies that the bean will be created by calling a factory-method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the <code>createInstance()</code> method must be a static method.</p>
<p>下面的bean定义指定了一个通过调用工厂方法创建的bean。定义没有指定返回对象的类型只有包含工厂方法的类。在这个例子中，<code>createInstance()</code>必须是一个静态方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see Dependencies and configuration in detail.</p>
<p>更多关于为工厂方法提供（可选）参数的原理和从工厂方法返回对象后设置对象实例属性的信息，请看”依赖和详细配置”。</p>
<p><strong>Instantiation using an instance factory method</strong></p>
<p>Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the <code>class</code> attribute empty, and in the <code>factory-bean</code> attribute, specify the name of a bean in the current (or parent/ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the <code>factory-method</code> attribute.</p>
<p>与通过静态工厂方法进行实例化类似，通过实例化工厂方法进行实例化，要从容器中调用现有bean非静态方法创建一个新的bean。使用这种机制，要让<code>class</code>属性为空，在<code>factory-bean</code>属性中，在包含实例化方法的当前容器（或父/祖先）中指定bean的名字，通过调用实例化方法来创建对象。通过<code>factory-method</code>属性设置工厂方法本身的名字。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>One factory class can also hold more than one factory method as shown here:</p>
<p>一个工厂类可以拥有多个工厂方法，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> accountService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See Dependencies and configuration in detail.</p>
<p>这个方法展示了工厂bean本身可以通过依赖注入（DI）来管理和配置。更多细节请看”依赖和配置”。</p>
<blockquote>
<p>In Spring documentation, factory bean refers to a bean that is configured in the Spring container that will create objects through an instance or static factory method. By contrast, <code>FactoryBean</code> (notice the capitalization) refers to a Spring-specific <code>FactoryBean</code>.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在Spring文档中，工厂bean引用了配置在Spring容器中的bean，Spring容器将通过实例或静态工厂方法来创建对象。相比之下，<code>FactoryBean</code>（注意大写）引用了Spring特定的<code>FactoryBean</code>。</p>
</blockquote>
<h3 id="3-4-Dependencies"><a href="#3-4-Dependencies" class="headerlink" title="3.4 Dependencies"></a>3.4 Dependencies</h3><p>A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.</p>
<p>标准企业应用不会由一个对象（或Spring用语中的bean）组成。即使是最简单的应用也是由一些对象共同工作，呈现给终端用户用户看到的是一个连续的应用。接下来的一节阐述了如何从定义许多独立的bean定义到完全实现的应用，它是一个通过对象协作来实现目标的过程。</p>
<h4 id="3-4-1-Dependency-Injection"><a href="#3-4-1-Dependency-Injection" class="headerlink" title="3.4.1 Dependency Injection"></a>3.4.1 Dependency Injection</h4><p><em>Dependency injection (DI)</em> is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then <em>injects</em> those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name <em>Inversion of Control (IoC)</em>, of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes, or the Service Locator pattern.</p>
<p><em>依赖注入（DI）</em>是一个处理过程，凭借对象之间依赖关系，也就是和它们一起工作的其它对象，只能通过构造函数参数，传递参数给工厂方法，在构造完成或工厂方法返回对象实例之后再设置对象实例的属性。当创建bean时容器再将这些依赖对象注入进去。这个过程从根本上颠倒了bean本身通过直接构建类或通过一种机制例如服务定位模式来控制依赖对象的实例化或定位，因此命名为<em>控制反转（IoC）</em>。</p>
<p>Code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies, and does not know the location or class of the dependencies. As such, your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.</p>
<p>使用依赖注入原则会使代码更简洁，当对象由依赖关系提供时解耦更有效。对象不会查找它的依赖，不知道依赖的位置和依赖关系的类别。同样的，你的类也变的更容易测试，尤其是依赖关系在接口或抽象基类之间的时候，这种情况下单元测试中会要求存桩或模拟实现。（注：Stub和Mock都是软件测试中使用的东西，如有疑问请自行google或百度）。</p>
<p>DI exists in two major variants, Constructor-based dependency injection and Setter-based dependency injection.</p>
<p>依赖有两个主要变种，基于构造函数的依赖注入和基于Setter的依赖注入。</p>
<p><strong>Constructor-based dependency injection</strong></p>
<p><em>Constructor-based DI</em> is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a <code>static</code> factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a <code>static</code> factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection. Notice that there is nothing <em>special</em> about this class, it is a POJO that has no dependencies on container specific interfaces, base classes or annotations.</p>
<p><em>基于构造函数的依赖注入</em>通过容器调用有参数的构造函数来实现，每个参数表示一个依赖。调用指定参数的静态工厂方法来构造bean是近似等价的，这里的讨论将给构造函数和静态工厂方法传参看成是类似的。接下来的例子展示了一个类仅能通过构建函数注入进行依赖注入。注意这个类没什么特别的，它是一个POJO，不依赖于容器特定的接口，基类或注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Constructor argument resolution</strong></p>
<p>Constructor argument resolution matching occurs using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, then the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class:</p>
<p>构造函数参数解析使用参数类型进行匹配。如果bean定义的构造函数参数中不存在潜在的歧义，bean定义中定义构造函数参数的顺序为bean实例化时提供给恰当构造函数的参数顺序。细想下面的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> x.y;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>No potential ambiguity exists, assuming that <code>Bar</code> and <code>Baz</code> classes are not related by inheritance. Thus the following configuration works fine, and you do not need to specify the constructor argument indexes and/or types explicitly in the <code>&lt;constructor-arg/&gt;</code> element.</p>
<p>不存在潜在的歧义，假设<code>Bar</code>类和<code>Baz</code>类之间不存在继承关系。因此下面的配置会工作良好，你不必在<code>&lt;constructor-arg/&gt;</code>元素中显式的指定构造函数参数索引的与/或类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as <code>&lt;value&gt;true&lt;/value&gt;</code>, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class:</p>
<p>当引用另一个bean时，类型已知，匹配正确（像上面的例子一样）。当使用简单类型时，例如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring不能决定值的类型，因此没有帮助不能按类型匹配。考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</div><div class="line"></div><div class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></div><div class="line">    <span class="keyword">private</span> String ultimateAnswer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument using the type attribute. For example:</p>
<p>在上面的场景中，如果你用<code>type</code>属性显式的指定了构造参数的类型，对于简单类型容器可以使用类型匹配。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Use the <code>index</code> attribute to specify explicitly the index of constructor arguments. For example:</p>
<p>使用<code>index</code>属性来显式的指定构造函数参数的索引，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type. Note that the index is 0 based.</p>
<p>除了要解析多个简单值的歧义性之外，当构造函数有两个相同类型的的参数时，指定索引可以解决歧义问题。注意索引是从0开始的。</p>
<p>You can also use the constructor parameter name for value disambiguation:</p>
<p>你也可以使用构造函数参数名字解决值的歧义问题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you can’t compile your code with debug flag (or don’t want to) you can use <code>@ConstructorProperties</code> JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:</p>
<p>记住，要使这个起作用你的代码必须使用调试模式进行编译，这样Spring可以从构造函数中查找参数名称。如果你不能用调试模式进行编译（或不想），你可以使用JDK注解<code>@ConstructorProperties</code>显式的命名你的构造函数参数。样板类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Fields omitted</span></div><div class="line"></div><div class="line">    <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Setter-based dependency injection</strong></p>
<p><em>Setter-based DI</em> is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.</p>
<p><em>基于Setter的依赖注入</em>在容器调用无参构造函数或无参静态工厂方法之后，通过调用bean的setter方法来实现依赖注入。</p>
<p>The following example shows a class that can only be dependency-injected using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.</p>
<p>下面的例子显示了一个类只能通过纯粹的setter注入进行依赖注入。这个类是常见的Java类。它是一个不依赖于容器中特定接口、基类或注解的POJO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <code>ApplicationContext</code> supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a <code>BeanDefinition</code>, which you use in conjunction with <code>PropertyEditor</code> instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (i.e., programmatically) but rather with XML bean definitions, annotated components (i.e., classes annotated with <code>@Component</code>, <code>@Controller</code>, etc.), or <code>@Bean</code> methods in Java-based <code>@Configuration</code> classes. These sources are then converted internally into instances of <code>BeanDefinition</code> and used to load an entire Spring IoC container instance.</p>
<p><code>ApplicationContext</code>支持基于构造函数和基于setter对它管理的bean进行依赖注入。它也支持一些依赖通过构造函数方法注入之后，使用基于setter的依赖注入。使用<code>BeanDefinition</code>形式配置依赖项，结合<code>PropertyEditor</code>实例可以将属性从一种形式转成另一种形式。然而大多数Spring用户直接使用这些类（例如以编程形式），而使用XML定义bean，注解组件（例如类中使用 <code>@Component</code>,，<code>@Controller</code>注解等等），或在基于Java的<code>@Configuration</code>类使用<code>@Bean</code>方法。</p>
<blockquote>
<p>Constructor-based or setter-based DI?</p>
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for <em>mandatory dependencies</em> and setter methods or configuration methods for <em>optional dependencies</em>. Note that use of the <code>@Required</code> annotation on a setter method can be used to make the property a required dependency.</p>
<p>The Spring team generally advocates constructor injection as it enables one to implement application components as <em>immutable objects</em> and to ensure that required dependencies are not <code>null</code>. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through <code>JMX MBeans</code> is therefore a compelling use case for setter injection.</p>
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>使用基于构造函数的依赖注入还是基于setter的依赖注入？</strong></p>
<p>你可以混合使用基于构造函数的依赖注入和基于setter的依赖注入，<em>强制依赖</em>使用构造函数注入，<em>可选依赖</em>使用setter方法或配置方法注入是一个很好的经验法则。注意在setter方法上使用<code>@Required</code>注解会检查依赖是否注入。</p>
<p>当实现的应用组件是<em>不可变对象</em>时，Spring团队通常主张构造函数注入，这样可以确保所需的依赖非空。此外，基于构造函数注入的组件总是以完全初始化状态返回客户（调用）代码。作为附注，含有许多构造函数参数的代码给人的感觉很差，这意味着类可能有很多职责，应该进行重构以便更好的处理关注问题的分离。</p>
<p>setter注入应该主要用来可选依赖上，在类内可以给可选依赖指定合理的默认值。此外，在每处使用依赖的代码都要进行非空检查。setter注入的一个好处就是setter方法使类的对象在后面可以进行再配置或再注入。<code>JMX MBeans</code>的管理是setter注入一个非常好的案例。</p>
<p>使用依赖注入的类型对于特定的类是最有意义的。有时候，当处理没有源码的第三方类时，使用哪种方式取决于你。例如，如果第三方库没有提供任何setter方法，构造函数注入可能是依赖注入唯一可行的方式。</p>
</blockquote>
<p><strong>Dependency resolution process</strong></p>
<p>The container performs bean dependency resolution as follows:</p>
<ul>
<li><p>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified via XML, Java code, or annotations.</p>
</li>
<li><p>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor. These dependencies are provided to the bean, when the bean is actually created.</p>
</li>
<li><p>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</p>
</li>
<li><p>Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument. By default Spring can convert a value supplied in string format to all built-in types, such as int, long, String, boolean, etc.</p>
</li>
</ul>
<p>容器按下面的过程处理bean依赖解析：</p>
<ul>
<li><p>创建<code>ApplicationContext</code>并使用描述所有bean的配置元数据初始化<code>ApplicationContext</code>，配置元数据可以通过XML，Java代码或注解指定。</p>
</li>
<li><p>对于每一个bean，它的依赖通过属性、构造函数参数、或静态工厂方法参数的形式表示，静态工厂方法可以替代标准的构造函数。当bean在实际创建时，这些依赖会提供给bean。</p>
</li>
<li><p>每个属性或构造函数参数或者是根据实际定义设置的值，或者是容器中另一个bean的引用。</p>
</li>
<li><p>每个属性或构造函数参数是一个从指定形式转成实际类型的属性或构造函数参数的值。</p>
</li>
</ul>
<p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean <em>is actually created</em>. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in Section 3.5, “Bean scopes”. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late, i.e. on first creation of the affected bean.</p>
<p>当容器创建后Spring容器会验证每个bean的配置。然而，bean属性本身只有bean创建时才会进行设置。bean是单例的并且当容器创建时会进行提前实例化（默认情况）。作用范围是在3.5 小节”Bean scopes”中定义的。此外，只有需要时候才会创建bean。bean的创建可能会引起beans图的创建，当bean的依赖和它的依赖的依赖（等等）创建和指定的时候。注意这些依赖中解析不匹配可能会在后面出现，例如，受影响的bean第一次创建时。</p>
<blockquote>
<p><strong>Circular dependencies</strong></p>
<p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p>
<p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code>BeanCurrentlyInCreationException</code>.</p>
<p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p>
<p>Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>循环依赖</strong></p>
<p>如果你主要使用构造函数注入，有可能会出现一个不能解决的循环依赖状况。</p>
<p>例如，类A需要通过构造函数注入得到一个类B的实例，而类B需要通过构造函数获得一个类A的实例。如果你为类A和类B配置了互相注入的bean，Spring IoC容器在运行时检测到循环引用，会抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>一个可能的解决方案是编译某个类的源代码使其通过setter注入而不是构造函数注入。或者，避免构造函数注入仅用setter注入。换句话说，尽管是不被推荐的，但你可以通过setter注入配置循环依赖。</p>
<p>不像通常的情况（没有循环依赖），bean A和bean B之间的循环依赖可以强制其中的一个bean优先注入另一个bean中，可以使其完全初始化（古老的鸡/蛋场景）。</p>
</blockquote>
<p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies. For example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why ApplicationContext implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated.</p>
<p>通常情况下你可以信任Spring去做正确的事情。在容器加载时它检测配置问题，例如引用不存在的beans和循环依赖。当bean实际创建时，Spring设置属性和解析依赖尽可能的晚。这意味着Spring容器正确加载但后面可能会产生异常，当你请求一个对象时，创建对象或它的某个依赖时出现问题，这时容器就会抛出异常。例如，由于缺失或存在无效属性，bean会抛出异常。在真正需要这些beans之前创建它们，会花费一些前期时间和内存，但当<code>ApplicationContext</code>创建时你会发现配置问题，而不是在创建之后。为了单例bean延迟初始化而不是预先实例化，你仍需要重写这个默认行为。</p>
<p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a configured init method or the InitializingBean callback method) are invoked.</p>
<p>如果没有循环依赖存在，当一个或更多协作beans注入到一个独立的bean中，在注入独立bean之前，每个协作bean都是完全配置的。这意味着如果bean A有个依赖为bean B，Spring IoC容器在调用bean A的setter方法之前会完整的配置bean B。换句话说，bean被实例化（不是预先实例化的单例），设置依赖和相关的生命周期方法（例如配置初始化方法或初始化bean回调方法）被调用。</p>
<p><strong>Examples of dependency injection</strong></p>
<p>The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:</p>
<p>下面的例子使用基于XML的配置元数据进行setter注入。Spring XML配置文件中的一小部分指定了一些bean的定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = beanOne;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:</p>
<p>在上面的例子中，setter声明匹配XML文件中指定的属性。下面的例子使用了基于构造函数的依赖注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</div><div class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The constructor arguments specified in the bean definition will be used as arguments to the constructor of the <code>ExampleBean</code>.</p>
<p>bean定义中指定的构造函数参数将作为<code>ExampleBean</code>的构造函数参数使用。</p>
<p>Now consider a variant of this example, where instead of using a constructor, Spring is told to call a static factory method to return an instance of the object:</p>
<p>现在考虑这个例子的一个变种，不使用构造函数，而是Spring调用静态工厂方法返回对象的一个实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// a private constructor</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></div><div class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></div><div class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line"></div><div class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</div><div class="line">        <span class="comment">// some other operations...</span></div><div class="line">        <span class="keyword">return</span> eb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Arguments to the <code>static</code> factory method are supplied via <code>&lt;constructor-arg/&gt;</code> elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the <code>static</code> factory method, although in this example it is. An instance (non-static) factory method would be used in an essentially identical fashion (aside from the use of the <code>factory-bean</code> attribute instead of the <code>class</code> attribute), so details will not be discussed here.</p>
<p>静态工厂方法的参数通过<code>&lt;constructor-arg/&gt;</code>元素提供，与构造函数使用的完全一样。虽然这个例子中工厂方法返回值的类型与包含静态工厂方法的类的类型一样，但它们可以不一样。工厂方法的实例（非静态）的使用本质上样式完全一样（除了使用<code>factory-bean</code>属性代替<code>class</code>属性之外），因此这儿不讨论这些细节。</p>
<h4 id="3-4-2-Dependencies-and-configuration-in-detail"><a href="#3-4-2-Dependencies-and-configuration-in-detail" class="headerlink" title="3.4.2 Dependencies and configuration in detail"></a>3.4.2 Dependencies and configuration in detail</h4><p>As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators), or as values defined inline. Spring’s XML-based configuration metadata supports sub-element types within its <code>&lt;property/&gt;</code> and <code>&lt;constructor-arg/&gt;</code> elements for this purpose.</p>
<p>正如上一节提到的那样，你可以通过引用其它被管理bean（协作者）来定义bean的属性和构造函数参数，或者在行内定义值。为了实现这个功能，Spring的基于XML的配置元数据在它的<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>中支持子元素类型。</p>
<p><strong>Straight values (primitives, Strings, and so on)</strong></p>
<p>The <code>value</code> attribute of the <code>&lt;property/&gt;</code> element specifies a property or constructor argument as a human-readable string representation. Spring’s conversion service is used to convert these values from a <code>String</code> to the actual type of the property or argument.</p>
<p><code>&lt;property/&gt;</code>元素的<code>value</code>属性指定了一个属性或构造函数参数作为可读的字符串表示。使用Spring的转换服务将这些值从<code>String</code>转成属性或参数的真实类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The following example uses the p-namespace for even more succinct XML configuration.</p>
<p>下面的例子为了更简洁的XML配置使用了p命名空间.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"close"</span></div><div class="line">        <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">        <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></div><div class="line">        <span class="attr">p:username</span>=<span class="string">"root"</span></div><div class="line">        <span class="attr">p:password</span>=<span class="string">"masterkaoli"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The preceding XML is more succinct; however, typos are discovered at runtime rather than design time, unless you use an IDE such as <code>IntelliJ IDEA</code> or the <code>Spring Tool Suite (STS)</code> that support automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.</p>
<p>上面的XML是更简洁的；然而，错别字是在运行时发现而不是在设计时，除非你使用IDE例如<code>IntelliJ IDEA</code>或<code>Spring Tool Suite (STS)</code>，当你创建bean定义时它们支持自动的属性补全。IDE辅助是强烈推荐的。</p>
<p>You can also configure a <code>java.util.Properties</code> instance as:</p>
<p>你也可以配置<code>java.util.Properties</code>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappings"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</div><div class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</div><div class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The Spring container converts the text inside the <code>&lt;value/&gt;</code>element into a <code>java.util.Properties</code> instance by using the JavaBeans <code>PropertyEditor</code> mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <code>&lt;value/&gt;</code> element over the <code>value</code> attribute style.</p>
<p>Spring容器通过JavaBeans的<code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素内部的文本转成<code>java.util.Properties</code>实例。这是一个很好的捷径，使用嵌入的<code>&lt;value/&gt;</code>元素而不是使用<code>value</code>属性的方式，是Spring团队支持的几个地方之一。</p>
<p><strong>The idref element</strong></p>
<p>The <code>idref</code> element is simply an error-proof way to pass the id (string value - not a reference) of another bean in the container to a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code> element.</p>
<p>在容器中传递另一个bean的id（字符串值，不是引用）到<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素时，<code>idref</code>元素是一种简单的的误差检验方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The above bean definition snippet is exactly equivalent (at runtime) to the following snippet:</p>
<p>上面的bean定义片段与下面的代码片段是等价的（运行时）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The first form is preferable to the second, because using the <code>idref</code> tag allows the container to validate <em>at deployment time</em> that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the <code>targetName</code> property of the <code>client</code> bean. Typos are only discovered (with most likely fatal results) when the <code>client</code> bean is actually instantiated. If the <code>client</code> bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.</p>
<p>第一种形式优于第二种形式，因为<code>idref</code>标签允许容器在部署时验证引用的bean，即命名的bean实际存在。在第二种形式中，当值传给<code>client</code>的<code>targetName</code>时没有进行验证。拼写错误只有在<code>client</code>bean实际创建时才会发现（最可能有严重后果）。如果<code>client</code> bean是原型bean，拼写错误和产生的异常可能只有在容器部署很长时间之后才会发现。</p>
<blockquote>
<p>The <code>local</code> attribute on the <code>idref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular bean reference anymore. Simply change your existing <code>idref local</code> references to <code>idref bean</code> when upgrading to the 4.0 schema.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>idref</code>元素的<code>local</code>属性在4.0 beans xsd中不再支持，因为它不再为合格的bean引用提供值。简单将你现有的<code>idref local</code>引用改成<code>idref bean</code>当更新到4.0 schema时。</p>
</blockquote>
<p>A common place (at least in versions earlier than Spring 2.0) where the <code>&lt;idref/&gt;</code> element brings value is in the configuration of AOP interceptors in a <code>ProxyFactoryBean</code> bean definition. Using <code>&lt;idref/&gt;</code> elements when you specify the interceptor names prevents you from misspelling an interceptor id.</p>
<p><code>&lt;idref/&gt;</code>元素带来值的通常位置（至少在Spring 2.0之前）是在<code>ProxyFactoryBean</code> bean定义中的AOP拦截器配置中。当你指定拦截器名字时使用<code>&lt;idref/&gt;</code>元素来防止误拼拦截器id。</p>
<p><strong>References to other beans (collaborators)</strong></p>
<p>The <code>ref</code> element is the final element inside a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code> definition element. Here you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property will be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may be initialized already by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the id/name of the other object through the <code>bean</code>, <code>local</code>, or <code>parent</code> attributes.</p>
<p><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素的最终的元素。在这个元素中设置bean的指定属性的值，值为容器管理的另一个bean（协作bean）的引用。引用的bean是设置属性bean的依赖，在属性设置之前引用bean需要进行初始化。（如果协作bean是一个单例模式的bean，它可能已经被容器初始化了。）所有引用bean根本上都是另一个对象的引用。作用域和验证是根据你是否通过<code>bean</code>，<code>local</code>，或<code>parent</code>属性指定了另一个对象的id/name来决定的。 </p>
<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the <code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean, or as one of the values in the <code>name</code> attribute of the target bean.</p>
<p>通过<code>&lt;ref/&gt;</code>标签的<code>bean</code>属性指定目标bean是最常用的形式，允许创建同容器或父容器中任何bean的引用，不管它是否是在同一个XML文件中。<code>bean</code>属性的值可能与目标bean的<code>id</code>属性值相同，或与目标bean的<code>name</code>属性值相同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"someBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean that is in a parent container of the current container. The value of the <code>parent</code> attribute may be the same as either the <code>id</code> attribute of the target bean, or one of the values in the <code>name</code> attribute of the target bean, and the target bean must be in a parent container of the current one. You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.</p>
<p>通过<code>parent</code>属性指定目标bean会引用当前容器的父容器中的bean。<code>parent</code>属性的值可能与目标bean的<code>id</code>值或<code>name</code>值相同，目标bean必须在当前容器的父容器中。当你有一个容器分层的时候你可以使用<code>parent</code>，你想将现有bean包裹在有代理的父容器中且现有bean与父容器中的bean同名，你可以使用<code>parent</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- in the parent context --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleAccountService"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- in the child (descendant) context --&gt;</div><div class="line">&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;</div><div class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</div><div class="line">    &lt;property name="target"&gt;</div><div class="line">        &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- insert other configuration and dependencies as required here --&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>The <code>local</code> attribute on the <code>ref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular <code>bean</code> reference anymore. Simply change your existing <code>ref local</code> references to <code>ref bean</code> when upgrading to the 4.0 schema.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>idref</code>元素的<code>local</code>属性在4.0 beans xsd中不再支持，因为它不再为合格的bean引用提供值。简单将你现有的<code>idref local</code>引用改成<code>idref bean</code>当更新到4.0 schema时。</p>
</blockquote>
<p><strong>Inner beans</strong></p>
<p>A <code>&lt;bean/&gt;</code> element inside the <code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines a so-called inner bean.</p>
<p><code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素内的<code>&lt;bean/&gt;</code>元素中定义bean称为内部bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>An inner bean definition does not require a defined id or name; if specified, the container does not use such a value as an identifier. The container also ignores the <code>scope</code> flag on creation: Inner beans are always anonymous and they are always created with the outer bean. It is not possible to inject inner beans into collaborating beans other than into the enclosing bean or to access them independently.</p>
<p>内部bean定义不要求定义id或name；如果指定了，容器不用用这个值作为标识符。容器创建时也忽略<code>scope</code>标记：内部bean总是匿名的且它们总是由外部bean创建。除了注入到封闭bean中或独立的访问它们，不可能将内部bean注入到协作bean中。</p>
<p>As a corner case, it is possible to receive destruction callbacks from a custom scope, e.g. for a request-scoped inner bean contained within a singleton bean: The creation of the inner bean instance will be tied to its containing bean, but destruction callbacks allow it to participate in the request scope’s lifecycle. This is not a common scenario; inner beans typically simply share their containing bean’s scope.</p>
<p>作为一种很少出现的情况，从特定的域中有可能会收到销毁回调函数，例如，对于请求域内的内部bean包含单例bean：内部bean实例的创建会绑定到它的包含bean，但销毁回调函数允许它进入到请求域的生命周期中。这不是一个常见的场景；内部bean通常简单的共享它们的包含bean的作用域。</p>
<p><strong>Collections</strong></p>
<p>In the <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code> elements, you set the properties and arguments of the Java <code>Collection</code> types <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>, respectively.</p>
<p>在<code>&lt;list/&gt;</code>，<code>&lt;set/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素中，你要分别设置Java <code>Collection</code>类型<code>list</code>，<code>set</code>，<code>map</code>和<code>Properties</code>的属性和参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><em>The value of a map key or value, or a set value, can also again be any of the following elements:</em></p>
<p>map的key或value，或者是set value的值也可以是下面元素中的任何一个：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bean | ref | idref | list | set | map | props | value | null</div></pre></td></tr></table></figure>
<p><strong>Collection merging</strong></p>
<p>The Spring container also supports the <em>merging</em> of collections. An application developer can define a parent-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> element, and have child-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> elements inherit and override values from the parent collection. That is, the child collection’s values are the result of merging the elements of the parent and child collections, with the child’s collection elements overriding values specified in the parent collection.</p>
<p>Spring也支持集合的合并。应用开发者可以定义父类型<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，可以有继承和覆盖父集合的子类型元素<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>。也就是说，子集合的值是父集合和子集合中元素合并的结果，子集合元素覆盖了父集合元素的值。</p>
<p>This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the relevant section before continuing.</p>
<p>关于合并的这节讨论了父子bean机制。对父子bean定义不熟悉的读者可以去读相关的章节。</p>
<p>The following example demonstrates collection merging:</p>
<p>下面的例子示范了集合合并：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Notice the use of the <code>merge=true</code> attribute on the <code>&lt;props/&gt;</code> element of the <code>adminEmails</code> property of the <code>child</code> bean definition. When the <code>child</code> bean is resolved and instantiated by the container, the resulting instance has an <code>adminEmails</code> <code>Properties</code> collection that contains the result of the merging of the child’s <code>adminEmails</code> collection with the parent’s <code>adminEmails</code> collection.</p>
<p>注意<code>child</code> bean定义中的<code>adminEmails</code>属性下的<code>&lt;props/&gt;</code>元素使用了<code>merge=true</code>属性。当容器解析并实例化<code>child</code> bean时，最终的实例含有<code>adminEmails</code> <code>Properties</code>集合，集合中的值是子<code>adminEmails</code>集合和父<code>adminEmails</code>集合合并的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">administrator=administrator@example.com</div><div class="line">sales=sales@example.com</div><div class="line">support=support@example.co.uk</div></pre></td></tr></table></figure>
<p>The child <code>Properties</code> collection’s value set inherits all property elements from the parent <code>&lt;props/&gt;</code>, and the child’s value for the <code>support</code> value overrides the value in the parent collection.</p>
<p>子<code>Properties</code>集合的值继承了父<code>&lt;props/&gt;</code>中的所有属性元素，子集合中的<code>support</code>值覆盖了父集合中的值。</p>
<p>This merging behavior applies similarly to the <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;set/&gt;</code> collection types. In the specific case of the <code>&lt;list/&gt;</code> element, the semantics associated with the <code>List</code> collection type, that is, the notion of an <code>ordered</code> collection of values, is maintained; the parent’s values precede all of the child list’s values. In the case of the <code>Map</code>, <code>Set</code>, and <code>Properties</code> collection types, no ordering exists. Hence no ordering semantics are in effect for the collection types that underlie the associated <code>Map</code>, <code>Set</code>, and <code>Properties</code> implementation types that the container uses internally.</p>
<p><code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型中的合并与上面类似。在特定的<code>&lt;list/&gt;</code>元素情况下，关于<code>List</code>集合类型的语义，也就是说，有序集合值的概念仍然是保留的；父list中的值领先于所有子list中的值。在<code>Map</code>，<code>Set</code>和<code>Properties</code>集合类型，不存在顺序。因此，无序语义在容器内部使用的集合类型<code>Map</code>，<code>Set</code>和<code>Properties</code>的实现基础上是有效的。</p>
<p><strong>Limitations of collection merging</strong></p>
<p>You cannot merge different collection types (such as a <code>Map</code> and a <code>List</code>), and if you do attempt to do so an appropriate <code>Exception</code> is thrown. The <code>merge</code> attribute must be specified on the lower, inherited, child definition; specifying the <code>merge</code> attribute on a parent collection definition is redundant and will not result in the desired merging.</p>
<p>你不能合并不同的集合类型（例如<code>Map</code>和<code>List</code>），如果你试图合并不同的集合类型会有适当的抛出<code>Exception</code>。<code>merge</code>属性必须在更低的、继承的子定义中；在父集合定义中指定<code>merge</code>属性是多余的并且不会进行合并。</p>
<p><strong>Strongly-typed collection</strong></p>
<p>With the introduction of generic types in Java 5, you can use strongly typed collections. That is, it is possible to declare a <code>Collection</code> type such that it can only contain <code>String</code> elements (for example). If you are using Spring to dependency-inject a strongly-typed <code>Collection</code> into a bean, you can take advantage of Spring’s type-conversion support such that the elements of your strongly-typed <code>Collection</code> instances are converted to the appropriate type prior to being added to the <code>Collection</code>.</p>
<p>随着Java 5中泛型的引入，你可以使用强类型集合。也就是说，你可以声明一个<code>Collection</code>类型但它只能包含<code>String</code>元素（例子）。如果你使用Spring将一个强类型的<code>Collection</code>注入到bean中，你可以利用Spring的类型转换支持，例如在将元素添加到<code>Collection</code>之前，将你的强类型<code>Collection</code>实例中的元素转成恰当的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.accounts = accounts;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>When the <code>accounts</code> property of the <code>foo</code> bean is prepared for injection, the generics information about the element type of the strongly-typed <code>Map&lt;String, Float&gt;</code> is available by reflection. Thus Spring’s type conversion infrastructure recognizes the various value elements as being of type <code>Float</code>, and the string values <code>9.99, 2.75</code>, and <code>3.99</code> are converted into an actual <code>Float</code> type.</p>
<p>当注入<code>foo</code> bean的<code>accounts</code>属性时，强类型<code>Map&lt;String, Float&gt;</code>中元素类型的泛型信息可以通过反射得到。因此Spring的类型转换结构能识别各种值元素的类型为<code>Float</code>，字符串<code>9.99, 2.75</code>和<code>3.99</code>会被转换成实际的<code>Float</code>类型。</p>
<p><strong>Null and empty string values</strong></p>
<p>Spring treats empty arguments for properties and the like as empty <code>Strings</code>. The following XML-based configuration metadata snippet sets the email property to the empty <code>String</code> value (“”).</p>
<p>Spring把属性的空参数都处理为空<code>Strings</code>。下面基于XML的配置元数据片段将email属性设为空<code>String</code>值(“”)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The preceding example is equivalent to the following Java code:</p>
<p>上面的例子与下面的Java代码是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exampleBean.setEmail(<span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>The <code>&lt;null/&gt;</code> element handles <code>null</code> values. For example:</p>
<p><code>&lt;null/&gt;</code>元素处理<code>null</code>值。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The above configuration is equivalent to the following Java code:</p>
<p>上面的配置与下面的Java代码等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exampleBean.setEmail(<span class="keyword">null</span>)</div></pre></td></tr></table></figure>
<p><strong>XML shortcut with the p-namespace</strong></p>
<p>The p-namespace enables you to use the <code>bean</code> element’s attributes, instead of nested <code>&lt;property/&gt;</code> elements, to describe your property values and/or collaborating beans.</p>
<p>p命名空间可以让你不需要嵌入<code>&lt;property/&gt;</code>元素便能使用<code>bean</code>元素的属性来描述你的属性值以及/或协作beans。</p>
<p>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
<p>Spring支持含有命名空间的扩展配置形式，命名控件是基于XML Schema定义的。本章讨论的beans配置形式是在XML Schema文档中定义的。但是p命名空间不能在XSD文件中定义并且只在Spring core中存在。</p>
<p>The following example shows two XML snippets that resolve to the same result: The first uses standard XML format and the second uses the p-namespace.</p>
<p>下面的例子显示了两个XML片段，解析结果是相同的：第一个是标准的XML形式，第二个使用了p命名空间。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></div><div class="line">        <span class="attr">p:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The example shows an attribute in the p-namespace called email in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.</p>
<p>这个例子显示了bean定义中p命名空间中有个一个叫email的属性。这会通知Spring包含属性声明。如前面所述，p命名空间没有schema定义，因此你可以将特性值（attribute）设到属性值（property）上。</p>
<p>This next example includes two more bean definitions that both have a reference to another bean:</p>
<p>下面的例子包括两个bean定义，且它们都引用了另一个bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-classic"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"John Doe"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spouse"</span> <span class="attr">ref</span>=<span class="string">"jane"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-modern"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"com.example.Person"</span></div><div class="line">        <span class="attr">p:name</span>=<span class="string">"John Doe"</span></div><div class="line">        <span class="attr">p:spouse-ref</span>=<span class="string">"jane"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>As you can see, this example includes not only a property value using the p-namespace, but also uses a special format to declare property references. Whereas the first bean definition uses <code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code> to create a reference from bean <code>john</code> to bean <code>jane</code>, the second bean definition uses <code>p:spouse-ref=&quot;jane&quot;</code> as an attribute to do the exact same thing. In this case <code>spouse</code> is the property name, whereas the <code>-ref</code> part indicates that this is not a straight value but rather a reference to another bean.</p>
<p>正如你所看到的，这个例子不仅包括使用了p命名空间的属性值，而且使用了一种特定的形式来声明属性引用。然而第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>创建了一个从bean <code>john</code>到bean <code>jane</code>的引用，第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为一个特性同样定义了从bean <code>john</code>到bean <code>jane</code>的引用。在<code>spouse</code>是属性名的情况下，<code>-ref</code>部分表示这不是一个直接的值而是另一个bean的引用。</p>
<blockquote>
<p>The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in <code>Ref</code>, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>p命名空间不是标准的XML格式，例如，声明的属性引用会与以<code>Ref</code>结尾的属性相冲突，而标准XML格式则不会。我们建议你仔细的选择你的方法并与你的团队成员交流，避免生成的XML文档同时使用了三种方式。</p>
</blockquote>
<p><strong>XML shortcut with the c-namespace</strong></p>
<p>Similar to the the section called “XML shortcut with the p-namespace”, the c-namespace, newly introduced in Spring 3.1, allows usage of inlined attributes for configuring the constructor arguments rather then nested <code>constructor-arg</code> elements.</p>
<p>与“XML shortcut with the p-namespace”小节类似，在Spring 3.1新引入的c命名空间允许使用行内属性配置构造函数参数而不用嵌入<code>constructor-arg</code>元素。</p>
<p>Let’s review the examples from the section called “Constructor-based dependency injection” with the <code>c:</code> namespace:</p>
<p>让我们重新回顾一下“Constructor-based dependency injection”小节中的例子并使用<code>c:</code>命名空间：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- traditional declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- c-namespace declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:bar-ref</span>=<span class="string">"bar"</span> <span class="attr">c:baz-ref</span>=<span class="string">"baz"</span> <span class="attr">c:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>c:</code> namespace uses the same conventions as the <code>p:</code> one (trailing <code>-ref</code> for bean references) for setting the constructor arguments by their names. And just as well, it needs to be declared even though it is not defined in an XSD schema (but it exists inside the Spring core).</p>
<p><code>c:</code>命名空间遵循与<code>p:</code>命名空间相同的约定在通过名字设置构造函数参数时。同样的，它也需要进行声明，虽然它不能在XSD schema中使用（但在Spring core中存在）。</p>
<p>For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can use fallback to the argument indexes:</p>
<p>对于很少出现的不能找到构造函数参数名字的情况（通常如果编译字节码且没有调试信息），可以使用参数索引：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:_0-ref</span>=<span class="string">"bar"</span> <span class="attr">c:_1-ref</span>=<span class="string">"baz"</span>/&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Due to the XML grammar, the index notation requires the presence of the leading <code>_</code> as XML attribute names cannot start with a number (even though some IDE allow it).</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>由于XML语法，索引符号需要前面加上<code>_</code>，因为XML属性名字不能以数字开头（即使一些IDE允许）。</p>
</blockquote>
<p>In practice, the constructor resolution mechanism is quite efficient in matching arguments so unless one really needs to, we recommend using the name notation through-out your configuration.</p>
<p>在实践中，构造函数解析机制能有效匹配参数，因此除非真的需要，否则我们推荐在配置中使用名字符号。</p>
<p><strong>Compound property names</strong></p>
<p>You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not <code>null</code>. Consider the following bean definition.</p>
<p>当你设置bean属性时，你可以使用混合的或嵌入的属性名字，只要路径中除了最后的属性名之外所有组件都是非<code>null</code>。考虑下面的bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"foo.Bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>foo</code> bean has a <code>fred</code> property, which has a <code>bob</code> property, which has a <code>sammy</code> property, and that final <code>sammy</code> property is being set to the value <code>123</code>. In order for this to work, the <code>fred</code> property of <code>foo</code>, and the <code>bob</code> property of <code>fred</code> must not be <code>null</code> after the bean is constructed, or a <code>NullPointerException</code> is thrown.</p>
<p><code>foo</code>bean有一个<code>fred</code>属性，<code>fred</code>有一个<code>sammy</code>属性，<code>bob</code>有一个<code>sammy</code>属性，最后的<code>sammy</code>属性设置值为<code>123</code>。为了这样设置，<code>foo</code>的<code>fred</code>属性，<code>fred</code>的<code>bob</code>属性在bean创建后必须是非<code>null</code>或抛出<code>NullPointerException</code>。</p>
<h4 id="3-4-3-Using-depends-on"><a href="#3-4-3-Using-depends-on" class="headerlink" title="3.4.3 Using depends-on"></a>3.4.3 Using depends-on</h4><p>If a bean is a dependency of another that usually means that one bean is set as a property of another. Typically you accomplish this with the <code>&lt;ref/&gt;</code> element in XML-based configuration metadata. However, sometimes dependencies between beans are less direct; for example, a static initializer in a class needs to be triggered, such as database driver registration. The <code>depends-on</code> attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the <code>depends-on</code> attribute to express a dependency on a single bean:</p>
<p>如果一个bean是另一个bean的一个依赖，这通常意味着一个bean作为另一个bean的一个属性去设置。在基于XML的配置元数据中通常使用<code>&lt;ref/&gt;</code>元素实现。然而有时beans之间的依赖关系是间接的；例如，类中的静态初始化程序需要触发，例如数据驱动注册。<code>depends-on</code>特性能显示的强制一个bean或多个beans在使用这个元素的bean初始化之前进行初始化。下面的例子使用<code>depends-on</code>特性表示一个单一bean的一个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>To express a dependency on multiple beans, supply a list of bean names as the value of the <code>depends-on</code> attribute, with commas, whitespace and semicolons, used as valid delimiters:</p>
<p>为了表示多个bean上的依赖关系，提供一个bean名字列表作为<code>depends-on</code>特性的值，用逗号，空格或分号作为有效分隔符：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>The <code>depends-on</code> attribute in the bean definition can specify both an initialization time dependency and, in the case of singleton beans only, a corresponding destroy time dependency. Dependent beans that define a <code>depends-on</code> relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus <code>depends-on</code> can also control shutdown order.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>depends-on</code>特性在bean定义中可以指定初始化时的依赖和对应的销毁时依赖（仅在单例情况下）。依赖beans与给定bean之间定义了一个<code>depends-on</code>关系，依赖beans在给定bean本身被销毁之前首先被销毁。因此<code>depends-on</code>也可以控制销毁顺序。</p>
</blockquote>
<h4 id="3-4-4-Lazy-initialized-beans"><a href="#3-4-4-Lazy-initialized-beans" class="headerlink" title="3.4.4 Lazy-initialized beans"></a>3.4.4 Lazy-initialized beans</h4><p>By default, <code>ApplicationContext</code> implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.</p>
<p>默认情况下，作为初始化过程的一部分，<code>ApplicationContext</code>实现时渴望创建并配置所有的单例beans。通常情况下，预实例化是必要的，因为配置中或周围环境中的错误可以立即发现，与几小时或几天后发现截然相反。当预实例化是不必要的时候，你可通过标记bean定义为延迟初始化来阻止单例bean的预实例化。延迟初始化的bean会通知IoC容器当第一次请求bean时创建一个bean实例，而不是在启动时创建。</p>
<p>In XML, this behavior is controlled by the <code>lazy-init</code> attribute on the <code>&lt;bean/&gt;</code> element; for example:</p>
<p>在XML中，延迟初始化通过<code>&lt;bean/&gt;</code>元素中的<code>lazy-init</code>特性来控制；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.AnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>When the preceding configuration is consumed by an <code>ApplicationContext</code>, the bean named <code>lazy</code> is not eagerly pre-instantiated when the <code>ApplicationContext</code> is starting up, whereas the <code>not.lazy</code> bean is eagerly pre-instantiated.</p>
<p>当<code>ApplicationContext</code>读取到上面的配置，<code>ApplicationContext</code>启动时名字为<code>lazy</code>的bean不会进行预实例化，而名字为<code>not.lazy</code>的bean会进行预实例化。</p>
<p>However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the <code>ApplicationContext</code> creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.</p>
<p>然而，当延迟初始化的bean是一个非延迟初始化的单例bean的依赖时，<code>ApplicationContext</code>会在启动时创建延迟初始化的bean，因为它必须提供单例bean的依赖。延迟初始化的bean会注入到单例bean中，而在其它地方它是非延迟初始化的。</p>
<p>You can also control lazy-initialization at the container level by using the <code>default-lazy-init</code> attribute on the <code>&lt;beans/&gt;</code> element; for example:</p>
<p>你也可以在容器中通过<code>&lt;beans/&gt;</code>中的<code>default-lazy-init</code>特性控制延迟初始化；例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-4-5-Autowiring-collaborators"><a href="#3-4-5-Autowiring-collaborators" class="headerlink" title="3.4.5 Autowiring collaborators"></a>3.4.5 Autowiring collaborators</h4><p>The Spring container can <em>autowire relationships</em> between collaborating beans. You can allow Spring to resolve collaborators (other beans) automatically for your bean by inspecting the contents of the <code>ApplicationContext</code>. Autowiring has the following advantages:</p>
<ul>
<li><p>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</li>
<li><p>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</li>
</ul>
<p>Spring容器能自动装配协作beans之间的关联关系。你可以允许Spring通过检查<code>ApplicationContext</code>中的内容自动的为你的bean解析协作者（其它bean）。自动装配有以下优势：</p>
<ul>
<li><p>自动装配能明显减少指定属性或构造函数参数的需要。（其它的机制例如在本章其它地方讨论的bean模板在这一点上也是非常重要的。）</p>
</li>
<li><p>当对象变化时自动装配能更新配置。例如，如果你需要增加一个类的依赖项，依赖项可以是满足自动装配的而不需要你去修改配置。因此自动装配在开发时尤其有用，当代码基础变的更稳定时可以改为显式装配。</p>
</li>
</ul>
<p>When using XML-based configuration metadata, you specify autowire mode for a bean definition with the <code>autowire</code> attribute of the <code>&lt;bean/&gt;</code> element. The autowiring functionality has four modes. You specify autowiring per bean and thus can choose which ones to autowire.</p>
<p>当使用基于XML的配置元数据时，通过使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>特性你可以指定一个bean定义的自动装配模式。自动注入功能有四种模式。你可以指定每个bean的自动装配模式，因此你可以选择使用哪一种模式。</p>
<p><strong>Table 3.2. Autowiring modes</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Mode</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no</td>
<td style="text-align:left">(Default) No autowiring. Bean references must be defined via a <code>ref</code> element. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name, and it contains a <em>master</em> property (that is, it has a <em>setMaster(..)</em> method), Spring looks for a bean definition named <code>master</code>, and uses it to set the property.</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">Allows a property to be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use <em>byType</em> autowiring for that bean. If there are no matching beans, nothing happens; the property is not set.</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">Analogous to <code>byType</code>, but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.</td>
</tr>
</tbody>
</table>
<p><strong>表 3.2 自动装配模式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">no</td>
<td style="text-align:left">（默认）无自动装配。引用bean必须通过<code>ref</code>元素定义。对于更大的部署，不推荐更改默认设置，因为显式指定协作者更清晰并且更易控制。在某种程度上来说，它记录了系统的结构。</td>
</tr>
<tr>
<td style="text-align:left">byName</td>
<td style="text-align:left">通过属性名称自动装配。Spring寻找与需要自动装配的属性同名的bean。例如，如果一个bean定义设置为通过名称自动装配，它有一个<code>master</code>属性（也就是说，它有一个<code>setMaster(..)</code>方法），Spring寻找名字为<code>master</code>的bean定义，使用它设置属性值。</td>
</tr>
<tr>
<td style="text-align:left">byType</td>
<td style="text-align:left">如果容器中含有属性类型已知的一个bean，那么可以允许按类型自动装配属性。如果此类型的bean不止一个，则会抛出致命的异常，这意味着你可能不能使用<code>byType</code>来注入那个bean。如果没有匹配的bean，则什么也不做；属性没有被设置。</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">与<code>byType</code>类似，但是应用到构造函数参数上的。如果容器中没有一个构造函数参数bean的确定类型，将会抛出一个致命的异常。</td>
</tr>
</tbody>
</table>
<p>With <em>byType</em> or constructor autowiring mode, you can wire arrays and typed-collections. In such cases all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed Maps if the expected key type is <code>String</code>. An autowired Maps values will consist of all bean instances that match the expected type, and the Maps keys will contain the corresponding bean names.</p>
<p>通过<code>byType</code>或构造函数自动装配模式，你可以配置数组和集合类型。在这种情况下容器内所有能匹配期望类型的自动装配候选对象将被提供合适的依赖项。如果期望的<code>key</code>类型是<code>String</code>类型，你可以自动装配强类型的<code>Maps</code>。自动装配的<code>Maps</code>的值将有所有匹配期望类型的bean组成，<code>Maps</code>的键将包含对应的bean名称。</p>
<p>You can combine autowire behavior with dependency checking, which is performed after autowiring completes.</p>
<p>你可以将依赖检查与自动装配相结合，它将在自动装配完成之后执行。</p>
<p><strong>Limitations and disadvantages of autowiring</strong></p>
<p>Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.</p>
<p>当自动装配在整个工程中一致的使用时其效果最好。如果通常情况下不使用自动装配，仅在一两个bean定义中使用自动装配开发人员可能感到非常困惑。</p>
<p>Consider the limitations and disadvantages of autowiring:</p>
<ul>
<li><p>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override autowiring. You cannot autowire so-called simple properties such as primitives, <code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is by-design.</p>
</li>
<li><p>Autowiring is less exact than explicit wiring. Although, as noted in the above table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.</p>
</li>
<li><p>Wiring information may not be available to tools that may generate documentation from a Spring container.</p>
</li>
<li><p>Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.</p>
</li>
</ul>
<p>考虑一下自动装配的限制与缺点：</p>
<ul>
<li><p><code>property</code>和<code>constructor-arg</code>中显式依赖的设置总是会覆盖自动装配。你不能自动装配所谓的简单属性例如基本类型，<code>Strings</code>和<code>Classes</code>（和简单类型的数组）。这是设计上的限制。</p>
</li>
<li><p>与显式配置相比，自动装配是更不确定的。尽管Spring小心的避免猜测以防歧义性引起无法预料的后果，但Spring管理的对象之间的关系不再被显式的记录。</p>
</li>
<li><p>Spring容器中能产生文档的工具可能得不到配置信息。</p>
</li>
<li><p>setter方法或构造函数参数指定的类型进行自动装配时可能匹配到容器中多个bean的定义。对于数组，集合或<code>Maps</code>而言，这是一个不必要的问题。然而对于只期望一个值的依赖而言，这个歧义性不能任意解决。如果不能获得唯一的bean定义，会抛出异常。</p>
</li>
</ul>
<p>In the latter scenario, you have several options:</p>
<ul>
<li><p>Abandon autowiring in favor of explicit wiring.</p>
</li>
<li><p>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes to <code>false</code> as described in the next section.</p>
</li>
<li><p>Designate a single bean definition as the <em>primary</em> candidate by setting the <code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</p>
</li>
<li><p>Implement the more fine-grained control available with annotation-based configuration, as described in Section 3.9, “Annotation-based container configuration”.</p>
</li>
</ul>
<p>后面的方案中，你有一些选择：</p>
<ul>
<li><p>放弃自动装配支持显式配置。</p>
</li>
<li><p>通过设置bean的<code>autowire-candidate</code>特性为<code>false</code>来避免自动装配。</p>
</li>
<li><p>通过设置<code>&lt;bean/&gt;</code>元素的<code>primary</code>特性为<code>true</code>来指定一个单例bean定义作为主要的候选bean。</p>
</li>
<li><p>通过基于注解的配置实现更多细颗粒的控制，如3.9小节 “基于注解的容器配置”。</p>
</li>
</ul>
<p><strong>Excluding a bean from autowiring</strong></p>
<p>On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the <code>autowire-candidate</code> attribute of the <code>&lt;bean/&gt;</code> element to <code>false</code>; the container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as <code>@Autowired</code>).</p>
<p>在单个bean的基础上，你可以排除bean在自动装配之外。在Spring的XML形式中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>特性为<code>false</code>；容器会使自动装配基础框架不能得到指定bean定义（包括注解类型的配置，例如<code>@Autowired</code>）。</p>
<p>You can also limit autowire candidates based on pattern-matching against bean names. The top-level <code>&lt;beans/&gt;</code> element accepts one or more patterns within its <code>default-autowire-candidates</code> attribute. For example, to limit autowire candidate status to any bean whose name ends with <em>Repository</em>, provide a value of <code>*Repository</code>. To provide multiple patterns, define them in a comma-separated list. An explicit value of <code>true</code> or <code>false</code> for a bean definitions <code>autowire-candidate</code> attribute always takes precedence, and for such beans, the pattern matching rules do not apply.</p>
<p>你也可以根据bean名称的匹配模式限制自动装配的候选目标。顶层的<code>&lt;beans/&gt;</code>元素可以接收<code>default-autowire-candidates</code>特性中的一个或多个模式。例如，为了限制自动装配候选目标匹配任何名字以<code>Repository</code>结尾的bean，可以提供一个<code>*Repository</code>值。为了提供多种模式，可以定义一个以逗号为分隔符的列表。bean定义中<code>autowire-candidate</code>特性显示的值<code>true</code>或<code>false</code>最是优先起作用的，对于这些bean而言，模式匹配规则不起作用。</p>
<p>These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p>
<p>这些技术对于那些你从不想通过自动装配方式注入到其它bean中的beans而言是很有用的。这不意味着一个排除的bean它本身不能通过自动装配进行配置。更确切的说，bean本身不是一个进行其它bean进行自动装配的候选者。</p>
<h4 id="3-4-6-Method-injection"><a href="#3-4-6-Method-injection" class="headerlink" title="3.4.6 Method injection"></a>3.4.6 Method injection</h4><p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean, or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container only creates the singleton bean A once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
<p>在大多数应用场景中，容器中的大多数bean是单例的。当一个单例bean需要与另一个单例bean协作时，或一个非单例bean需要与另一个非单例bean协作时，你通常通过定义一个bean作为另一个bean的一个属性来处理这个依赖关系。当bean的生命周期不同时问题就出现了。假设一个单例bean A需要使用非单例（标准）bean B时，也许A中的每一个方法调用都要使用bean B。容器仅创建单例bean A一次，因此仅有一次设置属性的机会。容器不能在每次需要bean B时提供一个bean B的新的实例。</p>
<p>A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the <code>ApplicationContextAware</code> interface, and by making a getBean(“B”) call to the container ask for (a typically new) bean B instance every time bean A needs it. The following is an example of this approach:</p>
<p>一个解决方案是放弃一些控制反转。你可以使bean A通过实现<code>ApplicationContextAware</code>接口感知到容器，每个bean A需要的时候就通过<code>getBean(&quot;B&quot;)</code>调用向容器请求（通常是新的）一个bean B的实例。下面是这种方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></div><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// Spring-API imports</span></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// notice the Spring API dependency!</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></div><div class="line">            ApplicationContext applicationContext) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, allows this use case to be handled in a clean fashion.</p>
<p>前面所讲的不是让人满意的，因为业务代码能感知并耦合了Spring框架。方法注入，Spring IoC容器的一个有点高级的特性，允许使用一种干净的方式来处理这个案例。</p>
<blockquote>
<p>You can read more about the motivation for Method Injection in this blog entry.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>你可以在blog entry中了解更多关于方法注入的动机。</p>
</blockquote>
<p><strong>Lookup method injection</strong></p>
<p>Lookup method injection is the ability of the container to override methods on container managed beans, to return the lookup result for another named bean in the container. The lookup typically involves a prototype bean as in the scenario described in the preceding section. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method.</p>
<p>查找方法注入是容器的一种覆盖其管理的beans中的方法的能力，可以返回容器中另一个命名bean查找结果。查找通常会涉及到一个标准bean，如前一小节中讲的那样。Spring框架实现了查找方法注入，它是通过使用CGLIB库生成的字节码来动态的产生一个覆盖这个方法的子类。</p>
<blockquote>
<ul>
<li><p>For this dynamic subclassing to work, the class that the Spring bean container will subclass cannot be final, and the method to be overridden cannot be final either.</p>
</li>
<li><p>Unit-testing a class that has an abstract method requires you to subclass the class yourself and to supply a stub implementation of the abstract method.</p>
</li>
<li><p>Concrete methods are also necessary for component scanning which requires concrete classes to pick up.</p>
</li>
<li><p>A further key limitation is that lookup methods won’t work with factory methods and in particular not with <code>@Bean</code> methods in configuration classes, since the container is not in charge of creating the instance in that case and therefore cannot create a runtime-generated subclass on the fly.</p>
</li>
<li><p>Finally, objects that have been the target of method injection cannot be serialized.</p>
</li>
</ul>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<ul>
<li><p>为了使动态子类化起作用，Spring bean容器要进行子类化的类不能是最终的类，要进行重写的方法也不是最终的方法。</p>
</li>
<li><p>单元测试一个含有抽象方法的类需要你自己对这个类进行子类化，并且提供这个抽象方法的<code>stub</code>实现。</p>
</li>
<li><p>实体方法对于要求获得实体类的组件扫描也是必需的。</p>
</li>
<li><p>一个更关键的限制是查找方法不能与工厂方法一起工作，尤其是在配置类中不能与<code>@Bean</code>方法同时起作用，由于那种情况下容器不能控制实例的创建，因此不能在飞速写入中创建一个运行时产生的子类。</p>
</li>
<li><p>最后，方法注入的目标对象不能被序列化。</p>
</li>
</ul>
</blockquote>
<p>Looking at the <code>CommandManager</code> class in the previous code snippet, you see that the Spring container will dynamically override the implementation of the <code>createCommand()</code> method. Your <code>CommandManager</code> class will not have any Spring dependencies, as can be seen in the reworked example:</p>
<p>看一下前面代码片中的<code>CommandManager</code>类，你可以看到Spring容器将会动态的覆盖<code>createCommand()</code>方法的实现。<code>CommandManager</code>类不会有任何Spring依赖，重写的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// no more Spring imports!</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In the client class containing the method to be injected (the <code>CommandManager</code> in this case), the method to be injected requires a signature of the following form:</p>
<p>客户类中包含要注入的方法（在这个例子中是<code>CommandManager</code>），要注入的方法需要下面形式的一个签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</div></pre></td></tr></table></figure>
<p>If the method is abstract, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. For example:</p>
<p>如果这个方法是抽象的，动态产生的子类会实现这个方法。另外，动态产生的子类会覆盖原来的类中定义的实体方法。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"command"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"command"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The bean identified as <em>commandManager</em> calls its own method <code>createCommand()</code> whenever it needs a new instance of the <code>command</code> bean. You must be careful to deploy the <code>command</code> bean as a prototype, if that is actually what is needed. If it is deployed as a singleton, the same instance of the <code>command</code> bean is returned each time.</p>
<p>无论什么时候识别为<code>commandManager</code>的bean需要一个<code>command</code> bean的新实例，它都会调用它的<code>createCommand()</code>方法。如果真的需要的话，你必须小心的部署<code>command</code> bean为一个原型。如果它被部署为一个单例，每次都会返回同一个<code>command</code>实例。</p>
<blockquote>
<p>The interested reader may also find the <code>ServiceLocatorFactoryBean</code> (in the <code>org.springframework.beans.factory.config</code> package) to be of use. The approach used in <code>ServiceLocatorFactoryBean</code> is similar to that of another utility class, <code>ObjectFactoryCreatingFactoryBean</code>, but it allows you to specify your own lookup interface as opposed to a Spring-specific lookup interface. Consult the javadocs of these classes for additional information.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>感兴趣的读者可能也会发现<code>ServiceLocatorFactoryBean</code>（在<code>org.springframework.beans.factory.config</code>包中）使用这种方法。<code>ServiceLocatorFactoryBean</code>中使用的方法与另一个工具类<code>ObjectFactoryCreatingFactoryBean</code>中的方法类似，但它允许你指定你自己的查找接口，与Spring特定的查找接口相反。这些类的额外信息请查询Java文档。</p>
</blockquote>
<p><strong>Arbitrary method replacement</strong></p>
<p>A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. Users may safely skip the rest of this section until the functionality is actually needed.</p>
<p>一种比查找方法注入更少使用的形式是用另一种方法实现替换管理的bean中任意方法的能力。用户可以安全跳过本节剩下的部分，直到这个方法真正需要的时候再看。</p>
<p>With XML-based configuration metadata, you can use the <code>replaced-method</code> element to replace an existing method implementation with another, for a deployed bean. Consider the following class, with a method <code>computeValue</code>, which we want to override:</p>
<p>在基于XML的配置元数据中，对于一个部署的bean，你可以通过<code>replaced-method</code>元素用另一个方法实现替换现有的方法实现。考虑下面的类，有一个我们想覆盖的<code>computeValue</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">        <span class="comment">// some real code...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// some other methods...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A class implementing the <code>org.springframework.beans.factory.support.MethodReplacer</code> interface provides the new method definition.</p>
<p>实现了<code>org.springframework.beans.factory.support.MethodReplacer</code>接口的类提供了一种新的方法定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * meant to be used to override the existing computeValue(String)</div><div class="line"> * implementation in MyValueCalculator</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></div><div class="line">        String input = (String) args[<span class="number">0</span>];</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> ...;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The bean definition to deploy the original class and specify the method override would look like this:</p>
<p>部署最初的类的bean定义和指定的重写方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>You can use one or more contained <code>&lt;arg-type/&gt;</code> elements within the <code>&lt;replaced-method/&gt;</code> element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match <code>java.lang.String</code>:</p>
<p>你可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个包含<code>&lt;arg-type/&gt;</code>元素来指出要覆盖的方法的方法签名。只有类中进行了方法重载且有多个重载变种的时候，参数的签名才是必需的。为了简便，字符串类型的参数可能是全拼类型名称的一个子串。例如，下面的所有写法都能匹配<code>java.lang.String</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.String</div><div class="line">String</div><div class="line">Str</div></pre></td></tr></table></figure>
<p>Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by allowing you to type only the shortest string that will match an argument type.</p>
<p>因为参数数目经常是足够区分每个可能的选择的，通过允许定义匹配参数类型的最短字符串类型，这个缩写可以保存许多类型。</p>
<h3 id="3-5-Bean-scopes"><a href="#3-5-Bean-scopes" class="headerlink" title="3.5 Bean scopes"></a>3.5 Bean scopes</h3><p>When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.</p>
<p>当你创建bean定义时，你创建了一个配方用于创建bean定义中定义的类的实例。bean定义是配方的想法是很重要的，因为这意味着对于一个类，你可以根据一个配方创建许多对象实例。</p>
<p>You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition, but also the scope of the objects created from a particular bean definition. This approach is powerful and flexible in that you can choose the scope of the objects you create through configuration instead of having to bake in the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes: out of the box, the Spring Framework supports six scopes, five of which are available only if you use a web-aware <code>ApplicationContext</code>.</p>
<p>你不仅能管理要插入对象中的的各种依赖和配置值，而且能管理对象的作用域，对象是从特定的bean定义中创建的。这种方法是强大且灵活的，你可以通过配置文件选择你创建的对象的作用域，从而代替Java类级别对象的内置作用域。定义的beans将部署成多种作用域中的一种：开箱即用，Spring框架支持六种作用域，如果你使用感知web的<code>ApplicationContext</code>，你只可以使用其中的五种作用域。</p>
<p>The following scopes are supported out of the box. You can also create a custom scope.</p>
<p>下面的作用域支持开箱即用。你也可以创建一个定制的作用域。</p>
<p><strong>Table 3.3. Bean scopes</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Scope</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">singleton</td>
<td style="text-align:left">(Default) Scopes a single bean definition to a single object instance per Spring IoC container.</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td style="text-align:left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td style="text-align:left">session</td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring ApplicationContext.</td>
</tr>
<tr>
<td style="text-align:left">application</td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td style="text-align:left">websocket</td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody>
</table>
<p><strong>表 3.3 bean作用域</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">作用域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">singleton</td>
<td style="text-align:left">(默认) 每个Spring IoC容器使单个bean定义只能创建一个对象实例。</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td style="text-align:left">单个bean定义可以创建任何数量的对象实例。</td>
</tr>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">单个bean定义的创建实例的作用域为单个HTTP request的声明周期；也就是说，每个HTTP request有它自己的根据bean定义创建的实例。只在感知Spring <code>ApplicationContext</code>的上下文中有效。</td>
</tr>
<tr>
<td style="text-align:left">session</td>
<td style="text-align:left">单个bean定义的创建实例的作用域为HTTP <code>Session</code>的生命周期. 只在感知Spring <code>ApplicationContext</code>的上下文中有效。</td>
</tr>
<tr>
<td style="text-align:left">application</td>
<td style="text-align:left">单个bean定义的创建实例的作用域为<code>ServletContext</code>的生命周期。 只在感知Spring <code>ApplicationContext</code>的上下文中有效。</td>
</tr>
<tr>
<td style="text-align:left">websocket</td>
<td style="text-align:left">单个bean定义的创建实例的作用域为<code>WebSocket</code>的生命周期。 只在感知Spring <code>ApplicationContext</code>的上下文中有效。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>As of Spring 3.0, a <em>thread scope</em> is available, but is not registered by default. For more information, see the documentation for <code>SimpleThreadScope</code>. For instructions on how to register this or any other custom scope, see the section called “Using a custom scope”.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>从Spring 3.0，引入了<code>thread scope</code>作用域，但默认情况下是不注册的。更多的信息请看<code>SimpleThreadScope</code>文档。关于怎么注册<code>thread scope</code>作用域或任何其它的定制作用域的介绍，请看『Using a custom scope』小节。</p>
</blockquote>
<h4 id="3-5-1-The-singleton-scope"><a href="#3-5-1-The-singleton-scope" class="headerlink" title="3.5.1 The singleton scope"></a>3.5.1 The singleton scope</h4><p>Only one <em>shared</em> instance of a singleton bean is managed, and all requests for beans with an id or ids matching that bean definition result in that one specific bean instance being returned by the Spring container.</p>
<p>单例bean只管理一个<em>共享</em>实例，id匹配bean定义的所有对beans的请求，Spring容器会返回一个特定的bean实例。</p>
<p>To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates <em>exactly</em> one instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and <em>all subsequent requests and references</em> for that named bean return the cached object.</p>
<p>换言之，当你定义一个bean定义时，它的作用域为单例，Spring IoC容器会根据bean定义创建一个确定的对象实例。这个单独的实例存储在单例beans的缓存中，接下来的对这个命名bean的所有请求和引用都会返回那个缓存的对象。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/spring_singleton.png" alt="image"></p>
<p>Spring’s concept of a singleton bean differs from the Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as per container and per bean. This means that if you define one bean for a particular class in a single Spring container, then the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you would write, for example:</p>
<p>Spring中的单例bean概念不同于《设计模式》书中定义的单例模式。设计模式中的单例是对对象的作用域进行硬编码，为的是每个类加载器只能创建一个特定类的实例。Spring单例作用域最好的描述是每个容器每个类。这意味着如果你在单个的Spring容器中为一个特定的类定义了一个bean，Spring只会根据bean定义创建一个类的实例。在Spring中单例作用域是默认的作用域。为了在XML定义一个单例bean，你可以像下面一样写，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-5-2-The-prototype-scope"><a href="#3-5-2-The-prototype-scope" class="headerlink" title="3.5.2 The prototype scope"></a>3.5.2 The prototype scope</h4><p>The non-singleton, prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a <code>getBean()</code> method call on the container. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.</p>
<p>非单例模式，bean部署采用原型作用域时，每次产生一个特定bean的请求时都会创建一个新的bean实例。也就是说，这个bean会注入到另一个bean中或你可以在容器中通过调用<code>getBean()</code>方法来请求它。通常，对于所有有状态的beans使用原型作用域，对于无状态的beans使用单例作用域。</p>
<p>The following diagram illustrates the Spring prototype scope. A data access object (DAO) is not typically configured as a prototype, because a typical DAO does not hold any conversational state; it was just easier for this author to reuse the core of the singleton diagram.</p>
<p>下面的图阐述了Spring原型作用域。数据访问对象（DAO）通常是不会配置为原型的，因为一个典型的DAO不会有任何会话状态；对于作者来说很容易重用单例图的核心。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/spring_prototype.png" alt="image"></p>
<p>The following example defines a bean as a prototype in XML:</p>
<p>下面的例子在XML中定义一个原型bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype bean(s) are holding. To get the Spring container to release resources held by prototype-scoped beans, try using a custom bean post-processor, which holds a reference to beans that need to be cleaned up.</p>
<p>与其它作用域相比，Spring不管理原型bean的完整生命周期：容器初始化、配置，另外组装原型对象，并把它传递给客户端，之后不再记录原型实例。因此，虽然不管什么作用域初始化生命周期回调函数都会在所有对象上调用，但是在原型作用域的情况下，不会调用配置的销毁生命周期回调函数。客户端代码必须清理原型作用域的对象并释放原型bean拥有的昂贵资源。为了使Spring容器释放原型bean拥有的资源，尝试使用定制的bean后处理程序，它拥有需要清理的bean的引用。</p>
<p>In some respects, the Spring container’s role in regard to a prototype-scoped bean is a replacement for the Java <code>new</code> operator. All lifecycle management past that point must be handled by the client. (For details on the lifecycle of a bean in the Spring container, see Section 3.6.1, “Lifecycle callbacks”.)</p>
<p>在有些方面，关于原型作用域，Spring容器的角色像是Java中<code>new</code>操作符的替代品。所有生命周期的管理必须由客户端处理。（Spring容器中更多关于bean生命周期的细节，请看3.6.1小节，”生命周期回调”）。</p>
<h4 id="3-5-3-Singleton-beans-with-prototype-bean-dependencies"><a href="#3-5-3-Singleton-beans-with-prototype-bean-dependencies" class="headerlink" title="3.5.3 Singleton beans with prototype-bean dependencies"></a>3.5.3 Singleton beans with prototype-bean dependencies</h4><p>When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean.</p>
<p>当你使用含有原型bean依赖的单例作用域bean时，要意识到依赖解析是在实例化时。因此如果你使用依赖注入将原型作用域的bean注入到单例作用域的bean中时，将会实例化一个新的原型bean并依赖注入到单例bean中。原型bean实例曾经是唯一提供给单例作用域的bean的实例。</p>
<p>However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container is instantiating the singleton bean and resolving and injecting its dependencies. If you need a new instance of a prototype bean at runtime more than once, see Section 3.4.6, “Method injection”.</p>
<p>假设你想在运行时让单例作用域的bean重复的获得原型作用域bean的新实例。你不能依赖注入原型作用域的bean到你的单例bean中，因为当Spring容器实例化单例bean，解析并注入它的依赖时，注入只发生一次。如果你在运行时不止一次需要原型bean的实例，请看3.4.6小节，”方法注入”。</p>
<h4 id="3-5-4-Request-session-application-and-WebSocket-scopes"><a href="#3-5-4-Request-session-application-and-WebSocket-scopes" class="headerlink" title="3.5.4 Request, session, application, and WebSocket scopes"></a>3.5.4 Request, session, application, and WebSocket scopes</h4><p>The <code>request</code>, <code>session</code>, <code>application</code>, and <code>websocket</code> scopes are only available if you use a web-aware Spring <code>ApplicationContext</code> implementation (such as <code>XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers such as the <code>ClassPathXmlApplicationContext</code>, an <code>IllegalStateException</code> will be thrown complaining about an unknown bean scope.</p>
<p>如果你使用感知web的Spring <code>ApplicationContext</code>实现（例如<code>XmlWebApplicationContext</code>），<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>作用域是唯一可用的作用域。如果你通过正规的Spring IoC容器例如<code>ClassPathXmlApplicationContext</code>来使用这些作用域，会抛出<code>IllegalStateException</code>异常，投诉使用了一个未知的bean作用域。</p>
<p><strong>Initial web configuration</strong></p>
<p>To support the scoping of beans at the <code>request</code>, <code>session</code>, <code>application</code>, and <code>websocket</code> levels (web-scoped beans), some minor initial configuration is required before you define your beans. (This initial setup is not required for the standard scopes, <code>singleton</code> and <code>prototype</code>.)</p>
<p>为了支持<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>标准的bean作用域，在你定义你的bean之前需要进行一些较小的初始化配置。（对于标准作用域<code>singleton</code>和<code>prototype</code>，初始化设置不需要的。）</p>
<p>How you accomplish this initial setup depends on your particular Servlet environment.</p>
<p>怎样完成这个初始化设置依赖于你特定的Servlet环境。</p>
<p>If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring <code>DispatcherServlet</code>, then no special setup is necessary: <code>DispatcherServlet</code> already exposes all relevant state.</p>
<p>如果你在Spring Web MVC中访问具有作用域的beans，请求内部是通过Spring的<code>DispatcherServlet</code>来处理的，不需要特定设置：<code>DispatcherServlet</code>已经显示了所有相关的状态。</p>
<p>If you use a Servlet 2.5 web container, with requests processed outside of Spring’s <code>DispatcherServlet</code> (for example, when using JSF or Struts), you need to register the <code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>. For Servlet 3.0+, this can be done programmatically via the <code>WebApplicationInitializer</code> interface. Alternatively, or for older containers, add the following declaration to your web application’s <code>web.xml</code> file:</p>
<p>如果你使用Servlet 2.5的web容器，在Spring的<code>DispatcherServlet</code>之外处理请求（例如使用JSF或Struts时），你需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于Servlet 3.0+，能通过<code>WebApplicationInitializer</code>接口以编程方式处理。对于更早的容器，可以在应用程序的<code>web.xml</code>文件中添加下面的声明来代替：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></div><div class="line">            org.springframework.web.context.request.RequestContextListener</div><div class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Alternatively, if there are issues with your listener setup, consider using Spring’s <code>RequestContextFilter</code>. The filter mapping depends on the surrounding web application configuration, so you have to change it as appropriate.</p>
<p>如果你的监听器设置有问题，作为一种选择，你可以考虑Spring的<code>RequestContextFilter</code>。过滤器映射依赖于web应用程序的相关配置，因此你必须适当的更改它。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code> all do exactly the same thing, namely bind the HTTP request object to the <code>Thread</code> that is servicing that request. This makes beans that are request- and session-scoped available further down the call chain.</p>
<p><code>DispatcherServlet</code>，<code>RequestContextListener</code>和<code>RequestContextFilter</code>都是在做同样的事，也就是说将HTTP请求对象绑定到服务请求的<code>Thread</code>上。这使得request作用域和session作用域的beans在更深一层的调用链中是可用的。</p>
<p><strong>Request scope</strong></p>
<p>Consider the following XML configuration for a bean definition:</p>
<p>考虑下面的bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.foo.LoginAction"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>The Spring container creates a new instance of the <code>LoginAction</code> bean by using the <code>loginAction</code> bean definition for each and every HTTP request. That is, the <code>loginAction</code> bean is scoped at the HTTP <code>request</code> level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same <code>loginAction</code> bean definition will not see these changes in state; they are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded.</p>
<p>对于每一个HTTP请求，Spring容器通过使用<code>loginAction</code>定义创建一个新的<code>LoginAction</code> bean实例。也就是说，<code>loginAction</code> bean的作用域是在HTTP <code>request</code>级别的。你可以任意改变创建的实例的内部状态，因为其它的根据<code>loginAction</code> bean定义创建的实例不会看到这些状态的改变；它们对于每个单独的请求都是独有的。当请求处理完成时，请求作用域的bean被销毁。</p>
<p>When using annotation-driven components or Java Config, the <code>@RequestScope</code> annotation can be used to assign a component to the request scope.</p>
<p>当使用注解驱动的组件或Java配置时，<code>@RequestScope</code>注解能用来指定一个组件的作用域为request。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Session scope</strong></p>
<p>Consider the following XML configuration for a bean definition:</p>
<p>考虑下面的bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>The Spring container creates a new instance of the <code>UserPreferences</code> bean by using the <code>userPreferences</code> bean definition for the lifetime of a single HTTP Session. In other words, the <code>userPreferences</code> bean is effectively scoped at the HTTP <code>Session</code> level. As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP Session instances that are also using instances created from the same <code>userPreferences</code> bean definition do not see these changes in state, because they are particular to an individual HTTP Session. When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is also discarded.</p>
<p>对于单个HTTP Session的生命周期，Spring容器通过<code>userPreferences</code> bean定义创建一个<code>UserPreferences</code> bean实例。换句话说，<code>userPreferences</code> bean的有效作用域是HTTP <code>Session</code>级别的。正如request作用域的beans一样，你可以任意改变你想改变的创建的bean实例的内部状态，知道其它的使用根据<code>userPreferences</code> bean定义创建的HTTP Session实例也不会看到这些内部状态的改变，因为它们对于每个单独的HTTP Session都是独有的。当HTTP Session被最终销毁时，Session作用域的bean也被销毁。</p>
<p>When using annotation-driven components or Java Config, the <code>@SessionScope</code> annotation can be used to assign a component to the session scope.</p>
<p>当使用注解驱动的组件或Java配置时，<code>@SessionScope</code>注解能用来指定一个组件的作用域为session。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SessionScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Application scope</strong></p>
<p>Consider the following XML configuration for a bean definition:</p>
<p>考虑下面的bean定义的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.AppPreferences"</span> <span class="attr">scope</span>=<span class="string">"application"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>The Spring container creates a new instance of the <code>AppPreferences</code> bean by using the <code>appPreferences</code> bean definition once for the entire web application. That is, the <code>appPreferences</code> bean is scoped at the <code>ServletContext</code> level, stored as a regular <code>ServletContext</code> attribute. This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per <code>ServletContext</code>, not per Spring ‘ApplicationContext’ (for which there may be several in any given web application), and it is actually exposed and therefore visible as a <code>ServletContext</code> attribute.</p>
<p>对于整个web应用而言，Spring容器根据<code>appPreferences</code> bean定义只创建一次<code>AppPreferences</code> bean的新实例。也就是说，<code>appPreferences</code> bean的作用域是<code>ServletContext</code>级别的，作为一个正规的<code>ServletContext</code>特性来存储。这有点类似于Spring的单例bean，但在两个方面是不同的：它对于每个<code>ServletContext</code>是单例的，而不是每个Spring <code>ApplicationContext</code>（在任何给定的web应用中可能有几个<code>ApplicationContext</code>），它是真正显露的，因此作为一个<code>ServletContext</code>特性是可见的。</p>
<p>When using annotation-driven components or Java Config, the <code>@ApplicationScope</code> annotation can be used to assign a component to the application scope.</p>
<p>当使用注解驱动的组件或Java配置时，<code>@ApplicationScope</code>注解能用来指定一个组件的作用域为Application。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ApplicationScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Scoped beans as dependencies</strong></p>
<p>The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real target object from the relevant scope (such as an HTTP request) and delegate method calls onto the real object.</p>
<p>Spring IoC容器不仅管理对象的实例化，而且管理协作者（或依赖）的绑定。例如，如果你想将一个具有HTTP request作用域的bean注入到另一个具有更长生命周期作用域的bean中，你可以选择注入一个AOP代理来代替具有作用域的bean。也就是说，你需要注入一个代理对象，这个对象能显露与具有作用域的对象相同的接口，但也能从相关的作用域中（例如HTTP request作用域）得到真正的目标对象，能通过委派方法调用到真正的对象。</p>
<blockquote>
<p>You may also use <code>&lt;aop:scoped-proxy/&gt;</code> between beans that are scoped as <code>singleton</code>, with the reference then going through an intermediate proxy that is serializable and therefore able to re-obtain the target singleton bean on deserialization.</p>
<p>When declaring <code>&lt;aop:scoped-proxy/&gt;</code> against a bean of scope <code>prototype</code>, every method call on the shared proxy will lead to the creation of a new target instance which the call is then being forwarded to.</p>
<p>Also, scoped proxies are not the only way to access beans from shorter scopes in a lifecycle-safe fashion. You may also simply declare your injection point (i.e. the constructor/setter argument or autowired field) as <code>ObjectFactory&lt;MyTargetBean&gt;</code>, allowing for a <code>getObject()</code> call to retrieve the current instance on demand every time it is needed - without holding on to the instance or storing it separately.</p>
<p>The JSR-330 variant of this is called <code>Provider</code>, used with a <code>Provider&lt;MyTargetBean&gt;</code> declaration and a corresponding <code>get()</code> call for every retrieval attempt. See here for more details on JSR-330 overall.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>你也可以在作用域为<code>singleton</code>的beans之间使用<code>&lt;aop:scoped-proxy/&gt;</code>，将通过中间代理的引用进行序列化，因此能通过反序列化重新获得目标的单例bean。</p>
<p>当将作用域为<code>prototype</code>的bean声明为<code>&lt;aop:scoped-proxy/&gt;</code>时，每个在共享代理上的方法调用会引起一个新目标实例（调用朝向的）的创建。</p>
<p>通过生命周期安全的方式访问更短的作用域中beans，作用域代理也不是唯一的方式。你也可以简单的声明你的注入点（例如，构造函数/setter参数或自动装配领域）为<code>ObjectFactory&lt;MyTargetBean&gt;</code>，考虑到每次需要的时候通过<code>getObject()</code>调用来取得索要的当前实例——没有分别控制实例或储存它。</p>
<p>JSR-300变量被称作<code>Provider</code>，对于每一次取回尝试使用<code>Provider&lt;MyTargetBean&gt;</code>声明和对应的<code>get()</code>调用。关于JSR-330整体的更多细节请看<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#beans-standard-annotations" target="_blank" rel="external">这儿</a>。</p>
</blockquote>
<p>The configuration in the following example is only one line, but it is important to understand the “why” as well as the “how” behind it.</p>
<p>下面例子中的配置只有一行，但对于理解它背后的”why”和”how”是重要的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/aop</div><div class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleUserService"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>To create such a proxy, you insert a child <code>&lt;aop:scoped-proxy/&gt;</code> element into a scoped bean definition (see the section called “Choosing the type of proxy to create” and Chapter 38, XML Schema-based configuration). Why do definitions of beans scoped at the <code>request</code>, <code>session</code> and custom-scope levels require the <code>&lt;aop:scoped-proxy/&gt;</code> element? Let’s examine the following singleton bean definition and contrast it with what you need to define for the aforementioned scopes (note that the following <code>userPreferences</code> bean definition as it stands is incomplete).</p>
<p>为了创建这样一个代理，你插入一个子元素<code>&lt;aop:scoped-proxy/&gt;</code>到具有作用域的bean定义中（看”选择创建的代理类型”小节和38章，基于XML Schema的配置）。为什么bean定义的作用域为<code>request</code>，<code>session</code>和定制作用域级别需要<code>&lt;aop:scoped-proxy/&gt;</code>元素？让我们检查下面的单例bean定义，并将它与你需要定义的前面提到的作用域进行比较（注意下面的<code>userPreferences</code> bean定义按目前情况是不完全的）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>In the preceding example, the singleton bean <code>userManager</code> is injected with a reference to the HTTP <code>Session</code>-scoped bean <code>userPreferences</code>. The salient point here is that the <code>userManager</code> bean is a singleton: it will be instantiated exactly once per container, and its dependencies (in this case only one, the <code>userPreferences</code> bean) are also injected only once. This means that the <code>userManager</code> bean will only operate on the exact same <code>userPreferences</code> object, that is, the one that it was originally injected with.</p>
<p>在上面的例子中，单例bean <code>userManager</code>通过引用被注入到具有HTTP <code>Session</code>作用域的bean <code>userPreferences</code>中。这的突出点是<code>userManager</code> bean是单例：每个容器它将确定的被实例化一次，它的依赖（在这个例子中只有一个，<code>userPreferences</code> bean）也只注入一次。这意味着<code>userManager</code> bean只能对确定的同一个<code>userPreferences</code>对象进行操作，也就是最初注入的那个对象。</p>
<p>This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived scoped bean, for example injecting an HTTP <code>Session</code>-scoped collaborating bean as a dependency into singleton bean. Rather, you need a single <code>userManager</code> object, and for the lifetime of an HTTP <code>Session</code>, you need a <code>userPreferences</code> object that is specific to said HTTP <code>Session</code>. Thus the container creates an object that exposes the exact same public interface as the <code>UserPreferences</code> class (ideally an object that is a <code>UserPreferences</code> instance) which can fetch the real <code>UserPreferences</code> object from the scoping mechanism (HTTP request, Session, etc.). The container injects this proxy object into the <code>userManager</code> bean, which is unaware that this <code>UserPreferences</code> reference is a proxy. In this example, when a <code>UserManager</code> instance invokes a method on the dependency-injected <code>UserPreferences</code> object, it actually is invoking a method on the proxy. The proxy then fetches the real <code>UserPreferences</code> object from (in this case) the HTTP <code>Session</code>, and delegates the method invocation onto the retrieved real <code>UserPreferences</code> object.</p>
<p>当将一个短期作用域的bean注入到一个长期作用域的bean中时，这不是你想要的行为，例如将一个具有HTTP <code>Session</code>作用域的协作bean作为一个依赖注入到一个单例bean中。当然，你需要一个单一的<code>userManager</code>对象，对于HTTP <code>Session</code>的生命周期，你需要一个特定的被称为HTTP <code>Session</code>的<code>userPreferences</code>对象。因此容器创建了一个与<code>UserPreferences</code>类暴露相同的公共接口的对象（理想情况下是一个<code>UserPreferences</code>实例），这个对象能从作用域机制中（HTTP request，Session等）取得真正的<code>UserPreferences</code>对象。容器将这个代理对象注入到<code>userManager</code> bean中，<code>userManager</code> bean不会意识到<code>UserPreferences</code>引用是一个代理。在这个例子中，当<code>UserManager</code>实例调用依赖注入的<code>UserPreferences</code>对象的方法时，它实际上调用的是代理中的一个方法。代理能从HTTP <code>Session</code>中（在这个例子）取得真正的<code>UserPreferences</code>对象，将方法调用委托到取得的真正的<code>UserPreferences</code>对象上。</p>
<p>Thus you need the following, correct and complete, configuration when injecting request- and session-scoped beans into collaborating objects:</p>
<p>因此当注入具有request或session作用域的bean到协作对象中时，你需要下面的，正确的，完整的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>Choosing the type of proxy to create</strong></p>
<p>By default, when the Spring container creates a proxy for a bean that is marked up with the <code>&lt;aop:scoped-proxy/&gt;</code> element, a CGLIB-based class proxy is created.</p>
<p>当Spring容器为具有<code>&lt;aop:scoped-proxy/&gt;</code>标记的bean创建代理时，默认情况下，创建一个基于CGLIB的类代理。</p>
<blockquote>
<p>CGLIB proxies only intercept public method calls! Do not call non-public methods on such a proxy; they will not be delegated to the actual scoped target object.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>CGLIB代理只拦截公有方法调用。在这个代理上不调用非公有方法；它们不能委托给实际作用域目标对象。</p>
</blockquote>
<p>Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying <code>false</code> for the value of the <code>proxy-target-class</code> attribute of the <code>&lt;aop:scoped-proxy/&gt;</code> element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to effect such proxying. However, it also means that the class of the scoped bean must implement at least one interface, and that all collaborators into which the scoped bean is injected must reference the bean through one of its interfaces.</p>
<p>作为一种选择，对于这种具有作用域的bean你可以配置Spring容器创建标准JDK基于接口的代理，通过指定<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code>特定的值为<code>false</code>。使用JDK基于接口的代理意味着在你应用程序类路径中你不需要额外的库来支持这种代理的使用。然而，它也意味着具有作用域的bean的类必须实现至少一个接口，并且注入这个bean的所有协作者必须通过它接口中的一个来引用它。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultUserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>For more detailed information about choosing class-based or interface-based proxying, see Section 7.6, “Proxying mechanisms”.</p>
<p>关于选择基于类或基于接口代理的更多细节信心，请看7.6小节，”代理机制”。</p>
<h3 id="3-5-5-Custom-scopes"><a href="#3-5-5-Custom-scopes" class="headerlink" title="3.5.5 Custom scopes"></a>3.5.5 Custom scopes</h3><p>The bean scoping mechanism is extensible; You can define your own scopes, or even redefine existing scopes, although the latter is considered bad practice and you cannot override the built-in <code>singleton</code> and <code>prototype</code> scopes.</p>
<p>bean作用域机制是可扩展的；你可以定义你自己的作用域，甚至重新定义现有的作用域，虽然后者被认为是一种不好的实践，你不能覆盖内置的<code>singleton</code>作用域和<code>prototype</code>作用域。</p>
<p><strong>Creating a custom scope</strong></p>
<p>To integrate your custom scope(s) into the Spring container, you need to implement the <code>org.springframework.beans.factory.config.Scope</code> interface, which is described in this section. For an idea of how to implement your own scopes, see the <code>Scope</code> implementations that are supplied with the Spring Framework itself and the <code>Scope</code> javadocs, which explains the methods you need to implement in more detail.</p>
<p>为了将你的定制作用域集成到Spring容器中，你需要实现<code>org.springframework.beans.factory.config.Scope</code>接口，这一节将描述这个接口。对于怎样实现你自己作用域的想法，请看Spring框架本身提供的<code>Scope</code>实现和<code>Scope</code>文档，它们解释了你需要实现的方法的更多细节。</p>
<p>The <code>Scope</code> interface has four methods to get objects from the scope, remove them from the scope, and allow them to be destroyed.</p>
<p><code>Scope</code>接口有四个方法，从作用域中取得对象，从作用域中移除对象，并且允许它们被销毁。</p>
<p>The following method returns the object from the underlying scope. The session scope implementation, for example, returns the session-scoped bean (and if it does not exist, the method returns a new instance of the bean, after having bound it to the session for future reference).</p>
<p>下面的方法从潜在的作用域返回对象。以session作用域实现为例，返回具有session作用域的bean（如果它不存在，这个方法返回一个bean的新实例，然后绑定到session中准备将来引用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span></div></pre></td></tr></table></figure>
<p>The following method removes the object from the underlying scope. The session scope implementation for example, removes the session-scoped bean from the underlying session. The object should be returned, but you can return null if the object with the specified name is not found.</p>
<p>下面的方法从潜在作用域中移除对象。以session作用域实现为例，从潜在的session中移除session作用域的bean。对象应该被返回，但如果没有找到指定名字的对象会返回空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span></div></pre></td></tr></table></figure>
<p>The following method registers the callbacks the scope should execute when it is destroyed or when the specified object in the scope is destroyed. Refer to the javadocs or a Spring scope implementation for more information on destruction callbacks.</p>
<p>下面的方法是注册当作用域销毁时或当作用域中的指定对象销毁时，作用域应该执行的回调函数。销毁回调函数的更多信息请看文档或Spring作用域实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable destructionCallback)</span></span></div></pre></td></tr></table></figure>
<p>The following method obtains the conversation identifier for the underlying scope. This identifier is different for each scope. For a session scoped implementation, this identifier can be the session identifier.</p>
<p>下面的方法是获得潜在作用域的会话标识符。每个作用域的标识符都是不同的。对于session作用域实现，标识符是session标识符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p><strong>Using a custom scope</strong></p>
<p>After you write and test one or more custom <code>Scope</code> implementations, you need to make the Spring container aware of your new scope(s). The following method is the central method to register a new <code>Scope</code> with the Spring container:</p>
<p>在你编写和测试一个或多个定制<code>Scope</code>实现之后，你需要让Spring容器感知到你的新作用域。下面是在Spring容器中注册一个新<code>Scope</code>的主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerScope</span><span class="params">(String scopeName, Scope scope)</span></span>;</div></pre></td></tr></table></figure>
<p>This method is declared on the <code>ConfigurableBeanFactory</code> interface, which is available on most of the concrete <code>ApplicationContext</code> implementations that ship with Spring via the <code>BeanFactory</code> property.</p>
<p>这个方法是在<code>ConfigurableBeanFactory</code>接口中声明的，在大多数具体的<code>ApplicationContext</code>实现中都可获得，在Spring中通过<code>BeanFactory</code>属性得到。</p>
<p>The first argument to the <code>registerScope(..)</code> method is the unique name associated with a scope; examples of such names in the Spring container itself are <code>singleton</code> and <code>prototype</code>. The second argument to the <code>registerScope(..)</code> method is an actual instance of the custom <code>Scope</code> implementation that you wish to register and use.</p>
<p><code>registerScope(..)</code>方法中的第一个参数是关于作用域的唯一名字；Spring容器本身中的这种名字的例子是<code>singleton</code>和<code>prototype</code>。<code>registerScope(..)</code>方法中的第二个参数是你想注册和使用的定制<code>Scope</code>实现的真正实例。</p>
<p>Suppose that you write your custom <code>Scope</code> implementation, and then register it as below.</p>
<p>假设你编写了你的定制<code>Scope</code>实现并按如下注册。</p>
<blockquote>
<p>The example below uses <code>SimpleThreadScope</code> which is included with Spring, but not registered by default. The instructions would be the same for your own custom <code>Scope</code> implementations.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>下面的例子使用Spring包含的<code>SimpleThreadScope</code>，但默认是不注册的。这个用法说明与你自己的定制<code>Scope</code>是一样的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scope threadScope = <span class="keyword">new</span> SimpleThreadScope();</div><div class="line">beanFactory.registerScope(<span class="string">"thread"</span>, threadScope);</div></pre></td></tr></table></figure>
<p>You then create bean definitions that adhere to the scoping rules of your custom <code>Scope</code>:</p>
<p>然后创建具有你自己定制的<code>Scope</code>规则的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>With a custom <code>Scope</code> implementation, you are not limited to programmatic registration of the scope. You can also do the <code>Scope</code> registration declaratively, using the <code>CustomScopeConfigurer</code> class:</p>
<p>在定制<code>Scope</code>实现后，你不会受限于作用域的程序注册。你也可以声明式的进行<code>Scope</code>注册，使用<code>CustomScopeConfigurer</code>类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/aop</div><div class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"thread"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.SimpleThreadScope"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Rick"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>When you place <code>&lt;aop:scoped-proxy/&gt;</code> in a <code>FactoryBean</code> implementation, it is the factory bean itself that is scoped, not the object returned from <code>getObject()</code>.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>当你在<code>FactoryBean</code>实现中放入<code>&lt;aop:scoped-proxy/&gt;</code>时，它是工厂bean本身具有作用域，不是从<code>getObject()</code>中返回的对象。</p>
</blockquote>
<h3 id="3-6-Customizing-the-nature-of-a-bean"><a href="#3-6-Customizing-the-nature-of-a-bean" class="headerlink" title="3.6 Customizing the nature of a bean"></a>3.6 Customizing the nature of a bean</h3><h4 id="3-6-1-Lifecycle-callbacks"><a href="#3-6-1-Lifecycle-callbacks" class="headerlink" title="3.6.1 Lifecycle callbacks"></a>3.6.1 Lifecycle callbacks</h4><p>To interact with the container’s management of the bean lifecycle, you can implement the Spring <code>InitializingBean</code> and <code>DisposableBean</code> interfaces. The container calls <code>afterPropertiesSet()</code> for the former and <code>destroy()</code> for the latter to allow the bean to perform certain actions upon initialization and destruction of your beans.</p>
<p>为了与容器中bean生命周期的管理进行交互，你可以实现Spring的<code>InitializingBean</code>和<code>DisposableBean</code>接口。当初始化beans时容器会调用<code>InitializingBean</code>中的<code>afterPropertiesSet()</code>方法，当销毁beans时容器会调用<code>DisposableBean</code>中的<code>destroy()</code>方法，在这两个方法中bean可以执行特定的行为。</p>
<blockquote>
<p>The JSR-250 <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces. For details see Section 3.9.8, “@PostConstruct and @PreDestroy”.</p>
<p>If you don’t want to use the JSR-250 annotations but you are still looking to remove coupling consider the use of init-method and destroy-method object definition metadata.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在现代Spring应用中，通常认为JSR-250的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解是最佳实践接收生命周期回调函数的方法。使用这些注解意味着你的bean没有耦合Spring特定的接口。更多细节请看3.9.8小节，”@PostConstruct和@PreDestroy”。</p>
<p>如果你不想使用JSR-250注解，但你仍要注意解耦，可以考虑使用对象定义元数据中的初始化方法和方法。</p>
</blockquote>
<p>Internally, the Spring Framework uses <code>BeanPostProcessor</code> implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not offer out-of-the-box, you can implement a <code>BeanPostProcessor</code>yourself. For more information, see Section 3.8, “Container Extension Points”.</p>
<p>在Spring内部，Spring框架使用<code>BeanPostProcessor</code>实现来处理任何它能发现的回调接口并调用合适的方法。如果你需要定制Spring不能提供的开箱即用的功能或其它生命周期行为，你可以自己实现<code>BeanPostProcessor</code>。更多信息请看3.8小节，”容器扩展点”。</p>
<p>In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the <code>Lifecycle</code> interface so that those objects can participate in the startup and shutdown process as driven by the container’s own lifecycle.</p>
<p>除了初始化回调函数和析构回调函数之外，Spring管理的对象也可以实现<code>Lifecycle</code>接口，这些对象可以参与容器自身生命周期驱动的启动和关闭过程。</p>
<p>The lifecycle callback interfaces are described in this section.</p>
<p>本节描述了生命周期回调接口。</p>
<p><strong>Initialization callbacks</strong></p>
<p>The <code>org.springframework.beans.factory.InitializingBean</code> interface allows a bean to perform initialization work after all necessary properties on the bean have been set by the container. The <code>InitializingBean</code> interface specifies a single method:</p>
<p><code>org.springframework.beans.factory.InitializingBean</code>接口在容器设置了bean所有的必须属性之后，允许bean执行初始化工作。<code>InitializingBean</code>接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
<p>It is recommended that you do not use the <code>InitializingBean</code> interface because it unnecessarily couples the code to Spring. Alternatively, use the <code>@PostConstruct</code> annotation or specify a POJO initialization method. In the case of XML-based configuration metadata, you use the <code>init-method</code> attribute to specify the name of the method that has a void no-argument signature. With Java config, you use the <code>initMethod</code> attribute of <code>@Bean</code>, see the section called “Receiving lifecycle callbacks”. For example, the following:</p>
<p>建议你不使用<code>InitializingBean</code>接口，因为它对代码与Spring进行了不必要的耦合。作为一种替代方法，你可以使用<code>@PostConstruct</code>注解或指定一个POPJO的初始化方法。在基于XML配置元数据的情况下，你可以使用<code>init-method</code>特性来指定方法的名称，方法是没有返回值和参数的。如果使用Java配置，你可以使用<code>@Bean</code>的<code>initMethod</code>特性，请看”接收生命周期回调”小节。例如，下面的代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some initialization work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>…​is exactly the same as…​</p>
<p>等价于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some initialization work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>but does not couple the code to Spring.</p>
<p>但没有与Spring代码耦合。</p>
<p><strong>Destruction callbacks</strong></p>
<p>Implementing the <code>org.springframework.beans.factory.DisposableBean</code> interface allows a bean to get a callback when the container containing it is destroyed. The <code>DisposableBean</code> interface specifies a single method:</p>
<p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许容器包含的bean销毁时调用回调函数。<code>DisposableBean</code>接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
<p>It is recommended that you do not use the <code>DisposableBean</code> callback interface because it unnecessarily couples the code to Spring. Alternatively, use the <code>@PreDestroy</code> annotation or specify a generic method that is supported by bean definitions. With XML-based configuration metadata, you use the <code>destroy-method</code> attribute on the <code>&lt;bean/&gt;</code>. With Java config, you use the <code>destroyMethod</code> attribute of <code>@Bean</code>, see the section called “Receiving lifecycle callbacks”. For example, the following definition:</p>
<p>建议你不使用<code>DisposableBean</code>回调接口，因为它对代码与Spring进行了不必要的耦合。作为一种替代方法，你可以使用<code>@PreDestroy</code>注解或指定一个bean定义支持的通用方法。在基于XML配置元数据的情况下，你可以使用<code>&lt;bean/&gt;</code>的<code>destroy-method</code>特性。如果使用Java配置，你可以使用<code>@Bean</code>的<code>destroyMethod</code>特性，请看”接收生命周期回调”小节。例如，下面的定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>is exactly the same as:</p>
<p>等价于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>but does not couple the code to Spring.</p>
<p>但没有与Spring代码耦合。</p>
<blockquote>
<p>The <code>destroy-method</code> attribute of a <code>&lt;bean&gt;</code> element can be assigned a special <code>(inferred)</code> value which instructs Spring to automatically detect a public <code>close</code> or <code>shutdown</code> method on the specific bean class (any class that implements <code>java.lang.AutoCloseable</code> or <code>java.io.Closeable</code> would therefore match). This special <code>(inferred)</code> value can also be set on the <code>default-destroy-method</code> attribute of a <code>&lt;beans&gt;</code> element to apply this behavior to an entire set of beans (see the section called “Default initialization and destroy methods”). Note that this is the default behavior with Java config.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>&lt;bean&gt;</code>元素的<code>destroy-method</code>特性可以分配一个特殊值<code>(inferred)</code>，它会指导Spring自动检测指定的bean类的公有<code>close</code>方法或<code>shutdown</code>方法（可以匹配任何实现<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>的类）。为了将这种行为应用到beans的全部集合中，特殊值<code>(inferred)</code>可以设置在<code>&lt;beans&gt;</code>元素中的<code>default-destroy-method</code>特性上（请看”默认初始化方法和销毁方法”小节）。注意Java配置的默认行为。</p>
</blockquote>
<p><strong>Default initialization and destroy methods</strong></p>
<p>When you write initialization and destroy method callbacks that do not use the Spring-specific <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces, you typically write methods with names such as <code>init()</code>, <code>initialize()</code>, <code>dispose()</code>, and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.</p>
<p>当你编写初始化回调函数和析构回调函数时，不要使用Spring特定的<code>InitializingBean</code>和<code>DisposableBean</code>回调接口，自己编写方法，方法名通常为<code>init()</code>，<code>initialize()</code>，<code>dispose()</code>等等。理想情况下，这种生命周期回调方法的名称在整个工程中是标准化的，以便所有开发人员使用同样的方法名称，保证一致性。</p>
<p>You can configure the Spring container to <code>look</code> for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called <code>init()</code>, without having to configure an <code>init-method=&quot;init&quot;</code> attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.</p>
<p>你可以配置Spring容器查找每个bean的初始化方法和析构方法时的名字。这意味着，作为一个应用开发者，你可以编写应用程序类并使用名为<code>init()</code>的初始化回调方法，而不必在每个bean定义中配置<code>init-method=&quot;init&quot;</code>特性。当bean创建时，Spring Ioc容器调用这个方法（按照前面描述的标准生命周期回调约定）。这个功能也强制了初始化方法和析构方法命名规范的一致性。</p>
<p>Suppose that your initialization callback methods are named <code>init()</code> and destroy callback methods are named <code>destroy()</code>. Your class will resemble the class in the following example.</p>
<p>假设你的初始化回调方法名为<code>init()</code>，析构回调方法名为<code>destroy()</code>。你的类应该与下面例子中的类类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title">BlogService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BlogDao blogDao;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blogDao = blogDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// this is (unsurprisingly) the initialization callback method</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultBlogService"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The presence of the <code>default-init-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element attribute causes the Spring IoC container to recognize a method called <code>init</code> on beans as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.</p>
<p>位于顶层<code>&lt;beans/&gt;</code>元素中的<code>default-init-method</code>特性，会让Spring IoC容器将beans中的名为<code>init</code>的方法识别为初始化回调方法。当一个bean创建和组装时，如果bean类有这样一个方法，它会在恰当的时间被调用。</p>
<p>You configure destroy method callbacks similarly (in XML, that is) by using the <code>default-destroy-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element.</p>
<p>类似的，你可以在顶层元素<code>&lt;beans/&gt;</code>中设置<code>default-destroy-method</code>特性来配置析构回调方法的名字。</p>
<p>Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name using the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean/&gt;</code> itself.</p>
<p>在现有的bean类已经有不符合命名规范的回调方法的情况下，你也可以通过在<code>&lt;bean/&gt;</code>本身的<code>init-method</code>和<code>destroy-method</code>特性（在XML中）中指定方法名称来覆盖<code>&lt;beans/&gt;</code>中的默认名称。</p>
<p>The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created first, then an AOP proxy (for example) with its interceptor chain is applied. If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the init method, because doing so would couple the lifecycle of the target bean with its proxy/interceptors and leave strange semantics when your code interacts directly to the raw target bean.</p>
<p>在bean被提供了所有依赖之后，Spring容器确保会立刻调用配置的初始化回调方法。因此初始化回调会在原生bean引用上调用，这意味着AOP拦截器等仍不能应用到bean中。首先要完整的创建目标bean，然后才会应用AOP代理（例如）等拦截器链。如果分别定义了目标bean和代理，你的代码甚至能绕过代理直接与原生的目标bean进行交互。将拦截器应用到初始化方法上可能会产生不一致性，因为这样做会使目标bean的生命周期与它的代理/拦截器相耦合，当你的代码与原生目标bean直接进行交互时，语义会变的很奇怪。</p>
<p><strong>Combining lifecycle mechanisms</strong></p>
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior: the <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces; custom <code>init()</code> and <code>destroy()</code> methods; and the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations. You can combine these mechanisms to control a given bean.</p>
<p>从Spring 2.5开始，在控制bean的生命周期行为时，你有三中选择：InitializingBean<code>和</code>DisposableBean<code>回调接口；定制</code>init()<code>和</code>destroy()<code>方法；</code>@PostConstruct<code>和</code>@PreDestroy`注解。在控制一个给定bean时你可以组合这些机制。</p>
<blockquote>
<p>If multiple lifecycle mechanisms are configured for a bean, and each mechanism is configured with a different method name, then each configured method is executed in the order listed below. However, if the same method name is configured - for example, <code>init()</code> for an initialization method - for more than one of these lifecycle mechanisms, that method is executed once, as explained in the preceding section.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>如果一个bean配置了多生命周期机制，每种机制配置了一个不同的方法名，那么每一个配置的方法会按照下面的顺序列表来执行。但是如果配置了相同的名字——例如，<code>init()</code>初始化方法——不止在一个生命周期机制中配置，那么这个方法只能执行一次，像之前所说的那样。</p>
</blockquote>
<p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:</p>
<ul>
<li><p>Methods annotated with <code>@PostConstruct</code></p>
</li>
<li><p><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</p>
</li>
<li><p>A custom configured <code>init()</code> method</p>
</li>
</ul>
<p>同一个bean配置了多生命周期机制，并有不同的初始化方法，那么调用顺序如下：</p>
<ul>
<li><p>先调用有注解<code>@PostConstruct</code>的方法</p>
</li>
<li><p>然后调用<code>InitializingBean</code>回调接口定义的<code>afterPropertiesSet()</code>方法</p>
</li>
<li><p>最好调用定制配置的<code>init()</code>方法</p>
</li>
</ul>
<p>Destroy methods are called in the same order:</p>
<ul>
<li><p>Methods annotated with <code>@PreDestroy</code></p>
</li>
<li><p><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</p>
</li>
<li><p>A custom configured <code>destroy()</code> method</p>
</li>
</ul>
<p>析构方法按同样的顺序调用：</p>
<ul>
<li><p>先调用有<code>@PreDestroy</code>注解的方法</p>
</li>
<li><p>再调用<code>DisposableBean</code>回调接口定义的<code>destroy()</code>方法</p>
</li>
<li><p>最好调用定制配置的<code>destroy()</code>方法</p>
</li>
</ul>
<p><strong>Startup and shutdown callbacks</strong></p>
<p>The <code>Lifecycle</code> interface defines the essential methods for any object that has its own lifecycle requirements (e.g. starts and stops some background process):</p>
<p><code>Lifecycle</code>接口定义了任何对象生命周期都需要的基本方法（例如启动和停止一些背景处理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Any Spring-managed object may implement that interface. Then, when the <code>ApplicationContext</code> itself receives start and stop signals, e.g. for a stop/restart scenario at runtime, it will cascade those calls to all <code>Lifecycle</code> implementations defined within that context. It does this by delegating to a <code>LifecycleProcessor</code>:</p>
<p>任何Spring管理的对象都可以实现那个接口。当<code>ApplicationContext</code>本身收到启动启动和关闭信号时，例如运行时关闭/再启动场景，它将级联调用所有的上下文定义的<code>Lifecycle</code>实现。它通过委托<code>LifecycleProcessor</code>来完成这个功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Notice that the <code>LifecycleProcessor</code> is itself an extension of the <code>Lifecycle</code> interface. It also adds two other methods for reacting to the context being refreshed and closed.</p>
<p>注意<code>LifecycleProcessor</code>本身是<code>Lifecycle</code>接口的一个扩展。它也添加了两个其它的方法来响应上下文的再刷新和关闭的。</p>
<blockquote>
<p>Note that the regular <code>org.springframework.context.Lifecycle</code> interface is just a plain contract for explicit start/stop notifications and does NOT imply auto-startup at context refresh time. Consider implementing <code>org.springframework.context.SmartLifecycle</code> instead for fine-grained control over auto-startup of a specific bean (including startup phases). Also, please note that stop notifications are not guaranteed to come before destruction: On regular shutdown, all <code>Lifecycle</code> beans will first receive a stop notification before the general destruction callbacks are being propagated; however, on hot refresh during a context’s lifetime or on aborted refresh attempts, only destroy methods will be called.</p>
<p>注意正规的<code>org.springframework.context.Lifecycle</code>接口只是一个显式启动/关闭通知的协议，并不意味着在上下文刷新时自动启动。考虑实现<code>org.springframework.context.SmartLifecycle</code>接口来实现对指定bean自动启动的细粒度控制（包括启动时期）。请注意停止通知不能保证在销毁之前到来：在正式关闭时，所有的<code>Lifecycle</code> beans在通常的析构回调传播之前首先会收到停止通知；但是，在上下文使用期间进行热刷新或尝试取消再刷新，只会调用析构方法。</p>
</blockquote>
<p>The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side will start after its dependency, and it will stop before its dependency. However, at times the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the <code>SmartLifecycle</code> interface defines another option, namely the <code>getPhase()</code> method as defined on its super-interface, <code>Phased</code>.</p>
<p>启动和关闭的调用顺序是很重要的。如果任何两个对象间存在一个”depends-on”关系，那么依赖关系将在它的依赖之后开始，在它的依赖之前停止。然而有时直接的依赖关系是未知的。你可能只知道某个类型的对象应该在另一个类型的对象之前启动。在那种情况下，<code>SmartLifecycle</code>接口定义了另一种选择，也就是说<code>getPhase()</code>定义在它的父接口<code>Phased</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When starting, the objects with the lowest phase start first, and when stopping, the reverse order is followed. Therefore, an object that implements <code>SmartLifecycle</code> and whose <code>getPhase()</code> method returns <code>Integer.MIN_VALUE</code> would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of <code>Integer.MAX_VALUE</code> would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it’s also important to know that the default phase for any “normal” <code>Lifecycle</code> object that does not implement <code>SmartLifecycle</code> would be 0. Therefore, any negative phase value would indicate that an object should start before those standard components (and stop after them), and vice versa for any positive phase value.</p>
<p>当开始时，最低相位的对象先启动，当停止时，最高相位的对象先停止。因此，实现了<code>SmartLifecycle</code>接口，<code>getPhase()</code>方法返回值为<code>Integer.MIN_VALUE</code>的对象将最先启动并最后停止。另一方面，相位值<code>Integer.MAX_VALUE</code>表明对象应该最后启动，最先停止（可能是因为它依赖其它运行的进程）。当考虑相位值时，知道任何没有实现<code>SmartLifecycle</code>接口的<code>Lifecycle</code>对象的默认值为0是很重要的。因此，任何负相位值表示对象应该在那么标准组件之前启动（在它们之后停止），反之为任何正相位值。</p>
<p>As you can see the stop method defined by <code>SmartLifecycle</code> accepts a callback. Any implementation must invoke that callback’s <code>run()</code> method after that implementation’s shutdown process is complete. That enables asynchronous shutdown where necessary since the default implementation of the <code>LifecycleProcessor</code> interface, <code>DefaultLifecycleProcessor</code>, will wait up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named “lifecycleProcessor” within the context. If you only want to modify the timeout, then defining the following would be sufficient:</p>
<p>正如你看到的，在<code>SmartLifecycle</code>中定义的停止方法接收一个回调函数。任何实现在关闭进程完成之后都必须调用回调的<code>run()</code>方法。当需要时这可以进行异步关闭，因为<code>LifecycleProcessor</code>接口、<code>DefaultLifecycleProcessor</code>接口的默认实现会等待每个阶段的对象组直到达到超时值，然后调用回调函数。默认每个时期的超时值为30秒。你可以在上下文中通过定义名为”lifecycleProcessor”的bean来覆盖默认的生命周期处理器实例。如果你只想修改超时值，如下定义是足够的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>As mentioned, the <code>LifecycleProcessor</code> interface defines callback methods for the refreshing and closing of the context as well. The latter will simply drive the shutdown process as if <code>stop()</code> had been called explicitly, but it will happen when the context is closing. The <code>refresh</code> callback on the other hand enables another feature of <code>SmartLifecycle</code> beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback will be invoked, and at that point the default lifecycle processor will check the boolean value returned by each <code>SmartLifecycle</code> object’s <code>isAutoStartup()</code> method. If “true”, then that object will be started at that point rather than waiting for an explicit invocation of the context’s or its own <code>start()</code> method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The “phase” value as well as any “depends-on” relationships will determine the startup order in the same way as described above.</p>
<p>像上面提到的那样，<code>LifecycleProcessor</code>接口为再刷新和上下文的关闭也定义了回调方法。后者会简单的驱动关闭进程就像显式的调用了<code>stop()</code>方法一样，但当上下文关闭时它才会发生。另一方面<code>refresh</code>回调能使<code>SmartLifecycle</code> beans的另一个功能可用。当上下文再刷新时（所有对象已经实例化并初始化），回调函数将被调用，那时默认的生命周期处理器将会检查每个<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法返回的布尔值。如果为<code>true</code>，对象将会在那时启动而不是等待上下文的显式调用或它自己的<code>start()</code>方法（不像上下文再刷新，对于一个标准的上下文实现上下启动不会自动发生）。”phase”值以及”depends-on”关系将决定启动顺序，像上面描述的一样。</p>
<p><strong>Shutting down the Spring IoC container gracefully in non-web applications</strong></p>
<blockquote>
<p>This section applies only to non-web applications. Spring’s web-based <code>ApplicationContext</code> implementations already have code in place to shut down the Spring IoC container gracefully when the relevant web application is shut down.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>这一节只应用于非web应用。Spring的基于web的<code>ApplicationContext</code>实现已经有代码来处理当相关的web应用关闭时，妥善关闭Spring IoC容器的问题。</p>
</blockquote>
<p>If you are using Spring’s IoC container in a non-web application environment; for example, in a rich client desktop environment; you register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. Of course, you must still configure and implement these destroy callbacks correctly.</p>
<p>如果你在非web应用环境使用Spring的IoC容器；例如，在一个富桌面客户端环境中，你在JVM中注册一个关闭钩子。这样做确保了妥善的关闭，为了释放所有资源需要调用与单例beans相关的析构方法。当然，你仍然必须正确的配置和实现这些销毁回调函数。</p>
<p>To register a shutdown hook, you call the <code>registerShutdownHook()</code> method that is declared on the <code>ConfigurableApplicationContext</code> interface:</p>
<p>为了注册一个关闭钩子，你可以调用<code>ConfigurableApplicationContext</code>接口中声明的<code>registerShutdownHook()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(</div><div class="line">                <span class="keyword">new</span> String []&#123;<span class="string">"beans.xml"</span>&#125;);</div><div class="line"></div><div class="line">        <span class="comment">// add a shutdown hook for the above context...</span></div><div class="line">        ctx.registerShutdownHook();</div><div class="line"></div><div class="line">        <span class="comment">// app runs here...</span></div><div class="line"></div><div class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-6-2-ApplicationContextAware-and-BeanNameAware"><a href="#3-6-2-ApplicationContextAware-and-BeanNameAware" class="headerlink" title="3.6.2 ApplicationContextAware and BeanNameAware"></a>3.6.2 ApplicationContextAware and BeanNameAware</h4><p>When an <code>ApplicationContext</code> creates an object instance that implements the <code>org.springframework.context.ApplicationContextAware</code> interface, the instance is provided with a reference to that <code>ApplicationContext</code>.</p>
<p>当<code>ApplicationContext</code>创建一个实现<code>org.springframework.context.ApplicationContextAware</code>接口的对象实例时，这个实例会提供一个<code>ApplicationContext</code>的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Thus beans can manipulate programmatically the <code>ApplicationContext</code> that created them, through the <code>ApplicationContext</code> interface, or by casting the reference to a known subclass of this interface, such as <code>ConfigurableApplicationContext</code>, which exposes additional functionality. One use would be the programmatic retrieval of other beans. Sometimes this capability is useful; however, in general you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties. Other methods of the <code>ApplicationContext</code> provide access to file resources, publishing application events, and accessing a <code>MessageSource</code>. These additional features are described in Section 3.15, “Additional Capabilities of the ApplicationContext”.</p>
<p>因此beans可以以编程方式操纵创建它们的<code>ApplicationContext</code>，通过<code>ApplicationContext</code>接口，或通过将引用抛给这个接口的一个已知子类，例如<code>ConfigurableApplicationContext</code>，它暴露了额外的功能。一个方法是编程式检索其他的bean。有时这个能力是很有用的，但是通常你应该避免使用它，因为它耦合了代码和Spring，不能遵循控制反转的风格，在控制反转中协作者是作为属性提供给beans的。<code>ApplicationContext</code>的其它方法提供了对文件资源的访问，发布应用事件，访问<code>MessageSource</code>的功能。这些额外的特性将在3.15小节『ApplicationContext”的额外能力』中描述。</p>
<p>As of Spring 2.5, autowiring is another alternative to obtain reference to the <code>ApplicationContext</code>. The “traditional” <code>constructor</code> and <code>byType</code>autowiring modes (as described in Section 3.4.5, “Autowiring collaborators”) can provide a dependency of type <code>ApplicationContext</code> for a constructor argument or setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the new annotation-based autowiring features. If you do, the <code>ApplicationContext</code> is autowired into a field, constructor argument, or method parameter that is expecting the <code>ApplicationContext</code> type if the field, constructor, or method in question carries the <code>@Autowired</code> annotation. For more information, see Section 3.9.2, “@Autowired”.</p>
<p>从Spring 2.5起，自动装配是另一种可替代的获得<code>ApplicationContext</code>引用的方法。『传统的』<code>constructor</code>和<code>byType</code>自动装配模式（如3.4.5小节所述，『自动装配协作者』）可以分别为构造函数参数或setter方法参数提供<code>ApplicationContext</code>类型的依赖。更多的灵活性包括自动装配变量的能力和多参数方法，使用新的基于注解的自动装配特性。如果你这一做的话，<code>ApplicationContext</code>可以被自动装配到变量中，构造函数参数中或方法参数中，如果讨论的变量，构造函数或方法有<code>@Autowired</code>注解，那么可以期望它是<code>ApplicationContext</code>类型。更多信息请看3.9.2小节，<code>@autowired</code>。</p>
<p>When an <code>ApplicationContext</code> creates a class that implements the <code>org.springframework.beans.factory.BeanNameAware</code> interface, the class is provided with a reference to the name defined in its associated object definition.</p>
<p>当<code>ApplicationContext</code>创建一个实现了<code>org.springframework.beans.factory.BeanNameAware</code>接口的类时，类中有相关的对象定义中定义的名称的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface BeanNameAware &#123;</div><div class="line"></div><div class="line">    void setBeanName(String name) throws BeansException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The callback is invoked after population of normal bean properties but before an initialization callback such as <code>InitializingBean</code> afterPropertiesSet or a custom init-method.</p>
<p>在正常的bean属性填入之后，回调方法调用，但在初始化回调方法之前，例如<code>InitializingBean</code>的afterPropertiesSet或一个定制的初始化方法。</p>
<h4 id="3-6-3-Other-Aware-interfaces"><a href="#3-6-3-Other-Aware-interfaces" class="headerlink" title="3.6.3 Other Aware interfaces"></a>3.6.3 Other Aware interfaces</h4><p>Besides <code>ApplicationContextAware</code> and <code>BeanNameAware</code> discussed above, Spring offers a range of <code>Aware</code> interfaces that allow beans to indicate to the container that they require a certain infrastructure dependency. The most important <code>Aware</code> interfaces are summarized below - as a general rule, the name is a good indication of the dependency type:</p>
<p>除了上面讨论的<code>ApplicationContextAware</code>和<code>BeanNameAware</code>之外，Spring给予了一系列<code>Aware</code>接口来允许beans向容器表明它们需要一个确定的基础结构依赖。最重要的<code>Aware</code>接口总结如下——作为一个通用规则，名字是依赖类型的一个很好暗示：</p>
<p><strong>Table 3.4. Aware interfaces</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Injected Dependency</th>
<th style="text-align:left">Explained in</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ApplicationContextAware</td>
<td style="text-align:left">Declaring ApplicationContext</td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">ApplicationEventPublisherAware</td>
<td style="text-align:left">Event publisher of the enclosing ApplicationContext</td>
<td style="text-align:left">Section 3.15, “Additional Capabilities of the ApplicationContext”</td>
</tr>
<tr>
<td style="text-align:left">BeanClassLoaderAware</td>
<td style="text-align:left">Class loader used to load the bean classes.</td>
<td style="text-align:left">Section 3.3.2, “Instantiating beans”</td>
</tr>
<tr>
<td style="text-align:left">BeanFactoryAware</td>
<td style="text-align:left">Declaring BeanFactory</td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">BeanNameAware</td>
<td style="text-align:left">Name of the declaring bean</td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">BootstrapContextAware</td>
<td style="text-align:left">Resource adapter BootstrapContext the container runs in. Typically available only in JCA aware ApplicationContexts</td>
<td style="text-align:left">Chapter 28, JCA CCI</td>
</tr>
<tr>
<td style="text-align:left">LoadTimeWeaverAware</td>
<td style="text-align:left">Defined weaver for processing class definition at load time</td>
<td style="text-align:left">Section 7.8.4, “Load-time weaving with AspectJ in the Spring Framework”</td>
</tr>
<tr>
<td style="text-align:left">MessageSourceAware</td>
<td style="text-align:left">Configured strategy for resolving messages (with support for parametrization and internationalization)</td>
<td style="text-align:left">Section 3.15, “Additional Capabilities of the ApplicationContext”</td>
</tr>
<tr>
<td style="text-align:left">NotificationPublisherAware</td>
<td style="text-align:left">Spring JMX notification publisher</td>
<td style="text-align:left">Section 27.7, “Notifications”</td>
</tr>
<tr>
<td style="text-align:left">ResourceLoaderAware</td>
<td style="text-align:left">Configured loader for low-level access to resources</td>
<td style="text-align:left">Chapter 4, Resources</td>
</tr>
<tr>
<td style="text-align:left">ServletConfigAware</td>
<td style="text-align:left">Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext</td>
<td style="text-align:left">Chapter 18, Web MVC framework</td>
</tr>
<tr>
<td style="text-align:left">ServletContextAware</td>
<td style="text-align:left">Current ServletContext the container runs in. Valid only in a web-aware Spring ApplicationContext</td>
<td style="text-align:left">Chapter 18, Web MVC framework</td>
</tr>
</tbody>
</table>
<p><strong>表3.4. Aware接口</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Injected Dependency</th>
<th style="text-align:left">Explained in</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ApplicationContextAware</td>
<td style="text-align:left">声明<code>ApplicationContext</code></td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">ApplicationEventPublisherAware</td>
<td style="text-align:left">封装事件发布的<code>ApplicationContext</code></td>
<td style="text-align:left">Section 3.15, “Additional Capabilities of the ApplicationContext”</td>
</tr>
<tr>
<td style="text-align:left">BeanClassLoaderAware</td>
<td style="text-align:left">用来加载bean的类加载器</td>
<td style="text-align:left">Section 3.3.2, “Instantiating beans”</td>
</tr>
<tr>
<td style="text-align:left">BeanFactoryAware</td>
<td style="text-align:left">声明<code>BeanFactory</code></td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">BeanNameAware</td>
<td style="text-align:left">声明的bean的名字</td>
<td style="text-align:left">Section 3.6.2, “ApplicationContextAware and BeanNameAware”</td>
</tr>
<tr>
<td style="text-align:left">BootstrapContextAware</td>
<td style="text-align:left">容器运行的资源自适应<code>BootstrapContext</code>. 通常只在JCA aware <code>ApplicationContexts</code>可获得</td>
<td style="text-align:left">Chapter 28, JCA CCI</td>
</tr>
<tr>
<td style="text-align:left">LoadTimeWeaverAware</td>
<td style="text-align:left">加载时为处理类定义定义的weaver</td>
<td style="text-align:left">Section 7.8.4, “Load-time weaving with AspectJ in the Spring Framework”</td>
</tr>
<tr>
<td style="text-align:left">MessageSourceAware</td>
<td style="text-align:left">解析消息配置策略 (支持参数化和国际化)</td>
<td style="text-align:left">Section 3.15, “Additional Capabilities of the ApplicationContext”</td>
</tr>
<tr>
<td style="text-align:left">NotificationPublisherAware</td>
<td style="text-align:left">Spring JMX通知发布器</td>
<td style="text-align:left">Section 27.7, “Notifications”</td>
</tr>
<tr>
<td style="text-align:left">ResourceLoaderAware</td>
<td style="text-align:left">为底层访问资源配置的加载器</td>
<td style="text-align:left">Chapter 4, Resources</td>
</tr>
<tr>
<td style="text-align:left">ServletConfigAware</td>
<td style="text-align:left">容器运行的当前<code>ServletConfig</code>。 仅在web感知的Spring <code>ApplicationContext</code>中有效</td>
<td style="text-align:left">Chapter 18, Web MVC framework</td>
</tr>
<tr>
<td style="text-align:left">ServletContextAware</td>
<td style="text-align:left">容器运行的当前<code>ServletContext</code>。 仅在web感知的Spring <code>ApplicationContext</code>中有效</td>
<td style="text-align:left">Chapter 18, Web MVC framework</td>
</tr>
</tbody>
</table>
<p>Note again that usage of these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As such, they are recommended for infrastructure beans that require programmatic access to the container.</p>
<p>注意这些接口的用法将你的代码与Spring进行了捆绑，不符合控制反转的风格。因此，它们是为那么需要以编程方式访问容器的基础结构beans推荐的。</p>
<h3 id="3-7-Bean-definition-inheritance"><a href="#3-7-Bean-definition-inheritance" class="headerlink" title="3.7 Bean definition inheritance"></a>3.7 Bean definition inheritance</h3><p>A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information such as initialization method, static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.</p>
<p>Bean定义中可以包含许多配置信息，包括构造函数参数，属性值和容器的特定信息例如初始化方法，静态工厂方法名等等。子定义继承父定义的配置信息。子定义可以覆盖一些值，或按需要添加一些其它值。使用父子bean定义可以保存许多类型。实际上，这是一种模板形式。</p>
<p>If you work with an <code>ApplicationContext</code> interface programmatically, child bean definitions are represented by the <code>ChildBeanDefinition</code> class. Most users do not work with them on this level, instead configuring bean definitions declaratively in something like the <code>ClassPathXmlApplicationContext</code>. When you use XML-based configuration metadata, you indicate a child bean definition by using the <code>parent</code> attribute, specifying the parent bean as the value of this attribute.</p>
<p>如果你以编程方式使用<code>ApplicationContext</code>接口，那么子bean定义是通过<code>ChildBeanDefinition</code>定义来表示的。大多数用户不在这个层级上使用它们，而是在一些像<code>ClassPathXmlApplicationContext</code>中声明式的配置bean定义。当你使用基于XML的配置元数据时，你可以使用<code>parent</code>特性来指明一个子bean定义。在特性值中指定父bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>A child bean definition uses the bean class from the parent definition if none is specified, but can also override it. In the latter case, the child bean class must be compatible with the parent, that is, it must accept the parent’s property values.</p>
<p>如果子bean定义中没有指定要使用的bean类，则使用父定义中的bean类，但也可以覆盖它。在后一种情况下（没有指定要用的bean类），子bean定义必须与父bean协作，也就是说，它必须接收父定义的属性值。</p>
<p>A child bean definition inherits scope, constructor argument values, property values, and method overrides from the parent, with the option to add new values. Any scope, initialization method, destroy method, and/or <code>static</code> factory method settings that you specify will override the corresponding parent settings.</p>
<p>子bean定义可以继承作用域，构造函数参数值，属性值，可以重写父方法，可以选择添加新值。你指定的任何作用域，初始化方法，析构方法，和/或静态工厂方法设置将会覆盖对应的父设置。</p>
<p>The remaining settings are always taken from the child definition: depends on, autowire mode, dependency check, singleton, lazy init.</p>
<p>其余的设置都是从子定义中获取：依赖关系，自动装配模式，依赖检查，单例，延迟初始化。</p>
<p>The preceding example explicitly marks the parent bean definition as <code>abstract</code> by using the abstract attribute. If the parent definition does not specify a class, explicitly marking the parent bean definition as <code>abstract</code> is required, as follows:</p>
<p>前面的例子使用抽象特性将父bean定义显式的标记为<code>abstract</code>。如果父定义没有指定一个类，需要显式的将父bean定义为<code>abstract</code>，形式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as <code>abstract</code>. When a definition is <code>abstract</code> like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions. Trying to use such an <code>abstract</code> parent bean on its own, by referring to it as a ref property of another bean or doing an explicit <code>getBean()</code> call with the parent bean id, returns an error. Similarly, the container’s internal <code>preInstantiateSingletons()</code> method ignores bean definitions that are defined as abstract.</p>
<p>父bean不能实例化，因为它不完整，并且它被显式的标记为<code>abstract</code>。当一个bean定义是<code>abstract</code>时，它只能是一个纯粹的bean定义模板，作为一个为子定义服务的父定义。当试图使用一个<code>abstract</code>父bean时，可以通过另一个bean的<code>ref</code>属性来引用它或通过父bean的id为参数显式的调用<code>getBean()</code>方法，会返回一个错误。类似的，容器内部的<code>preInstantiateSingletons()</code>方法会忽略抽象bean定义。</p>
<blockquote>
<p><code>ApplicationContext</code> pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the abstract attribute to true, otherwise the application context will actually (attempt to) pre-instantiate the <code>abstract</code> bean.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>默认情况下<code>ApplicationContext</code>会预实例化所有的单例。因此，如果你想有一个（父）bean定义只作为模板来使用，这个定义中指定了一个类，那你必须确保设置<code>abstract</code>特性为<code>true</code>，否则应用上下文会（试图）预实例化这个<code>abstract</code> bean。</p>
</blockquote>
<h3 id="3-8-Container-Extension-Points"><a href="#3-8-Container-Extension-Points" class="headerlink" title="3.8 Container Extension Points"></a>3.8 Container Extension Points</h3><p>Typically, an application developer does not need to subclass <code>ApplicationContext</code> implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.</p>
<p>通常情况下，应用开发者不需要继承<code>ApplicationContext</code>的实现类。反而是Spring的IoC容器可以通过插入特定集成接口的实现来进行扩展。下面几节将描述这些集成接口。</p>
<h4 id="3-8-1-Customizing-beans-using-a-BeanPostProcessor"><a href="#3-8-1-Customizing-beans-using-a-BeanPostProcessor" class="headerlink" title="3.8.1 Customizing beans using a BeanPostProcessor"></a>3.8.1 Customizing beans using a BeanPostProcessor</h4><p>The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency-resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more <code>BeanPostProcessor</code> implementations.</p>
<p><code>BeanPostProcessor</code>接口定义了回调方法，你可以实现这个方法来提供你自己的（或覆盖容器默认的）实例化逻辑，依赖解析逻辑等等。如果你想在Spring容器完成实例化，配置和初始化bean之后实现一些定制的业务逻辑，你可以插入一个或多个<code>BeanPostProcessor</code>实现。</p>
<p>You can configure multiple <code>BeanPostProcessor</code> instances, and you can control the order in which these <code>BeanPostProcessors</code> execute by setting the <code>order</code> property. You can set this property only if the <code>BeanPostProcessor</code> implements the <code>Ordered</code> interface; if you write your own <code>BeanPostProcessor</code> you should consider implementing the <code>Ordered</code> interface too. For further details, consult the javadocs of the <code>BeanPostProcessor</code> and <code>Ordered</code> interfaces. See also the note below on programmatic registration of <code>BeanPostProcessors</code>.</p>
<p>你可以配置多个<code>BeanPostProcessor</code>实例，通过设置<code>order</code>属性你可以控制<code>BeanPostProcessors</code>的执行顺序。只有<code>BeanPostProcessor</code>实现了<code>Ordered</code>接口时你才可以设置这个属性；如果你编写了你自己的<code>BeanPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。更多细节请参考<code>BeanPostProcessor</code>接口和<code>Ordered</code>接口的Java文档。也可以查看下面的<code>BeanPostProcessors</code>编程注册的笔记。</p>
<blockquote>
<p><code>BeanPostProcessors</code> operate on bean (or object) instances; that is to say, the Spring IoC container instantiates a bean instance and then <code>BeanPostProcessors</code> do their work.</p>
<p><code>BeanPostProcessors</code> are scoped per-container. This is only relevant if you are using container hierarchies. If you define a <code>BeanPostProcessor</code> in one container, it will only post-process the beans in that container. In other words, beans that are defined in one container are not post-processed by a <code>BeanPostProcessor</code> defined in another container, even if both containers are part of the same hierarchy.</p>
<p>To change the actual bean definition (i.e., the blueprint that defines the bean), you instead need to use a <code>BeanFactoryPostProcessor</code> as described in Section 3.8.2, “Customizing configuration metadata with a BeanFactoryPostProcessor”.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>BeanPostProcessors</code>操作一个bean（或对象）实例；也就是说，Spring Ioc容器实例化一个bean实例，然后<code>BeanPostProcessors</code>完成它们的工作。</p>
<p><code>BeanPostProcessors</code>的作用域是每个容器。只有你在使用容器分层的情况下，这才是相关的。如果你在一个容器中定义了一个<code>BeanPostProcessor</code>，它将只后处理容器中的beans。换句话说，某个容器中定义的beans不能被另一个容器中定义的<code>BeanPostProcessor</code>进行后处理，即使这两个容器是同一层上的一部分。</p>
<p>为了改变实际的bean定义（例如，定义bean的蓝图），你可以使用3.8.2小节中描述的<code>BeanFactoryPostProcessor</code>。</p>
</blockquote>
<p>The <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as InitializingBean’s afterPropertiesSet() and any declared init method) are called as well as after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.</p>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口包含恰好两个回调方法。当这样一个类在容器中注册为后处理器时，对于容器中创建的每一个bean实例，在容器初始化方法（例如<code>InitializingBean</code>的<code>afterPropertiesSet()</code>方法和任何已声明的初始化方法）被调用之前和任何bean初始化回调函数之后，后处理器会从容器中得到一个回调函数。后处理器可以对bean实例进行任何操作，包括完全忽略回调方法。bean后处理器通常检查回调接口或将bean包裹到代理中。为了提供代理包裹逻辑，一些Spring AOP基础结构类被实现为bean后处理器。</p>
<p>An <code>ApplicationContext</code> automatically detects any beans that are defined in the configuration metadata which implement the <code>BeanPostProcessor</code> interface. The <code>ApplicationContext</code> registers these beans as post-processors so that they can be called later upon bean creation. Bean post-processors can be deployed in the container just like any other beans.</p>
<p><code>ApplicationContext</code>会自动检测任何配置元数据中定义的实现了<code>BeanPostProcessor</code>接口的bean。为了能在后面bean创建时调用这些bean，<code>ApplicationContext</code>会将这些bean注册为后处理器。bean后处理器可以像其它bean一样在容器进行部署。</p>
<p>Note that when declaring a <code>BeanPostProcessor</code> using an <code>@Bean</code> factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface, clearly indicating the post-processor nature of that bean. Otherwise, the <code>ApplicationContext</code> won’t be able to autodetect it by type before fully creating it. Since a <code>BeanPostProcessor</code> needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.</p>
<p>注意当在一个配置类上使用<code>@Bean</code>声明一个<code>BeanPostProcessor</code>时，工厂方法的返回值应该是实现类本身或是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，这能清晰的表明bean的后处理器特性。此外，在完整的创建它之前，<code>ApplicationContext</code>不能通过类型自动检测它。由于<code>BeanPostProcessor</code>需要早一点实例化，为了在上下文中初始化其它的beans，早期的类型检测是非常关键的。</p>
<blockquote>
<p>While the recommended approach for <code>BeanPostProcessor</code> registration is through <code>ApplicationContext</code> auto-detection (as described above), it is also possible to register them programmatically against a <code>ConfigurableBeanFactory</code> using the <code>addBeanPostProcessor</code> method. This can be useful when needing to evaluate conditional logic before registration, or even for copying bean post processors across contexts in a hierarchy. Note however that <code>BeanPostProcessors</code> added programmatically do not respect the <code>Ordered</code> interface. Here it is the order of registration that dictates the order of execution. Note also that <code>BeanPostProcessors</code> registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>虽然推荐的注册<code>BeanPostProcessor</code>的方法是通过<code>ApplicationContext</code>自动检测（像前面描述的那样），但也可以通过以编程方法通过使用<code>ConfigurableBeanFactory</code>的<code>addBeanPostProcessor</code>方法来注册。在注册之前需要评估条件逻辑时，这是非常有用的，或者通过分层中的上下文来复制bean后处理器。注意以编程方式添加的<code>BeanPostProcessors</code>不需要<code>Ordered</code>接口。这种情况下注册顺序意味着执行顺序。注意以编程方式注册的<code>BeanPostProcessors</code>中是在那些通过自动检测注册的<code>BeanPostProcessors</code>之前进行处理，不管任何显式的顺序指定。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>Classes that implement the <code>BeanPostProcessor</code> interface are special and are treated differently by the container. All <code>BeanPostProcessors</code> and beans that they reference directly are instantiated on startup, as part of the special startup phase of the <code>ApplicationContext</code>. Next, all <code>BeanPostProcessors</code> are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessors</code> nor the beans they reference directly are eligible for auto-proxying, and thus do not have aspects woven into them.</p>
<p>For any such bean, you should see an informational log message: “Bean foo is not eligible for getting processed by all <code>BeanPostProcessor</code> interfaces (for example: not eligible for auto-proxying)”.</p>
<p>Note that if you have beans wired into your <code>BeanPostProcessor</code> using autowiring or <code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates, and therefore make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with <code>@Resource</code> where the <code>field/setter</code> name does not directly correspond to the declared name of a bean and no name attribute is used, then Spring will access other beans for matching them by type.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>实现<code>BeanPostProcessor</code>接口的类是特别的并被容器不同对待。所有的<code>BeanPostProcessors</code>和它们直接引用的beans在启动时进行实例化，它们是<code>ApplicationContext</code>特定启动阶段的一部分。接下来，所有<code>BeanPostProcessors</code>以有序形式进行注册，并适用于容器中所有更进一步的beans。由于AOP自动代理是作为<code>BeanPostProcessor</code>本身实现的，既不是<code>BeanPostProcessors</code>也不是它们直接引用的beans适合进行自动代理，因此没有融入它们的方面。</p>
<p>对于这样的bean，你应该看到一个信息日志消息：”Bean foo没资格被所有的<code>BeanPostProcessor</code>接口进行处理（例如，不适合自动代理）。”。</p>
<p>注意如果有beans使用自动装配或<code>@Resource</code>（可能回到自动装配）注入你的<code>BeanPostProcessor</code>，当搜索类型匹配的依赖候选者时，Spring可能访问未预料到beans，因此使它们不适合自动代理或其他类型的进行后处理的bean。例如，如果你有一个带有<code>@Resource</code>注解的依赖，<code>field/setter</code>名称不能直接对应bean声明的名字，也没有使用name特性，Spring将通过类型匹配来访问其它的bean。</p>
</blockquote>
<p>The following examples show how to write, register, and use <code>BeanPostProcessors</code> in an <code>ApplicationContext</code>.</p>
<p>下面的例子展示了在<code>ApplicationContext</code>中如何编写，注册和使用<code>BeanPostProcessors</code>。</p>
<p><strong>Example: Hello World, BeanPostProcessor-style</strong></p>
<p>This first example illustrates basic usage. The example shows a custom <code>BeanPostProcessor</code> implementation that invokes the <code>toString()</code> method of each bean as it is created by the container and prints the resulting string to the system console.</p>
<p>第一个例子阐述了基本用法。这个例子展示了一个定制<code>BeanPostProcessor</code>实现，实现中调用了每一个bean的<code>toString()</code>方法。当容器创建它时，会将结果字符串输出到系统控制台。</p>
<p>Find below the custom <code>BeanPostProcessor</code> implementation class definition:</p>
<p>下面是定制<code>BeanPostProcessor</code>实现的类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scripting;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// simply return the instantiated bean as-is</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/lang</div><div class="line">        http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></div><div class="line">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    when the above bean (messenger) is instantiated, this custom</div><div class="line">    BeanPostProcessor implementation will output the fact to the system console</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Notice how the <code>InstantiationTracingBeanPostProcessor</code> is simply defined. It does not even have a name, and because it is a bean it can be dependency-injected just like any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled Chapter 31, Dynamic language support.)</p>
<p>注意<code>InstantiationTracingBeanPostProcessor</code>是怎样简单定义的。它甚至没有一个名字，因为它是一个bean，它能像其它bean一样进行依赖注入。（前面的配置也定义了一个bean，它被Groovy脚本支持。Spring动态语言支持在31章『动态语言支持』中进行了详细描述。）</p>
<p>The following simple Java application executes the preceding code and configuration:</p>
<p>下面的简单Java应用执行了前面的代码和配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</div><div class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</div><div class="line">        System.out.println(messenger);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The output of the preceding application resembles the following:</p>
<p>前面的应用输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bean &apos;messenger&apos; created : org.springframework.scripting.groovy.GroovyMessenger@272961</div><div class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</div></pre></td></tr></table></figure>
<p><strong>Example: The RequiredAnnotationBeanPostProcessor</strong></p>
<p>Using callback interfaces or annotations in conjunction with a custom <code>BeanPostProcessor</code> implementation is a common means of extending the Spring IoC container. An example is Spring’s <code>RequiredAnnotationBeanPostProcessor</code> - a <code>BeanPostProcessor</code> implementation that ships with the Spring distribution which ensures that <code>JavaBean</code> properties on beans that are marked with an (arbitrary) annotation are actually (configured to be) dependency-injected with a value.</p>
<p>使用回调函数接口或注解结合定制<code>BeanPostProcessor</code>实现是扩展Spring IoC容器的常见方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code>——一个<code>BeanPostProcessor</code>实现附带在Spring发行中，它保证了标记有（任意）注解的beans上的<code>JavaBean</code>属性能真正（配置成）通过值进行依赖注入。</p>
<h4 id="3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><a href="#3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor"></a>3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</h4><p>The next extension point that we will look at is the <code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>. The semantics of this interface are similar to those of the <code>BeanPostProcessor</code>, with one major difference: <code>BeanFactoryPostProcessor</code> operates on the bean configuration metadata; that is, the Spring IoC container allows a <code>BeanFactoryPostProcessor</code> to read the configuration metadata and potentially change it before the container instantiates any beans other than <code>BeanFactoryPostProcessors</code>.</p>
<p>接下来我们要看到的扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与那些<code>BeanPostProcessor</code>类似，但有一个主要的不同：<code>BeanFactoryPostProcessor</code>可以操作配置元数据；也就是说，Spring IoC容器允许在容器实例化除了<code>BeanFactoryPostProcessor</code>之外的任何beans之前，<code>BeanFactoryPostProcessor</code>读取配置元数据并可能修改它们。</p>
<p>You can configure multiple <code>BeanFactoryPostProcessors</code>, and you can control the order in which these <code>BeanFactoryPostProcessors</code> execute by setting the <code>order</code> property. However, you can only set this property if the <code>BeanFactoryPostProcessor</code> implements the <code>Ordered</code> interface. If you write your own <code>BeanFactoryPostProcessor</code>, you should consider implementing the <code>Ordered</code> interface too. Consult the javadocs of the <code>BeanFactoryPostProcessor</code> and <code>Ordered</code> interfaces for more details.</p>
<p>你可以配置多个<code>BeanFactoryPostProcessors</code>，你可以通过设置<code>order</code>属性来控制这些<code>BeanFactoryPostProcessors</code>的执行顺序。但是，只有<code>BeanFactoryPostProcessor</code>实现了<code>Ordered</code>接口时你才可以设置这个属性。如果你编写了你自己的<code>BeanFactoryPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。关于<code>BeanFactoryPostProcessor</code>和<code>Ordered</code>的更多细节请看文档。</p>
<blockquote>
<p>If you want to change the actual bean instances (i.e., the objects that are created from the configuration metadata), then you instead need to use a <code>BeanPostProcessor</code> (described above in Section 3.8.1, “Customizing beans using a BeanPostProcessor”). While it is technically possible to work with bean instances within a <code>BeanFactoryPostProcessor</code> (e.g., using <code>BeanFactory.getBean()</code>), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects such as bypassing bean post processing.</p>
<p>Also, <code>BeanFactoryPostProcessors</code> are scoped per-container. This is only relevant if you are using container hierarchies. If you define a <code>BeanFactoryPostProcessor</code> in one container, it will only be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by <code>BeanFactoryPostProcessors</code> in another container, even if both containers are part of the same hierarchy.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>如果你想改变真正的bean实例（例如，从配置元数据中创建的对象），你应该需要使用<code>BeanPostProcessor</code>（3.8.1小节中描述的）。尽管在<code>BeanFactoryPostProcessor</code>中处理bean实例在技术上是可能的（例如使用<code>BeanFactory.getBean()</code>），但这样做会引起过早的bean实例化，违背标准的容器生命周期。这可能会产生负面影响例如绕过bean后处理。</p>
<p><code>BeanFactoryPostProcessors</code>的作用域也是在每个容器中。这仅对于容器分层而言。如果在一个容器中你定义了一个<code>BeanFactoryPostProcessor</code>，它将适用于那个容器中的bean定义。一个容器中的bean定义不能被另一个容器中的<code>BeanFactoryPostProcessors</code>进行后处理，即使两个容器是在同一个分层中。</p>
</blockquote>
<p>A bean factory post-processor is executed automatically when it is declared inside an <code>ApplicationContext</code>, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as <code>PropertyOverrideConfigurer</code> and <code>PropertyPlaceholderConfigurer</code>. A custom <code>BeanFactoryPostProcessor</code> can also be used, for example, to register custom property editors.</p>
<p>为了修改定义在容器中的配置元数据，当一个bean工厂后处理器在<code>ApplicationContext</code>中声明时，它会自动执行。Spring包含许多预先定义的bean工厂后处理器，例如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code>。定制的<code>BeanFactoryPostProcessor</code>也可以使用，例如，为了注册定制的属性编辑器。</p>
<p>An <code>ApplicationContext</code> automatically detects any beans that are deployed into it that implement the <code>BeanFactoryPostProcessor</code> interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.</p>
<p><code>ApplicationContext</code>会自动检测任何部署在它之内的实现了<code>BeanFactoryPostProcessor</code>接口的bean。在合适的时间，它会使用这些beans作为bean工厂后处理器。你可以像任何你使用的bean那样部署这些后处理器beans。</p>
<blockquote>
<p>As with <code>BeanPostProcessors</code>, you typically do not want to configure <code>BeanFactoryPostProcessors</code> for lazy initialization. If no other bean references a <code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the <code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the default-lazy-init attribute to <code>true</code>on the declaration of your <code>&lt;beans/&gt;</code> element.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>关于<code>BeanPostProcessors</code>, 通常情况下你不想配置<code>BeanFactoryPostProcessors</code>为延迟初始化。 如果没有别的bean引用<code>Bean(Factory)PostProcessor</code>，后处理器将不会实例化。因此，对它进行延迟初始化会被忽略，即使你将<code>&lt;beans/&gt;</code>元素中的<code>default-lazy-init</code>特性设置为<code>true</code>，<code>Bean(Factory)PostProcessor</code>也会急切的初始化。</p>
</blockquote>
<p><strong>Example: the Class name substitution PropertyPlaceholderConfigurer</strong></p>
<p>You use the <code>PropertyPlaceholderConfigurer</code> to externalize property values from a bean definition in a separate file using the standard Java <code>Properties</code> format. Doing so enables the person deploying an application to customize environment-specific properties such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.</p>
<p>你可以使用<code>PropertyPlaceholderConfigurer</code>读取单独文件中的bean定义来使属性具体化，这个单独文件使用标准的Java <code>Properties</code>格式。这样做可以在部署应用时定制特定环境属性例如数据库URLs和密码，没有复杂性或修改主XML定义文件及容器相关文件的风险。</p>
<p>Consider the following XML-based configuration metadata fragment, where a <code>DataSource</code> with placeholder values is defined. The example shows properties configured from an external <code>Properties</code> file. At runtime, a <code>PropertyPlaceholderConfigurer</code> is applied to the metadata that will replace some properties of the <code>DataSource</code>. The values to replace are specified as placeholders of the form <code>${property-name}</code> which follows the Ant/log4j/JSP EL style.</p>
<p>考虑一下下面的基于XML定义的配置元数据片段，其中定义了一个带有占位符的<code>DataSource</code>。这个例子展示了从外部<code>Properties</code>文件进行属性配置。在运行时，<code>PropertyPlaceholderConfigurer</code>会应用到元数据中，将会替换<code>DataSource</code>中的一些属性。通过<code>${property-name}</code>形式的占位符指定要替换的值，这遵循了Ant/log4j/JSP EL风格。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The actual values come from another file in the standard Java <code>Properties</code> format:</p>
<p>真正的属性值来自于另一个以标准Java <code>Properties</code>形式编写的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</div><div class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</div><div class="line">jdbc.username=sa</div><div class="line">jdbc.password=root</div></pre></td></tr></table></figure>
<p>Therefore, the string <code>${jdbc.username}</code> is replaced at runtime with the value ‘sa’, and the same applies for other placeholder values that match keys in the properties file. The <code>PropertyPlaceholderConfigurer</code> checks for placeholders in most properties and attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be customized.</p>
<p>因此，在运行是字符串<code>${jdbc.username}</code>被替换为<code>sa</code>，其它的匹配属性文件中的key的占位符的值以同样方式替换。<code>PropertyPlaceholderConfigurer</code>会检查bean中大多数属性和特性的占位符。此外，占位符的前缀和后缀都可以定制。</p>
<p>With the context namespace introduced in Spring 2.5, it is possible to configure property placeholders with a dedicated configuration element. One or more locations can be provided as a comma-separated list in the <code>location</code> attribute.</p>
<p>Spring 2.5中引入了上下文命名空间，可以通过专用配置元素配置属性占位符。在<code>location</code>特性可以提供一个或多个位置，多个位置用逗号分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-placeholder location=&quot;classpath:com/foo/jdbc.properties&quot;/&gt;</div></pre></td></tr></table></figure>
<p>The <code>PropertyPlaceholderConfigurer</code> not only looks for properties in the <code>Properties</code> file you specify. By default it also checks against the Java <code>System</code> properties if it cannot find a property in the specified properties files. You can customize this behavior by setting the <code>systemPropertiesMode</code> property of the configurer with one of the following three supported integer values:</p>
<ul>
<li><p>never (0): Never check system properties</p>
</li>
<li><p>fallback (1): Check system properties if not resolvable in the specified properties files. This is the default.</p>
</li>
<li><p>override (2): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.</p>
</li>
</ul>
<p><code>PropertyPlaceholderConfigurer</code>不仅仅查找指定<code>Properties</code>文件中的属性。默认情况下，如果不能在指定属性文件中找到属性，它也检查Java <code>System</code>属性。你可以通过下面三个支持的整数值中的一个设置配置器的<code>systemPropertiesMode</code>属性，从而定制查找行为。</p>
<ul>
<li><p>never (0): 从不检查<code>system</code>属性</p>
</li>
<li><p>fallback (1): 如果不能在指定文件中解析属性，检查<code>system</code>属性，这是默认值。</p>
</li>
<li><p>override (2): 在查找指定文件之前，首先检查<code>system</code>属性，这可以使系统属性覆盖任何其它属性源。</p>
</li>
</ul>
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
<p>更多信息请看<code>PropertyPlaceholderConfigurer</code>文档。</p>
<blockquote>
<p>You can use the <code>PropertyPlaceholderConfigurer</code> to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. For example:</p>
<p>你可以<code>PropertyPlaceholderConfigurer</code>替换类名，有时候非常有用，特别是运行时你必须选择一个特别的实现类的情况下。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;locations&quot;&gt;</div><div class="line">        &lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;properties&quot;&gt;</div><div class="line">        &lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;serviceStrategy&quot; class=&quot;$&#123;custom.strategy.class&#125;&quot;/&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the <code>preInstantiateSingletons()</code> phase of an <code>ApplicationContext</code> for a non-lazy-init bean.</p>
<p>如果这个类不能在运行时解析成一个有效类，对于一个非懒惰初始化的bean，当它要创建时，在<code>ApplicationContext</code>的<code>preInstantiateSingletons()</code>期间，bean会解析失败。</p>
</blockquote>
<p><strong>Example: the PropertyOverrideConfigurer</strong></p>
<p>The <code>PropertyOverrideConfigurer</code>, another bean factory post-processor, resembles the <code>PropertyPlaceholderConfigurer</code>, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding <code>Properties</code> file does not have an entry for a certain bean property, the default context definition is used.</p>
<p><code>PropertyOverrideConfigurer</code>，另一个bean工厂后处理器，类似于<code>PropertyPlaceholderConfigurer</code>，但不像后者，最初的定义可以有默认值或bean属性一点也没有值。如果一个覆写的<code>Properties</code>文件对于某个bean属性没有任何输入，会使用默认的上下文定义。</p>
<p>Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple <code>PropertyOverrideConfigurer</code> instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.</p>
<p>注意bean定义没有意识到被覆写了，因此从XML定义文件中它不能立刻很明显的看出在使用覆写的配置器。为了防止多个<code>PropertyOverrideConfigurer</code>实例对于同一个bean属性定义不同的值，根据覆写机制，使用最后一个定义的值。</p>
<p>Properties file configuration lines take this format:</p>
<p>属性文件配置形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">beanName.property=value</div></pre></td></tr></table></figure>
<p>For example:</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql:mydb</div></pre></td></tr></table></figure>
<p>This example file can be used with a container definition that contains a bean called <code>dataSource</code>, which has <code>driver</code> and <code>url</code> properties.</p>
<p>例子文件可以被包含名为<code>dataSource</code> bean的容器定义使用，它有一个<code>driver</code>和<code>url</code>属性。</p>
<p>Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In this example…​</p>
<p>混合属性命名也支持，除了最后被覆写的属性，只要路径的每部分都已经是非空（假设构造函数进行初始化）。在这个例子中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.fred.bob.sammy=123</div></pre></td></tr></table></figure>
<p>the <code>sammy</code> property of the <code>bob</code> property of the <code>fred</code> property of the <code>foo</code> bean is set to the scalar value <code>123</code>.</p>
<p><code>foo</code> bean中的<code>fred</code>属性的<code>bob</code>属性的<code>sammy</code>属性设为标量值<code>123</code>。</p>
<blockquote>
<p>Specified override values are always literal values; they are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>指定的覆写值总是字面值；它们不能转成bean引用。当XML bean定义中的初始值指定了一个bean引用时，这个规范同样有效。</p>
</blockquote>
<p>With the context namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element:</p>
<p>Spring 2.5引入了上下文命名空间，可以用专用配置元素配置属性覆写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;</div></pre></td></tr></table></figure>
<h4 id="3-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><a href="#3-8-3-Customizing-instantiation-logic-with-a-FactoryBean" class="headerlink" title="3.8.3 Customizing instantiation logic with a FactoryBean"></a>3.8.3 Customizing instantiation logic with a FactoryBean</h4><p>Implement the <code>org.springframework.beans.factory.FactoryBean</code> interface for objects that are themselves factories.</p>
<p>为对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口的是工厂本身。</p>
<p>The <code>FactoryBean</code> interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own <code>FactoryBean</code>, write the complex initialization inside that class, and then plug your custom <code>FactoryBean</code> into the container.</p>
<p><code>FactoryBean</code>接口是Spring IoC的实例化逻辑可插入性的一个点。如果你有复杂的初始化代码，相比于大量的冗余的XML代码用Java语言来表达会更好，那么你可以创建你自己的<code>FactoryBean</code>，在类里面编写复杂的初始化逻辑，并将你定制的<code>FactoryBean</code>插入到容器中。</p>
<p>The <code>FactoryBean</code> interface provides three methods:</p>
<ul>
<li><p><code>Object getObject()</code>: returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.</p>
</li>
<li><p><code>boolean isSingleton()</code>: returns true if this FactoryBean returns singletons, false otherwise.</p>
</li>
<li><p><code>Class getObjectType()</code>: returns the object type returned by the getObject() method or null if the type is not known in advance.</p>
</li>
</ul>
<p><code>FactoryBean</code>接口提供了三个方法：</p>
<ul>
<li><p><code>Object getObject()</code>: 返回一个工厂创建的对象实例。这个实例可能被共享， 依赖于工厂是否返回一个单例或原型。</p>
</li>
<li><p><code>boolean isSingleton()</code>: 如果<code>FactoryBean</code>返回单例，返回true，否则返回false。</p>
</li>
<li><p><code>Class getObjectType()</code>: 返回<code>getObject()</code>方法返回的类型，如果类型不能提前知道则返回null。</p>
</li>
</ul>
<p>The <code>FactoryBean</code> concept and interface is used in a number of places within the Spring Framework; more than 50 implementations of the <code>FactoryBean</code> interface ship with Spring itself.</p>
<p><code>FactoryBean</code>的概念和接口在Spring框架中的许多地方都使用了；Spring本身中有不止50个<code>FactoryBean</code>接口的实现。</p>
<p>When you need to ask a container for an actual <code>FactoryBean</code> instance itself instead of the bean it produces, preface the bean’s id with the ampersand symbol (&amp;) when calling the <code>getBean()</code> method of the <code>ApplicationContext</code>. So for a given <code>FactoryBean</code> with an id of <code>myBean</code>, invoking <code>getBean(&quot;myBean&quot;)</code> on the container returns the product of the <code>FactoryBean</code>; whereas, invoking <code>getBean(&quot;&amp;myBean&quot;)</code> returns the <code>FactoryBean</code> instance itself.</p>
<p>当你需要向容器请求一个真正的<code>FactoryBean</code>实例本身来代替它产生的bean时，调用<code>ApplicationContext</code>的<code>getBean()</code>方法时，bean的id前面要加上一个<code>$</code>符。因此给定一个id为<code>myBean</code>的<code>FactoryBean</code>，在容器中调用<code>getBean(&quot;myBean&quot;)</code>，返回<code>FactoryBean</code>的产品，但调用<code>getBean(&quot;&amp;myBean&quot;)</code>会返回<code>FactoryBean</code>实例本身。</p>
<h3 id="3-9-Annotation-based-container-configuration"><a href="#3-9-Annotation-based-container-configuration" class="headerlink" title="3.9 Annotation-based container configuration"></a>3.9 Annotation-based container configuration</h3><blockquote>
<p><strong>Are annotations better than XML for configuring Spring?</strong></p>
<p>The introduction of annotation-based configurations raised the question of whether this approach is ‘better’ than XML. The short answer is it depends. The long answer is that each approach has its pros and cons, and usually it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.</p>
<p>No matter the choice, Spring can accommodate both styles and even mix them together. It’s worth pointing out that through its JavaConfig option, Spring allows annotations to be used in a non-invasive way, without touching the target components source code and that in terms of tooling, all configuration styles are supported by the Spring Tool Suite.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><strong>在配置Spring时注解是否比XML更好？</strong></p>
<p>基于注解配置的引入引出了一个问题——这种方式是否比基于XML的配置更好。简短的回答是视情况而定。长一点的回答是每种方法都有它的优点和缺点，通常是由开发者决定哪一种策略更适合他们。由于注解的定义方式，注解在它们的声明中提供了许多上下文，导致配置更简短更简洁。然而，XML擅长连接组件而不必接触源代码或重新编译它们。一些开发者更喜欢接近源代码，而另一些人则认为基于注解的类不再是POJOs，此外，配置变的去中心化，而且更难控制。</p>
<p>无论选择是什么，Spring都能容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的Java配置选项，Spring允许注解以一种非入侵的方式使用，不触碰目标组件源码和那些工具，所有的配置风格由Spring工具套件支持。</p>
</blockquote>
<p>An alternative to XML setups is provided by annotation-based configuration which rely on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in the section called “Example: The RequiredAnnotationBeanPostProcessor”, using a <code>BeanPostProcessor</code> in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the <code>@Required</code> annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring’s dependency injection. Essentially, the <code>@Autowired</code> annotation provides the same capabilities as described in Section 3.4.5, “Autowiring collaborators” but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations such as <code>@PostConstruct</code>, and <code>@PreDestroy</code>. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the <code>javax.inject</code> package such as <code>@Inject</code> and <code>@Named</code>. Details about those annotations can be found in the relevant section.</p>
<p>基于注解的配置提供了一种XML设置的可替代方式，它依赖于字节码元数据来组装组件，而不是用尖括号声明的方式。代替使用XML来描述bean组装，开发者通过将注解使用在相关的类，方法或字段声明中，将配置移动到了组件类本身的内部。正如在“Example: The RequiredAnnotationBeanPostProcessor”那节提到的那样，使用<code>BeanPostProcessor</code>与注解结合是扩展Spring IoC容器的的常见方法。例如，Spring 2.0引入了<code>@Required</code>注解来执行需要的属性的可能性。Spring 2.5使以同样地通用方法来驱动Spring的依赖注入变为可能。本质上来说，<code>@Autowired</code>提供了如3.4.5小节描述的同样的能力。“Autowiring collaborators”但更细粒度的控制和更广的应用性。Spring 2.5也添加对JSR-250注解的支持，例如，<code>@PostConstruct</code>和<code>@PreDestroy</code><br>。Spring 3.0添加了对JSR-330，包含在<code>javax.inject</code>包内的注解（Java的依赖注入）的支持，例如<code>@Inject</code>和<code>@Named</code>。关于这些注解的细节可以在相关的小节找到。</p>
<blockquote>
<p>Annotation injection is performed before XML injection, thus the latter configuration will override the former for properties wired through both approaches.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>注解注入在XML注入之前进行，因此对于通过两种方法进行组装的属性后者的配置会覆盖前者。</p>
</blockquote>
<p>As always, you can register them as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the context namespace):</p>
<p>跟以前一样，你可以作为单独的bean定义来注册它们，但也可以通过在一个基于XML的Spring配置（注入包含上下文命名空间）中包含下面的标签来隐式的注册它们：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>(The implicitly registered post-processors include <code>AutowiredAnnotationBeanPostProcessor</code>, <code>CommonAnnotationBeanPostProcessor</code>, <code>PersistenceAnnotationBeanPostProcessor</code>, as well as the aforementioned <code>RequiredAnnotationBeanPostProcessor</code>.)</p>
<p>（隐式注册的后处理器包括 <code>AutowiredAnnotationBeanPostProcessor</code>，<code>CommonAnnotationBeanPostProcessor</code>，<code>PersistenceAnnotationBeanPostProcessor</code>和前面提到的<code>RequiredAnnotationBeanPostProcessor</code>。）</p>
<blockquote>
<p><code>&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same application context in which it is defined. This means that, if you put <code>&lt;context:annotation-config/&gt;</code> in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>, it only checks for <code>@Autowired</code> beans in your controllers, and not your services. See Section 18.2, “The DispatcherServlet” for more information.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>&lt;context:annotation-config/&gt;</code>仅在定义它的同样的应用上下文中寻找注解的beans。这意味着，如果你在一个为<code>DispatcherServlet</code>服务的<code>WebApplicationContext</code>中放置了<code>&lt;context:annotation-config/&gt;</code>，它只能在你的控制器中寻找<code>@Autowired</code>注解的beans，而不是在你的服务层中。更多信息请看18.2小节，“The DispatcherServlet”。</p>
</blockquote>
<h4 id="3-9-1-Required"><a href="#3-9-1-Required" class="headerlink" title="3.9.1 @Required"></a>3.9.1 @Required</h4><p>The <code>@Required</code> annotation applies to bean property setter methods, as in the following example:</p>
<p><code>@Required</code>注解应用到bean属性的setter方法上，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Required</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated; this allows for eager and explicit failure, avoiding <code>NullPointerExceptions</code> or the like later on. It is still recommended that you put assertions into the bean class itself, for example, into an init method. Doing so enforces those required references and values even when you use the class outside of a container.</p>
<p>这个注解仅仅是表明受影响的bean属性必须在配置时通过显式的bean定义或自动组装填充。如果受影响的bean属性没有填充，容器会抛出一个异常，这允许及早明确的失败，避免<code>NullPointerExceptions</code>或后面出现类似的情况。仍然建议你在bean类本身加入断言，例如，加入到初始化方法中。这样做可以强制这些需要的引用和值，甚至是你在容器外部使用这个类的时候。</p>
<h4 id="3-9-2-Autowired"><a href="#3-9-2-Autowired" class="headerlink" title="3.9.2 @Autowired"></a>3.9.2 @Autowired</h4><blockquote>
<p>JSR 330’s <code>@Inject</code> annotation can be used in place of Spring’s <code>@Autowired</code> annotation in the examples below. See here for more details.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>在下面的例子中JSR 330的<code>@Inject</code>注解可以用来代替Spring的<code>@Autowired</code>注解。</p>
</blockquote>
<p>You can apply the <code>@Autowired</code> annotation to constructors:</p>
<p>你可以将<code>@Autowired</code>注解应用到构造函数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>As of Spring Framework 4.3, the <code>@Autowired</code> constructor is no longer necessary if the target bean only defines one constructor. If several constructors are available, at least one must be annotated to teach the container which one it has to use.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>从Spring框架4.3起，如果目标bena仅定义了一个构造函数，那么<code>@Autowired</code>注解的构造函数不再是必要的。如果一些构造函数是可获得的，至少有一个必须要加上注解，以便于告诉容器使用哪一个。</p>
</blockquote>
<p>As expected, you can also apply the <code>@Autowired</code> annotation to “traditional” setter methods:</p>
<p>正如预料的那样，你也可以将<code>@Autowired</code>注解应用到“传统的”setter方法上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You can also apply the annotation to methods with arbitrary names and/or multiple arguments:</p>
<p>你也可以应用注解到具有任何名字和/或多个参数的方法上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></div><div class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You can apply <code>@Autowired</code> to fields as well and even mix it with constructors:</p>
<p>你也可以应用<code>@Autowired</code>到字段上，甚至可以与构造函数混合用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>It is also possible to provide all beans of a particular type from the <code>ApplicationContext</code> by adding the annotation to a field or method that expects an array of that type:</p>
<p>通过给带有数组的字段或方法添加<code>@Autowired</code>注解，也可以从<code>ApplicationContext</code>中提供一组特定类型的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The same applies for typed collections:</p>
<p>同样也可以应用到具有同一类型的集合上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Your beans can implement the <code>org.springframework.core.Ordered</code> interface or either use the <code>@Order</code> or standard <code>@Priority</code> annotation if you want items in the array or list to be sorted into a specific order.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>如果你希望数组或列表中的项按指定顺序排序，你的bean可以实现<code>org.springframework.core.Ordered</code>接口，或使用<code>@Order</code>或标准<code>@Priority</code>注解。</p>
</blockquote>
<p>Even typed Maps can be autowired as long as the expected key type is <code>String</code>. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:</p>
<p>只要期望的key是<code>String</code>，那么类型化的Maps就可以自动组装。Map的值将包含所有期望类型的beans，key将包含对应的bean名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>By default, the autowiring fails whenever zero candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed as demonstrated below.</p>
<p>默认情况下，当没有候选beans可获得时，自动组装会失败；默认的行为是将注解的方法，构造函数和字段看作指明了需要的依赖。这个行为也可以通过下面的方式去改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Only one annotated constructor per-class can be marked as required, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the greediest constructor whose dependencies can be satisfied, that is the constructor that has the largest number of arguments.</p>
<p><code>@Autowired</code>’s <code>required</code> attribute is recommended over the <code>@Required</code> annotation. The required attribute indicates that the property is not required for autowiring purposes, the property is ignored if it cannot be autowired. <code>@Required</code>, on the other hand, is stronger in that it enforces the property that was set by any means supported by the container. If no value is injected, a corresponding exception is raised.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>每个类只有一个构造函数可以标记为必需的，但可以注解多个非必需的构造函数。在这种情况下，会考虑这些候选者中的每一个，Spring使用最贪婪的构造函数，即依赖最满足的构造函数，具有最大数目的参数。</p>
<p>建议在<code>@Required</code>注解之上使用<code>@Autowired</code>的<code>required</code>特性。<code>required</code>特性表明这个属性自动装配是不需要的，如果这个属性不能被自动装配，它会被忽略。另一方面<code>@Required</code>是更强大的，在它强制这个属性被任何容器支持的bean设置。如果没有值注入，会抛出对应的异常。</p>
</blockquote>
<p>You can also use <code>@Autowired</code> for interfaces that are well-known resolvable dependencies: <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code>. These interfaces and their extended interfaces, such as <code>ConfigurableApplicationContext</code> or <code>ResourcePatternResolver</code>, are automatically resolved, with no special setup necessary.</p>
<p>你也可以对那些已知的具有可解析依赖的接口使用<code>@Autowired</code>：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>Environment</code>, <code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>。这些接口和它们的扩展接口，例如<code>ConfigurableApplicationContext</code>或<code>ResourcePatternResolver</code>，可以自动解析，不需要特别的设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>@Autowired</code>, <code>@Inject</code>, <code>@Resource</code>, and <code>@Value</code> annotations are handled by Spring <code>BeanPostProcessor</code> implementations which in turn means that you cannot apply these annotations within your own <code>BeanPostProcessor</code> or <code>BeanFactoryPostProcessor</code> types (if any). These types must be ‘wired up’ explicitly via XML or using a Spring <code>@Bean</code> method.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Resource</code>和<code>@Value</code>注解是通过Spring <code>BeanPostProcessor</code>实现处理，这反过来意味着你不能在你自己的<code>BeanPostProcessor</code>或<code>BeanFactoryPostProcessor</code>中应用这些注解（如果有的话）。这些类型必须显式的通过XML或使用Spring的<code>@Bean</code>方法来’wired up’。</p>
</blockquote>
<h4 id="3-9-3-Fine-tuning-annotation-based-autowiring-with-Primary"><a href="#3-9-3-Fine-tuning-annotation-based-autowiring-with-Primary" class="headerlink" title="3.9.3 Fine-tuning annotation-based autowiring with @Primary"></a>3.9.3 Fine-tuning annotation-based autowiring with @Primary</h4><p>Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring’s <code>@Primary</code> annotation. <code>@Primary</code> indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one ‘primary’ bean exists among the candidates, it will be the autowired value.</p>
<p>因为根据类型的自动装配可能会导致多个候选目标，所以在选择过程中进行更多的控制经常是有必要的。一种方式通过Spring的<code>@Primary</code>注解来完成。当有个多个候选bean要组装到一个单值的依赖时，<code>@Primary</code>表明指定的bean应该具有更高的优先级。如果确定一个’primary’ bean位于候选目标中间，它将是那个自动装配的值。</p>
<p>Let’s assume we have the following configuration that defines <code>firstMovieCatalog</code> as the primary <code>MovieCatalog</code>.</p>
<p>假设我们具有如下配置，将<code>firstMovieCatalog</code>定义为主要的<code>MovieCatalog</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>With such configuration, the following <code>MovieRecommender</code> will be autowired with the <code>firstMovieCatalog</code>.</p>
<p>根据这样的配置，下面的<code>MovieRecommender</code>将用<code>firstMovieCatalog</code>进行自动装配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MovieRecommender &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The corresponding bean definitions appear as follows.</p>
<p>对应的bean定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>3.9.4 Fine-tuning annotation-based autowiring with qualifiers</p>
<p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s <code>@Qualifier</code> annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p>
<p>当有多个实例需要确定一个主要的候选对象时，<code>@Primary</code>是一种按类型自动装配的有效方式。当需要在选择过程中进行更多的控制时，可以使用Spring的<code>@Qualifier</code>注解。为了给每个选择一个特定的bean，你可以将限定符的值与特定的参数联系在一起，减少类型匹配集合。在最简单的情况下，这是一个纯描述性值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <code>@Qualifier</code> annotation can also be specified on individual constructor arguments or method parameters:</p>
<p><code>@Qualifier</code>注解也可以指定单个构造函数参数或方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span>MovieCatalog movieCatalog,</span></div><div class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The corresponding bean definitions appear as follows. The bean with qualifier value “main” is wired with the constructor argument that is qualified with the same value.</p>
<p>对应的bean定义如下。限定符值为”main”的bean被组装到有相同值的构造函数参数中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"main"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"action"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>For a fallback match, the bean name is considered a default qualifier value. Thus you can define the bean with an id “main” instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, <code>@Autowired</code> is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches; they do not semantically express a reference to a unique bean id. Good qualifier values are “main” or “EMEA” or “persistent”, expressing characteristics of a specific component that are independent from the bean <code>id</code>, which may be auto-generated in case of an anonymous bean definition like the one in the preceding example.</p>
<p>对于回退匹配，bean名字被认为是默认的限定符值。因此你可以定义一个id为<code>main</code>的bean来代替内嵌的限定符元素，会有同样的匹配结果。然而，尽管你可以使用这个约定根据名字引用特定的beans，但是<code>@Autowired</code>从根本上来讲是使用可选的语义限定符来进行类型驱动注入的。这意味着限定符的值，即使回退到bean名称，总是缩小语义类型匹配的集合；它们没有从语义上将一个引用表达为一个唯一的bean id。好的限定符值是”main”或”EMEA”或”persistent”，表达一个特定组件的性质，这个组件是独立于bean <code>id</code>的，即使前面例子中像这个bean一样的匿名bean会自动生成id。</p>
<p>Qualifiers also apply to typed collections, as discussed above, for example, to <code>Set&lt;MovieCatalog&gt;</code>. In this case, all matching beans according to the declared qualifiers are injected as a collection. This implies that qualifiers do not have to be unique; they rather simply constitute filtering criteria. For example, you can define multiple <code>MovieCatalog</code> beans with the same qualifier value “action”, all of which would be injected into a <code>Set&lt;MovieCatalog&gt;</code> annotated with <code>@Qualifier(&quot;action&quot;)</code>.</p>
<p>正如前面讨论的那样，限定符也可以应用到类型结合上，例如，<code>Set&lt;MovieCatalog&gt;</code>。在这个例子中，根据声明的限定符匹配的所有beans作为一个集合进行注入。这意味着限定符不必是唯一的；它们只是构成过滤标准。例如，你可以定义多个具有同样限定符值”action”的<code>MovieCatalog</code>，所有的这些都将注入到带有注解<code>@Qualifier(&quot;action&quot;)</code>的<code>Set&lt;MovieCatalog&gt;</code>中。</p>
<blockquote>
<p>If you intend to express annotation-driven injection by name, do not primarily use <code>@Autowired</code>, even if is technically capable of referring to a bean name through <code>@Qualifier</code> values. Instead, use the JSR-250 <code>@Resource</code> annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. <code>@Autowired</code> has rather different semantics: After selecting candidate beans by type, the specified <code>String</code> qualifier value will be considered within those type-selected candidates only, e.g. matching an “account” qualifier against beans marked with the same qualifier label.</p>
<p>For beans that are themselves defined as a collection/map or array type, <code>@Resource</code> is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, collection/map and array types can be matched through Spring’s <code>@Autowired</code> type matching algorithm as well, as long as the element type information is preserved in <code>@Bean</code> return type signatures or collection inheritance hierarchies. In this case, qualifier values can be used to select among same-typed collections, as outlined in the previous paragraph.</p>
<p>As of 4.3, <code>@Autowired</code> also considers self references for injection, i.e. references back to the bean that is currently injected. Note that self injection is a fallback; regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary; on the contrary, they always end up as lowest precedence. In practice, use self references as a last resort only, e.g. for calling other methods on the same instance through the bean’s transactional proxy: Consider factoring out the affected methods to a separate delegate bean in such a scenario. Alternatively, use <code>@Resource</code> which may obtain a proxy back to the current bean by its unique name.</p>
<p><code>@Autowired</code> applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. By contrast, <code>@Resource</code> is supported only for fields and bean property setter methods with a single argument. As a consequence, stick with qualifiers if your injection target is a constructor or a multi-argument method.</p>
<p><code>@Autowired</code>可以应用到字段，构造函数和多参数方法上，允许通过限定符注解在参数层面上缩减候选目标。相比之下，<code>@Resource</code>仅支持字段和bean属性的带有单个参数的setter方法。因此，如果你的注入目标是一个构造函数或一个多参数的方法，坚持使用限定符。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>如果你想通过名字表达注解驱动的注入，不要主要使用<code>@Autowired</code>，虽然在技术上能通过<code>@Qualifier</code>值引用一个bean名字。作为可替代产品，可以使用JSR-250 <code>@Resource</code>注解，它在语义上被定义为通过组件唯一的名字来识别特定的目标组件，声明的类型与匹配过程无关。<code>@Autowired</code>有不同的语义：通过类型选择候选beans，特定的<code>String</code>限定符值被认为只在类型选择的候选目标中，例如，在那些标记为具有相同限定符标签的beans中匹配一个”account”限定符。</p>
<p>对于那些本身定义在集合/映射或数组类型中的beans来说，<code>@Resource</code>是一个很好的解决方案，适用于特定的集合或通过唯一名字区分的数组bean。也就是说，自Spring 4.3起，集合/映射和数组类型中也可以通过Spring的<code>@Autowired</code>类型匹配算法进行匹配，只要元素类型信息在<code>@Bean</code>中保留，返回类型签名或集合继承体系。在这种情况下，限定符值可以用来在相同类型的集合中选择，正如在前一段中概括的那样。</p>
<p>自Spring 4.3起，<code>@Autowired</code>也考虑自引用注入，例如，引用返回当前注入的bean。注意自注入是备用；普通对其它组件的依赖关系总是优先的。在这个意义上，自引用不参与普通的候选目标选择，因此尤其是从不是主要的；恰恰相反，它们最终总是最低的优先级。在实践中，自引用只是作为最后的手段，例如，通过bean的事务代理调用同一实例的其它方法：在考虑抽出受影响的方法来分隔代理bean的场景中。或者，使用<code>@Resource</code>通过它的唯一名字可能得到一个返回当前bean的代理。</p>
<p><code>@Autowired</code>可以应用到字段，构造函数和多参数方法上，允许通过限定符注解在参数层面上缩减候选目标。相比之下，<code>@Resource</code>仅支持字段和bean属性的带有单个参数的setter方法。因此，如果你的注入目标是一个构造函数或一个多参数的方法，坚持使用限定符。</p>
</blockquote>
<p>You can create your own custom qualifier annotations. Simply define an annotation and provide the <code>@Qualifier</code> annotation within your definition:</p>
<p>你可以创建自己的定制限定符注解。简单定义一个注解，在你自己的定义中提供<code>@Qualifier</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Then you can provide the custom qualifier on autowired fields and parameters:</p>
<p>然后你可以在自动装配的字段和参数上提供定制的限定符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Genre</span>(<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComedyCatalog</span><span class="params">(@Genre(<span class="string">"Comedy"</span>)</span> MovieCatalog comedyCatalog) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.comedyCatalog = comedyCatalog;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Next, provide the information for the candidate bean definitions. You can add <code>&lt;qualifier/&gt;</code> tags as sub-elements of the <code>&lt;bean/&gt;</code> tag and then specify the type and value to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Or, as a convenience if no risk of conflicting names exists, you can use the short class name. Both approaches are demonstrated in the following example.</p>
<p>接下来，提供候选bean定义的信息。你可以添加<code>&lt;qualifier/&gt;</code>标记作为<code>&lt;bean/&gt;</code>标记的子元素，然后指定匹配你的定制限定符注解的类型和值。类型用来匹配注解的全限定类名称。或者，如果没有名称冲突的风险，为了方便，你可以使用简写的类名称。下面的例子证实了这些方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"example.Genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>In Section 3.10, “Classpath scanning and managed components”, you will see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see Section 3.10.8, “Providing qualifier metadata with annotations”.</p>
<p>在3.10小节，“类路径扫描和管理组件”中，你将看到一个基于注解的替代方法，在XML中提供限定符元数据。特别地，看3.10.8小节，“用注解提供限定符元数据”。</p>
<p>In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that would be searched when no Internet connection is available. First define the simple annotation:</p>
<p>在某些情况下，使用没有值的注解就是足够的。当注解为了通用的目的时，这是非常有用的，可以应用到跨几个不同类型的依赖上。例如，当网络不可用时，你可以提供一个要搜索的离线目录。首先定义一个简单的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Then add the annotation to the field or property to be autowired:</p>
<p>然后将注解添加到要自动装配的字段或属性上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Offline</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now the bean definition only needs a qualifier type:</p>
<p>现在bean定义只需要一个限定符类型：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Offline"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:</p>
<p>你也可以定义接收命名属性之外的定制限定符注解或代替简单的值属性。如果要注入的字段或参数指定了多个属性值，bean定义必须匹配所有的属性值才会被认为是一个可自动装配的候选目标。作为一个例子，考虑下面的注解定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Qualifier</div><div class="line">public @interface MovieQualifier &#123;</div><div class="line"></div><div class="line">    String genre();</div><div class="line"></div><div class="line">    Format format();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In this case <code>Format</code> is an enum:</p>
<p>这种情况下<code>Format</code>是枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Format &#123;</div><div class="line">    VHS, DVD, BLURAY</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The fields to be autowired are annotated with the custom qualifier and include values for both attributes: <code>genre</code> and <code>format</code>.</p>
<p>要自动装配的字段使用定制限定符进行注解，并且包含了两个属性值：<code>genre</code>和<code>format</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Comedy"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.DVD, genre=<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="string">"Comedy"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that bean meta attributes may be used instead of the <code>&lt;qualifier/&gt;</code> sub-elements. If available, the <code>&lt;qualifier/&gt;</code> and its attributes take precedence, but the autowiring mechanism falls back on the values provided within the <code>&lt;meta/&gt;</code> tags if no such qualifier is present, as in the last two bean definitions in the following example.</p>
<p>最后，bean定义应该包含匹配的限定符值。这个例子也证实了bean元属性可以用来代替<code>&lt;qualifier/&gt;</code>子元素。如果可获得<code>&lt;qualifier/&gt;</code>，它和它的属性优先级更高，如果当前没有限定符，自动装配机制会将<code>&lt;meta/&gt;</code>内的值作为备用，正如下面的例子中的最后两个bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"DVD"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"BLURAY"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="3-9-5-Using-generics-as-autowiring-qualifiers"><a href="#3-9-5-Using-generics-as-autowiring-qualifiers" class="headerlink" title="3.9.5 Using generics as autowiring qualifiers"></a>3.9.5 Using generics as autowiring qualifiers</h4><p>In addition to the <code>@Qualifier</code> annotation, it is also possible to use Java generic types as an implicit form of qualification. For example, suppose you have the following configuration:</p>
<p>除了<code>@Qualifier</code>注解外，也可以使用Java的泛型类型作为限定符的一种隐式方式。例如，假设你有如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class MyConfiguration &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public StringStore stringStore() &#123;</div><div class="line">        return new StringStore();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public IntegerStore integerStore() &#123;</div><div class="line">        return new IntegerStore();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Assuming that beans above implement a generic interface, i.e. <code>Store&lt;String&gt;</code> and <code>Store&lt;Integer&gt;</code>, you can <code>@Autowire</code> the <code>Store</code> interface and the generic will be used as a qualifier:</p>
<p>假设上面的beans实现了一个泛型接口，例如，<code>Store&lt;String&gt;</code>和<code>Store&lt;Integer&gt;</code>，你可以<code>@Autowire</code> <code>Store</code>接口，泛型将作为限定符使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></div></pre></td></tr></table></figure>
<p>Generic qualifiers also apply when autowiring <code>Lists</code>, <code>Maps</code> and <code>Arrays</code>:</p>
<p>当自动装配<code>Lists</code>，<code>Maps</code>和<code>Arrays</code>时，也会应用泛型限定符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span></div><div class="line"><span class="comment">// Store&lt;String&gt; beans will not appear in this list</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</div></pre></td></tr></table></figure>
<h4 id="3-9-6-CustomAutowireConfigurer"><a href="#3-9-6-CustomAutowireConfigurer" class="headerlink" title="3.9.6 CustomAutowireConfigurer"></a>3.9.6 CustomAutowireConfigurer</h4><p>The <code>CustomAutowireConfigurer</code> is a <code>BeanFactoryPostProcessor</code> that enables you to register your own custom qualifier annotation types even if they are not annotated with Spring’s <code>@Qualifier</code> annotation.</p>
<p><code>CustomAutowireConfigurer</code>是一个能使你注册自己的定制限定符注解类型的<code>BeanFactoryPostProcessor</code>，即使它们不能使用Spring的<code>@Qualifier</code>注解进行注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;customAutowireConfigurer&quot;</div><div class="line">        class=&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;customQualifierTypes&quot;&gt;</div><div class="line">        &lt;set&gt;</div><div class="line">            &lt;value&gt;example.CustomQualifier&lt;/value&gt;</div><div class="line">        &lt;/set&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>The <code>AutowireCandidateResolver</code> determines autowire candidates by:</p>
<ul>
<li><p>the <code>autowire-candidate</code> value of each bean definition</p>
</li>
<li><p>any <code>default-autowire-candidates</code> pattern(s) available on the <code>&lt;beans/&gt;</code> element</p>
</li>
<li><p>the presence of <code>@Qualifier</code> annotations and any custom annotations registered with the <code>CustomAutowireConfigurer</code></p>
</li>
</ul>
<p><code>AutowireCandidateResolver</code>通过下面的方式决定自动装配的候选目标：</p>
<ul>
<li><p>每个bean定义的<code>autowire-candidate</code></p>
</li>
<li><p>在<code>&lt;beans/&gt;</code>元素可获得的任何<code>default-autowire-candidates</code>模式</p>
</li>
<li><p>存在<code>@Qualifier</code>注解和任何在<code>CustomAutowireConfigurer</code>中注册的定制注解</p>
</li>
</ul>
<p>When multiple beans qualify as autowire candidates, the determination of a “primary” is the following: if exactly one bean definition among the candidates has a <code>primary</code> attribute set to <code>true</code>, it will be selected.</p>
<p>当多个beans符合条件成为自动装配的候选目标时，”primary” bean的决定如下：如果在候选目标中某个确定的bean中的<code>primary</code>特性被设为<code>true</code>，它将被选为目标bean。</p>
<h4 id="3-9-7-Resource"><a href="#3-9-7-Resource" class="headerlink" title="3.9.7 @Resource"></a>3.9.7 @Resource</h4><p>Spring also supports injection using the JSR-250 <code>@Resource</code> annotation on fields or bean property setter methods. This is a common pattern in Java EE 5 and 6, for example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports this pattern for Spring-managed objects as well.</p>
<p>Spring也支持使用JSR-250 <code>@Resource</code>对字段或bean属性setter方法进行注入。这是在Java EE 5和6中的一种通用模式，例如在JSF 1.2管理的beans或JAX-WS 2.0的端点。Spring对它管理的对象也支持这种模式。</p>
<p><code>@Resource</code> takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows <em>by-name</em> semantics, as demonstrated in this example:</p>
<p><code>@Resource</code>采用名字属性，默认情况下Spring将名字值作为要注入的bean的名字。换句话说，它遵循<em>by-name</em>语义，下面的例子证实了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span>(name=<span class="string">"myMovieFinder"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name “movieFinder” injected into its setter method:</p>
<p>如果没有显式的指定名字，默认名字从字段名或setter方法中取得。在字段情况下，它采用字段名称；在setter方法情况下，它采用bean的属性名。因此下面的例子将名字为<code>movieFinder</code>的bean注入到它的setter方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>The name provided with the annotation is resolved as a bean name by the <code>ApplicationContext</code> of which the <code>CommonAnnotationBeanPostProcessor</code> is aware. The names can be resolved through JNDI if you configure Spring’s <code>SimpleJndiBeanFactory</code> explicitly. However, it is recommended that you rely on the default behavior and simply use Spring’s JNDI lookup capabilities to preserve the level of indirection.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>注解提供的名字被<code>CommonAnnotationBeanPostProcessor</code>感知的<code>ApplicationContext</code>解析为bean名字。如果你显式地配置了Spring的<code>SimpleJndiBeanFactory</code>，名字会通过JNDI解析。但是建议你依赖默认行为，简单使用Spring的JNDI查找功能保护间接查找级别。</p>
</blockquote>
<p>In the exclusive case of <code>@Resource</code> usage with no explicit name specified, and similar to <code>@Autowired</code>, <code>@Resource</code> finds a primary type match instead of a specific named bean and resolves well-known resolvable dependencies: the <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code> interfaces.</p>
<p>在<code>@Resource</code>特有的没有显式名字指定的情况下，类似于<code>@Autowired</code>，<code>@Resource</code>会进行主要的匹配类型来代替指定名字的bean并解析已知的可解析依赖：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p>
<p>Thus in the following example, the <code>customerPreferenceDao</code> field first looks for a bean named <code>customerPreferenceDao</code>, then falls back to a primary type match for the type <code>CustomerPreferenceDao</code>. The “context” field is injected based on the known resolvable dependency type <code>ApplicationContext</code>.</p>
<p>因此在下面的例子中，<code>customerPreferenceDao</code>字段首先查找名字为<code>customerPreferenceDao</code>的bean，然后回退到主要的类型为<code>CustomerPreferenceDao</code>的类型匹配。”context”字段会注入基于已知的可解析依赖类型<code>ApplicationContext</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-9-8-PostConstruct-and-PreDestroy"><a href="#3-9-8-PostConstruct-and-PreDestroy" class="headerlink" title="3.9.8 @PostConstruct and @PreDestroy"></a>3.9.8 @PostConstruct and @PreDestroy</h4><p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation but also the JSR-250 lifecycle annotations. Introduced in Spring 2.5, the support for these annotations offers yet another alternative to those described in initialization callbacks and destruction callbacks. Provided that the <code>CommonAnnotationBeanPostProcessor</code> is registered within the Spring <code>ApplicationContext</code>, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the example below, the cache will be pre-populated upon initialization and cleared upon destruction.</p>
<p><code>CommonAnnotationBeanPostProcessor</code>不仅识别<code>@Resource</code>注解，而且识别JSR-250生命周期注解。在Spring 2.5引入了对这些注解的支持，也提供了在初始化回调函数和销毁回调函数中描述的那些注解的一种可替代方式。假设<code>CommonAnnotationBeanPostProcessor</code>在Spring的<code>ApplicationContext</code>中注册，执行这些注解的方法在生命周期的同一点被调用，作为对应的Spring生命周期接口方法或显式声明的回调方法。在下面的例子中，缓存会预先放置接近初始化之前，并在销毁之前清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// populates the movie cache upon initialization...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PreDestroy</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// clears the movie cache upon destruction...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>For details about the effects of combining various lifecycle mechanisms, see the section called “Combining lifecycle mechanisms”.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>关于组合各种生命周期机制的影响的更多细节，请看“组合生命周期机制”小节。</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/07/2016-9-7-Spring 5.0.0框架介绍_中文版/" rel="next" title="Spring 5.0.0框架介绍_持续更新">
                <i class="fa fa-chevron-left"></i> Spring 5.0.0框架介绍_持续更新
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/08/2016-9-8-jquery滚动到页面到指定位置/" rel="prev" title="jQuery滚动到页面指定位置">
                jQuery滚动到页面指定位置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/"
     data-title="Spring 5.0.0框架介绍_中英文对照_持续更新"
     data-content=""
     data-url="noahsnail.com/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/"
           data-title="Spring 5.0.0框架介绍_中英文对照_持续更新" data-url="noahsnail.com/2016/09/07/2016-9-7-Spring 5.0.0框架中英文对照/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tyan" />
          <p class="site-author-name" itemprop="name">Tyan</p>
          <p class="site-description motion-element" itemprop="description">工作中的技术总结</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">191</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-I-Overview-of-Spring-Framework"><span class="nav-number">1.</span> <span class="nav-text">Part I. Overview of Spring Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Getting-Started-with-Spring"><span class="nav-number">1.1.</span> <span class="nav-text">1.Getting Started with Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Introduction-to-the-Spring-Framework"><span class="nav-number">1.2.</span> <span class="nav-text">2.Introduction to the Spring Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Dependency-Injection-and-Inversion-of-Control"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 Dependency Injection and Inversion of Control</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Modules"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Core-Container"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 Core Container</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-AOP-and-Instrumentation"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 AOP and Instrumentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-Messaging"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 Messaging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-Data-Access-Integration"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.2.4 Data Access/Integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-Web"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.2.5 Web</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-Test"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">2.2.6 Test</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Usage-scenarios"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 Usage scenarios</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-Dependency-Management-and-Naming-Conventions"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 Dependency Management and Naming Conventions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Logging"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 Logging</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-II-Core-Technologies"><span class="nav-number">2.</span> <span class="nav-text">Part II. Core Technologies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-The-IoC-container"><span class="nav-number">2.1.</span> <span class="nav-text">3. The IoC container</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Introduction-to-the-Spring-IoC-container-and-beans"><span class="nav-number">2.1.1.</span> <span class="nav-text">3.1 Introduction to the Spring IoC container and beans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Container-overview"><span class="nav-number">2.1.2.</span> <span class="nav-text">3.2 Container overview</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Configuration-metadata"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">3.2.1 Configuration metadata</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-Instantiating-a-container"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">3.2.2 Instantiating a container</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-Using-the-container"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">3.2.3 Using the container</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Bean-overview"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.3 Bean overview</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-Naming-beans"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.3.1 Naming beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-Instantiating-beans"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.3.2 Instantiating beans</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Dependencies"><span class="nav-number">2.1.4.</span> <span class="nav-text">3.4 Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-Dependency-Injection"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">3.4.1 Dependency Injection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-Dependencies-and-configuration-in-detail"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">3.4.2 Dependencies and configuration in detail</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-Using-depends-on"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">3.4.3 Using depends-on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-Lazy-initialized-beans"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">3.4.4 Lazy-initialized beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-Autowiring-collaborators"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">3.4.5 Autowiring collaborators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-Method-injection"><span class="nav-number">2.1.4.6.</span> <span class="nav-text">3.4.6 Method injection</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Bean-scopes"><span class="nav-number">2.1.5.</span> <span class="nav-text">3.5 Bean scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-The-singleton-scope"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">3.5.1 The singleton scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-The-prototype-scope"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">3.5.2 The prototype scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-Singleton-beans-with-prototype-bean-dependencies"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">3.5.3 Singleton beans with prototype-bean dependencies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-Request-session-application-and-WebSocket-scopes"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">3.5.4 Request, session, application, and WebSocket scopes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-Custom-scopes"><span class="nav-number">2.1.6.</span> <span class="nav-text">3.5.5 Custom scopes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Customizing-the-nature-of-a-bean"><span class="nav-number">2.1.7.</span> <span class="nav-text">3.6 Customizing the nature of a bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-Lifecycle-callbacks"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">3.6.1 Lifecycle callbacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-ApplicationContextAware-and-BeanNameAware"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">3.6.2 ApplicationContextAware and BeanNameAware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-Other-Aware-interfaces"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">3.6.3 Other Aware interfaces</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Bean-definition-inheritance"><span class="nav-number">2.1.8.</span> <span class="nav-text">3.7 Bean definition inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-Container-Extension-Points"><span class="nav-number">2.1.9.</span> <span class="nav-text">3.8 Container Extension Points</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-Customizing-beans-using-a-BeanPostProcessor"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">3.8.1 Customizing beans using a BeanPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><span class="nav-number">2.1.9.2.</span> <span class="nav-text">3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><span class="nav-number">2.1.9.3.</span> <span class="nav-text">3.8.3 Customizing instantiation logic with a FactoryBean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-Annotation-based-container-configuration"><span class="nav-number">2.1.10.</span> <span class="nav-text">3.9 Annotation-based container configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1-Required"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">3.9.1 @Required</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-2-Autowired"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">3.9.2 @Autowired</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-3-Fine-tuning-annotation-based-autowiring-with-Primary"><span class="nav-number">2.1.10.3.</span> <span class="nav-text">3.9.3 Fine-tuning annotation-based autowiring with @Primary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-5-Using-generics-as-autowiring-qualifiers"><span class="nav-number">2.1.10.4.</span> <span class="nav-text">3.9.5 Using generics as autowiring qualifiers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-6-CustomAutowireConfigurer"><span class="nav-number">2.1.10.5.</span> <span class="nav-text">3.9.6 CustomAutowireConfigurer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-7-Resource"><span class="nav-number">2.1.10.6.</span> <span class="nav-text">3.9.7 @Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-8-PostConstruct-and-PreDestroy"><span class="nav-number">2.1.10.7.</span> <span class="nav-text">3.9.8 @PostConstruct and @PreDestroy</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyan</span>
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"noahsnail"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>

  


</body>
</html>
