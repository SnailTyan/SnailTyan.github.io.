<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Spring 5.0.0框架介绍_中英文对照_3.8">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 5.0.0框架介绍_中英文对照_3.8">
<meta property="og:url" content="http://noahsnail.com/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/index.html">
<meta property="og:site_name" content="SnailTyan">
<meta property="og:description" content="Spring 5.0.0框架介绍_中英文对照_3.8">
<meta property="og:updated_time" content="2016-11-16T11:20:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring 5.0.0框架介绍_中英文对照_3.8">
<meta name="twitter:description" content="Spring 5.0.0框架介绍_中英文对照_3.8">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://noahsnail.com/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/"/>





  <title>Spring 5.0.0框架介绍_中英文对照_3.8 | SnailTyan</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-83591315-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SnailTyan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://noahsnail.com/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tyan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SnailTyan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring 5.0.0框架介绍_中英文对照_3.8</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  Spring 5.0.0框架介绍_中英文对照_3.8
              </div>
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h3 id="3-8-Container-Extension-Points"><a href="#3-8-Container-Extension-Points" class="headerlink" title="3.8 Container Extension Points"></a>3.8 Container Extension Points</h3><p>Typically, an application developer does not need to subclass <code>ApplicationContext</code> implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.</p>
<p>通常情况下，应用开发者不需要继承<code>ApplicationContext</code>的实现类。反而是Spring的IoC容器可以通过插入特定集成接口的实现来进行扩展。下面几节将描述这些集成接口。</p>
<h4 id="3-8-1-Customizing-beans-using-a-BeanPostProcessor"><a href="#3-8-1-Customizing-beans-using-a-BeanPostProcessor" class="headerlink" title="3.8.1 Customizing beans using a BeanPostProcessor"></a>3.8.1 Customizing beans using a BeanPostProcessor</h4><p>The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency-resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more <code>BeanPostProcessor</code> implementations.</p>
<p><code>BeanPostProcessor</code>接口定义了回调方法，你可以实现这个方法来提供你自己的（或覆盖容器默认的）实例化逻辑，依赖解析逻辑等等。如果你想在Spring容器完成实例化，配置和初始化bean之后实现一些定制的业务逻辑，你可以插入一个或多个<code>BeanPostProcessor</code>实现。</p>
<p>You can configure multiple <code>BeanPostProcessor</code> instances, and you can control the order in which these <code>BeanPostProcessors</code> execute by setting the <code>order</code> property. You can set this property only if the <code>BeanPostProcessor</code> implements the <code>Ordered</code> interface; if you write your own <code>BeanPostProcessor</code> you should consider implementing the <code>Ordered</code> interface too. For further details, consult the javadocs of the <code>BeanPostProcessor</code> and <code>Ordered</code> interfaces. See also the note below on programmatic registration of <code>BeanPostProcessors</code>.</p>
<p>你可以配置多个<code>BeanPostProcessor</code>实例，通过设置<code>order</code>属性你可以控制<code>BeanPostProcessors</code>的执行顺序。只有<code>BeanPostProcessor</code>实现了<code>Ordered</code>接口时你才可以设置这个属性；如果你编写了你自己的<code>BeanPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。更多细节请参考<code>BeanPostProcessor</code>接口和<code>Ordered</code>接口的Java文档。也可以查看下面的<code>BeanPostProcessors</code>编程注册的笔记。</p>
<blockquote>
<p><code>BeanPostProcessors</code> operate on bean (or object) instances; that is to say, the Spring IoC container instantiates a bean instance and then <code>BeanPostProcessors</code> do their work.</p>
<p><code>BeanPostProcessors</code> are scoped per-container. This is only relevant if you are using container hierarchies. If you define a <code>BeanPostProcessor</code> in one container, it will only post-process the beans in that container. In other words, beans that are defined in one container are not post-processed by a <code>BeanPostProcessor</code> defined in another container, even if both containers are part of the same hierarchy.</p>
<p>To change the actual bean definition (i.e., the blueprint that defines the bean), you instead need to use a <code>BeanFactoryPostProcessor</code> as described in Section 3.8.2, “Customizing configuration metadata with a BeanFactoryPostProcessor”.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p><code>BeanPostProcessors</code>操作一个bean（或对象）实例；也就是说，Spring Ioc容器实例化一个bean实例，然后<code>BeanPostProcessors</code>完成它们的工作。</p>
<p><code>BeanPostProcessors</code>的作用域是每个容器。只有你在使用容器分层的情况下，这才是相关的。如果你在一个容器中定义了一个<code>BeanPostProcessor</code>，它将只后处理容器中的beans。换句话说，某个容器中定义的beans不能被另一个容器中定义的<code>BeanPostProcessor</code>进行后处理，即使这两个容器是同一层上的一部分。</p>
<p>为了改变实际的bean定义（例如，定义bean的蓝图），你可以使用3.8.2小节中描述的<code>BeanFactoryPostProcessor</code>。</p>
</blockquote>
<p>The <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as InitializingBean’s afterPropertiesSet() and any declared init method) are called as well as after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.</p>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口包含恰好两个回调方法。当这样一个类在容器中注册为后处理器时，对于容器中创建的每一个bean实例，在容器初始化方法（例如<code>InitializingBean</code>的<code>afterPropertiesSet()</code>方法和任何已声明的初始化方法）被调用之前和任何bean初始化回调函数之后，后处理器会从容器中得到一个回调函数。后处理器可以对bean实例进行任何操作，包括完全忽略回调方法。bean后处理器通常检查回调接口或将bean包裹到代理中。为了提供代理包裹逻辑，一些Spring AOP基础结构类被实现为bean后处理器。</p>
<p>An <code>ApplicationContext</code> automatically detects any beans that are defined in the configuration metadata which implement the <code>BeanPostProcessor</code> interface. The <code>ApplicationContext</code> registers these beans as post-processors so that they can be called later upon bean creation. Bean post-processors can be deployed in the container just like any other beans.</p>
<p><code>ApplicationContext</code>会自动检测任何配置元数据中定义的实现了<code>BeanPostProcessor</code>接口的bean。为了能在后面bean创建时调用这些bean，<code>ApplicationContext</code>会将这些bean注册为后处理器。bean后处理器可以像其它bean一样在容器进行部署。</p>
<p>Note that when declaring a <code>BeanPostProcessor</code> using an <code>@Bean</code> factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface, clearly indicating the post-processor nature of that bean. Otherwise, the <code>ApplicationContext</code> won’t be able to autodetect it by type before fully creating it. Since a <code>BeanPostProcessor</code> needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.</p>
<p>注意当在一个配置类上使用<code>@Bean</code>声明一个<code>BeanPostProcessor</code>时，工厂方法的返回值应该是实现类本身或是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，这能清晰的表明bean的后处理器特性。此外，在完整的创建它之前，<code>ApplicationContext</code>不能通过类型自动检测它。由于<code>BeanPostProcessor</code>需要早一点实例化，为了在上下文中初始化其它的beans，早期的类型检测是非常关键的。</p>
<blockquote>
<p>While the recommended approach for <code>BeanPostProcessor</code> registration is through <code>ApplicationContext</code> auto-detection (as described above), it is also possible to register them programmatically against a <code>ConfigurableBeanFactory</code> using the <code>addBeanPostProcessor</code> method. This can be useful when needing to evaluate conditional logic before registration, or even for copying bean post processors across contexts in a hierarchy. Note however that <code>BeanPostProcessors</code> added programmatically do not respect the <code>Ordered</code> interface. Here it is the order of registration that dictates the order of execution. Note also that <code>BeanPostProcessors</code> registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>虽然推荐的注册<code>BeanPostProcessor</code>的方法是通过<code>ApplicationContext</code>自动检测（像前面描述的那样），但也可以通过以编程方法通过使用<code>ConfigurableBeanFactory</code>的<code>addBeanPostProcessor</code>方法来注册。在注册之前需要评估条件逻辑时，这是非常有用的，或者通过分层中的上下文来复制bean后处理器。注意以编程方式添加的<code>BeanPostProcessors</code>不需要<code>Ordered</code>接口。这种情况下注册顺序意味着执行顺序。注意以编程方式注册的<code>BeanPostProcessors</code>中是在那些通过自动检测注册的<code>BeanPostProcessors</code>之前进行处理，不管任何显式的顺序指定。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>Classes that implement the <code>BeanPostProcessor</code> interface are special and are treated differently by the container. All <code>BeanPostProcessors</code> and beans that they reference directly are instantiated on startup, as part of the special startup phase of the <code>ApplicationContext</code>. Next, all <code>BeanPostProcessors</code> are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessors</code> nor the beans they reference directly are eligible for auto-proxying, and thus do not have aspects woven into them.</p>
<p>For any such bean, you should see an informational log message: “Bean foo is not eligible for getting processed by all <code>BeanPostProcessor</code> interfaces (for example: not eligible for auto-proxying)”.</p>
<p>Note that if you have beans wired into your <code>BeanPostProcessor</code> using autowiring or <code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates, and therefore make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with <code>@Resource</code> where the <code>field/setter</code> name does not directly correspond to the declared name of a bean and no name attribute is used, then Spring will access other beans for matching them by type.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>实现<code>BeanPostProcessor</code>接口的类是特别的并被容器不同对待。所有的<code>BeanPostProcessors</code>和它们直接引用的beans在启动时进行实例化，它们是<code>ApplicationContext</code>特定启动阶段的一部分。接下来，所有<code>BeanPostProcessors</code>以有序形式进行注册，并适用于容器中所有更进一步的beans。由于AOP自动代理是作为<code>BeanPostProcessor</code>本身实现的，既不是<code>BeanPostProcessors</code>也不是它们直接引用的beans适合进行自动代理，因此没有融入它们的方面。</p>
<p>对于这样的bean，你应该看到一个信息日志消息：”Bean foo没资格被所有的<code>BeanPostProcessor</code>接口进行处理（例如，不适合自动代理）。”。</p>
<p>注意如果有beans使用自动装配或<code>@Resource</code>（可能回到自动装配）注入你的<code>BeanPostProcessor</code>，当搜索类型匹配的依赖候选者时，Spring可能访问未预料到beans，因此使它们不适合自动代理或其他类型的进行后处理的bean。例如，如果你有一个带有<code>@Resource</code>注解的依赖，<code>field/setter</code>名称不能直接对应bean声明的名字，也没有使用name特性，Spring将通过类型匹配来访问其它的bean。</p>
</blockquote>
<p>The following examples show how to write, register, and use <code>BeanPostProcessors</code> in an <code>ApplicationContext</code>.</p>
<p>下面的例子展示了在<code>ApplicationContext</code>中如何编写，注册和使用<code>BeanPostProcessors</code>。</p>
<p><strong>Example: Hello World, BeanPostProcessor-style</strong></p>
<p>This first example illustrates basic usage. The example shows a custom <code>BeanPostProcessor</code> implementation that invokes the <code>toString()</code> method of each bean as it is created by the container and prints the resulting string to the system console.</p>
<p>第一个例子阐述了基本用法。这个例子展示了一个定制<code>BeanPostProcessor</code>实现，实现中调用了每一个bean的<code>toString()</code>方法。当容器创建它时，会将结果字符串输出到系统控制台。</p>
<p>Find below the custom <code>BeanPostProcessor</code> implementation class definition:</p>
<p>下面是定制<code>BeanPostProcessor</code>实现的类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scripting;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// simply return the instantiated bean as-is</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/lang</div><div class="line">        http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></div><div class="line">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    when the above bean (messenger) is instantiated, this custom</div><div class="line">    BeanPostProcessor implementation will output the fact to the system console</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Notice how the <code>InstantiationTracingBeanPostProcessor</code> is simply defined. It does not even have a name, and because it is a bean it can be dependency-injected just like any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled Chapter 31, Dynamic language support.)</p>
<p>注意<code>InstantiationTracingBeanPostProcessor</code>是怎样简单定义的。它甚至没有一个名字，因为它是一个bean，它能像其它bean一样进行依赖注入。（前面的配置也定义了一个bean，它被Groovy脚本支持。Spring动态语言支持在31章『动态语言支持』中进行了详细描述。）</p>
<p>The following simple Java application executes the preceding code and configuration:</p>
<p>下面的简单Java应用执行了前面的代码和配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</div><div class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</div><div class="line">        System.out.println(messenger);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The output of the preceding application resembles the following:</p>
<p>前面的应用输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bean &apos;messenger&apos; created : org.springframework.scripting.groovy.GroovyMessenger@272961</div><div class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</div></pre></td></tr></table></figure>
<p><strong>Example: The RequiredAnnotationBeanPostProcessor</strong></p>
<p>Using callback interfaces or annotations in conjunction with a custom <code>BeanPostProcessor</code> implementation is a common means of extending the Spring IoC container. An example is Spring’s <code>RequiredAnnotationBeanPostProcessor</code> - a <code>BeanPostProcessor</code> implementation that ships with the Spring distribution which ensures that <code>JavaBean</code> properties on beans that are marked with an (arbitrary) annotation are actually (configured to be) dependency-injected with a value.</p>
<p>使用回调函数接口或注解结合定制<code>BeanPostProcessor</code>实现是扩展Spring IoC容器的常见方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code>——一个<code>BeanPostProcessor</code>实现附带在Spring发行中，它保证了标记有（任意）注解的beans上的<code>JavaBean</code>属性能真正（配置成）通过值进行依赖注入。</p>
<h4 id="3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><a href="#3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor"></a>3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</h4><p>The next extension point that we will look at is the <code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>. The semantics of this interface are similar to those of the <code>BeanPostProcessor</code>, with one major difference: <code>BeanFactoryPostProcessor</code> operates on the bean configuration metadata; that is, the Spring IoC container allows a <code>BeanFactoryPostProcessor</code> to read the configuration metadata and potentially change it before the container instantiates any beans other than <code>BeanFactoryPostProcessors</code>.</p>
<p>接下来我们要看到的扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与那些<code>BeanPostProcessor</code>类似，但有一个主要的不同：<code>BeanFactoryPostProcessor</code>可以操作配置元数据；也就是说，Spring IoC容器允许在容器实例化除了<code>BeanFactoryPostProcessor</code>之外的任何beans之前，<code>BeanFactoryPostProcessor</code>读取配置元数据并可能修改它们。</p>
<p>You can configure multiple <code>BeanFactoryPostProcessors</code>, and you can control the order in which these <code>BeanFactoryPostProcessors</code> execute by setting the <code>order</code> property. However, you can only set this property if the <code>BeanFactoryPostProcessor</code> implements the <code>Ordered</code> interface. If you write your own <code>BeanFactoryPostProcessor</code>, you should consider implementing the <code>Ordered</code> interface too. Consult the javadocs of the <code>BeanFactoryPostProcessor</code> and <code>Ordered</code> interfaces for more details.</p>
<p>你可以配置多个<code>BeanFactoryPostProcessors</code>，你可以通过设置<code>order</code>属性来控制这些<code>BeanFactoryPostProcessors</code>的执行顺序。但是，只有<code>BeanFactoryPostProcessor</code>实现了<code>Ordered</code>接口时你才可以设置这个属性。如果你编写了你自己的<code>BeanFactoryPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。关于<code>BeanFactoryPostProcessor</code>和<code>Ordered</code>的更多细节请看文档。</p>
<blockquote>
<p>If you want to change the actual bean instances (i.e., the objects that are created from the configuration metadata), then you instead need to use a <code>BeanPostProcessor</code> (described above in Section 3.8.1, “Customizing beans using a BeanPostProcessor”). While it is technically possible to work with bean instances within a <code>BeanFactoryPostProcessor</code> (e.g., using <code>BeanFactory.getBean()</code>), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects such as bypassing bean post processing.</p>
<p>Also, <code>BeanFactoryPostProcessors</code> are scoped per-container. This is only relevant if you are using container hierarchies. If you define a <code>BeanFactoryPostProcessor</code> in one container, it will only be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by <code>BeanFactoryPostProcessors</code> in another container, even if both containers are part of the same hierarchy.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>如果你想改变真正的bean实例（例如，从配置元数据中创建的对象），你应该需要使用<code>BeanPostProcessor</code>（3.8.1小节中描述的）。尽管在<code>BeanFactoryPostProcessor</code>中处理bean实例在技术上是可能的（例如使用<code>BeanFactory.getBean()</code>），但这样做会引起过早的bean实例化，违背标准的容器生命周期。这可能会产生负面影响例如绕过bean后处理。</p>
<p><code>BeanFactoryPostProcessors</code>的作用域也是在每个容器中。这仅对于容器分层而言。如果在一个容器中你定义了一个<code>BeanFactoryPostProcessor</code>，它将适用于那个容器中的bean定义。一个容器中的bean定义不能被另一个容器中的<code>BeanFactoryPostProcessors</code>进行后处理，即使两个容器是在同一个分层中。</p>
</blockquote>
<p>A bean factory post-processor is executed automatically when it is declared inside an <code>ApplicationContext</code>, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as <code>PropertyOverrideConfigurer</code> and <code>PropertyPlaceholderConfigurer</code>. A custom <code>BeanFactoryPostProcessor</code> can also be used, for example, to register custom property editors.</p>
<p>为了修改定义在容器中的配置元数据，当一个bean工厂后处理器在<code>ApplicationContext</code>中声明时，它会自动执行。Spring包含许多预先定义的bean工厂后处理器，例如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code>。定制的<code>BeanFactoryPostProcessor</code>也可以使用，例如，为了注册定制的属性编辑器。</p>
<p>An <code>ApplicationContext</code> automatically detects any beans that are deployed into it that implement the <code>BeanFactoryPostProcessor</code> interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.</p>
<p><code>ApplicationContext</code>会自动检测任何部署在它之内的实现了<code>BeanFactoryPostProcessor</code>接口的bean。在合适的时间，它会使用这些beans作为bean工厂后处理器。你可以像任何你使用的bean那样部署这些后处理器beans。</p>
<blockquote>
<p>As with <code>BeanPostProcessors</code>, you typically do not want to configure <code>BeanFactoryPostProcessors</code> for lazy initialization. If no other bean references a <code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the <code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the default-lazy-init attribute to <code>true</code>on the declaration of your <code>&lt;beans/&gt;</code> element.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>关于<code>BeanPostProcessors</code>, 通常情况下你不想配置<code>BeanFactoryPostProcessors</code>为延迟初始化。 如果没有别的bean引用<code>Bean(Factory)PostProcessor</code>，后处理器将不会实例化。因此，对它进行延迟初始化会被忽略，即使你将<code>&lt;beans/&gt;</code>元素中的<code>default-lazy-init</code>特性设置为<code>true</code>，<code>Bean(Factory)PostProcessor</code>也会急切的初始化。</p>
</blockquote>
<p><strong>Example: the Class name substitution PropertyPlaceholderConfigurer</strong></p>
<p>You use the <code>PropertyPlaceholderConfigurer</code> to externalize property values from a bean definition in a separate file using the standard Java <code>Properties</code> format. Doing so enables the person deploying an application to customize environment-specific properties such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.</p>
<p>你可以使用<code>PropertyPlaceholderConfigurer</code>读取单独文件中的bean定义来使属性具体化，这个单独文件使用标准的Java <code>Properties</code>格式。这样做可以在部署应用时定制特定环境属性例如数据库URLs和密码，没有复杂性或修改主XML定义文件及容器相关文件的风险。</p>
<p>Consider the following XML-based configuration metadata fragment, where a <code>DataSource</code> with placeholder values is defined. The example shows properties configured from an external <code>Properties</code> file. At runtime, a <code>PropertyPlaceholderConfigurer</code> is applied to the metadata that will replace some properties of the <code>DataSource</code>. The values to replace are specified as placeholders of the form <code>${property-name}</code> which follows the Ant/log4j/JSP EL style.</p>
<p>考虑一下下面的基于XML定义的配置元数据片段，其中定义了一个带有占位符的<code>DataSource</code>。这个例子展示了从外部<code>Properties</code>文件进行属性配置。在运行时，<code>PropertyPlaceholderConfigurer</code>会应用到元数据中，将会替换<code>DataSource</code>中的一些属性。通过<code>${property-name}</code>形式的占位符指定要替换的值，这遵循了Ant/log4j/JSP EL风格。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The actual values come from another file in the standard Java <code>Properties</code> format:</p>
<p>真正的属性值来自于另一个以标准Java <code>Properties</code>形式编写的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</div><div class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</div><div class="line">jdbc.username=sa</div><div class="line">jdbc.password=root</div></pre></td></tr></table></figure>
<p>Therefore, the string <code>${jdbc.username}</code> is replaced at runtime with the value ‘sa’, and the same applies for other placeholder values that match keys in the properties file. The <code>PropertyPlaceholderConfigurer</code> checks for placeholders in most properties and attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be customized.</p>
<p>因此，在运行是字符串<code>${jdbc.username}</code>被替换为<code>sa</code>，其它的匹配属性文件中的key的占位符的值以同样方式替换。<code>PropertyPlaceholderConfigurer</code>会检查bean中大多数属性和特性的占位符。此外，占位符的前缀和后缀都可以定制。</p>
<p>With the context namespace introduced in Spring 2.5, it is possible to configure property placeholders with a dedicated configuration element. One or more locations can be provided as a comma-separated list in the <code>location</code> attribute.</p>
<p>Spring 2.5中引入了上下文命名空间，可以通过专用配置元素配置属性占位符。在<code>location</code>特性可以提供一个或多个位置，多个位置用逗号分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-placeholder location=&quot;classpath:com/foo/jdbc.properties&quot;/&gt;</div></pre></td></tr></table></figure>
<p>The <code>PropertyPlaceholderConfigurer</code> not only looks for properties in the <code>Properties</code> file you specify. By default it also checks against the Java <code>System</code> properties if it cannot find a property in the specified properties files. You can customize this behavior by setting the <code>systemPropertiesMode</code> property of the configurer with one of the following three supported integer values:</p>
<ul>
<li><p>never (0): Never check system properties</p>
</li>
<li><p>fallback (1): Check system properties if not resolvable in the specified properties files. This is the default.</p>
</li>
<li><p>override (2): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.</p>
</li>
</ul>
<p><code>PropertyPlaceholderConfigurer</code>不仅仅查找指定<code>Properties</code>文件中的属性。默认情况下，如果不能在指定属性文件中找到属性，它也检查Java <code>System</code>属性。你可以通过下面三个支持的整数值中的一个设置配置器的<code>systemPropertiesMode</code>属性，从而定制查找行为。</p>
<ul>
<li><p>never (0): 从不检查<code>system</code>属性</p>
</li>
<li><p>fallback (1): 如果不能在指定文件中解析属性，检查<code>system</code>属性，这是默认值。</p>
</li>
<li><p>override (2): 在查找指定文件之前，首先检查<code>system</code>属性，这可以使系统属性覆盖任何其它属性源。</p>
</li>
</ul>
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
<p>更多信息请看<code>PropertyPlaceholderConfigurer</code>文档。</p>
<blockquote>
<p>You can use the <code>PropertyPlaceholderConfigurer</code> to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. For example:</p>
<p>你可以<code>PropertyPlaceholderConfigurer</code>替换类名，有时候非常有用，特别是运行时你必须选择一个特别的实现类的情况下。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;locations&quot;&gt;</div><div class="line">        &lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;properties&quot;&gt;</div><div class="line">        &lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;serviceStrategy&quot; class=&quot;$&#123;custom.strategy.class&#125;&quot;/&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the <code>preInstantiateSingletons()</code> phase of an <code>ApplicationContext</code> for a non-lazy-init bean.</p>
<p>如果这个类不能在运行时解析成一个有效类，对于一个非懒惰初始化的bean，当它要创建时，在<code>ApplicationContext</code>的<code>preInstantiateSingletons()</code>期间，bean会解析失败。</p>
</blockquote>
<p><strong>Example: the PropertyOverrideConfigurer</strong></p>
<p>The <code>PropertyOverrideConfigurer</code>, another bean factory post-processor, resembles the <code>PropertyPlaceholderConfigurer</code>, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding <code>Properties</code> file does not have an entry for a certain bean property, the default context definition is used.</p>
<p><code>PropertyOverrideConfigurer</code>，另一个bean工厂后处理器，类似于<code>PropertyPlaceholderConfigurer</code>，但不像后者，最初的定义可以有默认值或bean属性一点也没有值。如果一个覆写的<code>Properties</code>文件对于某个bean属性没有任何输入，会使用默认的上下文定义。</p>
<p>Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple <code>PropertyOverrideConfigurer</code> instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.</p>
<p>注意bean定义没有意识到被覆写了，因此从XML定义文件中它不能立刻很明显的看出在使用覆写的配置器。为了防止多个<code>PropertyOverrideConfigurer</code>实例对于同一个bean属性定义不同的值，根据覆写机制，使用最后一个定义的值。</p>
<p>Properties file configuration lines take this format:</p>
<p>属性文件配置形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">beanName.property=value</div></pre></td></tr></table></figure>
<p>For example:</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql:mydb</div></pre></td></tr></table></figure>
<p>This example file can be used with a container definition that contains a bean called <code>dataSource</code>, which has <code>driver</code> and <code>url</code> properties.</p>
<p>例子文件可以被包含名为<code>dataSource</code> bean的容器定义使用，它有一个<code>driver</code>和<code>url</code>属性。</p>
<p>Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In this example…​</p>
<p>混合属性命名也支持，除了最后被覆写的属性，只要路径的每部分都已经是非空（假设构造函数进行初始化）。在这个例子中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.fred.bob.sammy=123</div></pre></td></tr></table></figure>
<p>the <code>sammy</code> property of the <code>bob</code> property of the <code>fred</code> property of the <code>foo</code> bean is set to the scalar value <code>123</code>.</p>
<p><code>foo</code> bean中的<code>fred</code>属性的<code>bob</code>属性的<code>sammy</code>属性设为标量值<code>123</code>。</p>
<blockquote>
<p>Specified override values are always literal values; they are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference.</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>指定的覆写值总是字面值；它们不能转成bean引用。当XML bean定义中的初始值指定了一个bean引用时，这个规范同样有效。</p>
</blockquote>
<p>With the context namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element:</p>
<p>Spring 2.5引入了上下文命名空间，可以用专用配置元素配置属性覆写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;</div></pre></td></tr></table></figure>
<h4 id="3-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><a href="#3-8-3-Customizing-instantiation-logic-with-a-FactoryBean" class="headerlink" title="3.8.3 Customizing instantiation logic with a FactoryBean"></a>3.8.3 Customizing instantiation logic with a FactoryBean</h4><p>Implement the <code>org.springframework.beans.factory.FactoryBean</code> interface for objects that are themselves factories.</p>
<p>为对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口的是工厂本身。</p>
<p>The <code>FactoryBean</code> interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own <code>FactoryBean</code>, write the complex initialization inside that class, and then plug your custom <code>FactoryBean</code> into the container.</p>
<p><code>FactoryBean</code>接口是Spring IoC的实例化逻辑可插入性的一个点。如果你有复杂的初始化代码，相比于大量的冗余的XML代码用Java语言来表达会更好，那么你可以创建你自己的<code>FactoryBean</code>，在类里面编写复杂的初始化逻辑，并将你定制的<code>FactoryBean</code>插入到容器中。</p>
<p>The <code>FactoryBean</code> interface provides three methods:</p>
<ul>
<li><p><code>Object getObject()</code>: returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.</p>
</li>
<li><p><code>boolean isSingleton()</code>: returns true if this FactoryBean returns singletons, false otherwise.</p>
</li>
<li><p><code>Class getObjectType()</code>: returns the object type returned by the getObject() method or null if the type is not known in advance.</p>
</li>
</ul>
<p><code>FactoryBean</code>接口提供了三个方法：</p>
<ul>
<li><p><code>Object getObject()</code>: 返回一个工厂创建的对象实例。这个实例可能被共享， 依赖于工厂是否返回一个单例或原型。</p>
</li>
<li><p><code>boolean isSingleton()</code>: 如果<code>FactoryBean</code>返回单例，返回true，否则返回false。</p>
</li>
<li><p><code>Class getObjectType()</code>: 返回<code>getObject()</code>方法返回的类型，如果类型不能提前知道则返回null。</p>
</li>
</ul>
<p>The <code>FactoryBean</code> concept and interface is used in a number of places within the Spring Framework; more than 50 implementations of the <code>FactoryBean</code> interface ship with Spring itself.</p>
<p><code>FactoryBean</code>的概念和接口在Spring框架中的许多地方都使用了；Spring本身中有不止50个<code>FactoryBean</code>接口的实现。</p>
<p>When you need to ask a container for an actual <code>FactoryBean</code> instance itself instead of the bean it produces, preface the bean’s id with the ampersand symbol (&amp;) when calling the <code>getBean()</code> method of the <code>ApplicationContext</code>. So for a given <code>FactoryBean</code> with an id of <code>myBean</code>, invoking <code>getBean(&quot;myBean&quot;)</code> on the container returns the product of the <code>FactoryBean</code>; whereas, invoking <code>getBean(&quot;&amp;myBean&quot;)</code> returns the <code>FactoryBean</code> instance itself.</p>
<p>当你需要向容器请求一个真正的<code>FactoryBean</code>实例本身来代替它产生的bean时，调用<code>ApplicationContext</code>的<code>getBean()</code>方法时，bean的id前面要加上一个<code>$</code>符。因此给定一个id为<code>myBean</code>的<code>FactoryBean</code>，在容器中调用<code>getBean(&quot;myBean&quot;)</code>，返回<code>FactoryBean</code>的产品，但调用<code>getBean(&quot;&amp;myBean&quot;)</code>会返回<code>FactoryBean</code>实例本身。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>如果有收获，可以请我喝杯咖啡！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://ocs628urt.bkt.clouddn.com/weixin_pay_meitu_2.jpg" alt="Tyan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://ocs628urt.bkt.clouddn.com/ali_pay_meitu_1.jpg" alt="Tyan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中文版_3.8/" rel="next" title="Spring 5.0.0框架介绍_中文版_3.8">
                <i class="fa fa-chevron-left"></i> Spring 5.0.0框架介绍_中文版_3.8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/17/2016-11-17-Spring Boot 2.0.0参考手册_中英文对照_Part IV_23/" rel="prev" title="Spring Boot 2.0.0参考手册_中英文对照_Part IV_23">
                Spring Boot 2.0.0参考手册_中英文对照_Part IV_23 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tyan" />
          <p class="site-author-name" itemprop="name">Tyan</p>
           
              <p class="site-description motion-element" itemprop="description">工作中的技术总结</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">384</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-Container-Extension-Points"><span class="nav-number">1.</span> <span class="nav-text">3.8 Container Extension Points</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-Customizing-beans-using-a-BeanPostProcessor"><span class="nav-number">1.1.</span> <span class="nav-text">3.8.1 Customizing beans using a BeanPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><span class="nav-number">1.2.</span> <span class="nav-text">3.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><span class="nav-number">1.3.</span> <span class="nav-text">3.8.3 Customizing instantiation logic with a FactoryBean</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyan</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  
    <script id="dsq-count-scr" src="https://snailtyan.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://noahsnail.com/2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/';
        this.page.identifier = '2016/11/16/2016-11-16-Spring 5.0.0框架介绍_中英文对照_3.8/';
        this.page.title = 'Spring 5.0.0框架介绍_中英文对照_3.8';
      };
      var d = document, s = d.createElement('script');
      s.src = 'https://snailtyan.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    </script>
  




	





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
