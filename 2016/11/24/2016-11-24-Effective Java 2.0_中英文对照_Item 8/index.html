<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Effective Java 2.0_中英文对照_Item 8">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Java 2.0_中英文对照_Item 8">
<meta property="og:url" content="http://noahsnail.com/2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/index.html">
<meta property="og:site_name" content="SnailTyan">
<meta property="og:description" content="Effective Java 2.0_中英文对照_Item 8">
<meta property="og:updated_time" content="2016-11-24T14:42:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Java 2.0_中英文对照_Item 8">
<meta name="twitter:description" content="Effective Java 2.0_中英文对照_Item 8">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://noahsnail.com/2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/"/>





  <title>Effective Java 2.0_中英文对照_Item 8 | SnailTyan</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SnailTyan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://noahsnail.com/2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tyan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SnailTyan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Effective Java 2.0_中英文对照_Item 8</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  Effective Java 2.0_中英文对照_Item 8
              </div>
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a>  |  <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a>  |  <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="CHAPTER3-Methods-Common-to-All-Objects"><a href="#CHAPTER3-Methods-Common-to-All-Objects" class="headerlink" title="CHAPTER3 Methods Common to All Objects"></a>CHAPTER3 Methods Common to All Objects</h1><p>ALTHOUGH <code>Object</code> is a concrete class, it is designed primarily for extension. All of its nonfinal methods (<code>equals</code>, <code>hashCode</code>, <code>toString</code>, <code>clone</code>, and <code>finalize</code>) have explicit <em>general contracts</em> because they are designed to be overridden. It is the responsibility of any class overriding these methods to obey their general contracts; failure to do so will prevent other classes that depend on the contracts (such as <code>HashMap</code> and <code>HashSet</code>) from functioning properly in conjunction with the class.</p>
<p>虽然<code>Object</code>是一个具体的类，但设计它的主要目的是为了扩展。它的所有非<code>final</code>方法(<code>equals</code>，<code>hashCode</code>，<code>toString</code>，<code>clone</code>和<code>finalize</code>)都有明确的<em>通用约定</em>，因为设计它们的目的是为了重写。任何类都应该遵循通用约定重写这些方法；不这样做的话，依赖这些约定的其它类（例如<code>HashMap</code>和<code>HashSet</code>）将无法结合这个类正确运行。</p>
<p>This chapter tells you when and how to override the nonfinal <code>Object</code> methods. The <code>finalize</code> method is omitted from this chapter because it was discussed in Item 7. While not an <code>Object</code> method, <code>Comparable.compareTo</code> is discussed in this chapter because it has a similar character.</p>
<p>会告本章诉你什么时候，怎样重写这些非final的<code>Object</code>方法。本章会忽略<code>finalize</code>方法，因为它在Item 7中已经讨论过了。虽然不是一个<code>Object</code>方法，但是这章仍会讨论<code>Comparable.compareTo</code>，因为它有一个类似的特性。</p>
<h2 id="Item-8-Obey-the-general-contract-when-overriding-equals"><a href="#Item-8-Obey-the-general-contract-when-overriding-equals" class="headerlink" title="Item 8: Obey the general contract when overriding equals"></a>Item 8: Obey the general contract when overriding equals</h2><p>Overriding the <code>equals</code> method seems simple, but there are many ways to get it wrong, and consequences can be dire. The easiest way to avoid problems is not to override the <code>equals</code> method, in which case each instance of the class is equal only to itself. This is the right thing to do if any of the following conditions apply:</p>
<p>重写<code>equals</code>方法看似简单，但许多方式都会导致错误，结果是非常可怕的。避免这些问题的最简单方式是不要重写<code>equals</code>方法，在这种情况下类的每个实例只等价于它本身。如果符合以下任何条件，这样做就是正确的：</p>
<ul>
<li><p><strong>Each instance of the class is inherently unique.</strong> This is true for classes such as <code>Thread</code> that represent active entities rather than values. The <code>equals</code> implementation provided by <code>Object</code> has exactly the right behavior for these classes.</p>
</li>
<li><p><strong>类的每个实例本质上都是唯一的。</strong>对于表示活动实体而不是表示值的类确实如此，例如<code>Thread</code>。对于这些类，<code>Object</code>提供的<code>equals</code>实现具有完全正确的行为。</p>
</li>
<li><p><strong>You don’t care whether the class provides a “logical equality” test.</strong> For example, <code>java.util.Random</code> could have overridden <code>equals</code> to check whether two <code>Random</code> instances would produce the same sequence of random numbers going forward, but the designers didn’t think that clients would need or want this functionality. Under these circumstances, the <code>equals</code> implementation inherited from <code>Object</code> is adequate.</p>
</li>
<li><p><strong>不关心类是否提供“逻辑等价”的测试。</strong>例如，<code>java.util.Random</code>可以重写<code>equals</code>方法来检查两个<code>Random</code>实例是否会产生相同的随机数序列，但设计者认为客户不需要或者不想要这个功能。在这种情况下，从<code>Object</code>继承的<code>equals</code>实现就足够了。</p>
</li>
<li><p><strong>A super class has already overridden <code>equals</code>,and the super class behavior is appropriate for this class.</strong> For example, most <code>Set</code> implementations inherit their <code>equals</code> implementation from <code>AbstractSet</code>, <code>List</code> implementations from <code>AbstractList</code>, and <code>Map</code> implementations from <code>AbstractMap</code>.</p>
</li>
<li><p><strong>超类已经重写了<code>equals</code>，超类的行为对于子类是合适的。</strong>例如，大多数<code>Set</code>实现从<code>AbstractSet</code>继承了<code>equals</code>实现，<code>List</code>实现从<code>AbstractList</code>继承了<code>equals</code>实现，<code>Map</code>实现从<code>AbstractMap</code>继承了<code>equals</code>实现。</p>
</li>
<li><p><strong>The class is private or package-private,and you are certain that its <code>equals</code> method will never be invoked.</strong> Arguably, the <code>equals</code> method should be overridden under these circumstances, in case it is accidentally invoked:</p>
</li>
<li><p><strong>类是私有的或包私有的，可以确定它的<code>equals</code>方法从不会被调用。</strong>可以说，在这些情况下<code>equals</code>方法应该重写，以防它被偶然调用：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// Method is never called</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>So when is it appropriate to override <code>Object.equals</code>? When a class has a notion of logical equality that differs from mere object identity, and a superclass has not already overridden <code>equals</code> to implement the desired behavior. This is generally the case for value classes. A value class is simply a class that represents a value, such as <code>Integer</code> or <code>Date</code>. A programmer who compares references to value objects using the <code>equals</code> method expects to find out whether they are logically equivalent, not whether they refer to the same object. Not only is overriding the <code>equals</code> method necessary to satisfy programmer expectations; it enables instances to serve as map keys or set elements with predictable, desirable behavior.</p>
<p>什么时候重写<code>Object.equals</code>方法是合适的？如果类具有逻辑等的概念，不同于对象同一性，并且超类没有重写<code>equals</code>方法来实现要求的行为，这时候就需要重写<code>equals</code>方法。这种情况通常是对值类而言的。值类仅仅是表示值的类，例如<code>Integer</code>或<code>Date</code>。程序员用<code>equals</code>方法比较值对象的引用，期望找出它们是否是逻辑等价的，而不管它们是否是同一对象。重写<code>equals</code>方法不仅满足了程序员的期望；它也能使实例作为映射表的主键或者集合的元素，使它们表现出可预期的行为。</p>
<p>One kind of value class that does not require the <code>equals</code> method to be overridden is a class that uses instance control (Item 1) to ensure that at most one object exists with each value. <code>Enum</code> types (Item 30) fall into this category. For these classes, logical equality is the same as object identity, so <code>Object</code>’s <code>equals</code> method functions as a logical equals method.</p>
<p>有一种不需要重写<code>equals</code>方法的值类，它通过实例控制（Item 1）来确保每个值至多存在一个对象。枚举类型（Item 30）就是这种类。对于这种类而言，逻辑等价等同与对象同一性，<code>Object</code>的<code>equals</code>方法在功能上就如同逻辑等价方法。</p>
<p>When you override the <code>equals</code> method, you must adhere to its general contract. Here is the contract, copied from the specification for <code>Object</code> [JavaSE6]:</p>
<p>当你重写<code>equals</code>方法时，你必须遵循通用约定。下面是约定内容，从<code>Object</code>规范[JavaSE6]中拷贝的：</p>
<p>The <code>equals</code> method implements an equivalence relation. It is:</p>
<ul>
<li><p><em>Reflexive</em>:For any non-null reference value <code>x</code>,<code>x.equals(x)</code> must return <code>true</code>.</p>
</li>
<li><p><em>Symmetric</em>:For any non-null reference values <code>x</code> and <code>y</code>,<code>x.equals(y)</code> must return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.</p>
</li>
<li><p><em>Transitive</em>:For any non-null reference values <code>x</code>,<code>y</code>,<code>z</code>,if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> must return <code>true</code>.</p>
</li>
<li><p><em>Consistent</em>: For any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in <code>equals</code> comparisons on the objects is modified.</p>
</li>
<li><p>For any non-null reference value <code>x</code>,<code>x.equals(null)</code> must return <code>false</code>.</p>
</li>
</ul>
<p><code>equals</code>实现了一种等价关系。它是：</p>
<ul>
<li><p><em>自反性</em>：对于任何非空引用值<code>x</code>，<code>x.equals(x)</code>必须返回<code>true</code>。</p>
</li>
<li><p><em>对称性</em>：对于任何非空引用值<code>x</code>和<code>y</code>，<code>x.equals(y)</code>必须返回<code>true</code>当且仅当<code>y.equals(x)</code>返回<code>true</code>。</p>
</li>
<li><p><em>传递性</em>：对于任何非空引用值，<code>x</code>，<code>y</code>，<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>并且<code>y.equals(z)</code>返回<code>true</code>，则<code>x.equals(z)</code>必须返回<code>true</code>。</p>
</li>
<li><p><em>一致性</em>：对于任何非空引用值<code>x</code>和<code>y</code>，<code>x.equals(y)</code>的多次调用一致返回<code>true</code>或一致返回<code>false</code>，假设对象进行<code>equals</code>比较时没有修改任何信息。</p>
</li>
<li><p>对于非空引用值<code>x</code>，<code>x.equals(null)</code>必须返回<code>false</code>。</p>
</li>
</ul>
<p>Unless you are mathematically inclined, this might look a bit scary, but do not ignore it! If you violate it, you may well find that your program behaves erratically or crashes, and it can be very difficult to pin down the source of the failure. To paraphrase John Donne, no class is an island. Instances of one class are frequently passed to another. Many classes, including all collections classes, depend on the objects passed to them obeying the <code>equals</code> contract.</p>
<p>除非你擅长数学，否则这可能看起来有点可怕，但不要忽视它！如果你违反了它，你可能会发现你的程序表现不正常或程序崩溃，并且很难确定失败的来源。用John Donne的话来说，没有类是孤立的。一个类的实例频繁传递给另一个类。许多类，包括所有的集合类，都依赖于传递给它们的对象遵循<code>equals</code>约定。</p>
<p>Now that you are aware of the dangers of violating the <code>equals</code> contract, let’s go over the contract in detail. The good news is that, appearances notwithstanding, the contract really isn’t very complicated. Once you understand it, it’s not hard to adhere to it. Let’s examine the five requirements in turn:</p>
<p>现在你已经意识到了违反了<code>equals</code>约定的危险，让我们详细回顾一下这个约定。好消息是实际上这个约定并不复杂，尽管从表面上来看不是这样。一旦你理解了它，遵循它并不难。让我们依次检查这五个要求：</p>
<p><strong>Reflexivity</strong>—The first requirement says merely that an object must be equal to itself. It is hard to imagine violating this requirement unintentionally. If you were to violate it and then add an instance of your class to a collection, the collection’s <code>contains</code> method might well say that the collection didn’t contain the instance that you just added.</p>
<p><strong>自反性</strong>——第一个要求仅仅是说一个对象必须等价于它本身。很难想象会无意的违反这个要求。如果你违反了它并将你的类实例添加到一个集合中，集合的<code>contains</code>方法可能会说这个集合中不包含你刚刚添加的实例。</p>
<p><strong>Symmetry</strong>—The second requirement says that any two objects must agree on whether they are equal. Unlike the first requirement, it’s not hard to imagine violating this one unintentionally. For example, consider the following class, which implements a case-insensitive string. The case of the string is preserved by <code>toString</code> but ignored in comparisons:</p>
<p><strong>对称性</strong>——第二个要求是说任何两个对象必须对它们是否相等达成一致。不像第一个要求，不难想象会无意的违反这个要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串保存在<code>toString</code>中，但在比较时被忽略了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Broken - violates symmetry!</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Broken - violates symmetry!</span></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString)</div><div class="line">         	<span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</div><div class="line">           	<span class="keyword">if</span> (o <span class="keyword">instanceof</span> String)  <span class="comment">// One-way interoperability!</span></div><div class="line">            	<span class="keyword">return</span> s.equalsIgnoreCase((String) o);</div><div class="line">           	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       	&#125;</div><div class="line">       	...  <span class="comment">// Remainder omitted</span></div><div class="line">   	&#125;</div></pre></td></tr></table></figure>
<p>The well-intentioned <code>equals</code> method in this class naively attempts to interoperate with ordinary strings. Let’s suppose that we have one case-insensitive string and one ordinary one:</p>
<p>这个类中，<code>equals</code>方法的意图很好，单纯的想要与普通的字符串进行互操作。假设我们有一个区分大小写的字符串和一个普通的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CaseInsensitiveString cis = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Polish"</span>);</div><div class="line">String s = <span class="string">"polish"</span>;</div></pre></td></tr></table></figure>
<p>As expected, <code>cis.equals(s)</code> returns <code>true</code>. The problem is that while the <code>equals</code> method in <code>CaseInsensitiveString</code> knows about ordinary strings, the <code>equals</code> method in <code>String</code> is oblivious to case-insensitive strings. Therefore <code>s.equals(cis)</code> returns <code>false</code>, a clear violation of symmetry. Suppose you put a case-insensitive string into a collection:</p>
<p>正如预料的那样，<code>cis.equals(s)</code>返回<code>true</code>。问题是虽然<code>CaseInsensitiveString</code>中的<code>equals</code>知道普通的字符串，但是<code>String</code>中的<code>equals</code>方法不注意不区分大小写的字符串。因此<code>s.equals(cis)</code>返回<code>false</code>，这明显违反了对称性。假设你将一个不区分大小写的字符串放到一个集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> ArrayList&lt;CaseInsensitiveString&gt;();</div><div class="line">list.add(cis);</div></pre></td></tr></table></figure>
<p>What does <code>list.contains(s)</code> return at this point? Who knows? In Sun’s current implementation, it happens to return <code>false</code>, but that’s just an implementation artifact. In another implementation, it could just as easily return <code>true</code> or throw a runtime exception. <strong>Once you’ve violated the <code>equals</code> contract, you simply don’t know how other objects will behave when confronted with your object.</strong></p>
<p>这时<code>list.contains(s)</code>会返回什么？谁知道呢？在Sun当前的实现中，它碰巧会返回<code>false</code>，但那仅是一种实现方案。在另一种实现中，它也可能很容易的返回<code>true</code>或抛出一个运行时异常。<strong>一旦你违反了<code>equals</code>约定，当面对你的对象时，你根本不指定其它的对象行为会怎样。</strong></p>
<p>To eliminate the problem, merely remove the ill-conceived attempt to interoperate with <code>String</code> from the <code>equals</code> method. Once you do this, you can refactor the method to give it a single return:</p>
<p>为了消除这个问题，只要从<code>equals</code>方法中移除与<code>String</code>进行交互的，考虑不周的尝试即可。一旦你这样做了，你可以重构这个方法给它一个返回即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Transitivity</strong>—The third requirement of the <code>equals</code> contract says that if one object is equal to a second and the second object is equal to a third, then the first object must be equal to the third. Again, it’s not hard to imagine violating this requirement unintentionally. Consider the case of a subclass that adds a new value component to its superclass. In other words, the subclass adds a piece of information that affects <code>equals</code> comparisons. Let’s start with a simple immutable two-dimensional integer point class:</p>
<p><strong>传递性</strong>——<code>equals</code>约定的第三个要求是说如果一个对象等价于第二个对象，而第二个对象等价于第三个对象，则第一个对象等价于第三个对象。同样的，不难想象会无意中违反这个要求。考虑这样一种情况，子类添加一个新的值组件到它的超类中。换句话说，子类添加的信息会影响<code>equals</code>比较。以一个简单的不可变的二维整数点类作为开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.y = y; </div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Point p = (Point)o;</div><div class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</div><div class="line">	&#125;</div><div class="line">    ...  <span class="comment">// Remainder omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Suppose you want to extend this class, adding the notion of color to a point:</p>
<p>假设你想扩展这个类，给点添加颜色的概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    ...  <span class="comment">// Remainder omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>How should the <code>equals</code> method look? If you leave it out entirely, the implementation is inherited from <code>Point</code> and color information is ignored in <code>equals</code> comparisons. While this does not violate the <code>equals</code> contract, it is clearly unacceptable. Suppose you write an <code>equals</code> method that returns <code>true</code> only if its argument is another color point with the same position and color:</p>
<p><code>equals</code>方法应该看起来是怎样的？如果一点也不修改，直接从<code>Point</code>继承<code>equals</code>方法，在进行<code>equals</code>比较时颜色信息会被忽略。虽然这没有违反<code>equals</code>约定，但很明显这是不可接受的。假设你写了一个<code>equals</code>方法，只有在它的参数是另一个有色点，且它们具有相同的位置和颜色时才返回<code>true</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Broken - violates symmetry!</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   	<span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The problem with this method is that you might get different results when comparing a point to a color point and vice versa. The former comparison ignores color, while the latter comparison always returns <code>false</code> because the type of the argument is incorrect. To make this concrete, let’s create one point and one color point:</p>
<p>这个方法的问题在于：当你比较一个普通点和一个有色点或相反的情况时，你可能会得到不同的结果。前者的比较忽略了颜色，而后者总是返回<code>false</code>，因为参数类型不正确。为了使这个更具体一点，我们创建一个普通点和一个有色点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</div></pre></td></tr></table></figure>
<p>Then <code>p.equals(cp)</code> returns <code>true</code>, while <code>cp.equals(p)</code> returns <code>false</code>. You might try to fix the problem by having <code>ColorPoint.equals</code> ignore color when doing “mixed comparisons”:</p>
<p><code>p.equals(cp)</code>返回<code>true</code>，而<code>cp.equals(p)</code>返回<code>false</code>。你可能想让<code>ColorPoint.equals</code>进行比较混合比较时忽略颜色来修正这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Broken - violates transitivity!</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   	<span class="comment">// If o is a normal Point, do a color-blind comparison</span></div><div class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</div><div class="line">        <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// o is a ColorPoint; do a full comparison</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint)o).color == color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This approach does provide symmetry, but at the expense of transitivity:</p>
<p>这个方法提供了对称性，但违反了传递性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</div><div class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</div></pre></td></tr></table></figure>
<p>Now <code>p1.equals(p2)</code> and <code>p2.equals(p3)</code> return <code>true</code>, while <code>p1.equals(p3)</code> returns <code>false</code>, a clear violation of transitivity. The first two comparisons are “color-blind,” while the third takes color into account.</p>
<p>现在<code>p1.equals(p2)</code>和<code>p2.equals(p3)</code>返回<code>true</code>，而<code>p1.equals(p3)</code>返回<code>false</code>，很明显这违反了传递性。前两个比较忽略了颜色，而第三个比较考虑了颜色。</p>
<p>So what’s the solution? It turns out that this is a fundamental problem of equivalence relations in object-oriented languages. <strong>There is no way to extend an instantiable class and add a value component while preserving the <code>equals</code> contract</strong>, unless you are willing to forgo the benefits of object-oriented abstraction.</p>
<p>因此解决方案是什么？事实证明：在面向对象语言中，等价关系问题是一个基本的问题。<strong>当保留<code>equals</code>约定时，你无法在扩展一个实例化的类的同时添加值组件，</strong>除非你愿意放弃面向对象抽象的优势。</p>
<p>You may hear it said that you can extend an instantiable class and add a value component while preserving the <code>equals</code> contract by using a <code>getClass</code> test in place of the <code>instanceof</code> test in the <code>equals</code> method:</p>
<p>你可能听说过你可以在<code>equals</code>方法中通过使用<code>getClass</code>测试代替<code>instanceof</code>测试，从而在扩展一个可实例化的类并添加值组件的同时，保留<code>equals</code>约定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Broken - violates Liskov substitution principle (page 40)</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || o.getClass() != getClass())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    Point p = (Point) o;</div><div class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This has the effect of equating objects only if they have the same implementation class. While this may not seem so bad, the consequences are unacceptable.</p>
<p>当且仅当它们具有相同的实现类时，上面的代码在比较对象时才会有效。虽然这不是很糟糕，但结果是不可接受的。</p>
<p>Let’s suppose we want to write a method to tell whether an integer point is on the unit circle. Here is one way we could do it:</p>
<p>假设我们想写一个方法来判断一个整数点是否在单位圆上。下面是一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Initialize UnitCircle to contain all Points on the unit circle private static final Set&lt;Point&gt; unitCircle;</span></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    unitCircle = <span class="keyword">new</span> HashSet&lt;Point&gt;();</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point( <span class="number">1</span>,  <span class="number">0</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point( <span class="number">0</span>,  <span class="number">1</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point(-<span class="number">1</span>,  <span class="number">0</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point( <span class="number">0</span>, -<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onUnitCircle</span><span class="params">(Point p)</span> </span>&#123;</div><div class="line">   	<span class="keyword">return</span> unitCircle.contains(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While this may not be the fastest way to implement the functionality, it works fine. But suppose you extend <code>Point</code> in some trivial way that doesn’t add a value component, say, by having its constructor keep track of how many instances have been created:</p>
<p>虽然这可能不是实现这个功能的最快方式，但它确实有效。但假设你以某种不添加值组件的方式扩展了<code>Point</code>，例如通过它的构造函数来追踪创建了多少实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberCreated</span><span class="params">()</span> </span>&#123; </div><div class="line">    	<span class="keyword">return</span> counter.get(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The Liskov substitution principle says that any important property of a type should also hold for its subtypes, so that any method written for the type should work equally well on its subtypes [Liskov87]. But suppose we pass a <code>CounterPoint</code> instance to the <code>onUnitCircle</code> method. If the <code>Point</code> class uses a <code>getClass</code> based <code>equals</code> method, the <code>onUnitCircle</code> method will return <code>false</code> regardless of the <code>CounterPoint</code> instance’s <code>x</code> and <code>y</code> values. This is so because collections, such as the <code>HashSet</code>，used by the <code>onUnitCircle</code> method, use the <code>equals</code> method to test for containment, and no <code>CounterPoint</code> instance is equal to any <code>Point</code>. If, however, you use a proper <code>instanceof</code>-based <code>equals</code> method on <code>Point</code>, the same <code>onUnitCircle</code> method will work fine when presented with a <code>CounterPoint</code>.</p>
<p>里氏替换原则认为，一个类型的任何重要属性也适用于它的子类型，因此该类型编写的任何方法在它的子类型中也都应该工作良好[Liskov87]。但假设我们给<code>onUnitCircle</code>传递了一个<code>CounterPoint</code>实例。如果<code>Point</code>类使用了基于<code>getClass</code>的<code>equals</code>方法，<code>onUnitCircle</code>将会返回<code>false</code>，无论<code>CounterPoint</code>实例的<code>x</code>值和<code>y</code>值是多少。这是因为集合，例如<code>onUnitCircle</code>方法中的<code>HashSet</code>，使用<code>equals</code>方法来测试是否包含元素，没有<code>CounterPoint</code>实例等于<code>Point</code>。然而，如果你在<code>Point</code>上使用合适的基于<code>instanceof</code>的<code>equals</code>方法，当面对<code>CounterPoint</code>时，同样的<code>onUnitCircle</code>方法会工作的很好。</p>
<p>While there is no satisfactory way to extend an instantiable class and add a value component, there is a fine workaround. Follow the advice of Item 16, “Favor composition over inheritance.” Instead of having <code>ColorPoint</code> extend <code>Point</code>, give <code>ColorPoint</code> a private <code>Point</code> field and a public view method (Item 5) that returns the point at the same position as this color point:</p>
<p>尽管没有令人满意的方式来扩展一个可实例化的类并添加值组件，但有一个很好的解决方案。遵循Item 16 “Favor composition over inheritance”的建议，不再让<code>ColorPoint</code>继承<code>Point</code>，而是通过在<code>ColorPoint</code>中添加一个私有的<code>Point</code>字段和一个公有的视图方法（Item 5），此方法返回一个与有色点具有相同位置的普通点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adds a value component without violating the equals contract</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>)</div><div class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        point = <span class="keyword">new</span> Point(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"> 	 * Returns the point-view of this color point.</div><div class="line"> 	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123; </div><div class="line">		<span class="keyword">return</span> point;</div><div class="line">	&#125;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</div><div class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        ColorPoint cp = (ColorPoint) o;</div><div class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</div><div class="line">	&#125;</div><div class="line">    ...  <span class="comment">// Remainder omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>There are some classes in the Java platform libraries that do extend an instantiable class and add a value component. For example, <code>java.sql.Timestamp</code> extends <code>java.util.Date</code> and adds a <code>nanoseconds</code> field. The <code>equals</code> implementation for <code>Timestamp</code> does violate symmetry and can cause erratic behavior if <code>Timestamp</code> and <code>Date</code> objects are used in the same collection or are otherwise intermixed. The <code>Timestamp</code> class has a disclaimer cautioning programmers against mixing dates and timestamps. While you won’t get into trouble as long as you keep them separate, there’s nothing to prevent you from mixing them, and the resulting errors can be hard to debug. This behavior of the <code>Timestamp</code> class was a mistake and should not be emulated.</p>
<p>在Java平台库中有一些类扩展了一个可实例化的类并添加了一个值组件。例如，<code>java.sql.Timestamp</code>扩展了<code>java.util.Date</code>并添加了一个<code>nanoseconds</code>字段。<code>Timestamp</code>的<code>equals</code>实现确实违反了对称性，如果<code>Timestamp</code>和<code>Date</code>用在同一个集合中或混杂在一起，会引起不稳定的行为。<code>Timestamp</code>类有一个免责声明，警告程序员不要混合日期和时间戳。虽然只要你将它们分开就不会有麻烦，但是没有任何东西阻止你混合它们，而且产生的错误很难调试。<code>Timestamp</code>类的这个行为是一个错误，不应该进行模仿。</p>
<p>Note that you can add a value component to a subclass of an abstract class without violating the <code>equals</code> contract. This is important for the sort of class hierarchies that you get by following the advice in Item 20, “Prefer class hierarchies to tagged classes.” For example, you could have an abstract class <code>Shape</code> with no value components, a subclass <code>Circle</code> that adds a <code>radius</code> field, and a subclass <code>Rectangle</code> that adds <code>length</code> and <code>width</code> fields. Problems of the sort shown above won’t occur so long as it is impossible to create a superclass instance directly.</p>
<p>注意，你可以添加值组件到抽象类的子类而且不会违反<code>equals</code>约定。对于遵循Item 20 “Prefer class hierarchies to tagged classes”的建议而得到这种类层次来说，这是非常重要的。例如，你可以有一个没有值组件的抽象类<code>Shape</code>，子类<code>Circle</code>添加了<code>radius</code>字段，子类<code>Rectangle</code>添加了<code>length</code>和<code>width</code>字段。只要不能直接创建一个超类实例，上面的种种问题就不会发生。</p>
<p><strong>Consistency</strong>—The fourth requirement of the <code>equals</code> contract says that if two objects are equal, they must remain equal for all time unless one (or both) of them is modified. In other words, mutable objects can be equal to different objects at different times while immutable objects can’t. When you write a class, think hard about whether it should be immutable (Item 15). If you conclude that it should, make sure that your <code>equals</code> method enforces the restriction that equal objects remain equal and unequal objects remain unequal for all time.</p>
<p><strong>一致性</strong>——<code>equals</code>约定的第四个要求是说如果两个对象相等，它们必须一致相等，除非其中一个（或二者）被修改了。换句话说，可变对象在不同的时间可以等于不同的对象而不可变对象不能。当你写了一个类，仔细想想它是否应该是不可变的(Item 15)。如果你推断它应该是不可变的，那么要确保你的<code>equals</code>方法满足这样的约束条件：相等的对象永远相等，不等的对象永远不等。</p>
<p>Whether or not a class is immutable, <strong>do not write an <code>equals</code> method that depends on unreliable resources</strong>. It’s extremely difficult to satisfy the consistency requirement if you violate this prohibition. For example, <code>java.net.URL</code>’s <code>equals</code> method relies on comparison of the IP addresses of the hosts associated with the URLs. Translating a host name to an <code>IP</code> address can require network access, and it isn’t guaranteed to yield the same results over time. This can cause the <code>URL equals</code> method to violate the <code>equals</code> contract and has caused problems in practice. (Unfortunately, this behavior cannot be changed due to compatibility requirements.) With very few exceptions, <code>equals</code> methods should perform deterministic computations on memory-resident objects.</p>
<p>无论一个类是否是不可变的，<strong>都不要写一个依赖于不可靠资源的<code>equals</code>方法</strong>。如果你违反了这个禁令，要满足一致性要求是非常困难的。例如，<code>java.net.URL</code>的<code>equals</code>方法依赖于对关联URL主机的IP地址的比较。将主机名转换成IP地址可能需要访问网络，随时间推移它不能保证取得相同的结果。这可能会导致<code>URL equals</code>方法违反<code>equals</code>约定并在实践中产生问题。（很遗憾，由于兼容性问题，这一行为不能被修改。）除了极少数例外，<code>equals</code>方法应该对常驻内存对象进行确定性计算。</p>
<p>“<strong>Non-nullity</strong>”—The final requirement, which in the absence of a name I have taken the liberty of calling “non-nullity,” says that all objects must be unequal to <code>null</code>. While it is hard to imagine accidentally returning <code>true</code> in response to the invocation <code>o.equals(null)</code>, it isn’t hard to imagine accidentally throwing a <code>NullPointerException</code>. The general contract does not allow this. Many classes<br>have <code>equals</code> methods that guard against this with an explicit test for <code>null</code>:</p>
<p>“<strong>非空性</strong>”——最后的要求由于没有名字我称之为“非空性”，这个要求是说所有的对象都不等于<code>null</code>。虽然很难想象调用<code>o.equals(null)</code>会偶然的返回<code>true</code>，但不难想象会意外抛出<code>NullPointerException</code>的情况。通用约定不允许出现这种情况。许多类的<code>equals</code>方法为了防止出现这种情况都进行对<code>null</code>的显式测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This test is unnecessary. To test its argument for equality, the <code>equals</code> method must first cast its argument to an appropriate type so its accessors may be invoked or its fields accessed. Before doing the cast, the method must use the <code>instanceof</code> operator to check that its argument is of the correct type:</p>
<p>这个测试是没必要的。为了平等测试其参数，为了调用它的访问器或访问其字段，<code>equals</code>方法首先必须将它的参数转换成合适的类型。在进行转换之前，<code>equals</code>方法必须使用<code>instanceof</code>操作符来检查它的参数是否是正确的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyType))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    MyType mt = (MyType) o;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If this type check were missing and the <code>equals</code> method were passed an argument of the wrong type, the <code>equals</code> method would throw a <code>ClassCastException</code>, which violates the <code>equals</code> contract. But the <code>instanceof</code> operator is specified to return <code>false</code> if its first operand is <code>null</code>, regardless of what type appears in the second operand [JLS, 15.20.2]. Therefore the type check will return <code>false</code> if <code>null</code> is passed in, so you don’t need a separate <code>null</code> check.</p>
<p>如果缺少类型检查，<code>equals</code>方法传入了一个错误类型的参数，<code>equals</code>方法会抛出<code>ClassCastException</code>，这违反了<code>equals</code>约定。但当指定<code>instanceof</code>时，如果它的第一个操作数为<code>null</code>，无论它的第二个操作数是什么类型，它都会返回<code>false</code>[JLS, 15.20.2]。所以如果传入<code>null</code>类型检查将会返回<code>false</code>，因此你不必进行单独的<code>null</code>检查。</p>
<p>Putting it all together, here’s a recipe for a high-quality <code>equals</code> method:</p>
<ol>
<li><p><strong>Use the == operator to check if the argument is a reference to this object</strong>. If so, return <code>true</code>. This is just a performance optimization, but one that is worth doing if the comparison is potentially expensive.</p>
</li>
<li><p><strong>Use the <code>instanceof</code> operator to check if the argument has the correct type</strong>. If not, return <code>false</code>. Typically, the correct type is the class in which the method occurs. Occasionally, it is some interface implemented by this class. Use an interface if the class implements an interface that refines the <code>equals</code> contract to permit comparisons across classes that implement the interface. Collection interfaces such as <code>Set</code>, <code>List</code>, <code>Map</code>, and <code>Map.Entry</code> have this property.</p>
</li>
<li><p><strong>Cast the argument to the correct type</strong>. Because this cast was preceded by an <code>instanceof</code> test, it is guaranteed to succeed.</p>
</li>
<li><p><strong>For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object. </strong>If all these tests succeed, return <code>true</code>; otherwise, return <code>false</code>. If the type in step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.</p>
</li>
</ol>
<p>将上面所有的内容放在一起，下面是编写一个高质量<code>equals</code>方法的流程：</p>
<ol>
<li><p><strong>使用<code>==</code>操作符来检查参数是否是这个对象的一个引用，。</strong>如果是，返回<code>true</code>。这只是一个性能优化，如果比较的代价有可能很昂贵，这样做是值得的。</p>
</li>
<li><p><strong>使用<code>instanceof</code>操作符来检查参数类型是否正确。</strong>如果不正确，返回<code>false</code>。通常，正确的类型是指<code>equals</code>方法所在的那个类。有时候，它是这个类实现的一些接口。如果一个类实现了一个接口，这个接口提炼了<code>equals</code>约定来允许比较那些实现了这个接口类，那么就使用接口。集合接口例如<code>Set</code>，<code>List</code>，<code>Map</code>和<code>Map.Entry</code>都有这个属性。</p>
</li>
<li><p><strong>将参数转换成正确的类型。</strong>由于转换测试已经被<code>instanceof</code>在之前做了，因此它保证能成功。</p>
</li>
<li><p><strong>对于类中的每一个“有效”字段，检查参数的这个字段是否匹配这个对象的对应字段。</strong>如果所有的这些测试都成功了，返回<code>true</code>；否则返回<code>false</code>。如果第二步中的类型是一个接口，你必须通过接口方法访问参数的字段；如果类型是一个类，你可能要直接访问字段，依赖于它们的可访问性。</p>
</li>
</ol>
<p>For primitive fields whose type is not <code>float</code> or <code>double</code>, use the <code>==</code> operator for comparisons; for object reference fields, invoke the <code>equals</code>method recursively; for <code>float</code> fields, use the <code>Float.compare</code> method; and for <code>double</code> fields, use <code>Double.compare</code>. The special treatment of <code>float</code> and <code>double</code> fields is made necessary by the existence of <code>Float.NaN</code>, <code>-0.0f</code> and the analogous <code>double</code> constants; see the <code>Float.equals</code> documentation for details. For array fields, apply these guidelines to each element. If every element in an array field is significant, you can use one of the <code>Arrays.equals</code> methods added in release 1.5.</p>
<p>对于基本类型，如果不是<code>float</code>或<code>double</code>，使用<code>==</code>操作符进行比较；对于对象引用字段，递归地调用<code>equals</code>方法；对于<code>float</code>自动，使用<code>Float.compare</code>方法；对于<code>double</code>字段，使用<code>Double.compare</code>。<code>float</code>和<code>double</code>字段的特别对待是有必要的，因为存在<code>Float.NaN</code>，<code>-0.0f</code>和类似的<code>double</code>常量；更多细节请看<code>Float.equals</code>。对于数组字段，对每个元素应用这些指导。如果数组中的每个元素都是有意义的，你可以使用1.5版本中添加的<code>Arrays.equals</code>方法。</p>
<p>Some object reference fields may legitimately contain <code>null</code>. To avoid the possibility of a <code>NullPointerException</code>, use this idiom to compare such fields:</p>
<p>某些对象引用字段可能合理的包含<code>null</code>。为了避免产生<code>NullPointerException</code>的可能性，使用下面的习惯用法来比较这些字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(field == null ? o.field == null : field.equals(o.field))</div></pre></td></tr></table></figure>
<p>This alternative may be faster if <code>field</code> and <code>o.field</code> are often identical:</p>
<p>如果<code>field</code>和<code>o.field</code>经常是等价的，使用下面的可替代方式可能会更快：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(field == o.field || (field != null &amp;&amp; field.equals(o.field)))</div></pre></td></tr></table></figure>
<p>For some classes, such as <code>CaseInsensitiveString</code> above, field comparisons are more complex than simple equality tests. If this is the case, you may want to store a canonical form of the field, so the <code>equals</code> method can do cheap exact comparisons on these canonical forms rather than more costly inexact comparisons. This technique is most appropriate for immutable classes (Item 15); if the object can change, you must keep the canonical form up to date.</p>
<p>对于某些类而言，例如上面的<code>CaseInsensitiveString</code>，字段比较比简单的相等性检测更复杂。如果是这种情况，你可能想存储这个字段的标准形式，因此<code>equals</code>方法可以在这些标准形式上进行低开销的精确比较，而不是更高代码的非精确比较。这种技术最适合不可变类（Item 15）；如果对象可以改变，你必须保持最新的标准形式。</p>
<p>The performance of the <code>equals</code> method may be affected by the order in which fields are compared. For best performance, you should first compare fields that are more likely to differ, less expensive to compare, or, ideally, both. You must not compare fields that are not part of an object’s logical state, such as <code>Lock</code> fields used to synchronize operations. You need not compare redundant fields, which can be calculated from “significant fields,” but doing so may improve the performance of the <code>equals</code> method. If a redundant field amounts to a summary description of the entire object, comparing this field will save you the expense of comparing the actual data if the comparison fails. For example, suppose you have a <code>Polygon</code> class, and you cache the area. If two polygons have unequal areas, you needn’t bother comparing their edges and vertices.</p>
<p><code>equals</code>方法的性能可能会受到字段比较顺序的影响。为了最佳性能，你首先应该比较那些更可能不同，比较代价更小的字段，或者理想情况下二者兼具的字段。你不能比较那些不属于对象逻辑状态一部分的字段，例如同步操作中的<code>Lock</code>字段。你也不需要比较冗余的字段，它们能从“有意义字段”中计算出来，但这样做可能会改善<code>equals</code>方法的性能。如果冗余字段相当于整个对象的概要描述，比较这个字段，如果失败的话会节省你比较真正数据的开销。例如，假设你有一个<code>Polygon</code>类，并且你缓存这个区域。如果两个多边形有不同的面积，你就不需要比较它们的边和顶点。</p>
<ol>
<li><p>When you are finished writing your <code>equals</code> method, ask yourself three questions: Is it symmetric? Is it transitive? Is it consistent? And don’t just ask yourself; write unit tests to check that these properties hold! If they don’t, figure out why not, and modify the <code>equals</code> method accordingly. Of course your <code>equals</code> method also has to satisfy the other two properties (reflexivity and “non-nullity”), but these two usually take care of themselves.</p>
</li>
<li><p>当你完成了<code>equals</code>方法的编写时，问你自己三个问题：它是否是对称的？是否是可传递的？是否是一致的？并且不要只问你自己；编写单元测试来检查是否拥有这些属性！如果没有这些属性，弄清楚为什么没有，对应的修改<code>equals</code>方法。当然你的<code>equals</code>方法也必须满足其它两个属性（自反性和“非空性”），但这两个属性通常会自动满足。</p>
</li>
</ol>
<p>For a concrete example of an <code>equals</code> method constructed according to the above recipe, see <code>PhoneNumber.equals</code> in Item 9. Here are a few final caveats:</p>
<p>根据上述规则构建的<code>equals</code>方法具体例子请看Item 9的PhoneNumber.equals`。下面是一些最后的警告：</p>
<ul>
<li><p><strong>Always override <code>hashCode</code> when you override <code>equals</code>(Item9)</strong>.</p>
</li>
<li><p><strong>当你重写<code>equals</code>时，总是重写<code>hashCode</code>方法(Item9)</strong>。</p>
</li>
<li><p><strong>Don’t try to be too clever</strong>. If you simply test fields for equality, it’s not hard to adhere to the <code>equals</code> contract. If you are overly aggressive in searching for equivalence, it’s easy to get into trouble. It is generally a bad idea to take any form of aliasing into account. For example, the <code>File</code> class shouldn’t attempt to equate symbolic links referring to the same file. Thankfully, it doesn’t.</p>
</li>
<li><p><strong>不要试图自作聪明。</strong>如果你简单的测试字段的相等性，不难遵循<code>equals</code>约定。如果过度的追求等价关系，很容易陷入到麻烦中。考虑任何形式的别名通常不是一个好想法。例如，<code>File</code>类不应该试图把指向同名的符号链接看作相等。所幸它没有这样做。</p>
</li>
<li><p><strong>Don’t substitute another type for <code>Object</code> in the <code>equals</code> declaration</strong>.It is not uncommon for a programmer to write an <code>equals</code> method that looks like this, and then spend hours puzzling over why it doesn’t work properly:</p>
</li>
<li><p><strong>不要将<code>equals</code>声明中的<code>Object</code>对象替换为其它对象。</strong>对于程序员来讲，写一个<code>equals</code>方法看起来像下面的一样是不常见的，并且花费了好几个小时都不明白它为什么不能正确工作：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(MyClass o)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The problem is that this method does not override <code>Object.equals</code>, whose argument is of type <code>Object</code>, but overloads it instead (Item 41). It is acceptable to provide such a “strongly typed” <code>equals</code> method in addition to the normal one as long as the two methods return the same result, but there is no compelling reason to do so. It may provide minor performance gains under certain circumstances, but it isn’t worth the added complexity (Item 55).</p>
<p>这个问题在于这个方法没有重写<code>Object.equals</code>方法，<code>Object.equals</code>方法的参数类型是<code>Object</code>，但相反，它重载了<code>equals</code>方法(Item 41)。除了正常的<code>equals</code>方法之外，提供这样一个“强类型”<code>equals</code>方法是可接受的，只要这两个方法返回同样的结果，但没有令人信服的理由去这样做。在某些特定环境下它可能会提供很小的收益，但相对于增加的复杂性来讲是不值得的（Item 55）。</p>
<p>Consistent use of the <code>@Override</code> annotation, as illustrated throughout this item, will prevent you from making this mistake (Item 36). This <code>equals</code> method won’t compile and the error message will tell you exactly what is wrong:</p>
<p>正如本条目阐述的那样，<code>@Override</code>注解的一致使用会阻止你犯这个错误(Item 36)。这个<code>equals</code>方法不能编译并且错误信息会确切告诉你错误是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(MyClass o)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>如果有收获，可以请我喝杯咖啡！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="https://user-images.githubusercontent.com/21311442/54660728-7c650300-4b12-11e9-9b0a-1a5c09323afe.png" alt="Tyan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="https://user-images.githubusercontent.com/21311442/54660740-87b82e80-4b12-11e9-96e4-911014779bdc.png" alt="Tyan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/24/2016-11-24-Java instanceof操作符/" rel="next" title="Java instanceof操作符">
                <i class="fa fa-chevron-left"></i> Java instanceof操作符
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/24/2016-11-24-Effective Java 2.0_中文版_Item 8/" rel="prev" title="Effective Java 2.0_中文版_Item 8">
                Effective Java 2.0_中文版_Item 8 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tyan" />
          <p class="site-author-name" itemprop="name">Tyan</p>
           
              <p class="site-description motion-element" itemprop="description">工作中的技术总结</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">632</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER3-Methods-Common-to-All-Objects"><span class="nav-number">1.</span> <span class="nav-text">CHAPTER3 Methods Common to All Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-8-Obey-the-general-contract-when-overriding-equals"><span class="nav-number">1.1.</span> <span class="nav-text">Item 8: Obey the general contract when overriding equals</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyan</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  
    <script id="dsq-count-scr" src="https://snailtyan.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://noahsnail.com/2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/';
        this.page.identifier = '2016/11/24/2016-11-24-Effective Java 2.0_中英文对照_Item 8/';
        this.page.title = 'Effective Java 2.0_中英文对照_Item 8';
      };
      var d = document, s = d.createElement('script');
      s.src = 'https://snailtyan.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    </script>
  




	





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
