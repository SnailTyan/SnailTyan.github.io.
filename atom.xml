<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="noahsnail.com/"/>
  <updated>2017-04-09T10:16:31.000Z</updated>
  <id>noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode402——Remove K Digits</title>
    <link href="noahsnail.com/2017/04/09/2017-4-9-Leetcode402%E2%80%94%E2%80%94%20Remove%20K%20Digits/"/>
    <id>noahsnail.com/2017/04/09/2017-4-9-Leetcode402—— Remove K Digits/</id>
    <published>2017-04-09T06:09:34.000Z</published>
    <updated>2017-04-09T10:16:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p>
<p>Note:<br>The length of num is less than 10002 and will be ≥ k.<br>The given num does not contain any leading zero.<br>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;1432219&quot;, k = 3</div><div class="line">Output: &quot;1219&quot;</div><div class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</div></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;10200&quot;, k = 1</div><div class="line">Output: &quot;200&quot;</div><div class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</div></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;10&quot;, k = 2</div><div class="line">Output: &quot;0&quot;</div><div class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>每移除一个字符，找出移除一个字符串后得到的字符串中最小的那个，作为下一次移除字符的输入，这样每次移除字符后得到子串都是最小子串。这里必须要明确每次移除字符的最优解必定是下一次移除字符最优解的输入，即f(n)的最优解必定是求解f(n-1)的最优解的一部分。问题的最优解解中包含了子问题的最优解。</p>
<p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public String removeKdigits(String num, int k) &#123;</div><div class="line">        String min = remove(num, k);</div><div class="line">        if(min.equals(&quot;&quot;)) &#123;</div><div class="line">            return &quot;0&quot;;</div><div class="line">        &#125;</div><div class="line">        while(min.charAt(0) == &apos;0&apos;) &#123;</div><div class="line">            if(min.length() == 1) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            min = min.substring(1, min.length());</div><div class="line">        &#125;</div><div class="line">        return min;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public String remove(String num, int k) &#123;</div><div class="line">        if(k == 0) &#123;</div><div class="line">            return num;</div><div class="line">        &#125;</div><div class="line">        int n = num.length();</div><div class="line">        String minString = num.substring(0, num.length() - 1);</div><div class="line">        for(int i = 0; i &lt; n; i++) &#123;</div><div class="line">            String temp = num.substring(0, i) + num.substring(i + 1, n);</div><div class="line">            if(temp.compareTo(minString) &lt; 0) &#123;</div><div class="line">                minString = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return remove(minString, k - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode超时。</p>
<p><strong>方法二</strong></p>
<p>要想数字变小，应该从前往后删除字符，因为前面的字符是数字的高位，在删除一个字符的情况下，删除数字的位置会被它的后一位替代，因此应该删除当前数字大于后一位数字的字符。如果前面没有找到符合条件的数字，则删除最后一位数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">       public String removeKdigits(String num, int k) &#123;</div><div class="line">    	//用StringBuilder是因为StringBuilder有删除指定字符的功能</div><div class="line">        StringBuilder min = new StringBuilder(num);</div><div class="line">        for(int m = 0; m &lt; k; m++) &#123;</div><div class="line">            int index = 0;</div><div class="line">            int n = min.length();</div><div class="line">            for(int i = 0; i &lt; n; i++) &#123;</div><div class="line"></div><div class="line">                if((i == n -1) || min.charAt(i) &gt; min.charAt(i + 1)) &#123;</div><div class="line">                    index = i;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            min = min.deleteCharAt(index);</div><div class="line">        &#125;</div><div class="line">        //判断字符串为空的情况</div><div class="line">        if(min.length() == 0) &#123;</div><div class="line">            return &quot;0&quot;;</div><div class="line">        &#125;</div><div class="line">        //去掉字符串前面的“0”</div><div class="line">        while(min.charAt(0) == &apos;0&apos;) &#123;</div><div class="line">            if(min.length() == 1) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            min = min.deleteCharAt(0);</div><div class="line">        &#125;</div><div class="line">        return min.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode402—— Remove K Digits
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow的基本用法(二)</title>
    <link href="noahsnail.com/2017/04/08/2017-4-8-tensorflow%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%BA%8C)/"/>
    <id>noahsnail.com/2017/04/08/2017-4-8-tensorflow的基本用法(二)/</id>
    <published>2017-04-08T15:37:15.000Z</published>
    <updated>2017-04-09T06:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是使用tensorflow进行矩阵的乘法运算。代码中介绍了两种不同的使用session的方式。Demo源码及解释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">import tensorflow as tf</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"># 定义两个矩阵</div><div class="line">matrix1 = tf.constant([[3, 3]])</div><div class="line">matrix2 = tf.constant([[2], [2]])</div><div class="line"></div><div class="line"># 定义矩阵乘法</div><div class="line">product = tf.matmul(matrix1, matrix2)</div><div class="line"></div><div class="line"># 运行矩阵乘法，session用法一</div><div class="line">sess = tf.Session()</div><div class="line">result = sess.run(product)</div><div class="line">print &apos;Session用法一&apos;</div><div class="line">print result</div><div class="line">sess.close()</div><div class="line"></div><div class="line">## session用法二，不用考虑close，会自动关闭</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">	result = sess.run(product)</div><div class="line">	print &apos;Session用法二&apos;</div><div class="line">	print result</div></pre></td></tr></table></figure>
<p>执行结果如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Session用法一</div><div class="line">[[12]]</div><div class="line">Session用法二</div><div class="line">[[12]]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      tensorflow的基本用法(二)
    
    </summary>
    
      <category term="tensorflow" scheme="noahsnail.com/categories/tensorflow/"/>
    
    
      <category term="tensorflow" scheme="noahsnail.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow的基本用法(一)</title>
    <link href="noahsnail.com/2017/04/08/2017-4-8-tensorflow%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>noahsnail.com/2017/04/08/2017-4-8-tensorflow的基本用法/</id>
    <published>2017-04-08T15:07:03.000Z</published>
    <updated>2017-04-08T15:27:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是以求解线性回归的参数为例，讲解一下tensorflow的用法。下面的代码中我们自己构建了一个线性回归模型<code>y = 0.1 * x + 0.3</code>，然后我们使用tensorflow来进行了求解。Demo源码及解释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">import tensorflow as tf</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"># 随机生成100个浮点数</div><div class="line">x_data = np.random.rand(100).astype(np.float32)</div><div class="line"># y=0.1*x+0.3，这样就构造了训练数据(x_data,y_data)</div><div class="line">y_data = x_data * 0.1 + 0.3</div><div class="line"></div><div class="line"># 定义线性回归的权重参数</div><div class="line">Weights = tf.Variable(tf.random_uniform([1], -1.0, 1.0))</div><div class="line"># 定义线性回归的偏置参数</div><div class="line">Biases = tf.Variable(tf.zeros([1]))</div><div class="line"></div><div class="line"># 构建线性回归模型</div><div class="line">y = Weights * x_data + Biases</div><div class="line"># 计算线性回归的损失函数</div><div class="line">loss = tf.reduce_mean(tf.square(y - y_data))</div><div class="line"></div><div class="line"># 定义线性回归的求解方法，梯度下降法，学习率为0.5</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(0.5)</div><div class="line"># 使用tensorflow求解</div><div class="line">train = optimizer.minimize(loss)</div><div class="line"># 初始化tensorflow的所有变量</div><div class="line">init = tf.initialize_all_variables()</div><div class="line"># 定义tensorflow的session</div><div class="line">sess = tf.Session()</div><div class="line"># 将初始化数据放入到session中，执行时会用到</div><div class="line">sess.run(init)</div><div class="line"></div><div class="line"># 迭代201次求解线性回归参数</div><div class="line">for step in range(201):</div><div class="line">	# session执行训练</div><div class="line">	sess.run(train)</div><div class="line">	if step % 20 == 0:</div><div class="line">		# 每迭代二十次输出一次结果</div><div class="line">		print step, sess.run(Weights), sess.run(Biases)</div></pre></td></tr></table></figure>
<p>执行结果如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0 [ 0.46898228] [ 0.12989661]</div><div class="line">20 [ 0.18490312] [ 0.25323763]</div><div class="line">40 [ 0.1203066] [ 0.28881568]</div><div class="line">60 [ 0.10485679] [ 0.29732502]</div><div class="line">80 [ 0.10116163] [ 0.29936022]</div><div class="line">100 [ 0.10027781] [ 0.29984701]</div><div class="line">120 [ 0.10006645] [ 0.29996341]</div><div class="line">140 [ 0.10001589] [ 0.29999125]</div><div class="line">160 [ 0.10000382] [ 0.29999793]</div><div class="line">180 [ 0.10000091] [ 0.29999951]</div><div class="line">200 [ 0.10000024] [ 0.29999989]</div></pre></td></tr></table></figure>
<p>从结果中可以看出，求解的结果还是很准确的。</p>
]]></content>
    
    <summary type="html">
    
      tensorflow的基本用法(一)
    
    </summary>
    
      <category term="tensorflow" scheme="noahsnail.com/categories/tensorflow/"/>
    
    
      <category term="tensorflow" scheme="noahsnail.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode78——Subsets</title>
    <link href="noahsnail.com/2017/04/08/2017-4-8-Leetcode78%E2%80%94%E2%80%94Subsets/"/>
    <id>noahsnail.com/2017/04/08/2017-4-8-Leetcode78——Subsets/</id>
    <published>2017-04-08T14:30:15.000Z</published>
    <updated>2017-04-08T15:00:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = <code>[1,2,3]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>递归法</strong></p>
<p>这道题类似于数组的组合问题，可以用递归法求解。N个数中每个数都分为要与不要两种情况，求解的过程如下图。递归的边界条件为N个数都遍历完了。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/subset.png" alt="递归过程"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public static List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</div><div class="line">        result.clear();</div><div class="line">        result.add(new ArrayList&lt;Integer&gt;());</div><div class="line">        combination(nums, 0, new ArrayList&lt;Integer&gt;());</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void combination(int[] nums, int index, List&lt;Integer&gt; list) &#123;</div><div class="line">        if(index == nums.length) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        combination(nums, index + 1, new ArrayList&lt;Integer&gt;(list));</div><div class="line">        list.add(nums[index]);</div><div class="line">        result.add(list);</div><div class="line">        combination(nums, index + 1, new ArrayList&lt;Integer&gt;(list));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode78——Subsets
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《异类》读书笔记</title>
    <link href="noahsnail.com/2017/04/08/2017-4-8-%E3%80%8A%E5%BC%82%E7%B1%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>noahsnail.com/2017/04/08/2017-4-8-《异类》读书笔记/</id>
    <published>2017-04-08T07:10:29.000Z</published>
    <updated>2017-04-08T09:54:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>《异类》的作者是马尔科姆-格拉德威尔，《异类》主要探究许多人成功背后的原因到底是什么。《异类》分为两大部分，第一部分主要是讲述机遇对人的影响；第二部分主要是讲文化对人的影响。</p>
<h2 id="第1章-马太效应"><a href="#第1章-马太效应" class="headerlink" title="第1章 马太效应"></a>第1章 马太效应</h2><p>第一章主要是讲述了马太效应。通常我们认为，个体特征的卓越是一个人出类拔萃的根本原因，但作者认为不是这样的。作者以加拿大冰球队的选手为例，分析了这些选手的出生时间，发现大多数选手都是出生在前三个月，为什么出生在前三个月的人能成功优秀的冰球选手呢？这主要是因为加拿大冰球队按年龄分组的分界线是1月1日，同一年龄的选手，出生在1月份的比出生在12月份的选手发育的时间更长，球员之间在生理成熟度上表现出巨大的差异，因此在冰球选拔时具有更大的优势，而当出生在1月份的选手被选入冰球队后，能获得更优秀的辅导，进行的训练比没选拔上的12月份的人更多，优势变得更大，优势慢慢的积累，最终变成了出生在1月份的人变成了优秀的冰球选手，而同年出生的12月份的人慢慢的变成了普通人，两者差距越来越大。这种情况主要是3种制度共通作用的结果：筛选、分组和区别训练。美国的棒球队，英国足球队都有类似的现象。从年龄大几个月的优势在孩子的成长过程中不断积累，最终导致孩子成功或不成功，正是这种领先优势造就了天才们辉煌的成就。在社会学领域，成功就是“优势积累的结果”。天才并非开始就出众，一开始他只是比别人优秀一点点。</p>
<p><strong>备注：</strong>马太效应（Matthew Effect），指强者愈强、弱者愈弱的现象。</p>
<p><strong>想法：</strong>感觉这是不是与国内的读书的重点班，预科班很像啊。不让孩子输在起跑线上还是有些道理的。</p>
<h2 id="第2章-10000小时法则"><a href="#第2章-10000小时法则" class="headerlink" title="第2章 10000小时法则"></a>第2章 10000小时法则</h2><p>10000小时法则是讲当某个人在某个领域练习10000小时时，他就能成为这个领域的专家。作者以Sun公司创始人和比尔盖茨为例，他们从小就接触电脑，当他们成年时他们已经达到了10000小时的训练量，因此当机会来临时他们能够很好的抓住机会并取得成功。成功是天赋加上后天努力，天赋的作用其实很小，而后天努力的作用其实很大。练习并不是为了让你一次就能把事情做好，而是帮助你越做约好。</p>
<p><strong>想法：</strong>确实挺有道理，很多时候别人成功不是因为别人比你聪明，而是因为别人比你更努力，练习的更多。</p>
<h2 id="第3、4章-天才之忧"><a href="#第3、4章-天才之忧" class="headerlink" title="第3、4章 天才之忧"></a>第3、4章 天才之忧</h2><p>这两章主要讲述了一个智商接近200的叫兰根的人，虽然他的天赋非常的好，但他却并没有取得成功。爱因斯坦的智商才150左右，智商120以上的人就可以称为聪明人了。那他为什么不成功呢？作者举了其它的研究人员研究的例子，小时候具有同样高智商的人，长大后有的很成功，有的一般，有的混的很惨。他们小时候具有同样的智商优势，长大后的成就却差别很大。研究发现，比较成功的人小时候家庭条件通常都很好，而比较差的人家庭条件通常较差。这是为什么呢？原来，智商与成功只在一定程度上相互关联，除了智商之外，还有一种“实践智力”，即与他人沟通、交流、良好协作的能力。这种“实践智力”通常是家庭条件较差的人缺乏的。社交知识是门学问，是一系列可以习得的技能，而富人的孩子这种能力通常较好。这其实就是一种阶级优势。作者以奥本海默的例子与兰根作了对比，两个人有类似的境遇却有不同的成就，原因就在于家庭环境。你应该想到了，兰根的家庭条件确实很差。</p>
<p><strong>想法：</strong>“实践智力”我认为就是我们所说的情商，家庭环境对人的影响很大，事实确实如此。看看现在的社会，北京孩子跟西部山区的孩子确实差距很大。</p>
<h2 id="第5章-乔弗洛姆的启示"><a href="#第5章-乔弗洛姆的启示" class="headerlink" title="第5章 乔弗洛姆的启示"></a>第5章 乔弗洛姆的启示</h2><p>第五章讲述了乔弗洛姆，美国世达律师事务所总裁的故事，讲述了莫里斯简克洛的故事，他们时常身处逆境，这些不利因素却常常称为他们的机遇之源。</p>
<p><strong>想法：</strong>中国的古话时势造英雄能很好的解释这章。</p>
<h2 id="第6章-小镇哈伦"><a href="#第6章-小镇哈伦" class="headerlink" title="第6章 小镇哈伦"></a>第6章 小镇哈伦</h2><p>这章主要讲述了美国肯塔基州坎伯兰高原上的小镇哈伦里的两大家族，霍华德家族和特纳家族的恩怨情仇。同时美国还有许多其它的地方存在类似的世仇，这种世仇的模式被称为阿巴拉契亚模式。最后的调查发现民族的文化遗产才是这些世仇的诱因。</p>
<p><strong>想法：</strong>不同地方的人有不同的文化，不同的行事方式，这就是文化传承的力量。</p>
<h2 id="第7章-飞机失事的族裔理论"><a href="#第7章-飞机失事的族裔理论" class="headerlink" title="第7章 飞机失事的族裔理论"></a>第7章 飞机失事的族裔理论</h2><p>第七章讲述的是韩国的飞机在以前失事的概率很高，分析了一些空难的原因，当然还有其它国家的空难，最终研究发现这些空难主要是由文化原因导致的。其中提到了一个权利距离指数的概念，即下位者对上位者的服从程度，是否敢于与上位者发表不同的意见。这主要是因为飞机上的副驾驶及其他人要在机长有问题时及时指出，以降低可能产生问题的风险。美国典型的是低权利距离的国家，而韩国属于高权利距离的国家。</p>
<p><strong>想法：</strong>权利指数分析的确实没错，而权利指数形成的原因主要是由文化背景决定。</p>
<h2 id="第8章-稻田与数学"><a href="#第8章-稻田与数学" class="headerlink" title="第8章 稻田与数学"></a>第8章 稻田与数学</h2><p>这章讲了我国南方主要种植稻田，同时分析了我们读数字与英语读数字的区别，作者发现造成东西方数学差异的可能是得益于我们的族裔文化。同时比较了东西方种植时间的差异，我国种植水稻一年的劳作时间比西方要多很多，我们的文化是建立在勤劳基础上的文化。我们的发音学数学有优势，我们的文化使我们学习很勤劳，我们的数学成绩高当然也应该是理所当然的。努力工作是所有成功人士的共性，而稻田中产生的文明精华是，通过努力工作，在巨大的不确定性和贫穷中寻找人生真正的价值。成功就是坚持不懈，顽强不屈，就是别人花30秒放弃的事情你花22分钟去坚定思考的坚定信念。</p>
<p><strong>想法：</strong>成功机遇、努力、坚持都是必备的品质，当然还要有一点运气，而这些品质就存在于我们的族裔文化中。</p>
<h2 id="第9章-玛丽塔之幸"><a href="#第9章-玛丽塔之幸" class="headerlink" title="第9章 玛丽塔之幸"></a>第9章 玛丽塔之幸</h2><p>作者分析了美国的一个在KIPP学院上学的穷人家孩子玛丽塔的作息表，她的学习时间比普通美国孩子要多得多，当然也因此取得了更好的成绩，因此她的命运比她之前有了很大的改变。</p>
<p><strong>想法：</strong>穷人还是只有努力才能改变自己的命运。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>作者讲述了他自己的家庭历史，通过一步步分析说明他母亲的是如何一点点成功的。成功人士是历史和环境的产物，是机遇与积累的结果。</p>
<p><strong>想法：</strong>现在就要努力，这样才能一点点改变你的命运，你孩子的命运，你后代的命运。</p>
<p><strong>总结：</strong>花了将近两个小时总结，最后自己也感觉不知所云，但推荐看一下《异类》。</p>
]]></content>
    
    <summary type="html">
    
      《异类》读书笔记
    
    </summary>
    
      <category term="社科人文" scheme="noahsnail.com/categories/%E7%A4%BE%E7%A7%91%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="杂谈" scheme="noahsnail.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode198——House Robber</title>
    <link href="noahsnail.com/2017/04/08/2017-4-8-Leetcode198%E2%80%94%E2%80%94House%20Robber/"/>
    <id>noahsnail.com/2017/04/08/2017-4-8-Leetcode198——House Robber/</id>
    <published>2017-04-08T02:47:08.000Z</published>
    <updated>2017-04-08T12:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>ou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong>递归法</p>
<p>递归法如下图所示，从第0家开始，偷与不偷有两种情况，如果偷了则从第2家开始重复此过程，如果没偷，从第1家开始重复此过程，直至结束。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="递归过程"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        return robot(0, nums);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int robot(int start, int[] nums) &#123;</div><div class="line">        if(start &gt;= nums.length) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int left = nums[start] + robot(start + 2, nums);</div><div class="line">        int right = 0 + robot(start + 1, nums);</div><div class="line">        int max = Math.max(left, right);</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode运行超时，说明存在优化空间。</p>
<p><strong>方法二</strong>递归法+缓存</p>
<p>从图中可以看出，上述过程中会有重复的计算，例如从第二家开始偷的情况计算了两次，我们可以用一个HashMap将计算过的数据保存起来，去掉冗余计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public static Map&lt;Integer, Integer&gt; cache = new HashMap&lt;Integer, Integer&gt;();</div><div class="line">    </div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        cache.clear();</div><div class="line">        if(nums.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        return robot(0, nums);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int robot(int start, int[] nums) &#123;</div><div class="line">        if(start &gt;= nums.length) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if(cache.containsKey(start)) &#123;</div><div class="line">            return cache.get(start);</div><div class="line">        &#125;</div><div class="line">        int left = nums[start] + robot(start + 2, nums);</div><div class="line">        int right = 0 + robot(start + 1, nums);</div><div class="line">        int max = Math.max(left, right);</div><div class="line">        cache.put(start, max);</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法三：</strong>非递归</p>
<p>将递归改造成非递归。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public static Map&lt;Integer, Integer&gt; cache = new HashMap&lt;Integer, Integer&gt;();</div><div class="line">    </div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        cache.clear();</div><div class="line">        if(nums.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int n = nums.length;</div><div class="line">        cache.put(n-1, nums[n - 1]);</div><div class="line">        for(int i = n - 2; i &gt;=0; i--) &#123;</div><div class="line">            int a = nums[i] + (cache.containsKey(i + 2) ? cache.get(i + 2) : 0);</div><div class="line">            int b = cache.containsKey(i + 1) ? cache.get(i + 1) : 0;</div><div class="line">            int max = Math.max(a, b);</div><div class="line">            cache.put(i, max);</div><div class="line">        &#125;</div><div class="line">        return cache.get(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法四：</strong>HashMap变为数组</p>
<p>为了节省空间，可以将HashMap变为数组，代码也可以进一步优化，去掉三目运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if(nums.length == 1) &#123;</div><div class="line">            return nums[0];</div><div class="line">        &#125;</div><div class="line">        if(nums.length == 2) &#123;</div><div class="line">            return Math.max(nums[0], nums[1]);</div><div class="line">        &#125;</div><div class="line">        int n = nums.length;</div><div class="line">        int[] cache = new int[n];</div><div class="line">        cache[n - 1] = nums[n - 1];</div><div class="line">        cache[n - 2] = Math.max(nums[n - 1], nums[n - 2]);</div><div class="line">        for(int i = n - 3; i &gt;=0; i--) &#123;</div><div class="line">            cache[i] = Math.max(nums[i] + cache[i + 2], cache[i + 1]);</div><div class="line">        &#125;</div><div class="line">        return cache[0];</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode198——House Robber
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ROC，AUC，Precision，Recall，F1的介绍与计算</title>
    <link href="noahsnail.com/2017/04/06/2017-4-6-ROC%E5%92%8CAUC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>noahsnail.com/2017/04/06/2017-4-6-ROC和AUC曲线的介绍与计算/</id>
    <published>2017-04-06T03:40:00.000Z</published>
    <updated>2017-04-07T10:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-ROC与AUC"><a href="#1-1-ROC与AUC" class="headerlink" title="1.1 ROC与AUC"></a>1.1 ROC与AUC</h3><p>ROC曲线和AUC常被用来评价一个二值分类器（binary classifier）的优劣，ROC曲线称为受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve），AUC（Area Under Curve）是ROC曲线下的面积。在计算ROC曲线之前，首先要了解一些基本概念。在二元分类模型的预测结果有四种，以判断人是否有病为例：</p>
<ul>
<li>真阳性（TP）：诊断为有，实际上也有病。</li>
<li>伪阳性（FP）：诊断为有，实际却没有病。</li>
<li>真阴性（TN）：诊断为没有，实际上也没有病。</li>
<li>伪阴性（FN）：诊断为没有，实际却有病。</li>
</ul>
<p>其关系如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/roc.png" alt="TP、FP、TN、FN"></p>
<p>ROC空间将伪阳性率（FPR）定义为X轴，真阳性率（TPR）定义为Y轴。TPR：在所有实际为阳性的样本中，被正确地判断为阳性之比率，$TPR=\frac {TP} {TP+FN}$ 。FPR：在所有实际为阴性的样本中，被错误地判断为阳性之比率，$FPR=\frac {FP} {FP+TN}$。</p>
<h3 id="1-2-Precision、Recall与F1"><a href="#1-2-Precision、Recall与F1" class="headerlink" title="1.2 Precision、Recall与F1"></a>1.2 Precision、Recall与F1</h3><p>对于二分类问题另一个常用的评价指标是精确率（precision）与召回率（recall）以及F1值。精确率表示在预测为阳性的样本中，真正有阳性的样本所占的比例。精确率的定义为$P=\frac {TP} {TP+FP}$。召回率表示所有真正呈阳性的样本中，预测为阳性所占的比例。召回率的定义为$R=\frac {TP} {TP+FN}$，F1值是精确率和召回率的调和均值，公式为$F1=\frac {2PR} {P+R}$。精确率和召回率都高时，F1值也会高。通常情况下，Precision与Recall是相互矛盾的。</p>
<h2 id="2-曲线介绍"><a href="#2-曲线介绍" class="headerlink" title="2. 曲线介绍"></a>2. 曲线介绍</h2><h3 id="2-1-ROC曲线"><a href="#2-1-ROC曲线" class="headerlink" title="2.1 ROC曲线"></a>2.1 ROC曲线</h3><p>ROC曲线坐标系如下图所示，虚线为随机猜测的概率，即猜对跟猜错的概率是一样的。理想情况下，我们是希望FPR为0，没有一个假阳性，TPR为1，即全为真阳性，此时所有样本都被正确分类，点位于左上角(0,1)位置处，没有一个分错的数据，这是最完美的情况，实际情况中基本不可能。如果点位于虚线下方，例如C点，说明分类错误的多，分类正确的少，此时不是我们想要的。如果点位于虚线上方，例如$C \prime$点，说明分类错误的少，分类正确的多，此时是我们想要的，因此我们希望ROC曲线尽可能的靠近左上角。对于一个特定的分类器和测试数据集，只能得到一个分类结果，即ROC曲线坐标系中的一点，那么如何得到一条ROC曲线呢？分类问题中我们经常会得到某个样本是正样本的概率，根据概率值与阈值的比较来判断某个样本是否是正样本。在不同的阈值下可以得到不同的TPR和FPR值，即可以得到一系列的点，将它们在图中绘制出来，并依次连接起来就得到了ROC曲线，阈值取值越多，ROC曲线越平滑。</p>
<p>AUC为ROC曲线下的面积，它的面积不会大于1，由于ROC曲线一般都处于直线y=x的上方，因此AUC的取值范围通常在(0.5，1)之间。由于ROC曲线不能很好的看出分类器模型的好坏，因此采用AUC值来进行分类器模型的评估与比较。通常AUC值越大，分类器性能越好。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/700px-ROC_space-2.png" alt="ROC曲线"></p>
<p>在基本概念中我们提到了精确率、召回率以及F1值，既然有它们作为二分类的评价指标，为什么还要使用ROC和AUC呢？这是因为ROC曲线有个很好的特性：当测试集中的正负样本分布发生变化时，即正负样本数量相差较大时，ROC曲线仍能保持不变。实际数据集中经常会出现样本数量不平衡现象，并且测试数据中的正负样本的分布也可能随着时间发生变化。下图是两个分类器模型（算法）的ROC曲线比较图：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/roc_com.png" alt="ROC曲线比较"></p>
<h3 id="2-2-P-R曲线"><a href="#2-2-P-R曲线" class="headerlink" title="2.2 P-R曲线"></a>2.2 P-R曲线</h3><p>在P-R曲线中，Precision为横坐标，Recall为纵坐标。在ROC曲线中曲线越凸向左上角约好，在P-R曲线中，曲线越凸向右上角越好。P-R曲线判断模型的好坏要根据具体情况具体分析，有的项目要求召回率较高、有的项目要求精确率较高。P-R曲线的绘制跟ROC曲线的绘制是一样的，在不同的阈值下得到不同的Precision、Recall，得到一系列的点，将它们在P-R图中绘制出来，并依次连接起来就得到了P-R图。两个分类器模型（算法）P-R曲线比较的一个例子如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/p-r.png" alt="P-R曲线比较"></p>
<h3 id="2-3-ROC与P-R对比"><a href="#2-3-ROC与P-R对比" class="headerlink" title="2.3 ROC与P-R对比"></a>2.3 ROC与P-R对比</h3><p>从公式计算中可以看出，ROC曲线中真阳性率TPR的计算公式与P-R曲线中的召回率Recall计算公式是一样的，即二者是同一个东西在不同环境下的不同叫法。当正负样本差距不大的情况下，ROC曲线和P-R的趋势是差不多的，但是当负样本很多的时候，ROC曲线效果依然较好，但是P-R曲线效果一般。</p>
<h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h2><p>待续。</p>
]]></content>
    
    <summary type="html">
    
      ROC，AUC，Precision，Recall，F1的介绍与计算
    
    </summary>
    
      <category term="机器学习" scheme="noahsnail.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Machine Learning" scheme="noahsnail.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode109——Convert Sorted List to Binary Search Tree</title>
    <link href="noahsnail.com/2017/03/24/2017-3-24-Leetcode109%E2%80%94%E2%80%94Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/"/>
    <id>noahsnail.com/2017/03/24/2017-3-24-Leetcode109——Convert Sorted List to Binary Search Tree/</id>
    <published>2017-03-24T01:17:38.000Z</published>
    <updated>2017-03-24T01:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题主要是根据一个有序链表构造二叉查找树（树的左结点小于根节点，根节点小于右结点，子树具有同样的性质）。与有序数组最大的不同在于有序链表只能从前往后遍历，不能像有序数组一样访问任意位置的元素。因此构造时需要按顺序构造，其实有序链表是二叉查找树的中序遍历。因此需要按照中序遍历的顺序进行构建，先构建左子树，再构造根节点，最后构造右子树。由于是链表，每次构造之后头结点应该进行移动，Java中用了一个静态变量来保存根节点的位置。构造方法主要是递归，每次构建子树时都需要将数组分成左右两半，左边的构建左子树，右边的构建右子树，中间元素构造根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    static ListNode h;</div><div class="line">    </div><div class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</div><div class="line">        if(head == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int length = 0;</div><div class="line">        h = head;</div><div class="line">        //得到链表长度</div><div class="line">        while(head != null) &#123;</div><div class="line">            length++;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        return buildBinarySearchTree(h, 0, length - 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public TreeNode buildBinarySearchTree(ListNode head, int start, int end) &#123;</div><div class="line">        if(start &gt; end) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int mid = (start + end) / 2;</div><div class="line">        //先构建左子树</div><div class="line">        TreeNode left = buildBinarySearchTree(h, start, mid - 1);</div><div class="line">        //再构造根节点</div><div class="line">        TreeNode root = new TreeNode(h.val);</div><div class="line">        h = h.next;</div><div class="line">        //最后构造右子树</div><div class="line">        TreeNode right = buildBinarySearchTree(h, mid + 1, end);</div><div class="line">        root.left = left;</div><div class="line">        root.right = right;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode109——Convert Sorted List to Binary Search Tree
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode108——Convert Sorted Array to Binary Search Tree</title>
    <link href="noahsnail.com/2017/03/23/2017-3-23-Leetcode108%E2%80%94%E2%80%94Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/"/>
    <id>noahsnail.com/2017/03/23/2017-3-23-Leetcode108——Convert Sorted Array to Binary Search Tree/</id>
    <published>2017-03-23T09:53:39.000Z</published>
    <updated>2017-03-24T01:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题主要是根据一个有序数组构造二叉查找树（树的左结点小于根节点，根节点小于右结点，子树具有同样的性质）。构造方法主要是递归，每次构建子树时都需要将数组分成左右两半，左边的构建左子树，右边的构建右子树，中间元素构造根节点。其实有序数组是二叉查找树的中序遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</div><div class="line">        return buildBinarySearchTree(nums, 0, nums.length - 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public TreeNode buildBinarySearchTree(int[] nums, int start, int end) &#123;</div><div class="line">        if(start &gt; end) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int mid = (start + end) / 2;</div><div class="line">        TreeNode root = new TreeNode(nums[mid]);</div><div class="line">        root.left = buildBinarySearchTree(nums, start, mid - 1);</div><div class="line">        root.right = buildBinarySearchTree(nums, mid + 1, end);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode108——Convert Sorted Array to Binary Search Tree
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode102——Binary Tree Level Order Traversal</title>
    <link href="noahsnail.com/2017/03/22/2017-3-22-Leetcode102%E2%80%94%E2%80%94Binary%20Tree%20Level%20Order%20Traversal/"/>
    <id>noahsnail.com/2017/03/22/2017-3-22-Leetcode102——Binary Tree Level Order Traversal/</id>
    <published>2017-03-22T03:42:38.000Z</published>
    <updated>2017-03-22T03:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [9,20],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的层次遍历问题，需要用到新的数据结构队列，把每一层的结点的子结点放入到队列中，依次遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        Queue&lt;TreeNode&gt; result = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;();</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            TreeNode temp = queue.poll();</div><div class="line">            level.add(temp.val);</div><div class="line">            if(temp.left != null) &#123;</div><div class="line">                result.add(temp.left);</div><div class="line">            &#125;</div><div class="line">            if(temp.right != null) &#123;</div><div class="line">                result.add(temp.right);</div><div class="line">            &#125;</div><div class="line">            if(queue.isEmpty()) &#123;</div><div class="line">                queue = result;</div><div class="line">                result = new LinkedList&lt;TreeNode&gt;();</div><div class="line">                list.add(level);</div><div class="line">                level = new ArrayList&lt;Integer&gt;();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode102——Binary Tree Level Order Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode145——Binary Tree Postorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode145%E2%80%94%E2%80%94Binary%20Tree%20Postorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode145——Binary Tree Postorder Traversal/</id>
    <published>2017-03-21T10:22:59.000Z</published>
    <updated>2017-03-21T10:24:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[3,2,1]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的后序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; left = postorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = postorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.addAll(right);</div><div class="line">        list.add(root.val);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode145——Binary Tree Postorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode94——Binary Tree Inorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode94%E2%80%94%E2%80%94Binary%20Tree%20Inorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode94——Binary Tree Inorder Traversal/</id>
    <published>2017-03-21T10:21:12.000Z</published>
    <updated>2017-03-21T10:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的中序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; left = inorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = inorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.add(root.val);</div><div class="line">        list.addAll(right);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode94——Binary Tree Inorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode144——Binary Tree Preorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode144%E2%80%94%E2%80%94Binary%20Tree%20Preorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode144——Binary Tree Preorder Traversal/</id>
    <published>2017-03-21T10:16:00.000Z</published>
    <updated>2017-03-21T10:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的先序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        list.add(root.val);</div><div class="line">        List&lt;Integer&gt; left = preorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = preorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.addAll(right);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode144——Binary Tree Preorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode3——Longest Substring Without Repeating Characters</title>
    <link href="noahsnail.com/2017/03/17/2017-3-17-Leetcode3%E2%80%94%E2%80%94Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>noahsnail.com/2017/03/17/2017-3-17-Leetcode3——Longest Substring Without Repeating Characters/</id>
    <published>2017-03-17T05:05:29.000Z</published>
    <updated>2017-04-01T10:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.</div><div class="line"></div><div class="line">Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.</div><div class="line"></div><div class="line">Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong></p>
<p>当遍历第i个字符时，需要判断<code>[index,i-1]</code>的字符中是否有与s[i]重复的字符，如果字符s[j]与s[i]重复，index直接变为j + 1，重新计算不重复字符的数量，如果<code>[index,i-1]</code>的字符中没有与s[i]重复的字符，则不重复字符计数<code>count++</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        int max = 0;</div><div class="line">        int count = 0;</div><div class="line">        int index = 0;</div><div class="line">        //[index,i-1]中是否有与s[i]重复的字符</div><div class="line">        boolean flag = false;</div><div class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            flag = false;</div><div class="line">            char ch = s.charAt(i);</div><div class="line">            //如果s[j]与s[i]重复，index直接变为j + 1，重新计算不重复字符数</div><div class="line">            for(int j = index; j &lt; i; j++) &#123;</div><div class="line">                if(s.charAt(j) == s.charAt(i)) &#123;</div><div class="line">                    flag = true;</div><div class="line">                    index = j + 1;</div><div class="line">                    count = i - j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(!flag) &#123;</div><div class="line">                count++;</div><div class="line">                if(count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>方法二的思路是看到有重复问题，首先想到哈希表，由于求解的是不重复子串，因此需要将子串分为两部分，一部分为(i，n-1)，一部分为(j，i)，如果s[i]不在(j，i)中，则将s[i]放入哈希表中，同时计数器加1，如果s[i]在(j，i)中，则找到(j，i)中与s[i]重复的字符ch，将其移除，当然ch之前的字符也要将其从哈希表中移除，因为包含ch的子串一定与s[i]重复，每移除一个字符，j++。重复上述过程，直至i到字符串最后。每一个找的子串是从(j,i)不重复的最长子串。这里的j是方法一中的index。思路与方法一是一致的，区别是使用哈希表来判断重复而不是使用循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;();</div><div class="line">        int max = 0;</div><div class="line">        int count = 0;</div><div class="line">        int j = 0;</div><div class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            char ch = s.charAt(i);</div><div class="line">            //如果有重复字符，逐个移除字符，直到移除了与第i个字符重复的字符</div><div class="line">            if(map.containsKey(ch)) &#123;</div><div class="line">                while(map.containsKey(ch)) &#123;</div><div class="line">                    map.remove(s.charAt(j));</div><div class="line">                    j++;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">                count++;</div><div class="line">                map.put(ch, ch);</div><div class="line">            &#125;else &#123;</div><div class="line">                map.put(ch, ch);</div><div class="line">                count++;</div><div class="line">                if(count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>备注：</strong>Leetcode测试时，发现方法一比方法二速度更快。</p>
]]></content>
    
    <summary type="html">
    
      Leetcode3——Longest Substring Without Repeating Characters
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode2——Add Two Numbers</title>
    <link href="noahsnail.com/2017/03/16/2017-3-16-Leetcode2%E2%80%94%E2%80%94Add%20Two%20Numbers/"/>
    <id>noahsnail.com/2017/03/16/2017-3-16-Leetcode2——Add Two Numbers/</id>
    <published>2017-03-16T06:40:37.000Z</published>
    <updated>2017-03-16T07:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</div><div class="line">Output: 7 -&gt; 0 -&gt; 8</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong></p>
<p>先求解两个链表的和，直接一个链表结束或两个链表同时结束，然后再处理没结束链表的剩下部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</div><div class="line">        int sum = 0;</div><div class="line">        int a = 0;</div><div class="line">        int b = 0;</div><div class="line">        int quotient = 0;</div><div class="line">        ListNode head = new ListNode(0);</div><div class="line">        ListNode current = head;</div><div class="line">        while(l1 != null &amp;&amp; l2 !=null) &#123;</div><div class="line">            a = l1.val;</div><div class="line">            b = l2.val;</div><div class="line">            sum = a + b + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            l1 = l1.next;</div><div class="line">            l2 = l2.next;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        ListNode temp = null;</div><div class="line">        if(l1 != null) &#123;</div><div class="line">            temp = l1;</div><div class="line">        &#125;else if(l2 != null) &#123;</div><div class="line">            temp = l2;</div><div class="line">        &#125;else &#123;</div><div class="line">            if(quotient != 0) &#123;</div><div class="line">                temp = new ListNode(0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while(temp != null) &#123;</div><div class="line">            sum = temp.val + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            temp = temp.next;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        if(quotient != 0) &#123;</div><div class="line">             current.next = new ListNode(quotient);</div><div class="line">        &#125;</div><div class="line">        return head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p>方法一中的代码有较多的冗余，例如<code>current.next = new ListNode(sum % 10);</code>出现了两次，两次while循环的逻辑是非常类似的，经过代码的变换可以将两部分合成一部分，即同时处理两个链表直至两个链表都结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</div><div class="line">        int sum = 0;</div><div class="line">        int a = 0;</div><div class="line">        int b = 0;</div><div class="line">        int quotient = 0;</div><div class="line">        ListNode head = new ListNode(0);</div><div class="line">        ListNode current = head;</div><div class="line">        while(l1 != null || l2 !=null) &#123;</div><div class="line">            if(l1 ==null) &#123;</div><div class="line">                a = 0;</div><div class="line">            &#125;else &#123;</div><div class="line">                a = l1.val;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;</div><div class="line">            if(l2 == null) &#123;</div><div class="line">                b = 0;</div><div class="line">            &#125;else &#123;</div><div class="line">                b = l2.val;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            sum = a + b + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        if(quotient != 0) &#123;</div><div class="line">             current.next = new ListNode(quotient);</div><div class="line">        &#125;</div><div class="line">        return head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode2——Add Two Numbers
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二值卷积神经网络</title>
    <link href="noahsnail.com/2017/03/15/2017-3-15-%E4%BA%8C%E5%80%BC%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>noahsnail.com/2017/03/15/2017-3-15-二值卷积神经网络/</id>
    <published>2017-03-15T09:22:00.000Z</published>
    <updated>2017-03-16T00:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="XNOR-Net-ImageNet-Classification-Using-Binary-Convolutional-Neural-Networks"><a href="#XNOR-Net-ImageNet-Classification-Using-Binary-Convolutional-Neural-Networks" class="headerlink" title="XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks"></a>XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks</h1><h1 id="XNOR-Net：使用二值卷积神经网络对ImageNet分类"><a href="#XNOR-Net：使用二值卷积神经网络对ImageNet分类" class="headerlink" title="XNOR-Net：使用二值卷积神经网络对ImageNet分类"></a>XNOR-Net：使用二值卷积神经网络对ImageNet分类</h1>]]></content>
    
    <summary type="html">
    
      二值卷积神经网络
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1——Two Sum</title>
    <link href="noahsnail.com/2017/03/15/2017-3-15-Leetcode1%E2%80%94%E2%80%94Two%20Sum/"/>
    <id>noahsnail.com/2017/03/15/2017-3-15-Leetcode1——Two Sum/</id>
    <published>2017-03-15T01:41:41.000Z</published>
    <updated>2017-03-16T02:29:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>解法一</strong></p>
<p>这个题最简单也是最容易的就是两层循环遍历，这个没什么可说的，时间复杂度为O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] twoSum(int[] nums, int target) &#123;</div><div class="line">        int result[] = new int[2];</div><div class="line">        int n = nums.length;</div><div class="line">        for(int i = 0; i &lt; n; i++) &#123;</div><div class="line">            for(int j = i + 1; j &lt; n; j++) &#123;</div><div class="line">                int sum = nums[i] + nums[j];</div><div class="line">                if(sum == target) &#123;</div><div class="line">                    result[0] = i;</div><div class="line">                    result[1] = j;</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode Accepted，Runtime: 45 ms。</p>
<p><strong>解法二</strong></p>
<p>思考一下，如何进行优化呢？首先，条件为<code>nums[i] + nums[j] = target</code>，已知target和nums[i]的情况下，能不能直接确定nums[j]在数组中是否存在呢？这是可以的，很容易想到map结构，当然数据结构要变换一下，而map的查询复杂度为O(1)，map结构的设计有两种，要不是key为整数，要不key为整数的索引。由于我们求的是整数的索引，因此应该将key设为整数，value为整数的索引。但key为整数有一个问题就是，如果数组中存在相同整数，则后一个放入的数值会覆盖前一个，因此需要单独处理。题目中明确说了一个输入只有一个解，因此如果出现两个整数相等的情况，只需要找到另一个数字的索引即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] twoSum(int[] nums, int target) &#123;</div><div class="line">        int result[] = new int[2];</div><div class="line">        int n = nums.length;</div><div class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</div><div class="line">        for(int i = 0; i &lt; n; i++) &#123;</div><div class="line">            int other = target - nums[i];</div><div class="line">            map.put(nums[i], i);</div><div class="line">            if(map.containsKey(other)) &#123;</div><div class="line">                //两个数字不等情况</div><div class="line">                if(other != nums[i]) &#123;</div><div class="line">                    //注意顺序</div><div class="line">                    result[0] = map.get(other);</div><div class="line">                    result[1] = i;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    //数字相等情况</div><div class="line">                    result[0] = i;</div><div class="line">                    for(int j = i + 1; j &lt; n; j++) &#123;</div><div class="line">                        if(nums[j] == other) &#123;</div><div class="line">                            result[1] = j;</div><div class="line">                            return result;</div><div class="line">                        &#125;</div><div class="line">                    &#125;  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode Accepted，Runtime: 12 ms。</p>
]]></content>
    
    <summary type="html">
    
      Leetcode1——Two Sum
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode155——Min Stack</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode155%E2%80%94%E2%80%94Min%20Stack/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode155——Min Stack/</id>
    <published>2017-03-14T14:46:56.000Z</published>
    <updated>2017-03-18T02:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MinStack minStack = new MinStack();</div><div class="line">minStack.push(-2);</div><div class="line">minStack.push(0);</div><div class="line">minStack.push(-3);</div><div class="line">minStack.getMin();   --&gt; Returns -3.</div><div class="line">minStack.pop();</div><div class="line">minStack.top();      --&gt; Returns 0.</div><div class="line">minStack.getMin();   --&gt; Returns -2.</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong><br>主要是模拟写一个最小栈。要注意push时可能会输入null。需要使用双栈实现，一个保存数据，一个保存最小值。由于随着数据出栈，最小值是不断变化的，因此需要一个最小值栈来保存最小值。方法一是最小值栈与普通栈大小不等的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class MinStack &#123;</div><div class="line">    private Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class="line">    private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</div><div class="line">            minStack.push(x);</div><div class="line">        &#125;</div><div class="line">        stack.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pop() &#123;</div><div class="line">        if(stack.peek().equals(minStack.peek())) &#123;</div><div class="line">            minStack.pop();</div><div class="line">        &#125;</div><div class="line">        stack.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int top() &#123;</div><div class="line">        return stack.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getMin() &#123;</div><div class="line">        return minStack.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>最小值栈与存储元素的栈大小始终相等的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class MinStack &#123;</div><div class="line">    private Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</div><div class="line">    private Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</div><div class="line">            minStack.push(x);</div><div class="line">        &#125;else &#123;</div><div class="line">            minStack.push(minStack.peek());</div><div class="line">        &#125;</div><div class="line">        stack.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pop() &#123;</div><div class="line">        minStack.pop();</div><div class="line">        stack.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int top() &#123;</div><div class="line">        return stack.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getMin() &#123;</div><div class="line">        return minStack.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode155——Min Stack
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode152——Maximum Product Subarray</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode152%E2%80%94%E2%80%94Maximum%20Product%20Subarray/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode152——Maximum Product Subarray/</id>
    <published>2017-03-14T10:37:05.000Z</published>
    <updated>2017-03-14T10:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题跟Leetcode 53——Maximum Subarray类似，可以用三重循环，两种循环解决。但最好的还是用动态规划解决，找出状态转移方程最关键。由于乘积可能为负数，负负得正，因此第<code>i-1</code>次的乘积最大值（maxValuePre）与最小值（minValuePre）都需要保留。当然也可以定义最大值最小值数组来保存第i次乘积的最大值（maxValue）与最小值（minValue）。与Maximum Subarray相比，最大值为<code>maxValue = max(minValuePre * nums[i], maxValuePre * nums[i], nums[i])</code>，最小值同样如此。</p>
<p><strong>没有定义最大值数组与最小值数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        int n = nums.length;</div><div class="line">        int maxValue = nums[0];</div><div class="line">        int minValue = nums[0];</div><div class="line">        int result = nums[0];</div><div class="line">        int maxValuePre = nums[0], minValuePre = nums[0];</div><div class="line">        for(int i = 1; i &lt; n; i++) &#123;</div><div class="line">            maxValue = Math.max(minValuePre * nums[i], Math.max(maxValuePre * nums[i], nums[i]));</div><div class="line">            minValue = Math.min(minValuePre * nums[i], Math.min(maxValuePre * nums[i], nums[i]));</div><div class="line">            if(maxValue &gt; result) &#123;</div><div class="line">                result = maxValue;</div><div class="line">            &#125;</div><div class="line">            maxValuePre = maxValue;</div><div class="line">            minValuePre = minValue;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>定义最大值数组与最小值数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        int n = nums.length;</div><div class="line">        int maxValue[] = new int[nums.length];</div><div class="line">        int minValue[] = new int[nums.length];</div><div class="line">        maxValue[0] = nums[0];</div><div class="line">        minValue[0] = nums[0];</div><div class="line">        int result = nums[0];</div><div class="line">        for(int i = 1; i &lt; n; i++) &#123;</div><div class="line">            maxValue[i] = Math.max(minValue[i - 1] * nums[i], Math.max(maxValue[i - 1] * nums[i], nums[i]));</div><div class="line">            minValue[i] = Math.min(minValue[i - 1] * nums[i], Math.min(maxValue[i - 1] * nums[i], nums[i]));</div><div class="line">            if(maxValue[i] &gt; result) &#123;</div><div class="line">                result = maxValue[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode152——Maximum Product Subarray
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode128——Longest Consecutive Sequence</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode128%E2%80%94%E2%80%94Longest%20Consecutive%20Sequence/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode128——Longest Consecutive Sequence/</id>
    <published>2017-03-14T10:14:21.000Z</published>
    <updated>2017-03-14T10:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>题中明确要求时间复杂度为O(n)，因此这道题肯定不能使用循环遍历。这道题主要是考察哈希表，因为哈希表每次查询的时间复杂度为O(1)。因此首先要将数组转为Map。然后分别查询每个数字的前一个数与后一个数，统计数字连续的数量。如果在哈希表中存在相邻的数，查询后应该从哈希表中删除，当然不删也可以。如果哈希表为空，则直接跳出循环，不再遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">   	public int longestConsecutive(int[] nums) &#123;</div><div class="line">		int max = 0;</div><div class="line">		int count = 0;</div><div class="line">		Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">			map.put(String.valueOf(nums[i]), nums[i]);</div><div class="line">		&#125;</div><div class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">			count = 1;</div><div class="line">			int x = nums[i];</div><div class="line">			while(true) &#123;</div><div class="line">				int temp = --x;</div><div class="line">				if(map.containsKey(String.valueOf(temp))) &#123;</div><div class="line">					map.remove(String.valueOf(temp));</div><div class="line">					count++;</div><div class="line">				&#125;else &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			//必须重置x</div><div class="line">			x = nums[i];</div><div class="line">			while(true) &#123;</div><div class="line">				int temp = ++x;</div><div class="line">				if(map.containsKey(String.valueOf(temp))) &#123;</div><div class="line">					map.remove(String.valueOf(temp));</div><div class="line">					count++;</div><div class="line">				&#125;else &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if(count &gt; max) &#123;</div><div class="line">				max = count;</div><div class="line">			&#125;</div><div class="line">			if(map.isEmpty()) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode128——Longest Consecutive Sequence
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
