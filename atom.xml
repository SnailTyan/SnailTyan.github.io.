<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="noahsnail.com/"/>
  <updated>2017-11-17T07:08:19.000Z</updated>
  <id>noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="noahsnail.com/2017/11/17/2017-10-9-Inception-V3%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
    <id>noahsnail.com/2017/11/17/2017-10-9-Inception-V3论文翻译——中英文对照/</id>
    <published>2017-11-17T07:08:19.000Z</published>
    <updated>2017-11-17T07:08:19.000Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="layout" content="post">
<meta name="description" content="Inception-V3论文翻译——中英文对照">
<meta name="tags" content="[Deep Learning]">
<meta name="categories" content="深度学习"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAzUABAAAAAAFNgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABwAAAAcZMzaOEdERUYAAAGIAAAAHQAAACAAOQAET1MvMgAAAagAAAA+AAAAYHqhde9jbWFwAAAB6AAAAFIAAAFa4azkLWN2dCAAAAI8AAAAKAAAACgFgwioZnBnbQAAAmQAAAGxAAACZVO0L6dnYXNwAAAEGAAAAAgAAAAIAAAAEGdseWYAAAQgAAAFDgAACMz7eroHaGVhZAAACTAAAAAwAAAANgWEOEloaGVhAAAJYAAAAB0AAAAkDGEGa2htdHgAAAmAAAAAEwAAADBEgAAQbG9jYQAACZQAAAAaAAAAGgsICJBtYXhwAAAJsAAAACAAAAAgASgBD25hbWUAAAnQAAACZwAABOD4no+3cG9zdAAADDgAAABsAAAAmF+yXM9wcmVwAAAMpAAAAC4AAAAusPIrFAAAAAEAAAAAyYlvMQAAAADLVHQgAAAAAM/u9uZ4nGNgZGBg4ANiCQYQYGJgBEJuIGYB8xgABMMAPgAAAHicY2Bm42OcwMDKwMLSw2LMwMDQBqGZihmiwHycoKCyqJjB4YPDh4NsDP+BfNb3DIuAFCOSEgUGRgAKDgt4AAB4nGNgYGBmgGAZBkYGEAgB8hjBfBYGCyDNxcDBwMTA9MHhQ9SHrA8H//9nYACyQyFs/sP86/kX8HtB9UIBIxsDXICRCUgwMaACRoZhDwA3fxKSAAAAAAHyAHABJQB/AIEAdAFGAOsBIwC/ALgAxACGAGYAugBNACcA/wCIeJxdUbtOW0EQ3Q0PA4HE2CA52hSzmZDGe6EFCcTVjWJkO4XlCGk3cpGLcQEfQIFEDdqvGaChpEibBiEXSHxCPiESM2uIojQ7O7NzzpkzS8qRqnfpa89T5ySQwt0GzTb9Tki1swD3pOvrjYy0gwdabGb0ynX7/gsGm9GUO2oA5T1vKQ8ZTTuBWrSn/tH8Cob7/B/zOxi0NNP01DoJ6SEE5ptxS4PvGc26yw/6gtXhYjAwpJim4i4/plL+tzTnasuwtZHRvIMzEfnJNEBTa20Emv7UIdXzcRRLkMumsTaYmLL+JBPBhcl0VVO1zPjawV2ys+hggyrNgQfYw1Z5DB4ODyYU0rckyiwNEfZiq8QIEZMcCjnl3Mn+pED5SBLGvElKO+OGtQbGkdfAoDZPs/88m01tbx3C+FkcwXe/GUs6+MiG2hgRYjtiKYAJREJGVfmGGs+9LAbkUvvPQJSA5fGPf50ItO7YRDyXtXUOMVYIen7b3PLLirtWuc6LQndvqmqo0inN+17OvscDnh4Lw0FjwZvP+/5Kgfo8LK40aA4EQ3o3ev+iteqIq7wXPrIn07+xWgAAAAABAAH//wAPeJyFlctvG1UUh+/12DPN1B7P3JnYjj2Ox4/MuDHxJH5N3UdaEUQLqBIkfQQioJWQ6AMEQkIqsPGCPwA1otuWSmTBhjtps2ADWbJg3EpIXbGouqSbCraJw7kzNo2dRN1cnXN1ZvT7zuuiMEI7ncizyA0URofRBJpCdbQuIFShYY+GZRrxMDVtih5TwQPHtXDFFSIKoWIbuREBjLH27Ny4MsbVx+uOJThavebgVrNRLAiYx06rXsvhxLgWx9xpfHdrs/ekc2Pl2cpPCVEITQpwbj8VQhfXSq2m+Wxqaq2D73Kne5e3NjHqQNj3CRYlJlgUl/jRNP+2Gs2pNYRQiOnmUaQDqm30KqKiTTWPWjboxnTWpvgxjXo0KrtZXAHt7hwIz0YVcj88JnKlJKi3NPAwLyDwZudSmJSMMJFDYaOkaol6XtESx3Gt1VTytdZJ3DCLeaVhVnCBH1fycHTxFXwPX+l2e3d6H/TufGGmMTLTnbSJUdo00zuBswMO/nl3YLeL/wnu9/limCuD3vC54h5NBVz6Li414AI8Vx3iiosKcQXUbrvhFFiYb++HN4DaF4XzFW0fIN4XDWJ3a3XQoq9V8WiyRmdsatV9xUcHims1JloH0YUa090G3Tro3mC6c01f+YwCPquINr1PTaCP6rVTOOmf0GE2dBc7zWIhji3/5MchSuBHgDbU99RMWt3YUNMZMJmx92YP6NsHx/5/M1yvInpnkIOM3Z8fA3JQ2lW1RFC1KaBPDFXNAHYYvGy73aYZZZ3HifbeuiVZCpwA3oQBs0wGPYJbJfg60xrKEbKiNtTe1adwrpBRwlAuQ3q3VRaX0QmQ9a49BTSCuF1MLfQ6+tinOubRBZuWPNoMevGMT+V41KitO1is3D/tpMcq1JHZqDHGs8DoYGDkxJgKjHROeTCmhZvzPm9pod+ltKm4PN7Dyvvldlpsg8D+4AUJZ3F/JBstZz7cbFRxsaAGV6yX/dkcycWf8eS3QlQea+YLjdm3yrOnrhFpUyKVvFE4lpv4bO3Svx/6F/4xmiDu/RT5iI++lko18mY1oX+5UGKR6kmVjM/Zb76yfHtxy+h/SyQ0lLdpdKy/lWB6szatetQJ8nZ80A2Qt6ift6gJeavU3BO4gtxs/KCtNPVibCtYCWY3SIlSBPKXZALXiIR9oZeJ1AuMyxLpHIy/yO7vSiSE+kZvk0ihJ30HgHfzZtEMmvV58x6dtqns0XTAW7Vdm4HJ04OCp/crOO7rd9SGxQAE/mVA9xRN+kVSMRFF6S9JFGUtthkjBA5tFCWc2l4V43Ex9GmUP3SI37Jjmir9KqlaDJ4S4JB3vuM/jzyH1+8MuoZ+QGzfnvPoJb96cZlWjMcKLfgDwB7E634JTY+asjsPzS5CiVnEWY+KsrsIN5rn3mAPjqmQBxGjcGKB9f9ZxY3mYC2L85CJ2FXIxKKyHk+dg0FHbuEc7D5NzWUX32WxFcWNGRAbvwSx0RmIXVDuYySafluQBmzA/ssqJAMLnli+WIC90Gw4lm85wcp0qjArEDPJJV/sSx4P9ungTpgMw5gVC1XO4uULq0s3v1rqLi0vX/z65vlH50f8T/RHmSPTk5xxWBWOluMT6WiOy+tdvWxlV/XQb3o3c6Ssr+r6I708GsX9/nzp1tKFh0s3v7m4vAy/Hnb/KMOvc1wump6Il48K6mGDy02X9Yd65pa+nQIjk76lWxCkG8NBCP0HQS9IpAAAeJxjYGRgYGBhcCrq214Qz2/zlUGenQEEzr/77oug/zewFbB+AHI5GJhAogBwKQ0qeJxjYGRgYH3/P46BgZ0BBNgKGBgZUAEPAE/7At0AAAB4nGNngAB2IGYjhBsYBAAIYADVAAAAAAAAAAAAAFwAyAEeAaACCgKmAx4DggRmAAAAAQAAAAwAagAEAAAAAAACAAEAAgAWAAABAAChAAAAAHiclZI7bxQxFIWPd/JkUYQChEhIyAVKgdBMskm1QkKrRETpQiLRUczueB/K7HhlOxttg8LvoKPgP9DxFxANDR0tHRWi4NjrPIBEgh1p/dm+vufcawNYFWsQmP6e4jSyQB2fI9cwj++RE9wTjyPP4LYoI89iWbyLPIe6+Bh5Hs9rryMv4GbtW+RF3EhuRa7jbrIbeQkPkjdUETOLnL0Kip4FVvAhco1RXyMnSPEz8gzWxE7kWTwUp5HnsCLeR57HW/El8gJWa58iL+JO7UfkOh4l9yMv4UnyEtvQGGECgwF66MNBooF1bGCL1ELB/TYU+ZBRlvsKQ44Se6jQ4a7hef+fh72Crv25kp+8lNWGmeKoOI5jJLb1aGIGvb6TjfWNLdkqdFvJw4l1amjlXtXRZqRN7lSRylZZyhBqpVFWmTEXgWfUrpi/hZOQXdOd4rKuXOtEWT3k5IArPRzTUU5tHKjecZkTpnVbNOnt6jzN8240GD4xtikvZW56043rPMg/dS+dlOceXoR+WPbJ55Dsekq1lJpnypsMUsYOdCW30o103Ytu/lvh+5RWFLfBjm9/N8hJntPhvx92rnoE/kyHdGasGy754kw36vsVf/lFeBi+0COu+cfgQr42G3CRpeLoZ53gmfe3X6rcKt5oVxnptHR9JS8ehVUd5wvvahN2uqxOOpMXapibI5k7Zwbt4xBSaTfoKBufhAnO/uqNcfK8OTs0OQ6l7JIqFjDhYj5WcjevCnI/1DDiI8j4ndWb/5YzDZWh79yomWXeXj7Nnw70/2TIeFPTrlSh89k1ObOSRVZWZfgF0r/zJQB4nG2JUQuCQBCEd07TTg36fb2IyBaLd3vWaUh/vmSJnvpgmG8YcmS8X3Shf3R7QA4OBUocUKHGER5NNbOOEvwc1txnuWkTRb/aPjimJ5vXabI+3VfOiyS15UWvyezM2xiGOPyuMohOH8O8JiO4Af+FsAGNAEuwCFBYsQEBjlmxRgYrWCGwEFlLsBRSWCGwgFkdsAYrXFhZsBQrAAA=) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>Inception-V3论文翻译——中英文对照</title></head><body><article class="markdown-body"><p>文章作者：Tyan<br>
博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="rethinking-the-inception-architecture-for-computer-vision"><a name="user-content-rethinking-the-inception-architecture-for-computer-vision" href="#rethinking-the-inception-architecture-for-computer-vision" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Rethinking the Inception Architecture for Computer Vision</h1>
<h2 id="abstract"><a name="user-content-abstract" href="#abstract" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Abstract</h2>
<p>Convolutional networks are at the core of most state-of-the-art computer vision solutions for a wide variety of tasks. Since 2014 very deep convolutional networks started to become mainstream, yielding substantial gains in various benchmarks. Although increased model size and computational cost tend to translate to immediate quality gains for most tasks (as long as enough labeled data is provided for training), computational efficiency and low parameter count are still enabling factors for various use cases such as mobile vision and big-data scenarios. Here we are exploring ways to scale up networks in ways that aim at utilizing the added computation as efficiently as possible by suitably factorized convolutions and aggressive regularization. We benchmark our methods on the ILSVRC 2012 classification challenge validation set demonstrate substantial gains over the state of the art: 21.2% top-1 and 5.6% top-5 error for single frame evaluation using a network with a computational cost of 5 billion multiply-adds per inference and with using less than 25 million parameters. With an ensemble of 4 models and multi-crop evaluation, we report 3.5% top-5 error and 17.3% top-1 error.</p>
<p>对许多任务而言，卷积网络是目前最新的计算机视觉解决方案的核心。从2014年开始，深度卷积网络开始变成主流，在各种基准数据集上都取得了实质性成果。对于大多数任务而言，虽然增加的模型大小和计算成本都趋向于转化为直接的质量收益（只要提供足够的标注数据去训练），但计算效率和低参数计数仍是各种应用场景的限制因素，例如移动视觉和大数据场景。目前，我们正在探索增大网络的方法，目标是通过适当的分解卷积和积极的正则化来尽可能地有效利用增加的计算。我们在ILSVRC 2012分类挑战赛的验证集上评估了我们的方法，结果证明我们的方法超过了目前最先进的方法并取得了实质性收益：对于单一框架评估错误率为：<code>21.2% top-1</code>和<code>5.6% top-5</code>，使用的网络计算代价为每次推断需要进行50亿次乘加运算并使用不到2500万的参数。通过四个模型组合和多次评估，我们报告了<code>3.5% top-5</code>和<code>17.3% top-1</code>的错误率。</p>
<h2 id="1-introduction"><a name="user-content-1-introduction" href="#1-introduction" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Introduction</h2>
<p>Since the 2012 ImageNet competition [16] winning entry by Krizhevsky et al [9], their network “AlexNet” has been successfully applied to a larger variety of computer vision tasks, for example to object-detection [5], segmentation [12], human pose estimation [22], video classification [8], object tracking [23], and superresolution [3].</p>
<p>从2012年Krizhevsky等人[9]赢得了ImageNet竞赛[16]起，他们的网络“AlexNet”已经成功了应用到了许多计算机视觉任务中，例如目标检测[5]，分割[12]，行人姿势评估[22]，视频分类[8]，目标跟踪[23]和超分辨率[3]。</p>
<p>These successes spurred a new line of research that focused on finding higher performing convolutional neural networks. Starting in 2014, the quality of network architectures significantly improved by utilizing deeper and wider networks. VGGNet [18] and GoogLeNet [20] yielded similarly high performance in the 2014 ILSVRC [16] classification challenge. One interesting observation was that gains in the classification performance tend to transfer to significant quality gains in a wide variety of application domains. This means that architectural improvements in deep convolutional architecture can be utilized for improving performance for most other computer vision tasks that are increasingly reliant on high quality, learned visual features. Also, improvements in the network quality resulted in new application domains for convolutional networks in cases where AlexNet features could not compete with hand engineered, crafted solutions, e.g. proposal generation in detection[4].</p>
<p>这些成功推动了一个新研究领域，这个领域主要专注于寻找更高效运行的卷积神经网络。从2014年开始，通过利用更深更宽的网络，网络架构的质量得到了明显改善。VGGNet[18]和GoogLeNet[20]在2014 ILSVRC [16]分类挑战上取得了类似的高性能。一个有趣的发现是在分类性能上的收益趋向于转换成各种应用领域上的显著质量收益。这意味着深度卷积架构上的架构改进可以用来改善大多数越来越多地依赖于高质量、可学习视觉特征的其它计算机视觉任务的性能。网络质量的改善也导致了卷积网络在新领域的应用，在AlexNet特征不能与手工精心设计的解决方案竞争的情况下，例如，检测时的候选区域生成[4]。</p>
<p>Although VGGNet [18] has the compelling feature of architectural simplicity, this comes at a high cost: evaluating the network requires a lot of computation. On the other hand, the Inception architecture of GoogLeNet [20] was also designed to perform well even under strict constraints on memory and computational budget. For example, GoogleNet employed only 5 million parameters, which represented a 12× reduction with respect to its predecessor AlexNet, which used 60 million parameters. Furthermore, VGGNet employed about 3x more parameters than AlexNet.</p>
<p>尽管VGGNet[18]具有架构简洁的强有力特性，但它的成本很高：评估网络需要大量的计算。另一方面，GoogLeNet[20]的Inception架构也被设计为在内存和计算预算严格限制的情况下也能表现良好。例如，GoogleNet只使用了500万参数，与其前身AlexNet相比减少了12倍，AlexNet使用了6000万参数。此外，VGGNet使用了比AlexNet大约多3倍的参数。</p>
<p>The computational cost of Inception is also much lower than VGGNet or its higher performing successors [6]. This has made it feasible to utilize Inception networks in big-data scenarios[17], [13], where huge amount of data needed to be processed at reasonable cost or scenarios where memory or computational capacity is inherently limited, for example in mobile vision settings. It is certainly possible to mitigate parts of these issues by applying specialized solutions to target memory use [2], [15] or by optimizing the execution of certain operations via computational tricks [10]. However, these methods add extra complexity. Furthermore, these methods could be applied to optimize the Inception architecture as well, widening the efficiency gap again.</p>
<p>Inception的计算成本也远低于VGGNet或其更高性能的后继者[6]。这使得可以在大数据场景中[17]，[13]，在大量数据需要以合理成本处理的情况下或在内存或计算能力固有地受限情况下，利用Inception网络变得可行，例如在移动视觉设定中。通过应用针对内存使用的专门解决方案[2]，[15]或通过计算技巧优化某些操作的执行[10]，可以减轻部分这些问题。但是这些方法增加了额外的复杂性。此外，这些方法也可以应用于优化Inception架构，再次扩大效率差距。</p>
<p>Still, the complexity of the Inception architecture makes it more difficult to make changes to the network. If the architecture is scaled up naively, large parts of the computational gains can be immediately lost. Also, [20] does not provide a clear description about the contributing factors that lead to the various design decisions of the GoogLeNet architecture. This makes it much harder to adapt it to new use-cases while maintaining its efficiency. For example, if it is deemed necessary to increase the capacity of some Inception-style model, the simple transformation of just doubling the number of all filter bank sizes will lead to a 4x increase in both computational cost and number of parameters. This might prove prohibitive or unreasonable in a lot of practical scenarios, especially if the associated gains are modest. In this paper, we start with describing a few general principles and optimization ideas that that proved to be useful for scaling up convolution networks in efficient ways. Although our principles are not limited to Inception-type networks, they are easier to observe in that context as the generic structure of the Inception style building blocks is flexible enough to incorporate those constraints naturally. This is enabled by the generous use of dimensional reduction and parallel structures of the Inception modules which allows for mitigating the impact of structural changes on nearby components. Still, one needs to be cautious about doing so, as some guiding principles should be observed to maintain high quality of the models.</p>
<p>然而，Inception架构的复杂性使得更难以对网络进行更改。如果单纯地放大架构，大部分的计算收益可能会立即丢失。此外，[20]并没有提供关于导致GoogLeNet架构的各种设计决策的贡献因素的明确描述。这使得它更难以在适应新用例的同时保持其效率。例如，如果认为有必要增加一些Inception模型的能力，将滤波器组大小的数量加倍的简单变换将导致计算成本和参数数量增加4倍。这在许多实际情况下可能会被证明是禁止或不合理的，尤其是在相关收益适中的情况下。在本文中，我们从描述一些一般原则和优化思想开始，对于以有效的方式扩展卷积网络来说，这被证实是有用的。虽然我们的原则不局限于Inception类型的网络，但是在这种情况下，它们更容易观察，因为Inception类型构建块的通用结构足够灵活，可以自然地合并这些约束。这通过大量使用降维和Inception模块的并行结构来实现，这允许减轻结构变化对邻近组件的影响。但是，对于这样做需要谨慎，因为应该遵守一些指导原则来保持模型的高质量。</p>
<h2 id="2-general-design-principles"><a name="user-content-2-general-design-principles" href="#2-general-design-principles" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. General Design Principles</h2>
<p>Here we will describe a few design principles based on large-scale experimentation with various architectural choices with convolutional networks. At this point, the utility of the principles below are speculative and additional future experimental evidence will be necessary to assess their accuracy and domain of validity. Still, grave deviations from these principles tended to result in deterioration in the quality of the networks and fixing situations where those deviations were detected resulted in improved architectures in general.</p>
<h2 id="2"><a name="user-content-2" href="#2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. 通用设计原则</h2>
<p>这里我们将介绍一些具有卷积网络的、具有各种架构选择的、基于大规模实验的设计原则。在这一点上，以下原则的效用是推测性的，另外将来的实验证据将对于评估其准确性和有效领域是必要的。然而，严重偏移这些原则往往会导致网络质量的恶化，修正检测到的这些偏差状况通常会导致改进的架构。</p>
<ol>
<li>
<p>Avoid representational bottlenecks, especially early in the network. Feed-forward networks can be represented by an acyclic graph from the input layer(s) to the classifier or regressor. This defines a clear direction for the information flow. For any cut separating the inputs from the outputs, one can access the amount of information passing though the cut. One should avoid bottlenecks with extreme compression. In general the representation size should gently decrease from the inputs to the outputs before reaching the final representation used for the task at hand. Theoretically, information content can not be assessed merely by the dimensionality of the representation as it discards important factors like correlation structure; the dimensionality merely provides a rough estimate of information content.</p>
</li>
<li>
<p>Higher dimensional representations are easier to process locally within a network. Increasing the activations per tile in a convolutional network allows for more disentangled features. The resulting networks will train faster.</p>
</li>
<li>
<p>Spatial aggregation can be done over lower dimensional embeddings without much or any loss in representational power. For example, before performing a more spread out (e.g. 3 × 3) convolution, one can reduce the dimension of the input representation before the spatial aggregation without expecting serious adverse effects. We hypothesize that the reason for that is the strong correlation between adjacent unit results in much less loss of information during dimension reduction, if the outputs are used in a spatial aggregation context. Given that these signals should be easily compressible, the dimension reduction even promotes faster learning.</p>
</li>
<li>
<p>Balance the width and depth of the network. Optimal performance of the network can be reached by balancing the number of filters per stage and the depth of the network. Increasing both the width and the depth of the network can contribute to higher quality networks. However, the optimal improvement for a constant amount of computation can be reached if both are increased in parallel. The computational budget should therefore be distributed in a balanced way between the depth and width of the network.</p>
</li>
<li>
<p>避免表征瓶颈，尤其是在网络的前面。前馈网络可以由从输入层到分类器或回归器的非循环图表示。这为信息流定义了一个明确的方向。对于分离输入输出的任何切口，可以访问通过切口的信息量。应该避免极端压缩的瓶颈。一般来说，在达到用于着手任务的最终表示之前，表示大小应该从输入到输出缓慢减小。理论上，信息内容不能仅通过表示的维度来评估，因为它丢弃了诸如相关结构的重要因素；维度仅提供信息内容的粗略估计。</p>
</li>
<li>
<p>更高维度的表示在网络中更容易局部处理。在卷积网络中增加每个图块的激活允许更多解耦的特征。所产生的网络将训练更快。</p>
</li>
<li>
<p>空间聚合可以在较低维度嵌入上完成，而不会在表示能力上造成许多或任何损失。例如，在执行更多展开（例如3×3）卷积之前，可以在空间聚合之前减小输入表示的维度，没有预期的严重不利影响。我们假设，如果在空间聚合上下文中使用输出，则相邻单元之间的强相关性会导致维度缩减期间的信息损失少得多。鉴于这些信号应该易于压缩，因此尺寸减小甚至会促进更快的学习。</p>
</li>
<li>
<p>平衡网络的宽度和深度。通过平衡每个阶段的滤波器数量和网络的深度可以达到网络的最佳性能。增加网络的宽度和深度可以有助于更高质量的网络。然而，如果两者并行增加，则可以达到恒定计算量的最佳改进。因此，计算预算应该在网络的深度和宽度之间以平衡方式进行分配。</p>
</li>
</ol>
<p>Although these principles might make sense, it is not straightforward to use them to improve the quality of networks out of box. The idea is to use them judiciously in ambiguous situations only.</p>
<p>虽然这些原则可能是有意义的，但并不是开箱即用的直接使用它们来提高网络质量。我们的想法是仅在不明确的情况下才明智地使用它们。</p>
<h2 id="3-factorizing-convolutions-with-large-filter-size"><a name="user-content-3-factorizing-convolutions-with-large-filter-size" href="#3-factorizing-convolutions-with-large-filter-size" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Factorizing Convolutions with Large Filter Size</h2>
<p>Much of the original gains of the GoogLeNet network [20] arise from a very generous use of dimension reduction. This can be viewed as a special case of factorizing convolutions in a computationally efficient manner. Consider for example the case of a 1 × 1 convolutional layer followed by a 3 × 3 convolutional layer. In a vision network, it is expected that the outputs of near-by activations are highly correlated. Therefore, we can expect that their activations can be reduced before aggregation and that this should result in similarly expressive local representations.</p>
<h2 id="3"><a name="user-content-3" href="#3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. 基于大滤波器尺寸分解卷积</h2>
<p>GoogLeNet网络[20]的大部分初始收益来源于大量地使用降维。这可以被视为以计算有效的方式分解卷积的特例。考虑例如1×1卷积层之后接一个3×3卷积层的情况。在视觉网络中，预期相近激活的输出是高度相关的。因此，我们可以预期，它们的激活可以在聚合之前被减少，并且这应该会导致类似的富有表现力的局部表示。</p>
<p>Here we explore other ways of factorizing convolutions in various settings, especially in order to increase the computational efficiency of the solution. Since Inception networks are fully convolutional, each weight corresponds to one multiplication per activation. Therefore, any reduction in computational cost results in reduced number of parameters. This means that with suitable factorization, we can end up with more disentangled parameters and therefore with faster training. Also, we can use the computational and memory savings to increase the filter-bank sizes of our network while maintaining our ability to train each model replica on a single computer.</p>
<p>在这里，我们将在各种设定中探索卷积分解的其它方法，特别是为了提高解决方案的计算效率。由于Inception网络是全卷积的，每个权重对应每个激活的一次乘法。因此，任何计算成本的降低会导致参数数量减少。这意味着，通过适当的分解，我们可以得到更多的解耦参数，从而加快训练。此外，我们可以使用计算和内存节省来增加我们网络的滤波器组的大小，同时保持我们在单个计算机上训练每个模型副本的能力。</p>
<h3 id="31-factorization-into-smaller-convolutions"><a name="user-content-31-factorization-into-smaller-convolutions" href="#31-factorization-into-smaller-convolutions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.1. Factorization into smaller convolutions</h3>
<p>Convolutions with larger spatial filters (e.g. 5 × 5 or 7 × 7) tend to be disproportionally expensive in terms of computation. For example, a 5 × 5 convolution with n filters over a grid with m filters is 25/9 = 2.78 times more computationally expensive than a 3 × 3 convolution with the same number of filters. Of course, a 5 × 5 filter can capture dependencies between signals between activations of units further away in the earlier layers, so a reduction of the geometric size of the filters comes at a large cost of expressiveness. However, we can ask whether a 5 × 5 convolution could be replaced by a multi-layer network with less parameters with the same input size and output depth. If we zoom into the computation graph of the 5 × 5 convolution, we see that each output looks like a small fully-connected network sliding over 5 × 5 tiles over its input (see Figure 1). Since we are constructing a vision network, it seems natural to exploit translation invariance again and replace the fully connected component by a two layer convolutional architecture: the first layer is a 3 × 3 convolution, the second is a fully connected layer on top of the 3 × 3 output grid of the first layer (see Figure 1). Sliding this small network over the input activation grid boils down to replacing the 5 × 5 convolution with two layers of 3 × 3 convolution (compare Figure 4 with 5).</p>
<p><img alt="Figure 1" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig1.png"></p>
<p>Figure 1. Mini-network replacing the 5×5 convolutions.</p>
<p><img alt="Figure 4" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig4.png"></p>
<p>Figure 4. Original Inception module as described in [20].</p>
<p><img alt="Figure 5" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig5.png"></p>
<p>Figure 5. Inception modules where each 5 × 5 convolution is replaced by two 3 × 3 convolution, as suggested by principle 3 of Section 2.</p>
<h3 id="31"><a name="user-content-31" href="#31" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.1. 分解到更小的卷积</h3>
<p>具有较大空间滤波器（例如5×5或7×7）的卷积在计算方面往往不成比例地昂贵。例如，具有n个滤波器的5×5卷积在具有m个滤波器的网格上比具有相同数量的滤波器的3×3卷积的计算量高25/9=2.78倍。当然，5×5滤波器在更前面的层可以捕获更远的单元激活之间、信号之间的依赖关系，因此滤波器几何尺寸的减小带来了很大的表现力。然而，我们可以询问5×5卷积是否可以被具有相同输入尺寸和输出深度的参数较小的多层网络所取代。如果我们放大5×5卷积的计算图，我们看到每个输出看起来像一个小的完全连接的网络，在其输入上滑过5×5的块（见图1）。由于我们正在构建视觉网络，所以通过两层的卷积结构再次利用平移不变性来代替全连接的组件似乎是很自然的：第一层是3×3卷积，第二层是在第一层的3×3输出网格之上的一个全连接层（见图1）。通过在输入激活网格上滑动这个小网络，用两层3×3卷积来替换5×5卷积（比较图4和5）。</p>
<p><img alt="Figure 1" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig1.png"></p>
<p>图1。Mini网络替换5×5卷积</p>
<p><img alt="Figure 4" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig4.png"></p>
<p>图4。[20]中描述的最初的Inception模块.</p>
<p><img alt="Figure 5" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig5.png"></p>
<p>图5。Inception模块中每个5×5卷积由两个3×3卷积替换，正如第2小节中原则3建议的那样。</p>
<p>This setup clearly reduces the parameter count by sharing the weights between adjacent tiles. To analyze the expected computational cost savings, we will make a few simplifying assumptions that apply for the typical situations: We can assume that $n = \alpha m$, that is that we want to change the number of activations/unit by a constant alpha factor. Since the 5 × 5 convolution is aggregating, $\alpha$ is typically slightly larger than one (around 1.5 in the case of GoogLeNet). Having a two layer replacement for the 5 × 5 layer, it seems reasonable to reach this expansion in two steps: increasing the number of filters by $\sqrt \alpha$ in both steps. In order to simplify our estimate by choosing $\alpha = 1 $(no expansion), if we would naivly slide a network without reusing the computation between neighboring grid tiles, we would increase the computational cost. Sliding this network can be represented by two 3 × 3 convolutional layers which reuses the activations between adjacent tiles. This way, we end up with a net $\frac {9+9} {25} ×$ reduction of computation, resulting in a relative gain of 28% by this factorization. The exact same saving holds for the parameter count as each parameter is used exactly once in the computation of the activation of each unit. Still, this setup raises two general questions: Does this replacement result in any loss of expressiveness? If our main goal is to factorize the linear part of the computation, would it not suggest to keep linear activations in the first layer? We have ran several control experiments (for example see figure 2) and using linear activation was always inferior to using rectified linear units in all stages of the factorization. We attribute this gain to the enhanced space of variations that the network can learn especially if we batch-normalize [7] the output activations. One can see similar effects when using linear activations for the dimension reduction components.</p>
<p><img alt="Figure 2" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig2.png"></p>
<p>Figure 2. One of several control experiments between two Inception models, one of them uses factorization into linear + ReLU layers, the other uses two ReLU layers. After 3.86 million operations, the former settles at 76.2%, while the latter reaches 77.2% top-1 Accuracy on the validation set.</p>
<p>该设定通过相邻块之间共享权重明显减少了参数数量。为了分析预期的计算成本节省，我们将对典型的情况进行一些简单的假设：我们可以假设$n=\alpha m$，也就是我们想通过常数$\alpha$因子来改变激活/单元的数量。由于5×5卷积是聚合的，$\alpha$通常比1略大（在GoogLeNet中大约是1.5）。用两个层替换5×5层，似乎可以通过两个步骤来实现扩展：在两个步骤中通过$\sqrt \alpha$增加滤波器数量。为了简化我们的估计，通过选择$\alpha=1$（无扩展），如果我们单纯地滑动网络而不重新使用相邻网格图块之间的计算，我们将增加计算成本。滑动该网络可以由两个3×3的卷积层表示，其重用相邻图块之间的激活。这样，我们最终得到一个计算量减少到$\frac {9+9} {25} ×$的网络，通过这种分解导致了28％的相对增益。每个参数在每个单元的激活计算中只使用一次，所以参数计数具有完全相同的节约。不过，这个设置提出了两个一般性的问题：这种替换是否会导致任何表征力的丧失？如果我们的主要目标是对计算的线性部分进行分解，是不是建议在第一层保持线性激活？我们已经进行了几个控制实验（例如参见图2），并且在分解的所有阶段中使用线性激活总是逊于使用修正线性单元。我们将这个收益归因于网络可以学习的增强的空间变化，特别是如果我们对输出激活进行批标准化[7]。当对维度减小组件使用线性激活时，可以看到类似的效果。</p>
<p><img alt="Figure 2" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig2.png"></p>
<p>图2。两个Inception模型间几个控制实验中的一个，其中一个分解为线性层+ ReLU层，另一个使用两个ReLU层。在三亿八千六百万次运算后，在验证集上前者达到了<code>76.2% top-1</code>准确率，后者达到了<code>77.2% top-1</code>的准确率。</p>
<h3 id="32-spatial-factorization-into-asymmetric-convolutions"><a name="user-content-32-spatial-factorization-into-asymmetric-convolutions" href="#32-spatial-factorization-into-asymmetric-convolutions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.2. Spatial Factorization into Asymmetric Convolutions</h3>
<p>The above results suggest that convolutions with filters larger 3 × 3 might not be generally useful as they can always be reduced into a sequence of 3 × 3 convolutional layers. Still we can ask the question whether one should factorize them into smaller, for example 2 × 2 convolutions. However, it turns out that one can do even better than 2 × 2 by using asymmetric convolutions, e.g. n × 1. For example using a 3 × 1 convolution followed by a 1 × 3 convolution is equivalent to sliding a two layer network with the same receptive field as in a 3 × 3 convolution (see figure 3). Still the two-layer solution is 33% cheaper for the same number of output filters, if the number of input and output filters is equal. By comparison, factorizing a 3 × 3 convolution into a two 2 × 2 convolution represents only a 11% saving of computation.</p>
<p><img alt="Figure 3" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig3.png"></p>
<p>Figure 3. Mini-network replacing the 3 × 3 convolutions. The lower layer of this network consists of a 3 × 1 convolution with 3 output units.</p>
<h3 id="32"><a name="user-content-32" href="#32" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.2. 空间分解为不对称卷积</h3>
<p>上述结果表明，大于3×3的卷积滤波器可能不是通常有用的，因为它们总是可以简化为3×3卷积层序列。我们仍然可以问这个问题，是否应该把它们分解成更小的，例如2×2的卷积。然而，通过使用非对称卷积，可以做出甚至比2×2更好的效果，即n×1。例如使用3×1卷积后接一个1×3卷积，相当于以与3×3卷积相同的感受野滑动两层网络（参见图3）。如果输入和输出滤波器的数量相等，那么对于相同数量的输出滤波器，两层解决方案便宜33％。相比之下，将3×3卷积分解为两个2×2卷积表示仅节省了11％的计算量。</p>
<p><img alt="Figure 3" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig3.png"></p>
<p>图3。替换3×3卷积的Mini网络。网络的更低层由带有3个输出单元的3×1构成。</p>
<p>In theory, we could go even further and argue that one can replace any n × n convolution by a 1 × n convolution followed by a n × 1 convolution and the computational cost saving increases dramatically as n grows (see figure 6). In practice, we have found that employing this factorization does not work well on early layers, but it gives very good results on medium grid-sizes (On m × m feature maps, where m ranges between 12 and 20). On that level, very good results can be achieved by using 1 × 7 convolutions followed by 7 × 1 convolutions.</p>
<p><img alt="Figure 6" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig6.png"></p>
<p>Figure 6. Inception modules after the factorization of the n × n convolutions. In our proposed architecture, we chose n = 7 for the 17 × 17 grid. (The filter sizes are picked using principle 3)</p>
<p>在理论上，我们可以进一步论证，可以通过1×n卷积和后面接一个n×1卷积替换任何n×n卷积，并且随着n增长，计算成本节省显著增加（见图6）。实际上，我们发现，采用这种分解在前面的层次上不能很好地工作，但是对于中等网格尺寸（在m×m特征图上，其中m范围在12到20之间），其给出了非常好的结果。在这个水平上，通过使用1×7卷积，然后是7×1卷积可以获得非常好的结果。</p>
<p><img alt="Figure 6" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig6.png"></p>
<p>图6。n×n卷积分解后的Inception模块。在我们提出的架构中，对17×17的网格我们选择n=7。（滤波器尺寸可以通过原则3选择）</p>
<h2 id="4-utility-of-auxiliary-classifiers"><a name="user-content-4-utility-of-auxiliary-classifiers" href="#4-utility-of-auxiliary-classifiers" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Utility of Auxiliary Classifiers</h2>
<p>[20] has introduced the notion of auxiliary classifiers to improve the convergence of very deep networks. The original motivation was to push useful gradients to the lower layers to make them immediately useful and improve the convergence during training by combating the vanishing gradient problem in very deep networks. Also Lee et al[11] argues that auxiliary classifiers promote more stable learning and better convergence. Interestingly, we found that auxiliary classifiers did not result in improved convergence early in the training: the training progression of network with and without side head looks virtually identical before both models reach high accuracy. Near the end of training, the network with the auxiliary branches starts to overtake the accuracy of the network without any auxiliary branch and reaches a slightly higher plateau.</p>
<h2 id="4"><a name="user-content-4" href="#4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. 利用辅助分类器</h2>
<p>[20]引入了辅助分类器的概念，以改善非常深的网络的收敛。最初的动机是将有用的梯度推向较低层，使其立即有用，并通过抵抗非常深的网络中的消失梯度问题来提高训练过程中的收敛。Lee等人[11]也认为辅助分类器促进了更稳定的学习和更好的收敛。有趣的是，我们发现辅助分类器在训练早期并没有导致改善收敛：在两个模型达到高精度之前，有无侧边网络的训练进度看起来几乎相同。接近训练结束，辅助分支网络开始超越没有任何分支的网络的准确性，达到了更高的稳定水平。</p>
<p>Also [20] used two side-heads at different stages in the network. The removal of the lower auxiliary branch did not have any adverse effect on the final quality of the network. Together with the earlier observation in the previous paragraph, this means that original the hypothesis of [20] that these branches help evolving the low-level features is most likely misplaced. Instead, we argue that the auxiliary classifiers act as regularizer. This is supported by the fact that the main classifier of the network performs better if the side branch is batch-normalized [7] or has a dropout layer. This also gives a weak supporting evidence for the conjecture that batch normalization acts as a regularizer.</p>
<p>另外，[20]在网络的不同阶段使用了两个侧分支。移除更下面的辅助分支对网络的最终质量没有任何不利影响。再加上前一段的观察结果，这意味着[20]最初的假设，这些分支有助于演变低级特征很可能是不适当的。相反，我们认为辅助分类器起着正则化项的作用。这是由于如果侧分支是批标准化的[7]或具有丢弃层，则网络的主分类器性能更好。这也为推测批标准化作为正则化项给出了一个弱支持证据。</p>
<h2 id="5-efficient-grid-size-reduction"><a name="user-content-5-efficient-grid-size-reduction" href="#5-efficient-grid-size-reduction" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. Efficient Grid Size Reduction</h2>
<p>Traditionally, convolutional networks used some pooling operation to decrease the grid size of the feature maps. In order to avoid a representational bottleneck, before applying maximum or average pooling the activation dimension of the network filters is expanded. For example, starting a $d\times d$ grid with $k$ filters, if we would like to arrive at a $\frac{d}{2}\times \frac{d}{2}$ grid with $2k$ filters, we first need to compute a stride-1 convolution with $2k$ filters and then apply an additional pooling step. This means that the overall computational cost is dominated by the expensive convolution on the larger grid using $2d^2k^2$ operations. One possibility would be to switch to pooling with convolution and therefore resulting in $2(\frac{d}{2})^2k^2$ reducing the computational cost by a quarter. However, this creates a representational bottlenecks as the overall dimensionality of the representation drops to $(\frac{d}{2})^2k$ resulting in less expressive networks (see Figure 9). Instead of doing so, we suggest another variant the reduces the computational cost even further while removing the representational bottleneck. (see Figure 10). We can use two parallel stride 2 blocks: $P$ and $C$. $P$ is a pooling layer (either average or maximum pooling) the activation, both of them are stride $2$ the filter banks of which are concatenated as in figure 10.</p>
<p><img alt="Figure 9" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig9.png"></p>
<p>Figure 9. Two alternative ways of reducing the grid size. The solution on the left violates the principle 1 of not introducing an representational bottleneck from Section 2. The version on the right is 3 times more expensive computationally.</p>
<p><img alt="Figure 10" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig10.png"></p>
<p>Figure 10. Inception module that reduces the grid-size while expands the filter banks. It is both cheap and avoids the representational bottleneck as is suggested by principle 1. The diagram on the right represents the same solution but from the perspective of grid sizes rather than the operations.</p>
<h2 id="5"><a name="user-content-5" href="#5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>5. 有效的网格尺寸减少</h2>
<p>传统上，卷积网络使用一些池化操作来缩减特征图的网格大小。为了避免表示瓶颈，在应用最大池化或平均池化之前，需要扩展网络滤波器的激活维度。例如，开始有一个带有$k$个滤波器的$d \times d$网格，如果我们想要达到一个带有$2k$个滤波器的$\frac{d}{2}\times \frac{d}{2}$网格，我们首先需要用$2k$个滤波器计算步长为1的卷积，然后应用一个额外的池化步骤。这意味着总体计算成本由在较大的网格上使用$2d^2k^2$次运算的昂贵卷积支配。一种可能性是转换为带有卷积的池化，因此导致$2(\frac{d}{2})^2k^2$次运算，将计算成本降低为原来的四分之一。然而，由于表示的整体维度下降到$(\frac{d}{2})^2k$，会导致表示能力较弱的网络（参见图9），这会产生一个表示瓶颈。我们建议另一种变体，其甚至进一步降低了计算成本，同时消除了表示瓶颈（见图10），而不是这样做。我们可以使用两个平行的步长为2的块：$P$和$C$。$P$是一个池化层（平均池化或最大池化）的激活，两者都是步长为$2$，其滤波器组连接如图10所示。</p>
<p><img alt="Figure 9" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig9.png"></p>
<p>图9。减少网格尺寸的两种替代方式。左边的解决方案违反了第2节中不引入表示瓶颈的原则1。右边的版本计算量昂贵3倍。</p>
<p><img alt="Figure 10" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig10.png"></p>
<p>图10。缩减网格尺寸的同时扩展滤波器组的Inception模块。它不仅廉价并且避免了原则1中提出的表示瓶颈。右侧的图表示相同的解决方案，但是从网格大小而不是运算的角度来看。</p>
<h2 id="6-inception-v2"><a name="user-content-6-inception-v2" href="#6-inception-v2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Inception-v2</h2>
<p>Here we are connecting the dots from above and propose a new architecture with improved performance on the ILSVRC 2012 classification benchmark. The layout of our network is given in table 1. Note that we have factorized the traditional $7\times 7$ convolution into three $3\times 3$ convolutions based on the same ideas as described in section 3.1. For the Inception part of the network, we have $3$ traditional inception modules at the $35\times 35$ with $288$ filters each. This is reduced to a $17 \times 17$ grid with $768$ filters using the grid reduction technique described in section 5. This is is followed by $5$ instances of the factorized inception modules as depicted in figure 5. This is reduced to a $8 \times 8 \times 1280$ grid with the grid reduction technique depicted in figure 10. At the coarsest $8 \times 8$ level, we have two Inception modules as depicted in figure 6, with a concatenated output filter bank size of 2048 for each tile. The detailed structure of the network, including the sizes of filter banks inside the Inception modules, is given in the supplementary material, given in the <code>model.txt</code> that is in the tar-file of this submission. However, we have observed that the quality of the network is relatively stable to variations as long as the principles from Section 2 are observed. Although our network is $42$ layers deep, our computation cost is only about $2.5$ higher than that of GoogLeNet and it is still much more efficient than VGGNet.</p>
<p><img alt="Table 1" src="http://ocs628urt.bkt.clouddn.com/rethinking_table1.png"></p>
<p>Table 1. The outline of the proposed network architecture. The output size of each module is the input size of the next one. We are using variations of reduction technique depicted Figure 10 to reduce the grid sizes between the Inception blocks whenever applicable. We have marked the convolution with 0-padding, which is used to maintain the grid size. 0-padding is also used inside those Inception modules that do not reduce the grid size. All other layers do not use padding. The various filter bank sizes are chosen to observe principle 4 from Section 2.</p>
<p><img alt="Figure 7" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig7.png"></p>
<p>Figure 7. Inception modules with expanded the filter bank outputs. This architecture is used on the coarsest ($8 \times 8$) grids to promote high dimensional representations, as suggested by principle 2 of Section 2. We are using this solution only on the coarsest grid, since that is the place where producing high dimensional sparse representation is the most critical as the ratio of local processing (by $1 \times 1$ convolutions) is increased compared to the spatial aggregation.</p>
<p><img alt="Figure 8" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig8.png"></p>
<p>Figure 8. Auxiliary classifier on top of the last $17 \times 17$ layer. Batch normalization[7] of the layers in the side head results in a 0.4% absolute gain in top-1 accuracy. The lower axis shows the number of itertions performed, each with batch size 32.</p>
<h2 id="6-inception-v2_1"><a name="user-content-6-inception-v2_1" href="#6-inception-v2_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>6. Inception-v2</h2>
<p>在这里，我们连接上面的点，并提出了一个新的架构，在ILSVRC 2012分类基准数据集上提高了性能。我们的网络布局在表1中给出。注意，基于与3.1节中描述的同样想法，我们将传统的$7 \times 7$卷积分解为3个$3\times 3$卷积。对于网络的Inception部分，我们在$ 35 \times 35$处有$3$个传统的Inception模块，每个模块有$288$个滤波器。使用第5节中描述的网格缩减技术，这将缩减为$17\times 17$的网格，具有$768$个滤波器。这之后是图5所示的$5$个分解的Inception模块实例。使用图10所示的网格缩减技术，这被缩减为$8 \times 8 \times 1280$的网格。在最粗糙的$8 \times 8$级别，我们有两个如图6所示的Inception模块，每个块连接的输出滤波器组的大小为2048。网络的详细结构，包括Inception模块内滤波器组的大小，在补充材料中给出，在提交的tar文件中的<code>model.txt</code>中给出。然而，我们已经观察到，只要遵守第2节的原则，对于各种变化网络的质量就相对稳定。虽然我们的网络深度是$42$层，但我们的计算成本仅比GoogLeNet高出约$2.5$倍，它仍比VGGNet要高效的多。</p>
<p><img alt="Table 1" src="http://ocs628urt.bkt.clouddn.com/rethinking_table1.png"></p>
<p>表1。提出的网络架构的轮廓。每个模块的输出大小是下一模块的输入大小。我们正在使用图10所示的缩减技术的变种，以缩减应用时Inception块间的网格大小。我们用0填充标记了卷积，用于保持网格大小。这些Inception模块内部也使用0填充，不会减小网格大小。所有其它层不使用填充。选择各种滤波器组大小来观察第2节的原理4。</p>
<p><img alt="Figure 7" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig7.png"></p>
<p>图7。具有扩展的滤波器组输出的Inception模块。这种架构被用于最粗糙的（$8 \times 8$）网格，以提升高维表示，如第2节原则2所建议的那样。我们仅在最粗的网格上使用了此解决方案，因为这是产生高维度的地方，稀疏表示是最重要的，因为与空间聚合相比，局部处理（$1 \times 1$ 卷积）的比率增加。</p>
<p><img alt="Figure 8" src="http://ocs628urt.bkt.clouddn.com/rethinking_fig8.png"></p>
<p>图8。最后$17 \times 17$层之上的辅助分类器。 侧头中的层的批标准化[7]导致<code>top-1 0.4％</code>的绝对收益。下轴显示执行的迭代次数，每个批次大小为32。</p>
<h2 id="7-model-regularization-via-label-smoothing"><a name="user-content-7-model-regularization-via-label-smoothing" href="#7-model-regularization-via-label-smoothing" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>7. Model Regularization via Label Smoothing</h2>
<p>Here we propose a mechanism to regularize the classifier layer by estimating the marginalized effect of label-dropout during training.</p>
<h2 id="7"><a name="user-content-7" href="#7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>7. 通过标签平滑进行模型正则化</h2>
<p>我们提出了一种通过估计训练期间标签丢弃的边缘化效应来对分类器层进行正则化的机制。</p>
<p>For each training example $x$, our model computes the probability of each label $k\in \lbrace 1\ldots K \rbrace$: $p(k|x) = \frac{\exp(z_k)}{\sum_{i=1}^K \exp(z_i)}$. Here, $z_i$ are the <em>logits</em> or unnormalized log-probabilities. Consider the ground-truth distribution over labels $q(k|x)$ for this training example, normalized so that $\sum_k q(k|x) = 1$. For brevity, let us omit the dependence of $p$ and $q$ on example $x$. We define the loss for the example as the cross entropy: $\ell = -\sum_{k=1}^K \log(p(k)) q(k)$. Minimizing this is equivalent to maximizing the expected log-likelihood of a label, where the label is selected according to its ground-truth distribution $q(k)$. Cross-entropy loss is differentiable with respect to the logits $z_k$ and thus can be used for gradient training of deep models. The gradient has a rather simple form: $\frac{\partial\ell}{\partial z_k} = p(k) - q(k)$, which is bounded between $-1$ and $1$.</p>
<p>对于每个训练样本$x$，我们的模型计算每个标签的概率$k\in \lbrace 1\ldots K \rbrace$: $p(k|x) = \frac{\exp(z_k)}{\sum_{i=1}^K \exp(z_i)}$。这里，$z_i$是对数单位或未归一化的对数概率。考虑这个训练样本在标签上的实际分布$q(k|x)$，因此归一化后$\sum_k q(k|x) = 1$。为了简洁，我们省略$p$和$q$对样本$x$的依赖。我们将样本损失定义为交叉熵：$\ell = -\sum_{k=1}^K \log(p(k)) q(k)$。最小化交叉熵等价于最大化标签对数似然期望，其中标签是根据它的实际分布$q(k)$选择的。交叉熵损失对于$z_k$是可微的，因此可以用来进行深度模型的梯度训练。其梯度有一个更简单的形式：$\frac{\partial\ell}{\partial z_k} = p(k) - q(k)$，它的范围在$-1$到$1$之间。</p>
<p>Consider the case of a single ground-truth label $y$, so that $q(y)=1$ and $q(k)=0$ for all $k\neq y$. In this case, minimizing the cross entropy is equivalent to maximizing the log-likelihood of the correct label. For a particular example $x$ with label $y$, the log-likelihood is maximized for $q(k)= \delta_{k,y}$, where $\delta_{k,y}$ is Dirac delta, which equals $1$ for $k=y$ and $0$ otherwise. This maximum is not achievable for finite $z_k$ but is approached if $z_y\gg z_k$ for all $k\neq y$ —— that is, if the logit corresponding to the ground-truth label is much great than all other logits. This, however, can cause two problems. First, it may result in over-fitting: if the model learns to assign full probability to the ground-truth label for each training example, it is not guaranteed to generalize. Second, it encourages the differences between the largest logit and all others to become large, and this, combined with the bounded gradient $\frac{\partial\ell}{\partial z_k}$, reduces the ability of the model to adapt. Intuitively, this happens because the model becomes too confident about its predictions.</p>
<p>考虑单个真实标签$y$的例子，对于所有$k\neq y$，有$q(y)=1$，$q(k)=0$。在这种情况下，最小化交叉熵等价于最大化正确标签的对数似然。对于一个特定的样本$x$，其标签为$y$，对于$q(k)= \delta_{k,y}$，最大化其对数概率，$\delta_{k,y}$为狄拉克δ函数，当且仅当$k=y$时，δ函数值为1，否则为0。对于有限的$z_k$，不能取得最大值，但对于所有$k\neq y$，如果$z_y\gg z_k$——也就是说，如果对应实际标签的逻辑单元远大于其它的逻辑单元，那么对数概率会接近最大值。然而这可能会引起两个问题。首先，它可能导致过拟合：如果模型学习到对于每一个训练样本，分配所有概率到实际标签上，那么它不能保证泛化能力。第二，它鼓励最大的逻辑单元与所有其它逻辑单元之间的差距变大，与有界限的梯度$\frac{\partial\ell}{\partial z_k}$相结合，这会降低模型的适应能力。直观上讲这会发生，因为模型变得对它的预测过于自信。</p>
<p>We propose a mechanism for encouraging the model to be less confident. While this may not be desired if the goal is to maximize the log-likelihood of training labels, it does regularize the model and makes it more adaptable. The method is very simple. Consider a distribution over labels $u(k)$, <em>independent of the training example $x$</em>, and a smoothing parameter $\epsilon$. For a training example with ground-truth label $y$, we replace the label distribution $q(k|x)=\delta_{k,y}$ with $$q&rsquo;(k|x) = (1-\epsilon) \delta_{k,y} + \epsilon u(k)$$ which is a mixture of the original ground-truth distribution $q(k|x)$ and the fixed distribution $u(k)$, with weights $1-\epsilon$ and $\epsilon$, respectively. This can be seen as the distribution of the label $k$ obtained as follows: first, set it to the ground-truth label $k=y$; then, with probability $\epsilon$, replace $k$ with a sample drawn from the distribution $u(k)$. We propose to use the prior distribution over labels as $u(k)$. In our experiments, we used the uniform distribution $u(k) = 1/K$, so that $$q&rsquo;(k) = (1-\epsilon) \delta_{k,y} + \frac{\epsilon}{K}.$$ We refer to this change in ground-truth label distribution as <em>label-smoothing regularization</em>, or LSR.</p>
<p>我们提出了一个鼓励模型不那么自信的机制。如果目标是最大化训练标签的对数似然，这可能不是想要的，但它确实使模型正规化并使其更具适应性。这个方法很简单。考虑标签$u(k)$的分布和平滑参数$\epsilon$，<em>与训练样本$x$相互独立</em>。对于一个真实标签为$y$的训练样本，我们用$$q&rsquo;(k|x) = (1-\epsilon) \delta_{k,y} + \epsilon u(k)$$代替标签分布$q(k|x)=\delta_{k,y}$，其由最初的实际分布$q(k|x)$和固定分布$u(k)$混合得到，它们的权重分别为$1-\epsilon$和$\epsilon$。这可以看作获得标签$k$的分布如下：首先，将其设置为真实标签$k=y$；其次，用分布$u(k)$中的采样和概率$\epsilon$替代$k$。我们建议使用标签上的先验分布作为$u(k)$。在我们的实验中，我们使用了均匀分布$u(k) = 1/K$，以便使得$$q&rsquo;(k) = (1-\epsilon) \delta_{k,y} + \frac{\epsilon}{K}.$$我们将真实标签分布中的这种变化称为<em>标签平滑正则化</em>，或LSR。</p>
<p>Note that LSR achieves the desired goal of preventing the largest logit from becoming much larger than all others. Indeed, if this were to happen, then a single $q(k)$ would approach $1$ while all others would approach $0$. This would result in a large cross-entropy with $q&rsquo;(k)$ because, unlike $q(k)=\delta_{k,y}$, all $q&rsquo;(k)$ have a positive lower bound.</p>
<p>注意，LSR实现了期望的目标，阻止了最大的逻辑单元变得比其它的逻辑单元更大。实际上，如果发生这种情况，则一个$q(k)$将接近$1$，而所有其它的将会接近$0$。这会导致$q&rsquo;(k)$有一个大的交叉熵，因为不同于$q(k)=\delta_{k,y}$，所有的$q&rsquo;(k)$都有一个正的下界。</p>
<p>Another interpretation of LSR can be obtained by considering the cross entropy:$$H(q&rsquo;,p) = -\sum_{k=1}^K \log p(k) q&rsquo;(k) = (1-\epsilon)H(q, p) + \epsilon H(u, p)$$Thus, LSR is equivalent to replacing a single cross-entropy loss $H(q,p)$ with a pair of such losses $H(q,p)$ and $H(u,p)$. The second loss penalizes the deviation of predicted label distribution $p$ from the prior $u$, with the relative weight $\frac{\epsilon}{1-\epsilon}$. Note that this deviation could be equivalently captured by the KL divergence, since $H(u,p) = D_{KL}(u\|p) + H(u)$ and $H(u)$ is fixed. When $u$ is the uniform distribution, $H(u,p)$ is a measure of how dissimilar the predicted distribution $p$ is to uniform, which could also be measured (but not equivalently) by negative entropy $-H(p)$; we have not experimented with this approach.</p>
<p>LSR的另一种解释可以通过考虑交叉熵来获得：$$H(q&rsquo;,p) = -\sum_{k=1}^K \log p(k) q&rsquo;(k) = (1-\epsilon)H(q, p) + \epsilon H(u, p)$$因此，LSR等价于用一对这样的损失$H(q,p)$和$H(u,p)$来替换单个交叉熵损失$H(q,p)$。第二个损失惩罚预测的标签分布$p$与先验$u$之间的偏差，其中相对权重为$\frac{\epsilon}{1-\epsilon}$。注意，由于$H(u,p) = D_{KL}(u\|p) + H(u)$和$H(u)$是固定的，因此这个偏差可以等价地被KL散度捕获。当$u$是均匀分布时，$H(u,p)$是度量预测分布$p$与均匀分布不同的程度，也可以通过负熵$-H(p)$来度量（但不等价）；我们还没有实验过这种方法。</p>
<p>In our ImageNet experiments with $K=1000$ classes, we used $u(k) = 1/1000$ and $\epsilon=0.1$. For ILSVRC 2012, we have found a consistent improvement of about $0.2\%$ absolute both for top-$1$ error and the top-$5$ error (cf. Table 3).</p>
<p><img alt="Table 3" src="http://ocs628urt.bkt.clouddn.com/rethinking-table3.png"></p>
<p>Table 3. Single crop experimental results comparing the cumulative effects on the various contributing factors. We compare our numbers with the best published single-crop inference for Ioffe at al [7]. For the “Inception-v2” lines, the changes are cumulative and each subsequent line includes the new change in addition to the previous ones. The last line is referring to all the changes is what we refer to as “Inception-v3” below. Unfortunately, He et al [6] reports the only 10-crop evaluation results, but not single crop results, which is reported in the Table 4 below.</p>
<p><img alt="Table 4" src="http://ocs628urt.bkt.clouddn.com/rethinking-table4.png"></p>
<p>Table 4. Single-model, multi-crop experimental results comparing the cumulative effects on the various contributing factors. We compare our numbers with the best published single-model inference results on the ILSVRC 2012 classification benchmark.</p>
<p>在我们的$K=1000$类的ImageNet实验中，我们使用了$u(k) = 1/1000$和$\epsilon=0.1$。对于ILSVRC 2012，我们发现对于<code>top-1</code>错误率和<code>top-5</code>错误率，持续提高了大约$0.2\%$（参见表3）。</p>
<p><img alt="Table 3" src="http://ocs628urt.bkt.clouddn.com/rethinking-table3.png"></p>
<p>表3。单张裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与Ioffe等人[7]发布的单张裁剪图像的最好推断结果进行了比较。在“Inception-v2”行，变化是累积的并且接下来的每一行都包含除了前面的变化之外的新变化。最后一行是所有的变化，我们称为“Inception-v3”。遗憾的是，He等人[6]仅报告了10个裁剪图像的评估结果，但没有单张裁剪图像的结果，报告在下面的表4中。</p>
<p><img alt="Table 4" src="http://ocs628urt.bkt.clouddn.com/rethinking-table4.png"></p>
<p>表4。单模型，多裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与ILSVRC 2012分类基准中发布的最佳单模型推断结果进行了比较。</p>
<h2 id="8-training-methodology"><a name="user-content-8-training-methodology" href="#8-training-methodology" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>8. Training Methodology</h2>
<p>We have trained our networks with stochastic gradient utilizing the TensorFlow [1] distributed machine learning system using $50$ replicas running each on a NVidia Kepler GPU with batch size $32$ for $100$ epochs. Our earlier experiments used momentum [19] with a decay of $0.9$, while our best models were achieved using RMSProp [21] with decay of $0.9$ and $\epsilon=1.0$. We used a learning rate of $0.045$, decayed every two epoch using an exponential rate of $0.94$. In addition, gradient clipping [14] with threshold $2.0$ was found to be useful to stabilize the training. Model evaluations are performed using a running average of the parameters computed over time.</p>
<h2 id="8"><a name="user-content-8" href="#8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>8. 训练方法</h2>
<p>我们在TensorFlow[1]分布式机器学习系统上使用随机梯度方法训练了我们的网络，使用了$50$个副本，每个副本在一个NVidia Kepler GPU上运行，批处理大小为$32$，$100$个epoch。我们之前的实验使用动量方法[19]，衰减值为$0.9$，而我们最好的模型是用RMSProp [21]实现的，衰减值为$0.9$，$\epsilon=1.0$。我们使用$0.045$的学习率，每两个epoch以$0.94$的指数速率衰减。此外，阈值为$2.0$的梯度裁剪[14]被发现对于稳定训练是有用的。使用随时间计算的运行参数的平均值来执行模型评估。</p>
<h2 id="9-performance-on-lower-resolution-input"><a name="user-content-9-performance-on-lower-resolution-input" href="#9-performance-on-lower-resolution-input" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>9. Performance on Lower Resolution Input</h2>
<p>A typical use-case of vision networks is for the the post-classification of detection, for example in the Multibox [4] context. This includes the analysis of a relative small patch of the image containing a single object with some context. The tasks is to decide whether the center part of the patch corresponds to some object and determine the class of the object if it does. The challenge is that objects tend to be relatively small and low-resolution. This raises the question of how to properly deal with lower resolution input.</p>
<p>The common wisdom is that models employing higher resolution receptive fields tend to result in significantly improved recognition performance. However it is important to distinguish between the effect of the increased resolution of the first layer receptive field and the effects of larger model capacitance and computation. If we just change the resolution of the input without further adjustment to the model, then we end up using computationally much cheaper models to solve more difficult tasks. Of course, it is natural, that these solutions loose out already because of the reduced computational effort. In order to make an accurate assessment, the model needs to analyze vague hints in order to be able to “hallucinate” the fine details. This is computationally costly. The question remains therefore: how much does higher input resolution helps if the computational effort is<br>
kept constant. One simple way to ensure constant effort is to reduce the strides of the first two layer in the case of lower resolution input, or by simply removing the first pooling layer of the network.</p>
<p>For this purpose we have performed the following three experiments:<br>
\begin{enumerate}<br>
  \item $299\times 299$ receptive field with stride $2$ and maximum pooling<br>
        after the first layer.<br>
  \item $151\times 151$ receptive field with stride $1$ and maximum pooling<br>
        after the first layer.<br>
  \item $79\times 79$ receptive field with stride $1$ and {\bf without}<br>
        pooling after the first layer.<br>
\end{enumerate}<br>
All three networks have almost identical computational cost. Although the third network is slightly cheaper, the cost of the pooling layer is marginal and (within $1\%$ of the total cost of the)network. In each case, the networks were trained until convergence and their quality was measured on the validation set of the ImageNet ILSVRC 2012 classification benchmark. The results can be seen in table 2. Although the lower-resolution networks take longer to train, the quality of the final result is quite close to that of their higher resolution counterparts.</p>
<p>However, if one would just naively reduce the network size according to the input resolution, then network would perform much more poorly. However this<br>
would an unfair comparison as we would are comparing a 16 times cheaper model on a more difficult task.</p>
<p>Also these results of table 2 suggest, one might consider using dedicated high-cost low resolution networks for smaller objects in the R-CNN [5] context.</p>
<h2 id="10-experimental-results-and-comparisons"><a name="user-content-10-experimental-results-and-comparisons" href="#10-experimental-results-and-comparisons" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>10. Experimental Results and Comparisons</h2>
<p>Table 3 shows the experimental results about the recognition performance of our proposed architecture (Inception-v2) as described in Section 6. Each Inception-v2 line shows the result of the cumulative changes including the highlighted new modification plus all the earlier ones. Label Smoothing refers to method described in Section 7. Factorized $7\times 7$ includes a change that factorizes the first $7\times 7$ convolutional layer into a sequence of $3\times 3$ convolutional layers. BN-auxiliary refers to the version in which the fully connected layer of the auxiliary classifier is also batch-normalized, not just the convolutions. We are referring to the model in last row of Table 3 as Inception-v3 and evaluate its performance in the multi-crop and ensemble settings.</p>
<p>All our evaluations are done on the 48238 non-blacklisted examples on the<br>
ILSVRC-2012 validation set, as suggested by ~\cite{russakovsky2014imagenet}.<br>
We have evaluated all the 50000 examples as well and the results were roughly<br>
0.1\% worse in top-5 error and around 0.2\% in top-1<br>
error. In the upcoming version of this paper, we will verify our ensemble<br>
result on the test set, but at the time of our last evaluation of<br>
BN-Inception in spring~\cite{ioffe2015batch} indicates that the test and<br>
validation set error tends to correlate very well.</p>
<h2 id="references"><a name="user-content-references" href="#references" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>References</h2>
<p>[1] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane ́, R. Monga, S. Moore, D. Murray, C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Vie ́gas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. TensorFlow: Large-scale machine learning on heterogeneous systems, 2015. Software available from tensorflow.org.</p>
<p>[2] W. Chen, J. T. Wilson, S. Tyree, K. Q. Weinberger, and Y. Chen. Compressing neural networks with the hashing trick. In Proceedings of The 32nd International Conference on Machine Learning, 2015.</p>
<p>[3] C. Dong, C. C. Loy, K. He, and X. Tang. Learning a deep convolutional network for image super-resolution. In Computer Vision–ECCV 2014, pages 184–199. Springer, 2014.</p>
<p>[4] D.Erhan,C.Szegedy,A.Toshev,andD.Anguelov.Scalable object detection using deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 2155–2162. IEEE, 2014.</p>
<p>[5] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[6] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep into rectifiers: Surpassing human-level performance on imagenet classification. arXiv preprint arXiv:1502.01852, 2015.</p>
<p>[7] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Proceedings of The 32nd International Conference on Machine Learning, pages 448–456, 2015.</p>
<p>[8] A.Karpathy,G.Toderici,S.Shetty,T.Leung,R.Sukthankar, and L. Fei-Fei. Large-scale video classification with convolutional neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1725–1732. IEEE, 2014.</p>
<p>[9] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012.</p>
<p>[10] A. Lavin. Fast algorithms for convolutional neural networks. arXiv preprint arXiv:1509.09308, 2015.</p>
<p>[11] C.-Y.Lee,S.Xie,P.Gallagher,Z.Zhang,andZ.Tu.Deeply-supervised nets. arXiv preprint arXiv:1409.5185, 2014. </p>
<p>[12] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3431–3440, 2015.</p>
<p>[13] Y. Movshovitz-Attias, Q. Yu, M. C. Stumpe, V. Shet, S. Arnoud, and L. Yatziv. Ontological supervision for fine grained classification of street view storefronts. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1693–1702, 2015.</p>
<p>[14] R. Pascanu, T. Mikolov, and Y. Bengio. On the difficulty of training recurrent neural networks. arXiv preprint arXiv:1211.5063, 2012.</p>
<p>[15] D. C. Psichogios and L. H. Ungar. Svd-net: an algorithm that automatically selects network structure. IEEE transactions on neural networks/a publication of the IEEE Neural Networks Council, 5(3):513–515, 1993.</p>
<p>[16] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. 2014.</p>
<p>[17] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A unified embedding for face recognition and clustering. arXiv preprint arXiv:1503.03832, 2015.</p>
<p>[18] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.</p>
<p>[19] I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization and momentum in deep learning. In Proceedings of the 30th <br>
International Conference on Machine Learning (ICML-13), volume 28, pages 1139–1147. JMLR Workshop and Conference Proceedings, May 2013.</p>
<p>[20] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1–9, 2015.</p>
<p>[21] T. Tieleman and G. Hinton. Divide the gradient by a running average of its recent magnitude. COURSERA: Neural Networks for Machine Learning, 4, 2012. Accessed: 2015-11-05.</p>
<p>[22] A. Toshev and C. Szegedy. Deeppose: Human pose estimation via deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1653–1660. IEEE, 2014.</p>
<p>[23] N. Wang and D.-Y. Yeung. Learning a deep compact image representation for visual tracking. In Advances in Neural Information Processing Systems, pages 809–817, 2013.</p></article></body></html>]]></content>
    
    <summary type="html">
    
      &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;layout&quot; content=&quot;post&quot;&gt;
&lt;meta name=&quot;description&quot; content=&quot;Inception-V3论文翻译——中英文
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Check failed shape[i] &gt;= 0 (-1 vs. 0)错误</title>
    <link href="noahsnail.com/2017/10/13/2017-10-13-Check%20failed-%20shape%5Bi%5D%20%3E=%200%20(-1%20vs.%200)%E9%94%99%E8%AF%AF/"/>
    <id>noahsnail.com/2017/10/13/2017-10-13-Check failed- shape[i] &gt;= 0 (-1 vs. 0)错误/</id>
    <published>2017-10-13T02:00:22.000Z</published>
    <updated>2017-10-13T02:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>在使用Caffe模型进行图像分类时，通常使用的图像大小为<code>224 * 224</code>，如果改变输入图像的大小，有时候会碰到<code>Check failed: shape[i] &gt;= 0 (-1 vs. 0)</code>错误。</p>
<ul>
<li>背景</li>
</ul>
<p>使用ResNet-50进行图像分类训练，输入图像的大小为<code>160 *160</code>。</p>
<ul>
<li>错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">I1013 10:53:03.395526 76959 net.cpp:129] Top shape: 16 2048 5 5 (819200)</div><div class="line">I1013 10:53:03.395531 76959 net.cpp:137] Memory required for data: 1889075264</div><div class="line">I1013 10:53:03.395539 76959 layer_factory.hpp:77] Creating layer res5c_relu</div><div class="line">I1013 10:53:03.395553 76959 net.cpp:84] Creating Layer res5c_relu</div><div class="line">I1013 10:53:03.395567 76959 net.cpp:406] res5c_relu &lt;- res5c</div><div class="line">I1013 10:53:03.395594 76959 net.cpp:367] res5c_relu -&gt; res5c (in-place)</div><div class="line">I1013 10:53:03.395841 76959 net.cpp:122] Setting up res5c_relu</div><div class="line">I1013 10:53:03.395855 76959 net.cpp:129] Top shape: 16 2048 5 5 (819200)</div><div class="line">I1013 10:53:03.395861 76959 net.cpp:137] Memory required for data: 1892352064</div><div class="line">I1013 10:53:03.395869 76959 layer_factory.hpp:77] Creating layer pool5</div><div class="line">I1013 10:53:03.395900 76959 net.cpp:84] Creating Layer pool5</div><div class="line">I1013 10:53:03.395908 76959 net.cpp:406] pool5 &lt;- res5c</div><div class="line">I1013 10:53:03.395931 76959 net.cpp:380] pool5 -&gt; pool5</div><div class="line">F1013 10:53:03.396807 76959 blob.cpp:32] Check failed: shape[i] &gt;= 0 (-1 vs. 0)</div><div class="line">*** Check failure stack trace: ***</div><div class="line">    @     0x7fa7eef89e6d  (unknown)</div><div class="line">    @     0x7fa7eef8bced  (unknown)</div><div class="line">    @     0x7fa7eef89a5c  (unknown)</div><div class="line">    @     0x7fa7eef8c63e  (unknown)</div><div class="line">    @     0x7fa7f6141829  caffe::Blob&lt;&gt;::Reshape()</div><div class="line">    @     0x7fa7f6141581  caffe::Blob&lt;&gt;::Reshape()</div><div class="line">    @     0x7fa7f6200958  caffe::PoolingLayer&lt;&gt;::Reshape()</div><div class="line">    @     0x7fa7f61b14d8  caffe::CuDNNPoolingLayer&lt;&gt;::Reshape()</div><div class="line">    @     0x7fa7f6167d29  caffe::Layer&lt;&gt;::SetUp()</div><div class="line">    @     0x7fa7f6240213  caffe::Net&lt;&gt;::Init()</div><div class="line">    @     0x7fa7f623e7ea  caffe::Net&lt;&gt;::Net()</div><div class="line">    @     0x7fa7f62711e1  caffe::Solver&lt;&gt;::InitTrainNet()</div><div class="line">    @     0x7fa7f6270a75  caffe::Solver&lt;&gt;::Init()</div><div class="line">    @     0x7fa7f62705a7  caffe::Solver&lt;&gt;::Solver()</div><div class="line">    @     0x7fa7f627dc66  caffe::SGDSolver&lt;&gt;::SGDSolver()</div><div class="line">    @     0x7fa7f6287ab1  caffe::Creator_SGDSolver&lt;&gt;()</div><div class="line">    @           0x4215f5  caffe::SolverRegistry&lt;&gt;::CreateSolver()</div><div class="line">    @           0x41bdce  train()</div><div class="line">    @           0x41e167  main</div><div class="line">    @     0x7fa7e20eeb35  __libc_start_main</div><div class="line">    @           0x41aa69  (unknown)</div></pre></td></tr></table></figure>
<ul>
<li>解决方案</li>
</ul>
<p>错误日志中可以看出问题出在<code>pool5层</code>，它的输入为<code>Top shape: 16 2048 5 5 (819200)</code>，即<code>16 * 2048 * 5 * 5</code>，<code>16</code>是<code>batch_size</code>，<code>2048</code>为<code>channel</code>数量，即kernel个数，feature map大小为<code>5 * 5</code>，在prototxt中找到<code>pool5层</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">layer &#123;</div><div class="line">    bottom: &quot;res5c&quot;</div><div class="line">    top: &quot;pool5&quot;</div><div class="line">    name: &quot;pool5&quot;</div><div class="line">    type: &quot;Pooling&quot;</div><div class="line">    pooling_param &#123;</div><div class="line">        kernel_size: 7</div><div class="line">        stride: 1</div><div class="line">        pool: AVE</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kernel size为7，比5大，因此将7改为5，重新训练，没问题。</p>
]]></content>
    
    <summary type="html">
    
      Check failed shape[i] &gt;= 0 (-1 vs. 0)错误
    
    </summary>
    
      <category term="Caffe" scheme="noahsnail.com/categories/Caffe/"/>
    
    
      <category term="Caffe" scheme="noahsnail.com/tags/Caffe/"/>
    
  </entry>
  
  <entry>
    <title>Inception-V3论文翻译——中文版</title>
    <link href="noahsnail.com/2017/10/09/2017-10-9-Inception-V3%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>noahsnail.com/2017/10/09/2017-10-9-Inception-V3论文翻译——中文版/</id>
    <published>2017-10-09T08:25:03.000Z</published>
    <updated>2017-11-17T10:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="Rethinking-the-Inception-Architecture-for-Computer-Vision"><a href="#Rethinking-the-Inception-Architecture-for-Computer-Vision" class="headerlink" title="Rethinking the Inception Architecture for Computer Vision"></a>Rethinking the Inception Architecture for Computer Vision</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>对许多任务而言，卷积网络是目前最新的计算机视觉解决方案的核心。从2014年开始，深度卷积网络开始变成主流，在各种基准数据集上都取得了实质性成果。对于大多数任务而言，虽然增加的模型大小和计算成本都趋向于转化为直接的质量收益（只要提供足够的标注数据去训练），但计算效率和低参数计数仍是各种应用场景的限制因素，例如移动视觉和大数据场景。目前，我们正在探索增大网络的方法，目标是通过适当的分解卷积和积极的正则化来尽可能地有效利用增加的计算。我们在ILSVRC 2012分类挑战赛的验证集上评估了我们的方法，结果证明我们的方法超过了目前最先进的方法并取得了实质性收益：对于单一框架评估错误率为：<code>21.2% top-1</code>和<code>5.6% top-5</code>，使用的网络计算代价为每次推断需要进行50亿次乘加运算并使用不到2500万的参数。通过四个模型组合和多次评估，我们报告了<code>3.5% top-5</code>和<code>17.3% top-1</code>的错误率。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>从2012年Krizhevsky等人[9]赢得了ImageNet竞赛[16]起，他们的网络“AlexNet”已经成功了应用到了许多计算机视觉任务中，例如目标检测[5]，分割[12]，行人姿势评估[22]，视频分类[8]，目标跟踪[23]和超分辨率[3]。</p>
<p>这些成功推动了一个新研究领域，这个领域主要专注于寻找更高效运行的卷积神经网络。从2014年开始，通过利用更深更宽的网络，网络架构的质量得到了明显改善。VGGNet[18]和GoogLeNet[20]在2014 ILSVRC [16]分类挑战上取得了类似的高性能。一个有趣的发现是在分类性能上的收益趋向于转换成各种应用领域上的显著质量收益。这意味着深度卷积架构上的架构改进可以用来改善大多数越来越多地依赖于高质量、可学习视觉特征的其它计算机视觉任务的性能。网络质量的改善也导致了卷积网络在新领域的应用，在AlexNet特征不能与手工精心设计的解决方案竞争的情况下，例如，检测时的候选区域生成[4]。</p>
<p>尽管VGGNet[18]具有架构简洁的强有力特性，但它的成本很高：评估网络需要大量的计算。另一方面，GoogLeNet[20]的Inception架构也被设计为在内存和计算预算严格限制的情况下也能表现良好。例如，GoogleNet只使用了500万参数，与其前身AlexNet相比减少了12倍，AlexNet使用了6000万参数。此外，VGGNet使用了比AlexNet大约多3倍的参数。</p>
<p>Inception的计算成本也远低于VGGNet或其更高性能的后继者[6]。这使得可以在大数据场景中[17]，[13]，在大量数据需要以合理成本处理的情况下或在内存或计算能力固有地受限情况下，利用Inception网络变得可行，例如在移动视觉设定中。通过应用针对内存使用的专门解决方案[2]，[15]或通过计算技巧优化某些操作的执行[10]，可以减轻部分这些问题。但是这些方法增加了额外的复杂性。此外，这些方法也可以应用于优化Inception架构，再次扩大效率差距。</p>
<p>然而，Inception架构的复杂性使得更难以对网络进行更改。如果单纯地放大架构，大部分的计算收益可能会立即丢失。此外，[20]并没有提供关于导致GoogLeNet架构的各种设计决策的贡献因素的明确描述。这使得它更难以在适应新用例的同时保持其效率。例如，如果认为有必要增加一些Inception模型的能力，将滤波器组大小的数量加倍的简单变换将导致计算成本和参数数量增加4倍。这在许多实际情况下可能会被证明是禁止或不合理的，尤其是在相关收益适中的情况下。在本文中，我们从描述一些一般原则和优化思想开始，对于以有效的方式扩展卷积网络来说，这被证实是有用的。虽然我们的原则不局限于Inception类型的网络，但是在这种情况下，它们更容易观察，因为Inception类型构建块的通用结构足够灵活，可以自然地合并这些约束。这通过大量使用降维和Inception模块的并行结构来实现，这允许减轻结构变化对邻近组件的影响。但是，对于这样做需要谨慎，因为应该遵守一些指导原则来保持模型的高质量。</p>
<h2 id="2-通用设计原则"><a href="#2-通用设计原则" class="headerlink" title="2. 通用设计原则"></a>2. 通用设计原则</h2><p>这里我们将介绍一些具有卷积网络的、具有各种架构选择的、基于大规模实验的设计原则。在这一点上，以下原则的效用是推测性的，另外将来的实验证据将对于评估其准确性和有效领域是必要的。然而，严重偏移这些原则往往会导致网络质量的恶化，修正检测到的这些偏差状况通常会导致改进的架构。</p>
<ol>
<li><p>避免表征瓶颈，尤其是在网络的前面。前馈网络可以由从输入层到分类器或回归器的非循环图表示。这为信息流定义了一个明确的方向。对于分离输入输出的任何切口，可以访问通过切口的信息量。应该避免极端压缩的瓶颈。一般来说，在达到用于着手任务的最终表示之前，表示大小应该从输入到输出缓慢减小。理论上，信息内容不能仅通过表示的维度来评估，因为它丢弃了诸如相关结构的重要因素；维度仅提供信息内容的粗略估计。</p>
</li>
<li><p>更高维度的表示在网络中更容易局部处理。在卷积网络中增加每个图块的激活允许更多解耦的特征。所产生的网络将训练更快。</p>
</li>
<li><p>空间聚合可以在较低维度嵌入上完成，而不会在表示能力上造成许多或任何损失。例如，在执行更多展开（例如3×3）卷积之前，可以在空间聚合之前减小输入表示的维度，没有预期的严重不利影响。我们假设，如果在空间聚合上下文中使用输出，则相邻单元之间的强相关性会导致维度缩减期间的信息损失少得多。鉴于这些信号应该易于压缩，因此尺寸减小甚至会促进更快的学习。</p>
</li>
<li><p>平衡网络的宽度和深度。通过平衡每个阶段的滤波器数量和网络的深度可以达到网络的最佳性能。增加网络的宽度和深度可以有助于更高质量的网络。然而，如果两者并行增加，则可以达到恒定计算量的最佳改进。因此，计算预算应该在网络的深度和宽度之间以平衡方式进行分配。</p>
</li>
</ol>
<p>虽然这些原则可能是有意义的，但并不是开箱即用的直接使用它们来提高网络质量。我们的想法是仅在不明确的情况下才明智地使用它们。</p>
<h2 id="3-基于大滤波器尺寸分解卷积"><a href="#3-基于大滤波器尺寸分解卷积" class="headerlink" title="3. 基于大滤波器尺寸分解卷积"></a>3. 基于大滤波器尺寸分解卷积</h2><p>GoogLeNet网络[20]的大部分初始收益来源于大量地使用降维。这可以被视为以计算有效的方式分解卷积的特例。考虑例如1×1卷积层之后接一个3×3卷积层的情况。在视觉网络中，预期相近激活的输出是高度相关的。因此，我们可以预期，它们的激活可以在聚合之前被减少，并且这应该会导致类似的富有表现力的局部表示。</p>
<p>在这里，我们将在各种设定中探索卷积分解的其它方法，特别是为了提高解决方案的计算效率。由于Inception网络是全卷积的，每个权重对应每个激活的一次乘法。因此，任何计算成本的降低会导致参数数量减少。这意味着，通过适当的分解，我们可以得到更多的解耦参数，从而加快训练。此外，我们可以使用计算和内存节省来增加我们网络的滤波器组的大小，同时保持我们在单个计算机上训练每个模型副本的能力。</p>
<h3 id="3-1-分解到更小的卷积"><a href="#3-1-分解到更小的卷积" class="headerlink" title="3.1. 分解到更小的卷积"></a>3.1. 分解到更小的卷积</h3><p>具有较大空间滤波器（例如5×5或7×7）的卷积在计算方面往往不成比例地昂贵。例如，具有n个滤波器的5×5卷积在具有m个滤波器的网格上比具有相同数量的滤波器的3×3卷积的计算量高25/9=2.78倍。当然，5×5滤波器在更前面的层可以捕获更远的单元激活之间、信号之间的依赖关系，因此滤波器几何尺寸的减小带来了很大的表现力。然而，我们可以询问5×5卷积是否可以被具有相同输入尺寸和输出深度的参数较小的多层网络所取代。如果我们放大5×5卷积的计算图，我们看到每个输出看起来像一个小的完全连接的网络，在其输入上滑过5×5的块（见图1）。由于我们正在构建视觉网络，所以通过两层的卷积结构再次利用平移不变性来代替全连接的组件似乎是很自然的：第一层是3×3卷积，第二层是在第一层的3×3输出网格之上的一个全连接层（见图1）。通过在输入激活网格上滑动这个小网络，用两层3×3卷积来替换5×5卷积（比较图4和5）。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig1.png" alt="Figure 1"></p>
<p>图1。Mini网络替换5×5卷积</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig4.png" alt="Figure 4"></p>
<p>图4。[20]中描述的最初的Inception模块.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig5.png" alt="Figure 5"></p>
<p>图5。Inception模块中每个5×5卷积由两个3×3卷积替换，正如第2小节中原则3建议的那样。</p>
<p>该设定通过相邻块之间共享权重明显减少了参数数量。为了分析预期的计算成本节省，我们将对典型的情况进行一些简单的假设：我们可以假设$n=\alpha m$，也就是我们想通过常数$\alpha$因子来改变激活/单元的数量。由于5×5卷积是聚合的，$\alpha$通常比1略大（在GoogLeNet中大约是1.5）。用两个层替换5×5层，似乎可以通过两个步骤来实现扩展：在两个步骤中通过$\sqrt \alpha$增加滤波器数量。为了简化我们的估计，通过选择$\alpha=1$（无扩展），如果我们单纯地滑动网络而不重新使用相邻网格图块之间的计算，我们将增加计算成本。滑动该网络可以由两个3×3的卷积层表示，其重用相邻图块之间的激活。这样，我们最终得到一个计算量减少到$\frac {9+9} {25} ×$的网络，通过这种分解导致了28％的相对增益。每个参数在每个单元的激活计算中只使用一次，所以参数计数具有完全相同的节约。不过，这个设置提出了两个一般性的问题：这种替换是否会导致任何表征力的丧失？如果我们的主要目标是对计算的线性部分进行分解，是不是建议在第一层保持线性激活？我们已经进行了几个控制实验（例如参见图2），并且在分解的所有阶段中使用线性激活总是逊于使用修正线性单元。我们将这个收益归因于网络可以学习的增强的空间变化，特别是如果我们对输出激活进行批标准化[7]。当对维度减小组件使用线性激活时，可以看到类似的效果。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig2.png" alt="Figure 2"></p>
<p>图2。两个Inception模型间几个控制实验中的一个，其中一个分解为线性层+ ReLU层，另一个使用两个ReLU层。在三亿八千六百万次运算后，在验证集上前者达到了<code>76.2% top-1</code>准确率，后者达到了<code>77.2% top-1</code>的准确率。</p>
<h3 id="3-2-空间分解为不对称卷积"><a href="#3-2-空间分解为不对称卷积" class="headerlink" title="3.2. 空间分解为不对称卷积"></a>3.2. 空间分解为不对称卷积</h3><p>上述结果表明，大于3×3的卷积滤波器可能不是通常有用的，因为它们总是可以简化为3×3卷积层序列。我们仍然可以问这个问题，是否应该把它们分解成更小的，例如2×2的卷积。然而，通过使用非对称卷积，可以做出甚至比2×2更好的效果，即n×1。例如使用3×1卷积后接一个1×3卷积，相当于以与3×3卷积相同的感受野滑动两层网络（参见图3）。如果输入和输出滤波器的数量相等，那么对于相同数量的输出滤波器，两层解决方案便宜33％。相比之下，将3×3卷积分解为两个2×2卷积表示仅节省了11％的计算量。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig3.png" alt="Figure 3"></p>
<p>图3。替换3×3卷积的Mini网络。网络的更低层由带有3个输出单元的3×1构成。</p>
<p>在理论上，我们可以进一步论证，可以通过1×n卷积和后面接一个n×1卷积替换任何n×n卷积，并且随着n增长，计算成本节省显著增加（见图6）。实际上，我们发现，采用这种分解在前面的层次上不能很好地工作，但是对于中等网格尺寸（在m×m特征图上，其中m范围在12到20之间），其给出了非常好的结果。在这个水平上，通过使用1×7卷积，然后是7×1卷积可以获得非常好的结果。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig6.png" alt="Figure 6"></p>
<p>图6。n×n卷积分解后的Inception模块。在我们提出的架构中，对17×17的网格我们选择n=7。（滤波器尺寸可以通过原则3选择）</p>
<h2 id="4-利用辅助分类器"><a href="#4-利用辅助分类器" class="headerlink" title="4. 利用辅助分类器"></a>4. 利用辅助分类器</h2><p>[20]引入了辅助分类器的概念，以改善非常深的网络的收敛。最初的动机是将有用的梯度推向较低层，使其立即有用，并通过抵抗非常深的网络中的消失梯度问题来提高训练过程中的收敛。Lee等人[11]也认为辅助分类器促进了更稳定的学习和更好的收敛。有趣的是，我们发现辅助分类器在训练早期并没有导致改善收敛：在两个模型达到高精度之前，有无侧边网络的训练进度看起来几乎相同。接近训练结束，辅助分支网络开始超越没有任何分支的网络的准确性，达到了更高的稳定水平。</p>
<p>另外，[20]在网络的不同阶段使用了两个侧分支。移除更下面的辅助分支对网络的最终质量没有任何不利影响。再加上前一段的观察结果，这意味着[20]最初的假设，这些分支有助于演变低级特征很可能是不适当的。相反，我们认为辅助分类器起着正则化项的作用。这是由于如果侧分支是批标准化的[7]或具有丢弃层，则网络的主分类器性能更好。这也为推测批标准化作为正则化项给出了一个弱支持证据。</p>
<h2 id="5-有效的网格尺寸减少"><a href="#5-有效的网格尺寸减少" class="headerlink" title="5. 有效的网格尺寸减少"></a>5. 有效的网格尺寸减少</h2><p>传统上，卷积网络使用一些池化操作来缩减特征图的网格大小。为了避免表示瓶颈，在应用最大池化或平均池化之前，需要扩展网络滤波器的激活维度。例如，开始有一个带有$k$个滤波器的$d \times d$网格，如果我们想要达到一个带有$2k$个滤波器的$\frac{d}{2}\times \frac{d}{2}$网格，我们首先需要用$2k$个滤波器计算步长为1的卷积，然后应用一个额外的池化步骤。这意味着总体计算成本由在较大的网格上使用$2d^2k^2$次运算的昂贵卷积支配。一种可能性是转换为带有卷积的池化，因此导致$2(\frac{d}{2})^2k^2$次运算，将计算成本降低为原来的四分之一。然而，由于表示的整体维度下降到$(\frac{d}{2})^2k$，会导致表示能力较弱的网络（参见图9），这会产生一个表示瓶颈。我们建议另一种变体，其甚至进一步降低了计算成本，同时消除了表示瓶颈（见图10），而不是这样做。我们可以使用两个平行的步长为2的块：$P$和$C$。$P$是一个池化层（平均池化或最大池化）的激活，两者都是步长为$2$，其滤波器组连接如图10所示。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig9.png" alt="Figure 9"></p>
<p>图9。减少网格尺寸的两种替代方式。左边的解决方案违反了第2节中不引入表示瓶颈的原则1。右边的版本计算量昂贵3倍。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig10.png" alt="Figure 10"></p>
<p>图10。缩减网格尺寸的同时扩展滤波器组的Inception模块。它不仅廉价并且避免了原则1中提出的表示瓶颈。右侧的图表示相同的解决方案，但是从网格大小而不是运算的角度来看。</p>
<h2 id="6-Inception-v2"><a href="#6-Inception-v2" class="headerlink" title="6. Inception-v2"></a>6. Inception-v2</h2><p>在这里，我们连接上面的点，并提出了一个新的架构，在ILSVRC 2012分类基准数据集上提高了性能。我们的网络布局在表1中给出。注意，基于与3.1节中描述的同样想法，我们将传统的$7 \times 7$卷积分解为3个$3\times 3$卷积。对于网络的Inception部分，我们在$ 35 \times 35$处有$3$个传统的Inception模块，每个模块有$288$个滤波器。使用第5节中描述的网格缩减技术，这将缩减为$17\times 17$的网格，具有$768$个滤波器。这之后是图5所示的$5$个分解的Inception模块实例。使用图10所示的网格缩减技术，这被缩减为$8 \times 8 \times 1280$的网格。在最粗糙的$8 \times 8$级别，我们有两个如图6所示的Inception模块，每个块连接的输出滤波器组的大小为2048。网络的详细结构，包括Inception模块内滤波器组的大小，在补充材料中给出，在提交的tar文件中的<code>model.txt</code>中给出。然而，我们已经观察到，只要遵守第2节的原则，对于各种变化网络的质量就相对稳定。虽然我们的网络深度是$42$层，但我们的计算成本仅比GoogLeNet高出约$2.5$倍，它仍比VGGNet要高效的多。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_table1.png" alt="Table 1"></p>
<p>表1。提出的网络架构的轮廓。每个模块的输出大小是下一模块的输入大小。我们正在使用图10所示的缩减技术的变种，以缩减应用时Inception块间的网格大小。我们用0填充标记了卷积，用于保持网格大小。这些Inception模块内部也使用0填充，不会减小网格大小。所有其它层不使用填充。选择各种滤波器组大小来观察第2节的原理4。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig7.png" alt="Figure 7"></p>
<p>图7。具有扩展的滤波器组输出的Inception模块。这种架构被用于最粗糙的（$8 \times 8$）网格，以提升高维表示，如第2节原则2所建议的那样。我们仅在最粗的网格上使用了此解决方案，因为这是产生高维度的地方，稀疏表示是最重要的，因为与空间聚合相比，局部处理（$1 \times 1$ 卷积）的比率增加。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig8.png" alt="Figure 8"></p>
<p>图8。最后$17 \times 17$层之上的辅助分类器。 侧头中的层的批标准化[7]导致<code>top-1 0.4％</code>的绝对收益。下轴显示执行的迭代次数，每个批次大小为32。</p>
<h2 id="7-通过标签平滑进行模型正则化"><a href="#7-通过标签平滑进行模型正则化" class="headerlink" title="7. 通过标签平滑进行模型正则化"></a>7. 通过标签平滑进行模型正则化</h2><p>我们提出了一种通过估计训练期间标签丢弃的边缘化效应来对分类器层进行正则化的机制。</p>
<p>对于每个训练样本$x$，我们的模型计算每个标签的概率$k\in \lbrace 1\ldots K \rbrace$: $p(k|x) = \frac{\exp(z_k)}{\sum_{i=1}^K \exp(z_i)}$。这里，$z_i$是对数单位或未归一化的对数概率。考虑这个训练样本在标签上的实际分布$q(k|x)$，因此归一化后$\sum_k q(k|x) = 1$。为了简洁，我们省略$p$和$q$对样本$x$的依赖。我们将样本损失定义为交叉熵：$\ell = -\sum_{k=1}^K \log(p(k)) q(k)$。最小化交叉熵等价于最大化标签对数似然期望，其中标签是根据它的实际分布$q(k)$选择的。交叉熵损失对于$z_k$是可微的，因此可以用来进行深度模型的梯度训练。其梯度有一个更简单的形式：$\frac{\partial\ell}{\partial z_k} = p(k) - q(k)$，它的范围在$-1$到$1$之间。</p>
<p>考虑单个真实标签$y$的例子，对于所有$k\neq y$，有$q(y)=1$，$q(k)=0$。在这种情况下，最小化交叉熵等价于最大化正确标签的对数似然。对于一个特定的样本$x$，其标签为$y$，对于$q(k)= \delta_{k,y}$，最大化其对数概率，$\delta_{k,y}$为狄拉克δ函数，当且仅当$k=y$时，δ函数值为1，否则为0。对于有限的$z_k$，不能取得最大值，但对于所有$k\neq y$，如果$z_y\gg z_k$——也就是说，如果对应实际标签的逻辑单元远大于其它的逻辑单元，那么对数概率会接近最大值。然而这可能会引起两个问题。首先，它可能导致过拟合：如果模型学习到对于每一个训练样本，分配所有概率到实际标签上，那么它不能保证泛化能力。第二，它鼓励最大的逻辑单元与所有其它逻辑单元之间的差距变大，与有界限的梯度$\frac{\partial\ell}{\partial z_k}$相结合，这会降低模型的适应能力。直观上讲这会发生，因为模型变得对它的预测过于自信。</p>
<p>我们提出了一个鼓励模型不那么自信的机制。如果目标是最大化训练标签的对数似然，这可能不是想要的，但它确实使模型正规化并使其更具适应性。这个方法很简单。考虑标签$u(k)$的分布和平滑参数$\epsilon$，<em>与训练样本$x$相互独立</em>。对于一个真实标签为$y$的训练样本，我们用$$q’(k|x) = (1-\epsilon) \delta_{k,y} + \epsilon u(k)$$代替标签分布$q(k|x)=\delta_{k,y}$，其由最初的实际分布$q(k|x)$和固定分布$u(k)$混合得到，它们的权重分别为$1-\epsilon$和$\epsilon$。这可以看作获得标签$k$的分布如下：首先，将其设置为真实标签$k=y$；其次，用分布$u(k)$中的采样和概率$\epsilon$替代$k$。我们建议使用标签上的先验分布作为$u(k)$。在我们的实验中，我们使用了均匀分布$u(k) = 1/K$，以便使得$$q’(k) = (1-\epsilon) \delta_{k,y} + \frac{\epsilon}{K}.$$我们将真实标签分布中的这种变化称为<em>标签平滑正则化</em>，或LSR。</p>
<p>注意，LSR实现了期望的目标，阻止了最大的逻辑单元变得比其它的逻辑单元更大。实际上，如果发生这种情况，则一个$q(k)$将接近$1$，而所有其它的将会接近$0$。这会导致$q’(k)$有一个大的交叉熵，因为不同于$q(k)=\delta_{k,y}$，所有的$q’(k)$都有一个正的下界。</p>
<p>LSR的另一种解释可以通过考虑交叉熵来获得：$$H(q’,p) = -\sum_{k=1}^K \log p(k) q’(k) = (1-\epsilon)H(q, p) + \epsilon H(u, p)$$因此，LSR等价于用一对这样的损失$H(q,p)$和$H(u,p)$来替换单个交叉熵损失$H(q,p)$。第二个损失惩罚预测的标签分布$p$与先验$u$之间的偏差，其中相对权重为$\frac{\epsilon}{1-\epsilon}$。注意，由于$H(u,p) = D_{KL}(u|p) + H(u)$和$H(u)$是固定的，因此这个偏差可以等价地被KL散度捕获。当$u$是均匀分布时，$H(u,p)$是度量预测分布$p$与均匀分布不同的程度，也可以通过负熵$-H(p)$来度量（但不等价）；我们还没有实验过这种方法。</p>
<p>在我们的$K=1000$类的ImageNet实验中，我们使用了$u(k) = 1/1000$和$\epsilon=0.1$。对于ILSVRC 2012，我们发现对于<code>top-1</code>错误率和<code>top-5</code>错误率，持续提高了大约$0.2\%$（参见表3）。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table3.png" alt="Table 3"></p>
<p>表3。单张裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与Ioffe等人[7]发布的单张裁剪图像的最好推断结果进行了比较。在“Inception-v2”行，变化是累积的并且接下来的每一行都包含除了前面的变化之外的新变化。最后一行是所有的变化，我们称为“Inception-v3”。遗憾的是，He等人[6]仅报告了10个裁剪图像的评估结果，但没有单张裁剪图像的结果，报告在下面的表4中。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table4.png" alt="Table 4"></p>
<p>表4。单模型，多裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与ILSVRC 2012分类基准中发布的最佳单模型推断结果进行了比较。</p>
<h2 id="8-训练方法"><a href="#8-训练方法" class="headerlink" title="8. 训练方法"></a>8. 训练方法</h2><p>我们在TensorFlow[1]分布式机器学习系统上使用随机梯度方法训练了我们的网络，使用了$50$个副本，每个副本在一个NVidia Kepler GPU上运行，批处理大小为$32$，$100$个epoch。我们之前的实验使用动量方法[19]，衰减值为$0.9$，而我们最好的模型是用RMSProp [21]实现的，衰减值为$0.9$，$\epsilon=1.0$。我们使用$0.045$的学习率，每两个epoch以$0.94$的指数速率衰减。此外，阈值为$2.0$的梯度裁剪[14]被发现对于稳定训练是有用的。使用随时间计算的运行参数的平均值来执行模型评估。</p>
<h2 id="9-低分辨率输入上的性能"><a href="#9-低分辨率输入上的性能" class="headerlink" title="9. 低分辨率输入上的性能"></a>9. 低分辨率输入上的性能</h2><p>视觉网络的典型用例是用于检测的后期分类，例如在Multibox [4]上下文中。这包括分析在某个上下文中包含单个对象的相对较小的图像块。任务是确定图像块的中心部分是否对应某个对象，如果是，则确定该对象的类别。这个挑战的是对象往往比较小，分辨率低。这就提出了如何正确处理低分辨率输入的问题。</p>
<p>普遍的看法是，使用更高分辨率感受野的模型倾向于导致显著改进的识别性能。然而，区分第一层感受野分辨率增加的效果和较大的模型容量、计算量的效果是很重要的。如果我们只是改变输入的分辨率而不进一步调整模型，那么我们最终将使用计算上更便宜的模型来解决更困难的任务。当然，由于减少了计算量，这些解决方案很自然就出来了。为了做出准确的评估，模型需要分析模糊的提示，以便能够“幻化”细节。这在计算上是昂贵的。因此问题依然存在：如果计算量保持不变，更高的输入分辨率会有多少帮助。确保不断努力的一个简单方法是在较低分辨率输入的情况下减少前两层的步长，或者简单地移除网络的第一个池化层。</p>
<p>为了这个目的我们进行了以下三个实验：</p>
<ol>
<li>步长为$2$，大小为$299\times 299$的感受野和最大池化。</li>
<li>步长为$1$，大小为$151\times 151$的感受野和最大池化。</li>
<li>步长为$1$，大小为$79\times 79$的感受野和第一层之后<strong>没有</strong>池化。</li>
</ol>
<p>所有三个网络具有几乎相同的计算成本。虽然第三个网络稍微便宜一些，但是池化层的成本是无足轻重的（在总成本的$1\％$以内）。在每种情况下，网络都进行了训练，直到收敛，并在ImageNet ILSVRC 2012分类基准数据集的验证集上衡量其质量。结果如表2所示。虽然分辨率较低的网络需要更长时间去训练，但最终结果却与较高分辨率网络的质量相当接近。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table2.png" alt="Table 2"></p>
<p>表2。当感受野尺寸变化时，识别性能的比较，但计算代价是不变的。</p>
<p>但是，如果只是单纯地按照输入分辨率减少网络尺寸，那么网络的性能就会差得多。然而，这将是一个不公平的比较，因为我们将在比较困难的任务上比较一个便宜16倍的模型。</p>
<p>表2的这些结果也表明，有人可能会考虑在R-CNN [5]的上下文中对更小的对象使用专用的高成本低分辨率网络。</p>
<h2 id="10-实验结果和比较"><a href="#10-实验结果和比较" class="headerlink" title="10. 实验结果和比较"></a>10. 实验结果和比较</h2><p>表3显示了我们提出的体系结构（Inception-v2）识别性能的实验结果，架构如第6节所述。每个Inception-v2行显示了累积变化的结果，包括突出显示的新修改加上所有先前修改的结果。标签平滑是指在第7节中描述的方法。分解的$7\times 7$包括将第一个$7\times 7$卷积层分解成$3\times 3$卷积层序列的改变。BN-auxiliary是指辅助分类器的全连接层也批标准化的版本，而不仅仅是卷积。我们将表3最后一行的模型称为Inception-v3，并在多裁剪图像和组合设置中评估其性能。</p>
<p>我们所有的评估都在ILSVRC-2012验证集上的48238个非黑名单样本中完成，如[16]所示。我们也对所有50000个样本进行了评估，结果在<code>top-5</code>错误率中大约为$0.1\%$，在<code>top-1</code>错误率中大约为$0.2\%$。在本文即将出版的版本中，我们将在测试集上验证我们的组合结果，但是我们上一次对BN-Inception的春季测试[7]表明测试集和验证集错误趋于相关性很好。</p>
<h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11. 结论"></a>11. 结论</h2><p>我们提供了几个设计原则来扩展卷积网络，并在Inception体系结构的背景下进行研究。这个指导可以导致高性能的视觉网络，与更简单、更单一的体系结构相比，它具有相对适中的计算成本。Inception-v3的最高质量版本在ILSVR 2012分类上的<strong>单裁剪图像</strong>评估中达到了$21.2\％$的<code>top-1</code>错误率和$5.6\％$的<code>top-5</code>错误率，达到了新的水平。与Ioffe等[7]中描述的网络相比，这是通过增加相对适中（$2.5/times$）的计算成本来实​​现的。尽管如此，我们的解决方案所使用的计算量比基于更密集网络公布的最佳结果要少得多：我们的模型比He等[6]的结果更好——将<code>top-5(top-1)</code>的错误率相对分别减少了$25\%$ ($14\%$)，然而在计算代价上便宜了六倍，并且使用了至少减少了五倍的参数（估计值）。我们的四个Inception-v3模型的组合效果达到了$3.5\％$，多裁剪图像评估达到了$3.5\％$的<code>top-5</code>的错误率，这相当于比最佳发布的结果减少了$25\％$以上，几乎是ILSVRC 2014的冠军GoogLeNet组合错误率的一半。</p>
<p>我们还表明，可以通过感受野分辨率为$79\times 79$的感受野取得高质量的结果。这可能证明在检测相对较小物体的系统中是有用的。我们已经研究了在神经网络中如何分解卷积和积极降维可以导致计算成本相对较低的网络，同时保持高质量。较低的参数数量、额外的正则化、批标准化的辅助分类器和标签平滑的组合允许在相对适中大小的训练集上训练高质量的网络。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane ́, R. Monga, S. Moore, D. Murray, C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Vie ́gas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. TensorFlow: Large-scale machine learning on heterogeneous systems, 2015. Software available from tensorflow.org.</p>
<p>[2] W. Chen, J. T. Wilson, S. Tyree, K. Q. Weinberger, and Y. Chen. Compressing neural networks with the hashing trick. In Proceedings of The 32nd International Conference on Machine Learning, 2015.</p>
<p>[3] C. Dong, C. C. Loy, K. He, and X. Tang. Learning a deep convolutional network for image super-resolution. In Computer Vision–ECCV 2014, pages 184–199. Springer, 2014.</p>
<p>[4] D.Erhan,C.Szegedy,A.Toshev,andD.Anguelov.Scalable object detection using deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 2155–2162. IEEE, 2014.</p>
<p>[5] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[6] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep into rectifiers: Surpassing human-level performance on imagenet classification. arXiv preprint arXiv:1502.01852, 2015.</p>
<p>[7] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Proceedings of The 32nd International Conference on Machine Learning, pages 448–456, 2015.</p>
<p>[8] A.Karpathy,G.Toderici,S.Shetty,T.Leung,R.Sukthankar, and L. Fei-Fei. Large-scale video classification with convolutional neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1725–1732. IEEE, 2014.</p>
<p>[9] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012.</p>
<p>[10] A. Lavin. Fast algorithms for convolutional neural networks. arXiv preprint arXiv:1509.09308, 2015.</p>
<p>[11] C.-Y.Lee,S.Xie,P.Gallagher,Z.Zhang,andZ.Tu.Deeply-supervised nets. arXiv preprint arXiv:1409.5185, 2014. </p>
<p>[12] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3431–3440, 2015.</p>
<p>[13] Y. Movshovitz-Attias, Q. Yu, M. C. Stumpe, V. Shet, S. Arnoud, and L. Yatziv. Ontological supervision for fine grained classification of street view storefronts. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1693–1702, 2015.</p>
<p>[14] R. Pascanu, T. Mikolov, and Y. Bengio. On the difficulty of training recurrent neural networks. arXiv preprint arXiv:1211.5063, 2012.</p>
<p>[15] D. C. Psichogios and L. H. Ungar. Svd-net: an algorithm that automatically selects network structure. IEEE transactions on neural networks/a publication of the IEEE Neural Networks Council, 5(3):513–515, 1993.</p>
<p>[16] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. 2014.</p>
<p>[17] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A unified embedding for face recognition and clustering. arXiv preprint arXiv:1503.03832, 2015.</p>
<p>[18] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.</p>
<p>[19] I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization and momentum in deep learning. In Proceedings of the 30th<br>International Conference on Machine Learning (ICML-13), volume 28, pages 1139–1147. JMLR Workshop and Conference Proceedings, May 2013.</p>
<p>[20] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1–9, 2015.</p>
<p>[21] T. Tieleman and G. Hinton. Divide the gradient by a running average of its recent magnitude. COURSERA: Neural Networks for Machine Learning, 4, 2012. Accessed: 2015-11-05.</p>
<p>[22] A. Toshev and C. Szegedy. Deeppose: Human pose estimation via deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1653–1660. IEEE, 2014.</p>
<p>[23] N. Wang and D.-Y. Yeung. Learning a deep compact image representation for visual tracking. In Advances in Neural Information Processing Systems, pages 809–817, 2013.</p>
]]></content>
    
    <summary type="html">
    
      Inception-V3论文翻译——中文版
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Inception-V3论文翻译——中英文对照</title>
    <link href="noahsnail.com/2017/10/09/2017-10-9-Inception-V3%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
    <id>noahsnail.com/2017/10/09/2017-10-9-Inception-V3论文翻译——中英文对照/</id>
    <published>2017-10-09T08:24:27.000Z</published>
    <updated>2017-11-17T10:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="Rethinking-the-Inception-Architecture-for-Computer-Vision"><a href="#Rethinking-the-Inception-Architecture-for-Computer-Vision" class="headerlink" title="Rethinking the Inception Architecture for Computer Vision"></a>Rethinking the Inception Architecture for Computer Vision</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Convolutional networks are at the core of most state-of-the-art computer vision solutions for a wide variety of tasks. Since 2014 very deep convolutional networks started to become mainstream, yielding substantial gains in various benchmarks. Although increased model size and computational cost tend to translate to immediate quality gains for most tasks (as long as enough labeled data is provided for training), computational efficiency and low parameter count are still enabling factors for various use cases such as mobile vision and big-data scenarios. Here we are exploring ways to scale up networks in ways that aim at utilizing the added computation as efficiently as possible by suitably factorized convolutions and aggressive regularization. We benchmark our methods on the ILSVRC 2012 classification challenge validation set demonstrate substantial gains over the state of the art: 21.2% top-1 and 5.6% top-5 error for single frame evaluation using a network with a computational cost of 5 billion multiply-adds per inference and with using less than 25 million parameters. With an ensemble of 4 models and multi-crop evaluation, we report 3.5% top-5 error and 17.3% top-1 error.</p>
<p>对许多任务而言，卷积网络是目前最新的计算机视觉解决方案的核心。从2014年开始，深度卷积网络开始变成主流，在各种基准数据集上都取得了实质性成果。对于大多数任务而言，虽然增加的模型大小和计算成本都趋向于转化为直接的质量收益（只要提供足够的标注数据去训练），但计算效率和低参数计数仍是各种应用场景的限制因素，例如移动视觉和大数据场景。目前，我们正在探索增大网络的方法，目标是通过适当的分解卷积和积极的正则化来尽可能地有效利用增加的计算。我们在ILSVRC 2012分类挑战赛的验证集上评估了我们的方法，结果证明我们的方法超过了目前最先进的方法并取得了实质性收益：对于单一框架评估错误率为：<code>21.2% top-1</code>和<code>5.6% top-5</code>，使用的网络计算代价为每次推断需要进行50亿次乘加运算并使用不到2500万的参数。通过四个模型组合和多次评估，我们报告了<code>3.5% top-5</code>和<code>17.3% top-1</code>的错误率。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Since the 2012 ImageNet competition [16] winning entry by Krizhevsky et al [9], their network “AlexNet” has been successfully applied to a larger variety of computer vision tasks, for example to object-detection [5], segmentation [12], human pose estimation [22], video classification [8], object tracking [23], and superresolution [3].</p>
<p>从2012年Krizhevsky等人[9]赢得了ImageNet竞赛[16]起，他们的网络“AlexNet”已经成功了应用到了许多计算机视觉任务中，例如目标检测[5]，分割[12]，行人姿势评估[22]，视频分类[8]，目标跟踪[23]和超分辨率[3]。</p>
<p>These successes spurred a new line of research that focused on finding higher performing convolutional neural networks. Starting in 2014, the quality of network architectures significantly improved by utilizing deeper and wider networks. VGGNet [18] and GoogLeNet [20] yielded similarly high performance in the 2014 ILSVRC [16] classification challenge. One interesting observation was that gains in the classification performance tend to transfer to significant quality gains in a wide variety of application domains. This means that architectural improvements in deep convolutional architecture can be utilized for improving performance for most other computer vision tasks that are increasingly reliant on high quality, learned visual features. Also, improvements in the network quality resulted in new application domains for convolutional networks in cases where AlexNet features could not compete with hand engineered, crafted solutions, e.g. proposal generation in detection[4].</p>
<p>这些成功推动了一个新研究领域，这个领域主要专注于寻找更高效运行的卷积神经网络。从2014年开始，通过利用更深更宽的网络，网络架构的质量得到了明显改善。VGGNet[18]和GoogLeNet[20]在2014 ILSVRC [16]分类挑战上取得了类似的高性能。一个有趣的发现是在分类性能上的收益趋向于转换成各种应用领域上的显著质量收益。这意味着深度卷积架构上的架构改进可以用来改善大多数越来越多地依赖于高质量、可学习视觉特征的其它计算机视觉任务的性能。网络质量的改善也导致了卷积网络在新领域的应用，在AlexNet特征不能与手工精心设计的解决方案竞争的情况下，例如，检测时的候选区域生成[4]。</p>
<p>Although VGGNet [18] has the compelling feature of architectural simplicity, this comes at a high cost: evaluating the network requires a lot of computation. On the other hand, the Inception architecture of GoogLeNet [20] was also designed to perform well even under strict constraints on memory and computational budget. For example, GoogleNet employed only 5 million parameters, which represented a 12× reduction with respect to its predecessor AlexNet, which used 60 million parameters. Furthermore, VGGNet employed about 3x more parameters than AlexNet.</p>
<p>尽管VGGNet[18]具有架构简洁的强有力特性，但它的成本很高：评估网络需要大量的计算。另一方面，GoogLeNet[20]的Inception架构也被设计为在内存和计算预算严格限制的情况下也能表现良好。例如，GoogleNet只使用了500万参数，与其前身AlexNet相比减少了12倍，AlexNet使用了6000万参数。此外，VGGNet使用了比AlexNet大约多3倍的参数。</p>
<p>The computational cost of Inception is also much lower than VGGNet or its higher performing successors [6]. This has made it feasible to utilize Inception networks in big-data scenarios[17], [13], where huge amount of data needed to be processed at reasonable cost or scenarios where memory or computational capacity is inherently limited, for example in mobile vision settings. It is certainly possible to mitigate parts of these issues by applying specialized solutions to target memory use [2], [15] or by optimizing the execution of certain operations via computational tricks [10]. However, these methods add extra complexity. Furthermore, these methods could be applied to optimize the Inception architecture as well, widening the efficiency gap again.</p>
<p>Inception的计算成本也远低于VGGNet或其更高性能的后继者[6]。这使得可以在大数据场景中[17]，[13]，在大量数据需要以合理成本处理的情况下或在内存或计算能力固有地受限情况下，利用Inception网络变得可行，例如在移动视觉设定中。通过应用针对内存使用的专门解决方案[2]，[15]或通过计算技巧优化某些操作的执行[10]，可以减轻部分这些问题。但是这些方法增加了额外的复杂性。此外，这些方法也可以应用于优化Inception架构，再次扩大效率差距。</p>
<p>Still, the complexity of the Inception architecture makes it more difficult to make changes to the network. If the architecture is scaled up naively, large parts of the computational gains can be immediately lost. Also, [20] does not provide a clear description about the contributing factors that lead to the various design decisions of the GoogLeNet architecture. This makes it much harder to adapt it to new use-cases while maintaining its efficiency. For example, if it is deemed necessary to increase the capacity of some Inception-style model, the simple transformation of just doubling the number of all filter bank sizes will lead to a 4x increase in both computational cost and number of parameters. This might prove prohibitive or unreasonable in a lot of practical scenarios, especially if the associated gains are modest. In this paper, we start with describing a few general principles and optimization ideas that that proved to be useful for scaling up convolution networks in efficient ways. Although our principles are not limited to Inception-type networks, they are easier to observe in that context as the generic structure of the Inception style building blocks is flexible enough to incorporate those constraints naturally. This is enabled by the generous use of dimensional reduction and parallel structures of the Inception modules which allows for mitigating the impact of structural changes on nearby components. Still, one needs to be cautious about doing so, as some guiding principles should be observed to maintain high quality of the models.</p>
<p>然而，Inception架构的复杂性使得更难以对网络进行更改。如果单纯地放大架构，大部分的计算收益可能会立即丢失。此外，[20]并没有提供关于导致GoogLeNet架构的各种设计决策的贡献因素的明确描述。这使得它更难以在适应新用例的同时保持其效率。例如，如果认为有必要增加一些Inception模型的能力，将滤波器组大小的数量加倍的简单变换将导致计算成本和参数数量增加4倍。这在许多实际情况下可能会被证明是禁止或不合理的，尤其是在相关收益适中的情况下。在本文中，我们从描述一些一般原则和优化思想开始，对于以有效的方式扩展卷积网络来说，这被证实是有用的。虽然我们的原则不局限于Inception类型的网络，但是在这种情况下，它们更容易观察，因为Inception类型构建块的通用结构足够灵活，可以自然地合并这些约束。这通过大量使用降维和Inception模块的并行结构来实现，这允许减轻结构变化对邻近组件的影响。但是，对于这样做需要谨慎，因为应该遵守一些指导原则来保持模型的高质量。</p>
<h2 id="2-General-Design-Principles"><a href="#2-General-Design-Principles" class="headerlink" title="2. General Design Principles"></a>2. General Design Principles</h2><p>Here we will describe a few design principles based on large-scale experimentation with various architectural choices with convolutional networks. At this point, the utility of the principles below are speculative and additional future experimental evidence will be necessary to assess their accuracy and domain of validity. Still, grave deviations from these principles tended to result in deterioration in the quality of the networks and fixing situations where those deviations were detected resulted in improved architectures in general.</p>
<h2 id="2-通用设计原则"><a href="#2-通用设计原则" class="headerlink" title="2. 通用设计原则"></a>2. 通用设计原则</h2><p>这里我们将介绍一些具有卷积网络的、具有各种架构选择的、基于大规模实验的设计原则。在这一点上，以下原则的效用是推测性的，另外将来的实验证据将对于评估其准确性和有效领域是必要的。然而，严重偏移这些原则往往会导致网络质量的恶化，修正检测到的这些偏差状况通常会导致改进的架构。</p>
<ol>
<li><p>Avoid representational bottlenecks, especially early in the network. Feed-forward networks can be represented by an acyclic graph from the input layer(s) to the classifier or regressor. This defines a clear direction for the information flow. For any cut separating the inputs from the outputs, one can access the amount of information passing though the cut. One should avoid bottlenecks with extreme compression. In general the representation size should gently decrease from the inputs to the outputs before reaching the final representation used for the task at hand. Theoretically, information content can not be assessed merely by the dimensionality of the representation as it discards important factors like correlation structure; the dimensionality merely provides a rough estimate of information content.</p>
</li>
<li><p>Higher dimensional representations are easier to process locally within a network. Increasing the activations per tile in a convolutional network allows for more disentangled features. The resulting networks will train faster.</p>
</li>
<li><p>Spatial aggregation can be done over lower dimensional embeddings without much or any loss in representational power. For example, before performing a more spread out (e.g. 3 × 3) convolution, one can reduce the dimension of the input representation before the spatial aggregation without expecting serious adverse effects. We hypothesize that the reason for that is the strong correlation between adjacent unit results in much less loss of information during dimension reduction, if the outputs are used in a spatial aggregation context. Given that these signals should be easily compressible, the dimension reduction even promotes faster learning.</p>
</li>
<li><p>Balance the width and depth of the network. Optimal performance of the network can be reached by balancing the number of filters per stage and the depth of the network. Increasing both the width and the depth of the network can contribute to higher quality networks. However, the optimal improvement for a constant amount of computation can be reached if both are increased in parallel. The computational budget should therefore be distributed in a balanced way between the depth and width of the network.</p>
</li>
</ol>
<ol>
<li><p>避免表征瓶颈，尤其是在网络的前面。前馈网络可以由从输入层到分类器或回归器的非循环图表示。这为信息流定义了一个明确的方向。对于分离输入输出的任何切口，可以访问通过切口的信息量。应该避免极端压缩的瓶颈。一般来说，在达到用于着手任务的最终表示之前，表示大小应该从输入到输出缓慢减小。理论上，信息内容不能仅通过表示的维度来评估，因为它丢弃了诸如相关结构的重要因素；维度仅提供信息内容的粗略估计。</p>
</li>
<li><p>更高维度的表示在网络中更容易局部处理。在卷积网络中增加每个图块的激活允许更多解耦的特征。所产生的网络将训练更快。</p>
</li>
<li><p>空间聚合可以在较低维度嵌入上完成，而不会在表示能力上造成许多或任何损失。例如，在执行更多展开（例如3×3）卷积之前，可以在空间聚合之前减小输入表示的维度，没有预期的严重不利影响。我们假设，如果在空间聚合上下文中使用输出，则相邻单元之间的强相关性会导致维度缩减期间的信息损失少得多。鉴于这些信号应该易于压缩，因此尺寸减小甚至会促进更快的学习。</p>
</li>
<li><p>平衡网络的宽度和深度。通过平衡每个阶段的滤波器数量和网络的深度可以达到网络的最佳性能。增加网络的宽度和深度可以有助于更高质量的网络。然而，如果两者并行增加，则可以达到恒定计算量的最佳改进。因此，计算预算应该在网络的深度和宽度之间以平衡方式进行分配。</p>
</li>
</ol>
<p>Although these principles might make sense, it is not straightforward to use them to improve the quality of networks out of box. The idea is to use them judiciously in ambiguous situations only.</p>
<p>虽然这些原则可能是有意义的，但并不是开箱即用的直接使用它们来提高网络质量。我们的想法是仅在不明确的情况下才明智地使用它们。</p>
<h2 id="3-Factorizing-Convolutions-with-Large-Filter-Size"><a href="#3-Factorizing-Convolutions-with-Large-Filter-Size" class="headerlink" title="3. Factorizing Convolutions with Large Filter Size"></a>3. Factorizing Convolutions with Large Filter Size</h2><p>Much of the original gains of the GoogLeNet network [20] arise from a very generous use of dimension reduction. This can be viewed as a special case of factorizing convolutions in a computationally efficient manner. Consider for example the case of a 1 × 1 convolutional layer followed by a 3 × 3 convolutional layer. In a vision network, it is expected that the outputs of near-by activations are highly correlated. Therefore, we can expect that their activations can be reduced before aggregation and that this should result in similarly expressive local representations.</p>
<h2 id="3-基于大滤波器尺寸分解卷积"><a href="#3-基于大滤波器尺寸分解卷积" class="headerlink" title="3. 基于大滤波器尺寸分解卷积"></a>3. 基于大滤波器尺寸分解卷积</h2><p>GoogLeNet网络[20]的大部分初始收益来源于大量地使用降维。这可以被视为以计算有效的方式分解卷积的特例。考虑例如1×1卷积层之后接一个3×3卷积层的情况。在视觉网络中，预期相近激活的输出是高度相关的。因此，我们可以预期，它们的激活可以在聚合之前被减少，并且这应该会导致类似的富有表现力的局部表示。</p>
<p>Here we explore other ways of factorizing convolutions in various settings, especially in order to increase the computational efficiency of the solution. Since Inception networks are fully convolutional, each weight corresponds to one multiplication per activation. Therefore, any reduction in computational cost results in reduced number of parameters. This means that with suitable factorization, we can end up with more disentangled parameters and therefore with faster training. Also, we can use the computational and memory savings to increase the filter-bank sizes of our network while maintaining our ability to train each model replica on a single computer.</p>
<p>在这里，我们将在各种设定中探索卷积分解的其它方法，特别是为了提高解决方案的计算效率。由于Inception网络是全卷积的，每个权重对应每个激活的一次乘法。因此，任何计算成本的降低会导致参数数量减少。这意味着，通过适当的分解，我们可以得到更多的解耦参数，从而加快训练。此外，我们可以使用计算和内存节省来增加我们网络的滤波器组的大小，同时保持我们在单个计算机上训练每个模型副本的能力。</p>
<h3 id="3-1-Factorization-into-smaller-convolutions"><a href="#3-1-Factorization-into-smaller-convolutions" class="headerlink" title="3.1. Factorization into smaller convolutions"></a>3.1. Factorization into smaller convolutions</h3><p>Convolutions with larger spatial filters (e.g. 5 × 5 or 7 × 7) tend to be disproportionally expensive in terms of computation. For example, a 5 × 5 convolution with n filters over a grid with m filters is 25/9 = 2.78 times more computationally expensive than a 3 × 3 convolution with the same number of filters. Of course, a 5 × 5 filter can capture dependencies between signals between activations of units further away in the earlier layers, so a reduction of the geometric size of the filters comes at a large cost of expressiveness. However, we can ask whether a 5 × 5 convolution could be replaced by a multi-layer network with less parameters with the same input size and output depth. If we zoom into the computation graph of the 5 × 5 convolution, we see that each output looks like a small fully-connected network sliding over 5 × 5 tiles over its input (see Figure 1). Since we are constructing a vision network, it seems natural to exploit translation invariance again and replace the fully connected component by a two layer convolutional architecture: the first layer is a 3 × 3 convolution, the second is a fully connected layer on top of the 3 × 3 output grid of the first layer (see Figure 1). Sliding this small network over the input activation grid boils down to replacing the 5 × 5 convolution with two layers of 3 × 3 convolution (compare Figure 4 with 5).</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig1.png" alt="Figure 1"></p>
<p>Figure 1. Mini-network replacing the 5×5 convolutions.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig4.png" alt="Figure 4"></p>
<p>Figure 4. Original Inception module as described in [20].</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig5.png" alt="Figure 5"></p>
<p>Figure 5. Inception modules where each 5 × 5 convolution is replaced by two 3 × 3 convolution, as suggested by principle 3 of Section 2.</p>
<h3 id="3-1-分解到更小的卷积"><a href="#3-1-分解到更小的卷积" class="headerlink" title="3.1. 分解到更小的卷积"></a>3.1. 分解到更小的卷积</h3><p>具有较大空间滤波器（例如5×5或7×7）的卷积在计算方面往往不成比例地昂贵。例如，具有n个滤波器的5×5卷积在具有m个滤波器的网格上比具有相同数量的滤波器的3×3卷积的计算量高25/9=2.78倍。当然，5×5滤波器在更前面的层可以捕获更远的单元激活之间、信号之间的依赖关系，因此滤波器几何尺寸的减小带来了很大的表现力。然而，我们可以询问5×5卷积是否可以被具有相同输入尺寸和输出深度的参数较小的多层网络所取代。如果我们放大5×5卷积的计算图，我们看到每个输出看起来像一个小的完全连接的网络，在其输入上滑过5×5的块（见图1）。由于我们正在构建视觉网络，所以通过两层的卷积结构再次利用平移不变性来代替全连接的组件似乎是很自然的：第一层是3×3卷积，第二层是在第一层的3×3输出网格之上的一个全连接层（见图1）。通过在输入激活网格上滑动这个小网络，用两层3×3卷积来替换5×5卷积（比较图4和5）。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig1.png" alt="Figure 1"></p>
<p>图1。Mini网络替换5×5卷积</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig4.png" alt="Figure 4"></p>
<p>图4。[20]中描述的最初的Inception模块.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig5.png" alt="Figure 5"></p>
<p>图5。Inception模块中每个5×5卷积由两个3×3卷积替换，正如第2小节中原则3建议的那样。</p>
<p>This setup clearly reduces the parameter count by sharing the weights between adjacent tiles. To analyze the expected computational cost savings, we will make a few simplifying assumptions that apply for the typical situations: We can assume that $n = \alpha m$, that is that we want to change the number of activations/unit by a constant alpha factor. Since the 5 × 5 convolution is aggregating, $\alpha$ is typically slightly larger than one (around 1.5 in the case of GoogLeNet). Having a two layer replacement for the 5 × 5 layer, it seems reasonable to reach this expansion in two steps: increasing the number of filters by $\sqrt \alpha$ in both steps. In order to simplify our estimate by choosing $\alpha = 1 $(no expansion), if we would naivly slide a network without reusing the computation between neighboring grid tiles, we would increase the computational cost. Sliding this network can be represented by two 3 × 3 convolutional layers which reuses the activations between adjacent tiles. This way, we end up with a net $\frac {9+9} {25} ×$ reduction of computation, resulting in a relative gain of 28% by this factorization. The exact same saving holds for the parameter count as each parameter is used exactly once in the computation of the activation of each unit. Still, this setup raises two general questions: Does this replacement result in any loss of expressiveness? If our main goal is to factorize the linear part of the computation, would it not suggest to keep linear activations in the first layer? We have ran several control experiments (for example see figure 2) and using linear activation was always inferior to using rectified linear units in all stages of the factorization. We attribute this gain to the enhanced space of variations that the network can learn especially if we batch-normalize [7] the output activations. One can see similar effects when using linear activations for the dimension reduction components.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig2.png" alt="Figure 2"></p>
<p>Figure 2. One of several control experiments between two Inception models, one of them uses factorization into linear + ReLU layers, the other uses two ReLU layers. After 3.86 million operations, the former settles at 76.2%, while the latter reaches 77.2% top-1 Accuracy on the validation set.</p>
<p>该设定通过相邻块之间共享权重明显减少了参数数量。为了分析预期的计算成本节省，我们将对典型的情况进行一些简单的假设：我们可以假设$n=\alpha m$，也就是我们想通过常数$\alpha$因子来改变激活/单元的数量。由于5×5卷积是聚合的，$\alpha$通常比1略大（在GoogLeNet中大约是1.5）。用两个层替换5×5层，似乎可以通过两个步骤来实现扩展：在两个步骤中通过$\sqrt \alpha$增加滤波器数量。为了简化我们的估计，通过选择$\alpha=1$（无扩展），如果我们单纯地滑动网络而不重新使用相邻网格图块之间的计算，我们将增加计算成本。滑动该网络可以由两个3×3的卷积层表示，其重用相邻图块之间的激活。这样，我们最终得到一个计算量减少到$\frac {9+9} {25} ×$的网络，通过这种分解导致了28％的相对增益。每个参数在每个单元的激活计算中只使用一次，所以参数计数具有完全相同的节约。不过，这个设置提出了两个一般性的问题：这种替换是否会导致任何表征力的丧失？如果我们的主要目标是对计算的线性部分进行分解，是不是建议在第一层保持线性激活？我们已经进行了几个控制实验（例如参见图2），并且在分解的所有阶段中使用线性激活总是逊于使用修正线性单元。我们将这个收益归因于网络可以学习的增强的空间变化，特别是如果我们对输出激活进行批标准化[7]。当对维度减小组件使用线性激活时，可以看到类似的效果。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig2.png" alt="Figure 2"></p>
<p>图2。两个Inception模型间几个控制实验中的一个，其中一个分解为线性层+ ReLU层，另一个使用两个ReLU层。在三亿八千六百万次运算后，在验证集上前者达到了<code>76.2% top-1</code>准确率，后者达到了<code>77.2% top-1</code>的准确率。</p>
<h3 id="3-2-Spatial-Factorization-into-Asymmetric-Convolutions"><a href="#3-2-Spatial-Factorization-into-Asymmetric-Convolutions" class="headerlink" title="3.2. Spatial Factorization into Asymmetric Convolutions"></a>3.2. Spatial Factorization into Asymmetric Convolutions</h3><p>The above results suggest that convolutions with filters larger 3 × 3 might not be generally useful as they can always be reduced into a sequence of 3 × 3 convolutional layers. Still we can ask the question whether one should factorize them into smaller, for example 2 × 2 convolutions. However, it turns out that one can do even better than 2 × 2 by using asymmetric convolutions, e.g. n × 1. For example using a 3 × 1 convolution followed by a 1 × 3 convolution is equivalent to sliding a two layer network with the same receptive field as in a 3 × 3 convolution (see figure 3). Still the two-layer solution is 33% cheaper for the same number of output filters, if the number of input and output filters is equal. By comparison, factorizing a 3 × 3 convolution into a two 2 × 2 convolution represents only a 11% saving of computation.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig3.png" alt="Figure 3"></p>
<p>Figure 3. Mini-network replacing the 3 × 3 convolutions. The lower layer of this network consists of a 3 × 1 convolution with 3 output units.</p>
<h3 id="3-2-空间分解为不对称卷积"><a href="#3-2-空间分解为不对称卷积" class="headerlink" title="3.2. 空间分解为不对称卷积"></a>3.2. 空间分解为不对称卷积</h3><p>上述结果表明，大于3×3的卷积滤波器可能不是通常有用的，因为它们总是可以简化为3×3卷积层序列。我们仍然可以问这个问题，是否应该把它们分解成更小的，例如2×2的卷积。然而，通过使用非对称卷积，可以做出甚至比2×2更好的效果，即n×1。例如使用3×1卷积后接一个1×3卷积，相当于以与3×3卷积相同的感受野滑动两层网络（参见图3）。如果输入和输出滤波器的数量相等，那么对于相同数量的输出滤波器，两层解决方案便宜33％。相比之下，将3×3卷积分解为两个2×2卷积表示仅节省了11％的计算量。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig3.png" alt="Figure 3"></p>
<p>图3。替换3×3卷积的Mini网络。网络的更低层由带有3个输出单元的3×1构成。</p>
<p>In theory, we could go even further and argue that one can replace any n × n convolution by a 1 × n convolution followed by a n × 1 convolution and the computational cost saving increases dramatically as n grows (see figure 6). In practice, we have found that employing this factorization does not work well on early layers, but it gives very good results on medium grid-sizes (On m × m feature maps, where m ranges between 12 and 20). On that level, very good results can be achieved by using 1 × 7 convolutions followed by 7 × 1 convolutions.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig6.png" alt="Figure 6"></p>
<p>Figure 6. Inception modules after the factorization of the n × n convolutions. In our proposed architecture, we chose n = 7 for the 17 × 17 grid. (The filter sizes are picked using principle 3)</p>
<p>在理论上，我们可以进一步论证，可以通过1×n卷积和后面接一个n×1卷积替换任何n×n卷积，并且随着n增长，计算成本节省显著增加（见图6）。实际上，我们发现，采用这种分解在前面的层次上不能很好地工作，但是对于中等网格尺寸（在m×m特征图上，其中m范围在12到20之间），其给出了非常好的结果。在这个水平上，通过使用1×7卷积，然后是7×1卷积可以获得非常好的结果。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig6.png" alt="Figure 6"></p>
<p>图6。n×n卷积分解后的Inception模块。在我们提出的架构中，对17×17的网格我们选择n=7。（滤波器尺寸可以通过原则3选择）</p>
<h2 id="4-Utility-of-Auxiliary-Classifiers"><a href="#4-Utility-of-Auxiliary-Classifiers" class="headerlink" title="4. Utility of Auxiliary Classifiers"></a>4. Utility of Auxiliary Classifiers</h2><p>[20] has introduced the notion of auxiliary classifiers to improve the convergence of very deep networks. The original motivation was to push useful gradients to the lower layers to make them immediately useful and improve the convergence during training by combating the vanishing gradient problem in very deep networks. Also Lee et al[11] argues that auxiliary classifiers promote more stable learning and better convergence. Interestingly, we found that auxiliary classifiers did not result in improved convergence early in the training: the training progression of network with and without side head looks virtually identical before both models reach high accuracy. Near the end of training, the network with the auxiliary branches starts to overtake the accuracy of the network without any auxiliary branch and reaches a slightly higher plateau.</p>
<h2 id="4-利用辅助分类器"><a href="#4-利用辅助分类器" class="headerlink" title="4. 利用辅助分类器"></a>4. 利用辅助分类器</h2><p>[20]引入了辅助分类器的概念，以改善非常深的网络的收敛。最初的动机是将有用的梯度推向较低层，使其立即有用，并通过抵抗非常深的网络中的消失梯度问题来提高训练过程中的收敛。Lee等人[11]也认为辅助分类器促进了更稳定的学习和更好的收敛。有趣的是，我们发现辅助分类器在训练早期并没有导致改善收敛：在两个模型达到高精度之前，有无侧边网络的训练进度看起来几乎相同。接近训练结束，辅助分支网络开始超越没有任何分支的网络的准确性，达到了更高的稳定水平。</p>
<p>Also [20] used two side-heads at different stages in the network. The removal of the lower auxiliary branch did not have any adverse effect on the final quality of the network. Together with the earlier observation in the previous paragraph, this means that original the hypothesis of [20] that these branches help evolving the low-level features is most likely misplaced. Instead, we argue that the auxiliary classifiers act as regularizer. This is supported by the fact that the main classifier of the network performs better if the side branch is batch-normalized [7] or has a dropout layer. This also gives a weak supporting evidence for the conjecture that batch normalization acts as a regularizer.</p>
<p>另外，[20]在网络的不同阶段使用了两个侧分支。移除更下面的辅助分支对网络的最终质量没有任何不利影响。再加上前一段的观察结果，这意味着[20]最初的假设，这些分支有助于演变低级特征很可能是不适当的。相反，我们认为辅助分类器起着正则化项的作用。这是由于如果侧分支是批标准化的[7]或具有丢弃层，则网络的主分类器性能更好。这也为推测批标准化作为正则化项给出了一个弱支持证据。</p>
<h2 id="5-Efficient-Grid-Size-Reduction"><a href="#5-Efficient-Grid-Size-Reduction" class="headerlink" title="5. Efficient Grid Size Reduction"></a>5. Efficient Grid Size Reduction</h2><p>Traditionally, convolutional networks used some pooling operation to decrease the grid size of the feature maps. In order to avoid a representational bottleneck, before applying maximum or average pooling the activation dimension of the network filters is expanded. For example, starting a $d\times d$ grid with $k$ filters, if we would like to arrive at a $\frac{d}{2}\times \frac{d}{2}$ grid with $2k$ filters, we first need to compute a stride-1 convolution with $2k$ filters and then apply an additional pooling step. This means that the overall computational cost is dominated by the expensive convolution on the larger grid using $2d^2k^2$ operations. One possibility would be to switch to pooling with convolution and therefore resulting in $2(\frac{d}{2})^2k^2$ reducing the computational cost by a quarter. However, this creates a representational bottlenecks as the overall dimensionality of the representation drops to $(\frac{d}{2})^2k$ resulting in less expressive networks (see Figure 9). Instead of doing so, we suggest another variant the reduces the computational cost even further while removing the representational bottleneck. (see Figure 10). We can use two parallel stride 2 blocks: $P$ and $C$. $P$ is a pooling layer (either average or maximum pooling) the activation, both of them are stride $2$ the filter banks of which are concatenated as in figure 10.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig9.png" alt="Figure 9"></p>
<p>Figure 9. Two alternative ways of reducing the grid size. The solution on the left violates the principle 1 of not introducing an representational bottleneck from Section 2. The version on the right is 3 times more expensive computationally.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig10.png" alt="Figure 10"></p>
<p>Figure 10. Inception module that reduces the grid-size while expands the filter banks. It is both cheap and avoids the representational bottleneck as is suggested by principle 1. The diagram on the right represents the same solution but from the perspective of grid sizes rather than the operations.</p>
<h2 id="5-有效的网格尺寸减少"><a href="#5-有效的网格尺寸减少" class="headerlink" title="5. 有效的网格尺寸减少"></a>5. 有效的网格尺寸减少</h2><p>传统上，卷积网络使用一些池化操作来缩减特征图的网格大小。为了避免表示瓶颈，在应用最大池化或平均池化之前，需要扩展网络滤波器的激活维度。例如，开始有一个带有$k$个滤波器的$d \times d$网格，如果我们想要达到一个带有$2k$个滤波器的$\frac{d}{2}\times \frac{d}{2}$网格，我们首先需要用$2k$个滤波器计算步长为1的卷积，然后应用一个额外的池化步骤。这意味着总体计算成本由在较大的网格上使用$2d^2k^2$次运算的昂贵卷积支配。一种可能性是转换为带有卷积的池化，因此导致$2(\frac{d}{2})^2k^2$次运算，将计算成本降低为原来的四分之一。然而，由于表示的整体维度下降到$(\frac{d}{2})^2k$，会导致表示能力较弱的网络（参见图9），这会产生一个表示瓶颈。我们建议另一种变体，其甚至进一步降低了计算成本，同时消除了表示瓶颈（见图10），而不是这样做。我们可以使用两个平行的步长为2的块：$P$和$C$。$P$是一个池化层（平均池化或最大池化）的激活，两者都是步长为$2$，其滤波器组连接如图10所示。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig9.png" alt="Figure 9"></p>
<p>图9。减少网格尺寸的两种替代方式。左边的解决方案违反了第2节中不引入表示瓶颈的原则1。右边的版本计算量昂贵3倍。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig10.png" alt="Figure 10"></p>
<p>图10。缩减网格尺寸的同时扩展滤波器组的Inception模块。它不仅廉价并且避免了原则1中提出的表示瓶颈。右侧的图表示相同的解决方案，但是从网格大小而不是运算的角度来看。</p>
<h2 id="6-Inception-v2"><a href="#6-Inception-v2" class="headerlink" title="6. Inception-v2"></a>6. Inception-v2</h2><p>Here we are connecting the dots from above and propose a new architecture with improved performance on the ILSVRC 2012 classification benchmark. The layout of our network is given in table 1. Note that we have factorized the traditional $7\times 7$ convolution into three $3\times 3$ convolutions based on the same ideas as described in section 3.1. For the Inception part of the network, we have $3$ traditional inception modules at the $35\times 35$ with $288$ filters each. This is reduced to a $17 \times 17$ grid with $768$ filters using the grid reduction technique described in section 5. This is is followed by $5$ instances of the factorized inception modules as depicted in figure 5. This is reduced to a $8 \times 8 \times 1280$ grid with the grid reduction technique depicted in figure 10. At the coarsest $8 \times 8$ level, we have two Inception modules as depicted in figure 6, with a concatenated output filter bank size of 2048 for each tile. The detailed structure of the network, including the sizes of filter banks inside the Inception modules, is given in the supplementary material, given in the <code>model.txt</code> that is in the tar-file of this submission. However, we have observed that the quality of the network is relatively stable to variations as long as the principles from Section 2 are observed. Although our network is $42$ layers deep, our computation cost is only about $2.5$ higher than that of GoogLeNet and it is still much more efficient than VGGNet.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_table1.png" alt="Table 1"></p>
<p>Table 1. The outline of the proposed network architecture. The output size of each module is the input size of the next one. We are using variations of reduction technique depicted Figure 10 to reduce the grid sizes between the Inception blocks whenever applicable. We have marked the convolution with 0-padding, which is used to maintain the grid size. 0-padding is also used inside those Inception modules that do not reduce the grid size. All other layers do not use padding. The various filter bank sizes are chosen to observe principle 4 from Section 2.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig7.png" alt="Figure 7"></p>
<p>Figure 7. Inception modules with expanded the filter bank outputs. This architecture is used on the coarsest ($8 \times 8$) grids to promote high dimensional representations, as suggested by principle 2 of Section 2. We are using this solution only on the coarsest grid, since that is the place where producing high dimensional sparse representation is the most critical as the ratio of local processing (by $1 \times 1$ convolutions) is increased compared to the spatial aggregation.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig8.png" alt="Figure 8"></p>
<p>Figure 8. Auxiliary classifier on top of the last $17 \times 17$ layer. Batch normalization[7] of the layers in the side head results in a 0.4% absolute gain in top-1 accuracy. The lower axis shows the number of itertions performed, each with batch size 32.</p>
<h2 id="6-Inception-v2-1"><a href="#6-Inception-v2-1" class="headerlink" title="6. Inception-v2"></a>6. Inception-v2</h2><p>在这里，我们连接上面的点，并提出了一个新的架构，在ILSVRC 2012分类基准数据集上提高了性能。我们的网络布局在表1中给出。注意，基于与3.1节中描述的同样想法，我们将传统的$7 \times 7$卷积分解为3个$3\times 3$卷积。对于网络的Inception部分，我们在$ 35 \times 35$处有$3$个传统的Inception模块，每个模块有$288$个滤波器。使用第5节中描述的网格缩减技术，这将缩减为$17\times 17$的网格，具有$768$个滤波器。这之后是图5所示的$5$个分解的Inception模块实例。使用图10所示的网格缩减技术，这被缩减为$8 \times 8 \times 1280$的网格。在最粗糙的$8 \times 8$级别，我们有两个如图6所示的Inception模块，每个块连接的输出滤波器组的大小为2048。网络的详细结构，包括Inception模块内滤波器组的大小，在补充材料中给出，在提交的tar文件中的<code>model.txt</code>中给出。然而，我们已经观察到，只要遵守第2节的原则，对于各种变化网络的质量就相对稳定。虽然我们的网络深度是$42$层，但我们的计算成本仅比GoogLeNet高出约$2.5$倍，它仍比VGGNet要高效的多。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_table1.png" alt="Table 1"></p>
<p>表1。提出的网络架构的轮廓。每个模块的输出大小是下一模块的输入大小。我们正在使用图10所示的缩减技术的变种，以缩减应用时Inception块间的网格大小。我们用0填充标记了卷积，用于保持网格大小。这些Inception模块内部也使用0填充，不会减小网格大小。所有其它层不使用填充。选择各种滤波器组大小来观察第2节的原理4。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig7.png" alt="Figure 7"></p>
<p>图7。具有扩展的滤波器组输出的Inception模块。这种架构被用于最粗糙的（$8 \times 8$）网格，以提升高维表示，如第2节原则2所建议的那样。我们仅在最粗的网格上使用了此解决方案，因为这是产生高维度的地方，稀疏表示是最重要的，因为与空间聚合相比，局部处理（$1 \times 1$ 卷积）的比率增加。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking_fig8.png" alt="Figure 8"></p>
<p>图8。最后$17 \times 17$层之上的辅助分类器。 侧头中的层的批标准化[7]导致<code>top-1 0.4％</code>的绝对收益。下轴显示执行的迭代次数，每个批次大小为32。</p>
<h2 id="7-Model-Regularization-via-Label-Smoothing"><a href="#7-Model-Regularization-via-Label-Smoothing" class="headerlink" title="7. Model Regularization via Label Smoothing"></a>7. Model Regularization via Label Smoothing</h2><p>Here we propose a mechanism to regularize the classifier layer by estimating the marginalized effect of label-dropout during training.</p>
<h2 id="7-通过标签平滑进行模型正则化"><a href="#7-通过标签平滑进行模型正则化" class="headerlink" title="7. 通过标签平滑进行模型正则化"></a>7. 通过标签平滑进行模型正则化</h2><p>我们提出了一种通过估计训练期间标签丢弃的边缘化效应来对分类器层进行正则化的机制。</p>
<p>For each training example $x$, our model computes the probability of each label $k\in \lbrace 1\ldots K \rbrace$: $p(k|x) = \frac{\exp(z_k)}{\sum_{i=1}^K \exp(z_i)}$. Here, $z_i$ are the <em>logits</em> or unnormalized log-probabilities. Consider the ground-truth distribution over labels $q(k|x)$ for this training example, normalized so that $\sum_k q(k|x) = 1$. For brevity, let us omit the dependence of $p$ and $q$ on example $x$. We define the loss for the example as the cross entropy: $\ell = -\sum_{k=1}^K \log(p(k)) q(k)$. Minimizing this is equivalent to maximizing the expected log-likelihood of a label, where the label is selected according to its ground-truth distribution $q(k)$. Cross-entropy loss is differentiable with respect to the logits $z_k$ and thus can be used for gradient training of deep models. The gradient has a rather simple form: $\frac{\partial\ell}{\partial z_k} = p(k) - q(k)$, which is bounded between $-1$ and $1$.</p>
<p>对于每个训练样本$x$，我们的模型计算每个标签的概率$k\in \lbrace 1\ldots K \rbrace$: $p(k|x) = \frac{\exp(z_k)}{\sum_{i=1}^K \exp(z_i)}$。这里，$z_i$是对数单位或未归一化的对数概率。考虑这个训练样本在标签上的实际分布$q(k|x)$，因此归一化后$\sum_k q(k|x) = 1$。为了简洁，我们省略$p$和$q$对样本$x$的依赖。我们将样本损失定义为交叉熵：$\ell = -\sum_{k=1}^K \log(p(k)) q(k)$。最小化交叉熵等价于最大化标签对数似然期望，其中标签是根据它的实际分布$q(k)$选择的。交叉熵损失对于$z_k$是可微的，因此可以用来进行深度模型的梯度训练。其梯度有一个更简单的形式：$\frac{\partial\ell}{\partial z_k} = p(k) - q(k)$，它的范围在$-1$到$1$之间。</p>
<p>Consider the case of a single ground-truth label $y$, so that $q(y)=1$ and $q(k)=0$ for all $k\neq y$. In this case, minimizing the cross entropy is equivalent to maximizing the log-likelihood of the correct label. For a particular example $x$ with label $y$, the log-likelihood is maximized for $q(k)= \delta_{k,y}$, where $\delta_{k,y}$ is Dirac delta, which equals $1$ for $k=y$ and $0$ otherwise. This maximum is not achievable for finite $z_k$ but is approached if $z_y\gg z_k$ for all $k\neq y$ —— that is, if the logit corresponding to the ground-truth label is much great than all other logits. This, however, can cause two problems. First, it may result in over-fitting: if the model learns to assign full probability to the ground-truth label for each training example, it is not guaranteed to generalize. Second, it encourages the differences between the largest logit and all others to become large, and this, combined with the bounded gradient $\frac{\partial\ell}{\partial z_k}$, reduces the ability of the model to adapt. Intuitively, this happens because the model becomes too confident about its predictions.</p>
<p>考虑单个真实标签$y$的例子，对于所有$k\neq y$，有$q(y)=1$，$q(k)=0$。在这种情况下，最小化交叉熵等价于最大化正确标签的对数似然。对于一个特定的样本$x$，其标签为$y$，对于$q(k)= \delta_{k,y}$，最大化其对数概率，$\delta_{k,y}$为狄拉克δ函数，当且仅当$k=y$时，δ函数值为1，否则为0。对于有限的$z_k$，不能取得最大值，但对于所有$k\neq y$，如果$z_y\gg z_k$——也就是说，如果对应实际标签的逻辑单元远大于其它的逻辑单元，那么对数概率会接近最大值。然而这可能会引起两个问题。首先，它可能导致过拟合：如果模型学习到对于每一个训练样本，分配所有概率到实际标签上，那么它不能保证泛化能力。第二，它鼓励最大的逻辑单元与所有其它逻辑单元之间的差距变大，与有界限的梯度$\frac{\partial\ell}{\partial z_k}$相结合，这会降低模型的适应能力。直观上讲这会发生，因为模型变得对它的预测过于自信。</p>
<p>We propose a mechanism for encouraging the model to be less confident. While this may not be desired if the goal is to maximize the log-likelihood of training labels, it does regularize the model and makes it more adaptable. The method is very simple. Consider a distribution over labels $u(k)$, <em>independent of the training example $x$</em>, and a smoothing parameter $\epsilon$. For a training example with ground-truth label $y$, we replace the label distribution $q(k|x)=\delta_{k,y}$ with $$q’(k|x) = (1-\epsilon) \delta_{k,y} + \epsilon u(k)$$ which is a mixture of the original ground-truth distribution $q(k|x)$ and the fixed distribution $u(k)$, with weights $1-\epsilon$ and $\epsilon$, respectively. This can be seen as the distribution of the label $k$ obtained as follows: first, set it to the ground-truth label $k=y$; then, with probability $\epsilon$, replace $k$ with a sample drawn from the distribution $u(k)$. We propose to use the prior distribution over labels as $u(k)$. In our experiments, we used the uniform distribution $u(k) = 1/K$, so that $$q’(k) = (1-\epsilon) \delta_{k,y} + \frac{\epsilon}{K}.$$ We refer to this change in ground-truth label distribution as <em>label-smoothing regularization</em>, or LSR.</p>
<p>我们提出了一个鼓励模型不那么自信的机制。如果目标是最大化训练标签的对数似然，这可能不是想要的，但它确实使模型正规化并使其更具适应性。这个方法很简单。考虑标签$u(k)$的分布和平滑参数$\epsilon$，<em>与训练样本$x$相互独立</em>。对于一个真实标签为$y$的训练样本，我们用$$q’(k|x) = (1-\epsilon) \delta_{k,y} + \epsilon u(k)$$代替标签分布$q(k|x)=\delta_{k,y}$，其由最初的实际分布$q(k|x)$和固定分布$u(k)$混合得到，它们的权重分别为$1-\epsilon$和$\epsilon$。这可以看作获得标签$k$的分布如下：首先，将其设置为真实标签$k=y$；其次，用分布$u(k)$中的采样和概率$\epsilon$替代$k$。我们建议使用标签上的先验分布作为$u(k)$。在我们的实验中，我们使用了均匀分布$u(k) = 1/K$，以便使得$$q’(k) = (1-\epsilon) \delta_{k,y} + \frac{\epsilon}{K}.$$我们将真实标签分布中的这种变化称为<em>标签平滑正则化</em>，或LSR。</p>
<p>Note that LSR achieves the desired goal of preventing the largest logit from becoming much larger than all others. Indeed, if this were to happen, then a single $q(k)$ would approach $1$ while all others would approach $0$. This would result in a large cross-entropy with $q’(k)$ because, unlike $q(k)=\delta_{k,y}$, all $q’(k)$ have a positive lower bound.</p>
<p>注意，LSR实现了期望的目标，阻止了最大的逻辑单元变得比其它的逻辑单元更大。实际上，如果发生这种情况，则一个$q(k)$将接近$1$，而所有其它的将会接近$0$。这会导致$q’(k)$有一个大的交叉熵，因为不同于$q(k)=\delta_{k,y}$，所有的$q’(k)$都有一个正的下界。</p>
<p>Another interpretation of LSR can be obtained by considering the cross entropy:$$H(q’,p) = -\sum_{k=1}^K \log p(k) q’(k) = (1-\epsilon)H(q, p) + \epsilon H(u, p)$$Thus, LSR is equivalent to replacing a single cross-entropy loss $H(q,p)$ with a pair of such losses $H(q,p)$ and $H(u,p)$. The second loss penalizes the deviation of predicted label distribution $p$ from the prior $u$, with the relative weight $\frac{\epsilon}{1-\epsilon}$. Note that this deviation could be equivalently captured by the KL divergence, since $H(u,p) = D_{KL}(u|p) + H(u)$ and $H(u)$ is fixed. When $u$ is the uniform distribution, $H(u,p)$ is a measure of how dissimilar the predicted distribution $p$ is to uniform, which could also be measured (but not equivalently) by negative entropy $-H(p)$; we have not experimented with this approach.</p>
<p>LSR的另一种解释可以通过考虑交叉熵来获得：$$H(q’,p) = -\sum_{k=1}^K \log p(k) q’(k) = (1-\epsilon)H(q, p) + \epsilon H(u, p)$$因此，LSR等价于用一对这样的损失$H(q,p)$和$H(u,p)$来替换单个交叉熵损失$H(q,p)$。第二个损失惩罚预测的标签分布$p$与先验$u$之间的偏差，其中相对权重为$\frac{\epsilon}{1-\epsilon}$。注意，由于$H(u,p) = D_{KL}(u|p) + H(u)$和$H(u)$是固定的，因此这个偏差可以等价地被KL散度捕获。当$u$是均匀分布时，$H(u,p)$是度量预测分布$p$与均匀分布不同的程度，也可以通过负熵$-H(p)$来度量（但不等价）；我们还没有实验过这种方法。</p>
<p>In our ImageNet experiments with $K=1000$ classes, we used $u(k) = 1/1000$ and $\epsilon=0.1$. For ILSVRC 2012, we have found a consistent improvement of about $0.2\%$ absolute both for top-$1$ error and the top-$5$ error (cf. Table 3).</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table3.png" alt="Table 3"></p>
<p>Table 3. Single crop experimental results comparing the cumulative effects on the various contributing factors. We compare our numbers with the best published single-crop inference for Ioffe at al [7]. For the “Inception-v2” lines, the changes are cumulative and each subsequent line includes the new change in addition to the previous ones. The last line is referring to all the changes is what we refer to as “Inception-v3” below. Unfortunately, He et al [6] reports the only 10-crop evaluation results, but not single crop results, which is reported in the Table 4 below.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table4.png" alt="Table 4"></p>
<p>Table 4. Single-model, multi-crop experimental results comparing the cumulative effects on the various contributing factors. We compare our numbers with the best published single-model inference results on the ILSVRC 2012 classification benchmark.</p>
<p>在我们的$K=1000$类的ImageNet实验中，我们使用了$u(k) = 1/1000$和$\epsilon=0.1$。对于ILSVRC 2012，我们发现对于<code>top-1</code>错误率和<code>top-5</code>错误率，持续提高了大约$0.2\%$（参见表3）。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table3.png" alt="Table 3"></p>
<p>表3。单张裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与Ioffe等人[7]发布的单张裁剪图像的最好推断结果进行了比较。在“Inception-v2”行，变化是累积的并且接下来的每一行都包含除了前面的变化之外的新变化。最后一行是所有的变化，我们称为“Inception-v3”。遗憾的是，He等人[6]仅报告了10个裁剪图像的评估结果，但没有单张裁剪图像的结果，报告在下面的表4中。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table4.png" alt="Table 4"></p>
<p>表4。单模型，多裁剪图像的实验结果，比较各种影响因素的累积影响。我们将我们的数据与ILSVRC 2012分类基准中发布的最佳单模型推断结果进行了比较。</p>
<h2 id="8-Training-Methodology"><a href="#8-Training-Methodology" class="headerlink" title="8. Training Methodology"></a>8. Training Methodology</h2><p>We have trained our networks with stochastic gradient utilizing the TensorFlow [1] distributed machine learning system using $50$ replicas running each on a NVidia Kepler GPU with batch size $32$ for $100$ epochs. Our earlier experiments used momentum [19] with a decay of $0.9$, while our best models were achieved using RMSProp [21] with decay of $0.9$ and $\epsilon=1.0$. We used a learning rate of $0.045$, decayed every two epoch using an exponential rate of $0.94$. In addition, gradient clipping [14] with threshold $2.0$ was found to be useful to stabilize the training. Model evaluations are performed using a running average of the parameters computed over time.</p>
<h2 id="8-训练方法"><a href="#8-训练方法" class="headerlink" title="8. 训练方法"></a>8. 训练方法</h2><p>我们在TensorFlow[1]分布式机器学习系统上使用随机梯度方法训练了我们的网络，使用了$50$个副本，每个副本在一个NVidia Kepler GPU上运行，批处理大小为$32$，$100$个epoch。我们之前的实验使用动量方法[19]，衰减值为$0.9$，而我们最好的模型是用RMSProp [21]实现的，衰减值为$0.9$，$\epsilon=1.0$。我们使用$0.045$的学习率，每两个epoch以$0.94$的指数速率衰减。此外，阈值为$2.0$的梯度裁剪[14]被发现对于稳定训练是有用的。使用随时间计算的运行参数的平均值来执行模型评估。</p>
<h2 id="9-Performance-on-Lower-Resolution-Input"><a href="#9-Performance-on-Lower-Resolution-Input" class="headerlink" title="9. Performance on Lower Resolution Input"></a>9. Performance on Lower Resolution Input</h2><p>A typical use-case of vision networks is for the the post-classification of detection, for example in the Multibox [4] context. This includes the analysis of a relative small patch of the image containing a single object with some context. The tasks is to decide whether the center part of the patch corresponds to some object and determine the class of the object if it does. The challenge is that objects tend to be relatively small and low-resolution. This raises the question of how to properly deal with lower resolution input.</p>
<h2 id="9-低分辨率输入上的性能"><a href="#9-低分辨率输入上的性能" class="headerlink" title="9. 低分辨率输入上的性能"></a>9. 低分辨率输入上的性能</h2><p>视觉网络的典型用例是用于检测的后期分类，例如在Multibox [4]上下文中。这包括分析在某个上下文中包含单个对象的相对较小的图像块。任务是确定图像块的中心部分是否对应某个对象，如果是，则确定该对象的类别。这个挑战的是对象往往比较小，分辨率低。这就提出了如何正确处理低分辨率输入的问题。</p>
<p>The common wisdom is that models employing higher resolution receptive fields tend to result in significantly improved recognition performance. However it is important to distinguish between the effect of the increased resolution of the first layer receptive field and the effects of larger model capacitance and computation. If we just change the resolution of the input without further adjustment to the model, then we end up using computationally much cheaper models to solve more difficult tasks. Of course, it is natural, that these solutions loose out already because of the reduced computational effort. In order to make an accurate assessment, the model needs to analyze vague hints in order to be able to “hallucinate” the fine details. This is computationally costly. The question remains therefore: how much does higher input resolution helps if the computational effort is kept constant. One simple way to ensure constant effort is to reduce the strides of the first two layer in the case of lower resolution input, or by simply removing the first pooling layer of the network.</p>
<p>普遍的看法是，使用更高分辨率感受野的模型倾向于导致显著改进的识别性能。然而，区分第一层感受野分辨率增加的效果和较大的模型容量、计算量的效果是很重要的。如果我们只是改变输入的分辨率而不进一步调整模型，那么我们最终将使用计算上更便宜的模型来解决更困难的任务。当然，由于减少了计算量，这些解决方案很自然就出来了。为了做出准确的评估，模型需要分析模糊的提示，以便能够“幻化”细节。这在计算上是昂贵的。因此问题依然存在：如果计算量保持不变，更高的输入分辨率会有多少帮助。确保不断努力的一个简单方法是在较低分辨率输入的情况下减少前两层的步长，或者简单地移除网络的第一个池化层。</p>
<p>For this purpose we have performed the following three experiments:</p>
<ol>
<li>$299\times 299$ receptive field with stride $2$ and maximum pooling after the first layer.</li>
<li>$151\times 151$ receptive field with stride $1$ and maximum pooling after the first layer.</li>
<li>$79\times 79$ receptive field with stride $1$ and <strong>without</strong> pooling after the first layer.</li>
</ol>
<p>All three networks have almost identical computational cost. Although the third network is slightly cheaper, the cost of the pooling layer is marginal and (within $1\%$ of the total cost of the network). In each case, the networks were trained until convergence and their quality was measured on the validation set of the ImageNet ILSVRC 2012 classification benchmark. The results can be seen in table 2. Although the lower-resolution networks take longer to train, the quality of the final result is quite close to that of their higher resolution counterparts.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table2.png" alt="Table 2"></p>
<p>Table 2. Comparison of recognition performance when the size of the receptive field varies, but the computational cost is constant.</p>
<p>为了这个目的我们进行了以下三个实验：</p>
<ol>
<li>步长为$2$，大小为$299\times 299$的感受野和最大池化。</li>
<li>步长为$1$，大小为$151\times 151$的感受野和最大池化。</li>
<li>步长为$1$，大小为$79\times 79$的感受野和第一层之后<strong>没有</strong>池化。</li>
</ol>
<p>所有三个网络具有几乎相同的计算成本。虽然第三个网络稍微便宜一些，但是池化层的成本是无足轻重的（在总成本的$1\%$以内）。在每种情况下，网络都进行了训练，直到收敛，并在ImageNet ILSVRC 2012分类基准数据集的验证集上衡量其质量。结果如表2所示。虽然分辨率较低的网络需要更长时间去训练，但最终结果却与较高分辨率网络的质量相当接近。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table2.png" alt="Table 2"></p>
<p>表2。当感受野尺寸变化时，识别性能的比较，但计算代价是不变的。</p>
<p>However, if one would just naively reduce the network size according to the input resolution, then network would perform much more poorly. However this would an unfair comparison as we would are comparing a 16 times cheaper model on a more difficult task.</p>
<p>但是，如果只是单纯地按照输入分辨率减少网络尺寸，那么网络的性能就会差得多。然而，这将是一个不公平的比较，因为我们将在比较困难的任务上比较一个便宜16倍的模型。</p>
<p>Also these results of table 2 suggest, one might consider using dedicated high-cost low resolution networks for smaller objects in the R-CNN [5] context.</p>
<p>表2的这些结果也表明，有人可能会考虑在R-CNN [5]的上下文中对更小的对象使用专用的高成本低分辨率网络。</p>
<h2 id="10-Experimental-Results-and-Comparisons"><a href="#10-Experimental-Results-and-Comparisons" class="headerlink" title="10. Experimental Results and Comparisons"></a>10. Experimental Results and Comparisons</h2><p>Table 3 shows the experimental results about the recognition performance of our proposed architecture (Inception-v2) as described in Section 6. Each Inception-v2 line shows the result of the cumulative changes including the highlighted new modification plus all the earlier ones. Label Smoothing refers to method described in Section 7. Factorized $7\times 7$ includes a change that factorizes the first $7\times 7$ convolutional layer into a sequence of $3\times 3$ convolutional layers. BN-auxiliary refers to the version in which the fully connected layer of the auxiliary classifier is also batch-normalized, not just the convolutions. We are referring to the model in last row of Table 3 as Inception-v3 and evaluate its performance in the multi-crop and ensemble settings.</p>
<h2 id="10-实验结果和比较"><a href="#10-实验结果和比较" class="headerlink" title="10. 实验结果和比较"></a>10. 实验结果和比较</h2><p>表3显示了我们提出的体系结构（Inception-v2）识别性能的实验结果，架构如第6节所述。每个Inception-v2行显示了累积变化的结果，包括突出显示的新修改加上所有先前修改的结果。标签平滑是指在第7节中描述的方法。分解的$7\times 7$包括将第一个$7\times 7$卷积层分解成$3\times 3$卷积层序列的改变。BN-auxiliary是指辅助分类器的全连接层也批标准化的版本，而不仅仅是卷积。我们将表3最后一行的模型称为Inception-v3，并在多裁剪图像和组合设置中评估其性能。</p>
<p>All our evaluations are done on the 48238 non-blacklisted examples on the ILSVRC-2012 validation set, as suggested by [16]. We have evaluated all the 50000 examples as well and the results were roughly $0.1\%$ worse in top-5 error and around $0.2\%$ in top-1 error. In the upcoming version of this paper, we will verify our ensemble result on the test set, but at the time of our last evaluation of BN-Inception in spring [7] indicates that the test and validation set error tends to correlate very well.</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table5.png" alt="Table 5"></p>
<p>Table 5. Ensemble evaluation results comparing multi-model, multi-crop reported results. Our numbers are compared with the best published ensemble inference results on the ILSVRC 2012 classification benchmark. All results, but the top-5 ensemble result reported are on the validation set. The ensemble yielded 3.46% top-5 error on the validation set.</p>
<p>我们所有的评估都在ILSVRC-2012验证集上的48238个非黑名单样本中完成，如[16]所示。我们也对所有50000个样本进行了评估，结果在<code>top-5</code>错误率中大约为$0.1\%$，在<code>top-1</code>错误率中大约为$0.2\%$。在本文即将出版的版本中，我们将在测试集上验证我们的组合结果，但是我们上一次对BN-Inception的春季测试[7]表明测试集和验证集错误趋于相关性很好。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/rethinking-table5.png" alt="Table 5"></p>
<p>表5。模型组合评估结果，比较多模型，多裁剪图像的报告结果。我们的数据与ILSVRC 2012分类基准数据集上发布的最好模型组合推断结果的比较。所有的结果，除了在验证集上的<code>top-5</code>模型组合结果。模型组合在验证集上取得了<code>3.46% top-5</code>错误率。</p>
<h2 id="11-Conclusions"><a href="#11-Conclusions" class="headerlink" title="11. Conclusions"></a>11. Conclusions</h2><p>We have provided several design principles to scale up convolutional networks and studied them in the context of the Inception architecture. This guidance can lead to high performance vision networks that have a relatively modest computation cost compared to simpler, more monolithic architectures. Our highest quality version of Inception-v3 reaches $21.2\%$, top-$1$ and $5.6\%$ top-5 error for <strong>single crop</strong> evaluation on the ILSVR 2012 classification, setting a new state of the art. This is achieved with relatively modest ($2.5\times$) increase in computational cost compared to the network described in Ioffe et al [7]. Still our solution uses much less computation than the best published results based on denser networks: our model outperforms the results of He et al [6] —— cutting the top-$5$ (top-$1$) error by $25\%$ ($14\%$) relative, respectively —— while being six times cheaper computationally and using at least five times less parameters (estimated). Our ensemble of four Inception-v3 models reaches $3.5\%$ with multi-crop evaluation reaches $3.5\%$ top-$5$ error which represents an over $25\%$ reduction to the best published results and is almost half of the error of ILSVRC 2014 winining GoogLeNet ensemble.</p>
<h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11. 结论"></a>11. 结论</h2><p>我们提供了几个设计原则来扩展卷积网络，并在Inception体系结构的背景下进行研究。这个指导可以导致高性能的视觉网络，与更简单、更单一的体系结构相比，它具有相对适中的计算成本。Inception-v3的最高质量版本在ILSVR 2012分类上的<strong>单裁剪图像</strong>评估中达到了$21.2\％$的<code>top-1</code>错误率和$5.6\％$的<code>top-5</code>错误率，达到了新的水平。与Ioffe等[7]中描述的网络相比，这是通过增加相对适中（$2.5/times$）的计算成本来实​​现的。尽管如此，我们的解决方案所使用的计算量比基于更密集网络公布的最佳结果要少得多：我们的模型比He等[6]的结果更好——将<code>top-5(top-1)</code>的错误率相对分别减少了$25\%$ ($14\%$)，然而在计算代价上便宜了六倍，并且使用了至少减少了五倍的参数（估计值）。我们的四个Inception-v3模型的组合效果达到了$3.5\％$，多裁剪图像评估达到了$3.5\％$的<code>top-5</code>的错误率，这相当于比最佳发布的结果减少了$25\％$以上，几乎是ILSVRC 2014的冠军GoogLeNet组合错误率的一半。</p>
<p>We have also demonstrated that high quality results can be reached with receptive field resolution as low as $79\times 79$. This might prove to be helpful in systems for detecting relatively small objects. We have studied how factorizing convolutions and aggressive dimension reductions inside neural network can result in networks with relatively low computational cost while maintaining high quality. The combination of lower parameter count and additional regularization with batch-normalized auxiliary classifiers and label-smoothing allows for training high quality networks on relatively modest sized training sets.</p>
<p>我们还表明，可以通过感受野分辨率为$79\times 79$的感受野取得高质量的结果。这可能证明在检测相对较小物体的系统中是有用的。我们已经研究了在神经网络中如何分解卷积和积极降维可以导致计算成本相对较低的网络，同时保持高质量。较低的参数数量、额外的正则化、批标准化的辅助分类器和标签平滑的组合允许在相对适中大小的训练集上训练高质量的网络。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane ́, R. Monga, S. Moore, D. Murray, C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Vie ́gas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. TensorFlow: Large-scale machine learning on heterogeneous systems, 2015. Software available from tensorflow.org.</p>
<p>[2] W. Chen, J. T. Wilson, S. Tyree, K. Q. Weinberger, and Y. Chen. Compressing neural networks with the hashing trick. In Proceedings of The 32nd International Conference on Machine Learning, 2015.</p>
<p>[3] C. Dong, C. C. Loy, K. He, and X. Tang. Learning a deep convolutional network for image super-resolution. In Computer Vision–ECCV 2014, pages 184–199. Springer, 2014.</p>
<p>[4] D.Erhan,C.Szegedy,A.Toshev,andD.Anguelov.Scalable object detection using deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 2155–2162. IEEE, 2014.</p>
<p>[5] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[6] K. He, X. Zhang, S. Ren, and J. Sun. Delving deep into rectifiers: Surpassing human-level performance on imagenet classification. arXiv preprint arXiv:1502.01852, 2015.</p>
<p>[7] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Proceedings of The 32nd International Conference on Machine Learning, pages 448–456, 2015.</p>
<p>[8] A.Karpathy,G.Toderici,S.Shetty,T.Leung,R.Sukthankar, and L. Fei-Fei. Large-scale video classification with convolutional neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1725–1732. IEEE, 2014.</p>
<p>[9] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012.</p>
<p>[10] A. Lavin. Fast algorithms for convolutional neural networks. arXiv preprint arXiv:1509.09308, 2015.</p>
<p>[11] C.-Y.Lee,S.Xie,P.Gallagher,Z.Zhang,andZ.Tu.Deeply-supervised nets. arXiv preprint arXiv:1409.5185, 2014. </p>
<p>[12] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3431–3440, 2015.</p>
<p>[13] Y. Movshovitz-Attias, Q. Yu, M. C. Stumpe, V. Shet, S. Arnoud, and L. Yatziv. Ontological supervision for fine grained classification of street view storefronts. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1693–1702, 2015.</p>
<p>[14] R. Pascanu, T. Mikolov, and Y. Bengio. On the difficulty of training recurrent neural networks. arXiv preprint arXiv:1211.5063, 2012.</p>
<p>[15] D. C. Psichogios and L. H. Ungar. Svd-net: an algorithm that automatically selects network structure. IEEE transactions on neural networks/a publication of the IEEE Neural Networks Council, 5(3):513–515, 1993.</p>
<p>[16] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. 2014.</p>
<p>[17] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A unified embedding for face recognition and clustering. arXiv preprint arXiv:1503.03832, 2015.</p>
<p>[18] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.</p>
<p>[19] I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization and momentum in deep learning. In Proceedings of the 30th<br>International Conference on Machine Learning (ICML-13), volume 28, pages 1139–1147. JMLR Workshop and Conference Proceedings, May 2013.</p>
<p>[20] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1–9, 2015.</p>
<p>[21] T. Tieleman and G. Hinton. Divide the gradient by a running average of its recent magnitude. COURSERA: Neural Networks for Machine Learning, 4, 2012. Accessed: 2015-11-05.</p>
<p>[22] A. Toshev and C. Szegedy. Deeppose: Human pose estimation via deep neural networks. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 1653–1660. IEEE, 2014.</p>
<p>[23] N. Wang and D.-Y. Yeung. Learning a deep compact image representation for visual tracking. In Advances in Neural Information Processing Systems, pages 809–817, 2013.</p>
]]></content>
    
    <summary type="html">
    
      Inception-V3论文翻译——中英文对照
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Structuring Machine Learning Projects学习笔记(一)</title>
    <link href="noahsnail.com/2017/09/24/2017-9-24-Structuring%20Machine%20Learning%20Projects%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>noahsnail.com/2017/09/24/2017-9-24-Structuring Machine Learning Projects学习笔记(一)/</id>
    <published>2017-09-24T05:39:05.000Z</published>
    <updated>2017-09-25T13:01:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Introduction-to-ML-Strategy"><a href="#1-Introduction-to-ML-Strategy" class="headerlink" title="1. Introduction to ML Strategy"></a>1. Introduction to ML Strategy</h2><h4 id="1-1-Why-ML-Strategy"><a href="#1-1-Why-ML-Strategy" class="headerlink" title="1.1 Why ML Strategy?"></a>1.1 Why ML Strategy?</h4><p>Teach you ways of analyzing a machine learning problem that will point you in the direction of the most promising things to try.</p>
<h4 id="1-2-Orthogonalization"><a href="#1-2-Orthogonalization" class="headerlink" title="1.2 Orthogonalization"></a>1.2 Orthogonalization</h4><p>Chain of assumptions in ML</p>
<ul>
<li>Fit training set well on cost function</li>
<li>Fit dev set well on cost function</li>
<li>Fit test set well on cost function</li>
<li>Performs well in real world</li>
</ul>
<p>Orthogonalization or orthogonality is a system design property that assures that modifying an instruction or a component of an algorithm will not create or propagate side effects to other components of the system. It becomes easier to verify the algorithms independently from one another, it reduces testing and development time.</p>
<p>When a supervised learning system is design, these are the 4 assumptions that needs to be true and orthogonal.</p>
<ol>
<li>Fit training set well in cost function<br>- If it doesn’t fit well, the use of a bigger neural network or switching to a better optimization algorithm might help.</li>
<li>Fit development set well on cost function<br>- If it doesn’t fit well, regularization or using bigger training set might help.</li>
<li>Fit test set well on cost function<br>- If it doesn’t fit well, the use of a bigger development set might help</li>
<li>Performs well in real world<br>- If it doesn’t perform well, the development test set is not set correctly or the cost function is not evaluating the right thing.</li>
</ol>
<h2 id="2-Setting-up-your-goal"><a href="#2-Setting-up-your-goal" class="headerlink" title="2. Setting up your goal"></a>2. Setting up your goal</h2><h4 id="2-1-Single-number-evaluation-metric"><a href="#2-1-Single-number-evaluation-metric" class="headerlink" title="2.1 Single number evaluation metric"></a>2.1 Single number evaluation metric</h4><p>Set up a single real number evaluation metric for your problem.</p>
<p>Dev set + single number evaluation metric.</p>
<h4 id="2-2-Satisficing-and-Optimiziong-metric"><a href="#2-2-Satisficing-and-Optimiziong-metric" class="headerlink" title="2.2 Satisficing and Optimiziong metric"></a>2.2 Satisficing and Optimiziong metric</h4><p>multiple metrics</p>
<h4 id="2-3-Train-dev-test-distribution"><a href="#2-3-Train-dev-test-distribution" class="headerlink" title="2.3 Train/dev/test distribution"></a>2.3 Train/dev/test distribution</h4><h4 id="2-4-Size-of-the-dev-and-test-sets"><a href="#2-4-Size-of-the-dev-and-test-sets" class="headerlink" title="2.4 Size of the dev and test sets"></a>2.4 Size of the dev and test sets</h4><h4 id="2-5-When-to-change-dev-test-sets-and-metrics"><a href="#2-5-When-to-change-dev-test-sets-and-metrics" class="headerlink" title="2.5 When to change dev/test sets and metrics"></a>2.5 When to change dev/test sets and metrics</h4>]]></content>
    
    <summary type="html">
    
      Structuring Machine Learning Projects学习笔记(一)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(十)——卷积神经网络</title>
    <link href="noahsnail.com/2017/09/22/2017-9-22-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E5%8D%81)%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>noahsnail.com/2017/09/22/2017-9-22-PyTorch基本用法(十)——卷积神经网络/</id>
    <published>2017-09-22T12:24:41.000Z</published>
    <updated>2017-09-22T12:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torchvision</div><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"><span class="comment"># 超参数定义</span></div><div class="line">EPOCH = <span class="number">1</span></div><div class="line">LR = <span class="number">0.01</span></div><div class="line">BATCH_SIZE = <span class="number">64</span></div><div class="line"></div><div class="line"><span class="comment"># 下载MNIST数据集</span></div><div class="line">train_data = torchvision.datasets.MNIST(</div><div class="line">    root = <span class="string">'./mnist/'</span>,</div><div class="line">    <span class="comment"># 是否是训练数据</span></div><div class="line">    train = <span class="keyword">True</span>,</div><div class="line">    <span class="comment"># 数据变换(0, 255) -&gt; (0, 1)</span></div><div class="line">    transform = torchvision.transforms.ToTensor(),</div><div class="line">    <span class="comment"># 是否下载MNIST数据</span></div><div class="line">    download = <span class="keyword">True</span></div><div class="line">)</div><div class="line"></div><div class="line">test_data = torchvision.datasets.MNIST(</div><div class="line">    root = <span class="string">'./mnist/'</span>,</div><div class="line">    <span class="comment"># 是否是训练数据</span></div><div class="line">    train = <span class="keyword">False</span>,</div><div class="line">    <span class="comment"># 数据变换(0, 255) -&gt; (0, 1)</span></div><div class="line">    transform = torchvision.transforms.ToTensor(),</div><div class="line">    <span class="comment"># 是否下载MNIST数据</span></div><div class="line">    download = <span class="keyword">True</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">print</span> train_data.train_data.size()</div><div class="line"><span class="keyword">print</span> train_data.train_labels.size()</div><div class="line"><span class="keyword">print</span> test_data.test_data.size()</div><div class="line"><span class="keyword">print</span> test_data.test_labels.size()</div></pre></td></tr></table></figure>
<pre><code>torch.Size([60000, 28, 28])
torch.Size([60000])
torch.Size([10000, 28, 28])
torch.Size([10000])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看图像</span></div><div class="line">plt.imshow(train_data.train_data[<span class="number">0</span>].numpy(), cmap = <span class="string">'gray'</span>)</div><div class="line">plt.title(<span class="string">'%i'</span> % train_data.train_labels[<span class="number">0</span>])</div><div class="line">plt.show()</div><div class="line"></div><div class="line">plt.imshow(test_data.test_data[<span class="number">0</span>].numpy(), cmap = <span class="string">'gray'</span>)</div><div class="line">plt.title(<span class="string">'%i'</span> % test_data.test_labels[<span class="number">0</span>])</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/cnn_1_0.png" alt="png"></p>
<p><img src="http://ocs628urt.bkt.clouddn.com/cnn_1_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 数据加载</span></div><div class="line">train_loader = Data.DataLoader(dataset = train_data, batch_size = BATCH_SIZE, shuffle = <span class="keyword">True</span>, num_workers = <span class="number">2</span>)</div><div class="line">test_loader = Data.DataLoader(dataset = test_data, batch_size = BATCH_SIZE, shuffle = <span class="keyword">False</span>, num_workers = <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义卷积神经网络</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(CNN, self).__init__()</div><div class="line">        self.conv1 = nn.Sequential(</div><div class="line">            nn.Conv2d(</div><div class="line">                in_channels = <span class="number">1</span>,</div><div class="line">                out_channels = <span class="number">16</span>,</div><div class="line">                kernel_size = <span class="number">5</span>,</div><div class="line">                stride = <span class="number">1</span>,</div><div class="line">                padding = <span class="number">2</span></div><div class="line">            ),</div><div class="line">            nn.ReLU(),</div><div class="line">            nn.MaxPool2d(kernel_size = <span class="number">2</span>)</div><div class="line">        )</div><div class="line">        <span class="comment"># conv1输出为(16, 14, 14)</span></div><div class="line">        self.conv2 = nn.Sequential(</div><div class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</div><div class="line">            nn.ReLU(),</div><div class="line">            nn.MaxPool2d(<span class="number">2</span>)</div><div class="line">        )</div><div class="line">        <span class="comment"># conv2输出为(32, 7, 7)</span></div><div class="line">        self.output = nn.Linear(<span class="number">32</span> * <span class="number">7</span> * <span class="number">7</span>, <span class="number">10</span>)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = self.conv1(x)</div><div class="line">        x = self.conv2(x)</div><div class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</div><div class="line">        prediction = self.output(x)</div><div class="line">        <span class="keyword">return</span> prediction</div><div class="line"></div><div class="line">cnn = CNN()</div><div class="line"><span class="keyword">print</span> cnn</div></pre></td></tr></table></figure>
<pre><code>CNN (
  (conv1): Sequential (
    (0): Conv2d(1, 16, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
    (1): ReLU ()
    (2): MaxPool2d (size=(2, 2), stride=(2, 2), dilation=(1, 1))
  )
  (conv2): Sequential (
    (0): Conv2d(16, 32, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
    (1): ReLU ()
    (2): MaxPool2d (size=(2, 2), stride=(2, 2), dilation=(1, 1))
  )
  (output): Linear (1568 -&gt; 10)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义优化器</span></div><div class="line">optimizer = torch.optim.Adam(cnn.parameters(), lr = LR, betas= (<span class="number">0.9</span>, <span class="number">0.999</span>))</div><div class="line"></div><div class="line"><span class="comment"># 定义损失函数</span></div><div class="line">loss_func = nn.CrossEntropyLoss()</div><div class="line"></div><div class="line"><span class="comment"># 训练</span></div><div class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> xrange(EPOCH):</div><div class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(train_loader):</div><div class="line">        x_var = Variable(x)</div><div class="line">        y_var = Variable(y)</div><div class="line">        prediction = cnn(x_var)</div><div class="line">        loss = loss_func(prediction, y_var)</div><div class="line">        optimizer.zero_grad()</div><div class="line">        loss.backward()</div><div class="line">        optimizer.step()</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            correct = <span class="number">0.0</span></div><div class="line">            <span class="keyword">for</span> step_test, (test_x, test_y) <span class="keyword">in</span> enumerate(test_loader):</div><div class="line">                test_x = Variable(test_x)</div><div class="line">                test_output = cnn(test_x)</div><div class="line">                pred_y = torch.max(test_output, <span class="number">1</span>)[<span class="number">1</span>].data.squeeze()</div><div class="line">                correct += sum(pred_y == test_y)</div><div class="line">            accuracy = correct / test_data.test_data.size(<span class="number">0</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">'Epoch: '</span>, epoch, <span class="string">'| train loss: %.4f'</span> % loss.data[<span class="number">0</span>], <span class="string">'| accuracy: '</span>, accuracy</div></pre></td></tr></table></figure>
<pre><code>Epoch:  0 | train loss: 2.2787 | accuracy:  0.0982
Epoch:  0 | train loss: 0.0788 | accuracy:  0.9592
Epoch:  0 | train loss: 0.0587 | accuracy:  0.9626
Epoch:  0 | train loss: 0.0188 | accuracy:  0.9745
Epoch:  0 | train loss: 0.0707 | accuracy:  0.9759
Epoch:  0 | train loss: 0.0564 | accuracy:  0.9775
Epoch:  0 | train loss: 0.0489 | accuracy:  0.9779
Epoch:  0 | train loss: 0.0925 | accuracy:  0.9791
Epoch:  0 | train loss: 0.0566 | accuracy:  0.9834
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(十)——卷积神经网络
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Improving Deep Neural Networks学习笔记(三)</title>
    <link href="noahsnail.com/2017/09/22/2017-9-22-Improving%20Deep%20Neural%20Networks%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>noahsnail.com/2017/09/22/2017-9-22-Improving Deep Neural Networks学习笔记(三)/</id>
    <published>2017-09-21T23:59:41.000Z</published>
    <updated>2017-09-25T08:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="5-Hyperparameter-tuning"><a href="#5-Hyperparameter-tuning" class="headerlink" title="5. Hyperparameter tuning"></a>5. Hyperparameter tuning</h2><h4 id="5-1-Tuning-process"><a href="#5-1-Tuning-process" class="headerlink" title="5.1 Tuning process"></a>5.1 Tuning process</h4><p>Hyperparameters:</p>
<p>$\alpha$, $\beta$, $\beta_1,\beta_2, \epsilon$, layers, hidden units, learning rate decay, mini-batch size.</p>
<p>The learning rate is the most important hyperparameter to tune. $\beta$, mini-batch size and hidden units is second in importance to tune.</p>
<p>Try random values: Don’t use a grid. Corarse to fine.</p>
<h4 id="5-2-Using-an-appropriate-scale-to-pick-hyperparameters"><a href="#5-2-Using-an-appropriate-scale-to-pick-hyperparameters" class="headerlink" title="5.2 Using an appropriate scale to pick hyperparameters"></a>5.2 Using an appropriate scale to pick hyperparameters</h4><p>Appropriate scale to hyperparameters:</p>
<p>$\alpha = [0.0001, 1]$, r = -4 * np.random.rand(), $\alpha = 10^r$.</p>
<p>If $\alpha = [10^a, 10^b]$, random pick from [a, b] uniformly, and set $\alpha = 10^r$.</p>
<p>Hyperparameters for exponentially weighted average</p>
<p>$\beta = [0.9, 0.999]$, don’t random pick from $[0.9, 0.999]$. Use $1-\beta = [0.001, 0.1]$, use similar method lik $\alpha$.</p>
<p>Why don’t use linear pick? Because when $\beta$ is close one, even if a little change, it will have a huge impact on algorithm.</p>
<h4 id="5-3-Hyperparameters-tuning-in-practice-Pandas-vs-Caviar"><a href="#5-3-Hyperparameters-tuning-in-practice-Pandas-vs-Caviar" class="headerlink" title="5.3 Hyperparameters tuning in practice: Pandas vs Caviar"></a>5.3 Hyperparameters tuning in practice: Pandas vs Caviar</h4><ul>
<li><p>Re-test hyperparamters occasionally</p>
</li>
<li><p>Babysitting one model(Pandas)</p>
</li>
<li><p>Training many models in parallel(Caviar)</p>
</li>
</ul>
<h2 id="6-Batch-Normalization"><a href="#6-Batch-Normalization" class="headerlink" title="6. Batch Normalization"></a>6. Batch Normalization</h2><h4 id="6-1-Normalizing-activations-in-a-network"><a href="#6-1-Normalizing-activations-in-a-network" class="headerlink" title="6.1 Normalizing activations in a network"></a>6.1 Normalizing activations in a network</h4><p>In logistic regression, normalizing inputs to speed up learning.</p>
<ol>
<li>compute means$\mu = \frac {1} {m} \sum_{i=1}^n x^{(i)}$</li>
<li>subtract off the means from training set $x = x - \mu$\</li>
<li>compute the variances $\sigma ^2 = \frac {1} {m} \sum_{i=1}^n {x^{(i)}}^2$</li>
<li>normalize training set $X = \frac {X} {\sigma ^2}$</li>
</ol>
<p>Similarly, in order to speed up training neural network, we can normalize intermediate values in layers（<code>z</code> in hidden layer）, it is called Batch Normalization or Batch Norm.</p>
<p>Implementing Batch Norm</p>
<ol>
<li>Given some intermediate value in neural network, $z^{(1)}, z^{(2)},…,z^{(m)}$</li>
<li>compute means $\mu = \frac {1} {m} \sum_{i=1} z^{(i)}$</li>
<li>compute the variances $\sigma ^2 = \frac {1} {m} \sum_{i=1} (z^{(i)} - \mu)^2$</li>
<li>normalize $z$, $z^{(i)} = \frac {z^{(i)} - \mu} {\sqrt {(\sigma ^2 + \epsilon)}}$</li>
<li>compute $\hat z$, $\hat z = \gamma z^{(i)} + \beta$.</li>
</ol>
<p>Now we have normalized Z to have mean zero and standard unit variance. But maybe it makes sense for hidden units to have a different distribution. So we use $\hat z$ instead of $z$, $\gamma$ and $\beta$ are learnable parameters of your model.</p>
<h4 id="6-2-Fitting-Batch-Norm-into-a-neural-network"><a href="#6-2-Fitting-Batch-Norm-into-a-neural-network" class="headerlink" title="6.2 Fitting Batch Norm into a neural network"></a>6.2 Fitting Batch Norm into a neural network</h4><p>Add Batch Norm to a network</p>
<p>$X \rightarrow Z^{[1]} \rightarrow {\hat Z^{[1]}} \rightarrow {a^{[1]}} \rightarrow Z^{[2]} \rightarrow {\hat Z^{[2]}} \rightarrow {a^{[2]}}…$</p>
<p>Parameters:<br>$W^{[1]}, b^{[1]}$, $W^{[2]}, b^{[2]}…$<br>$\gamma^{[1]}, \beta^{[1]}$, $\gamma^{[2]}, \beta^{[2]}…$</p>
<p>If you use Batch Norm, you need to computing means and subtracting means, so $b^{[i]}$ is useless, so we can set $b^{[i]} = 0$ permanently.</p>
<h4 id="6-3-Why-does-Batch-Norm-work"><a href="#6-3-Why-does-Batch-Norm-work" class="headerlink" title="6.3 Why does Batch Norm work?"></a>6.3 Why does Batch Norm work?</h4><p>Covariate Shift: You have learned a function from $x \rightarrow y$, it works well. If the distribution of $x$ changes, you need to learn a new function to make it work well.</p>
<p>Hidden unit values change all the time, and so it’s suffering from the problem of covariate.</p>
<p>Batch Norm as regularization</p>
<ul>
<li>Each mini-batch is scaled by the mean/variance computed on just that mini-batch.</li>
<li>This adds some noise to the values $z^{[l]}$ within that mini-batch. So similar to dropout, it adds some noise to each hidden layer’s activations.</li>
<li>This has a slight regularization effect.</li>
</ul>
<h4 id="6-4-Batch-Norm-at-test-time"><a href="#6-4-Batch-Norm-at-test-time" class="headerlink" title="6.4 Batch Norm at test time"></a>6.4 Batch Norm at test time</h4><p>In order to apply neural network at test time, come up with some seperate estimate of mu and sigma squared.</p>
<h2 id="7-Multi-class-classification"><a href="#7-Multi-class-classification" class="headerlink" title="7. Multi-class classification"></a>7. Multi-class classification</h2><h4 id="7-1-Softmax-regression"><a href="#7-1-Softmax-regression" class="headerlink" title="7.1 Softmax regression"></a>7.1 Softmax regression</h4><h4 id="7-2-Training-a-softmax-classifier"><a href="#7-2-Training-a-softmax-classifier" class="headerlink" title="7.2 Training a softmax classifier"></a>7.2 Training a softmax classifier</h4><p>Hard max. </p>
<p>Loss function.</p>
<p>Gradient descent with softmax.</p>
<h2 id="8-Programming-Frameworks"><a href="#8-Programming-Frameworks" class="headerlink" title="8. Programming Frameworks"></a>8. Programming Frameworks</h2><h4 id="8-1-Deep-Learning-frameworks"><a href="#8-1-Deep-Learning-frameworks" class="headerlink" title="8.1 Deep Learning frameworks"></a>8.1 Deep Learning frameworks</h4><ul>
<li>Caffe/Caffe2</li>
<li>TensorFlow</li>
<li>Torch</li>
<li>Theano</li>
<li>mxnet</li>
<li>PaddlePaddle</li>
<li>Keras</li>
<li>CNTK</li>
</ul>
<p>Choosing deep learning frameworks</p>
<ul>
<li>Ease of programming (development and deployment)</li>
<li>Running speed</li>
<li>Truly open (open source with good governance)</li>
</ul>
<h4 id="8-2-TensorFlow"><a href="#8-2-TensorFlow" class="headerlink" title="8.2 TensorFlow"></a>8.2 TensorFlow</h4><p>…</p>
]]></content>
    
    <summary type="html">
    
      Improving Deep Neural Networks学习笔记(三)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(九)——优化器</title>
    <link href="noahsnail.com/2017/09/21/2017-9-21-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%B9%9D)%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E5%99%A8/"/>
    <id>noahsnail.com/2017/09/21/2017-9-21-PyTorch基本用法(九)——优化器/</id>
    <published>2017-09-21T11:32:17.000Z</published>
    <updated>2017-09-21T11:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</div><div class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义超参数</span></div><div class="line">LR = <span class="number">0.01</span></div><div class="line">BATCH_SIZE = <span class="number">32</span></div><div class="line">EPOCH = <span class="number">10</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 生成数据</span></div><div class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1000</span>), dim = <span class="number">1</span>)</div><div class="line">y = x.pow(<span class="number">2</span>) + <span class="number">0.1</span>  * torch.normal(torch.zeros(x.size()))</div><div class="line"></div><div class="line"><span class="comment"># 绘制数据图像</span></div><div class="line">plt.scatter(x.numpy(), y.numpy())</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/opt_0_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义数据库</span></div><div class="line">dataset = Data.TensorDataset(data_tensor = x, target_tensor = y)</div><div class="line"></div><div class="line"><span class="comment"># 定义数据加载器</span></div><div class="line">loader = Data.DataLoader(dataset = dataset, batch_size = BATCH_SIZE, shuffle = <span class="keyword">True</span>, num_workers = <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义pytorch网络</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_features, n_hidden, n_output)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.hidden = torch.nn.Linear(n_features, n_hidden)</div><div class="line">        self.predict = torch.nn.Linear(n_hidden, n_output)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.relu(self.hidden(x))</div><div class="line">        y = self.predict(x)</div><div class="line">        <span class="keyword">return</span> y</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义不同的优化器网络</span></div><div class="line">net_SGD = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</div><div class="line">net_Momentum = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</div><div class="line">net_RMSprop = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</div><div class="line">net_Adam = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 选择不同的优化方法</span></div><div class="line">opt_SGD = torch.optim.SGD(net_SGD.parameters(), lr = LR)</div><div class="line">opt_Momentum = torch.optim.SGD(net_Momentum.parameters(), lr = LR, momentum = <span class="number">0.9</span>)</div><div class="line">opt_RMSprop = torch.optim.RMSprop(net_RMSprop.parameters(), lr = LR, alpha = <span class="number">0.9</span>)</div><div class="line">opt_Adam = torch.optim.Adam(net_Adam.parameters(), lr = LR, betas= (<span class="number">0.9</span>, <span class="number">0.99</span>))</div><div class="line"></div><div class="line">nets = [net_SGD, net_Momentum, net_RMSprop, net_Adam]</div><div class="line">optimizers = [opt_SGD, opt_Momentum, opt_RMSprop, opt_Adam]</div><div class="line"></div><div class="line"><span class="comment"># 选择损失函数</span></div><div class="line">loss_func = torch.nn.MSELoss()</div><div class="line"></div><div class="line"><span class="comment"># 不同方法的loss</span></div><div class="line">loss_SGD = []</div><div class="line">loss_Momentum = []</div><div class="line">loss_RMSprop =[]</div><div class="line">loss_Adam = []</div><div class="line"></div><div class="line"><span class="comment"># 保存所有loss</span></div><div class="line">losses = [loss_SGD, loss_Momentum, loss_RMSprop, loss_Adam]</div><div class="line"></div><div class="line"><span class="comment"># 执行训练</span></div><div class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> xrange(EPOCH):</div><div class="line">    <span class="keyword">for</span> step, (batch_x, batch_y) <span class="keyword">in</span> enumerate(loader):</div><div class="line">        var_x = Variable(batch_x)</div><div class="line">        var_y = Variable(batch_y)</div><div class="line">        <span class="keyword">for</span> net, optimizer, loss_history <span class="keyword">in</span> zip(nets, optimizers, losses):</div><div class="line">            <span class="comment"># 对x进行预测</span></div><div class="line">            prediction = net(var_x)</div><div class="line">            <span class="comment"># 计算损失</span></div><div class="line">            loss = loss_func(prediction, var_y)</div><div class="line">            <span class="comment"># 每次迭代清空上一次的梯度</span></div><div class="line">            optimizer.zero_grad()</div><div class="line">            <span class="comment"># 反向传播</span></div><div class="line">            loss.backward()</div><div class="line">            <span class="comment"># 更新梯度</span></div><div class="line">            optimizer.step()</div><div class="line">            <span class="comment"># 保存loss记录</span></div><div class="line">            loss_history.append(loss.data[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 画图</span></div><div class="line">labels = [<span class="string">'SGD'</span>, <span class="string">'Momentum'</span>, <span class="string">'RMSprop'</span>, <span class="string">'Adam'</span>]</div><div class="line"><span class="keyword">for</span> i, loss_history <span class="keyword">in</span> enumerate(losses):</div><div class="line">    plt.plot(loss_history, label = labels[i])</div><div class="line">plt.legend(loc = <span class="string">'best'</span>)</div><div class="line">plt.xlabel(<span class="string">'Steps'</span>)</div><div class="line">plt.ylabel(<span class="string">'Loss'</span>)</div><div class="line">plt.ylim((<span class="number">0</span>, <span class="number">0.2</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/opt_3_0.png" alt="png"></p>
]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(九)——优化器
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(八)——批训练</title>
    <link href="noahsnail.com/2017/09/20/2017-9-20-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E5%85%AB)%E2%80%94%E2%80%94%E6%89%B9%E8%AE%AD%E7%BB%83/"/>
    <id>noahsnail.com/2017/09/20/2017-9-20-PyTorch基本用法(八)——批训练/</id>
    <published>2017-09-20T13:30:52.000Z</published>
    <updated>2017-09-20T13:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"><span class="comment"># 定义batch size</span></div><div class="line">BATCH_SIZE = <span class="number">5</span></div><div class="line"></div><div class="line"><span class="comment"># 定义数据</span></div><div class="line">x = torch.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>)</div><div class="line">y = torch.linspace(<span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> x.numpy()</div><div class="line"><span class="keyword">print</span> y.numpy()</div></pre></td></tr></table></figure>
<pre><code>[  1.   2.   3.   4.   5.   6.   7.   8.   9.  10.]
[ 10.   9.   8.   7.   6.   5.   4.   3.   2.   1.]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义数据库</span></div><div class="line">dataset = Data.TensorDataset(data_tensor = x, target_tensor = y)</div><div class="line"></div><div class="line"><span class="comment"># 定义数据加载器</span></div><div class="line">loader = Data.DataLoader(dataset = dataset, batch_size = BATCH_SIZE, shuffle = <span class="keyword">True</span>, num_workers = <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 训练过程</span></div><div class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">    <span class="keyword">for</span> step, (batch_x, batch_y) <span class="keyword">in</span> enumerate(loader):</div><div class="line">        <span class="comment"># 训练过程</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Epoch: '</span>, epoch, <span class="string">'| Step: '</span>, step, <span class="string">'| batch x: '</span>, batch_x.numpy(), <span class="string">'| betch y: '</span>, batch_y.numpy()</div></pre></td></tr></table></figure>
<pre><code>Epoch:  0 | Step:  0 | batch x:  [ 7.  4.  8.  5.  2.] | betch y:  [ 4.  7.  3.  6.  9.]
Epoch:  0 | Step:  1 | batch x:  [ 10.   6.   3.   1.   9.] | betch y:  [  1.   5.   8.  10.   2.]
Epoch:  1 | Step:  0 | batch x:  [  6.   7.  10.   1.   3.] | betch y:  [  5.   4.   1.  10.   8.]
Epoch:  1 | Step:  1 | batch x:  [ 9.  4.  5.  8.  2.] | betch y:  [ 2.  7.  6.  3.  9.]
Epoch:  2 | Step:  0 | batch x:  [ 5.  4.  7.  3.  8.] | betch y:  [ 6.  7.  4.  8.  3.]
Epoch:  2 | Step:  1 | batch x:  [  6.   9.   2.  10.   1.] | betch y:  [  5.   2.   9.   1.  10.]
Epoch:  3 | Step:  0 | batch x:  [  9.   1.   5.   3.  10.] | betch y:  [  2.  10.   6.   8.   1.]
Epoch:  3 | Step:  1 | batch x:  [ 8.  6.  4.  2.  7.] | betch y:  [ 3.  5.  7.  9.  4.]
Epoch:  4 | Step:  0 | batch x:  [ 10.   5.   9.   7.   3.] | betch y:  [ 1.  6.  2.  4.  8.]
Epoch:  4 | Step:  1 | batch x:  [ 6.  8.  2.  4.  1.] | betch y:  [  5.   3.   9.   7.  10.]
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(八)——批训练
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(七)——模型的保存与加载</title>
    <link href="noahsnail.com/2017/09/20/2017-9-20-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%B8%83)%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>noahsnail.com/2017/09/20/2017-9-20-PyTorch基本用法(七)——模型的保存与加载/</id>
    <published>2017-09-20T11:42:59.000Z</published>
    <updated>2017-09-20T12:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 生成数据</span></div><div class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100</span>), dim = <span class="number">1</span>)</div><div class="line">y = x.pow(<span class="number">2</span>) + <span class="number">0.2</span> * torch.rand(x.size())</div><div class="line"></div><div class="line"><span class="comment"># 变为Variable</span></div><div class="line">x, y = Variable(x), Variable(y)</div><div class="line"></div><div class="line"><span class="comment"># 定义网络</span></div><div class="line">net = torch.nn.Sequential(</div><div class="line">    torch.nn.Linear(<span class="number">1</span>, <span class="number">10</span>),</div><div class="line">    torch.nn.ReLU(),</div><div class="line">    torch.nn.Linear(<span class="number">10</span>, <span class="number">1</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">print</span> net</div></pre></td></tr></table></figure>
<pre><code>Sequential (
  (0): Linear (1 -&gt; 10)
  (1): ReLU ()
  (2): Linear (10 -&gt; 1)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 选择优化方法</span></div><div class="line">optimizer = torch.optim.SGD(net.parameters(), lr = <span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="comment"># 选择损失函数</span></div><div class="line">loss_func = torch.nn.MSELoss()</div><div class="line"></div><div class="line"><span class="comment"># 训练网络</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</div><div class="line">    <span class="comment"># 对x进行预测</span></div><div class="line">    prediction = net(x)</div><div class="line">    <span class="comment"># 计算损失</span></div><div class="line">    loss = loss_func(prediction, y)</div><div class="line">    <span class="comment"># 每次迭代清空上一次的梯度</span></div><div class="line">    optimizer.zero_grad()</div><div class="line">    <span class="comment"># 反向传播</span></div><div class="line">    loss.backward()</div><div class="line">    <span class="comment"># 更新梯度</span></div><div class="line">    optimizer.step()</div><div class="line"></div><div class="line">plt.scatter(x.data.numpy(), y.data.numpy())</div><div class="line">plt.plot(x.data.numpy(), prediction.data.numpy(), <span class="string">'r-'</span>, lw = <span class="number">5</span>)</div><div class="line">plt.text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">'Loss=%.4f'</span> % loss.data[<span class="number">0</span>], fontdict=&#123;<span class="string">'size'</span>: <span class="number">10</span>, <span class="string">'color'</span>:  <span class="string">'red'</span>&#125;)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/model_save_1_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 保存训练的模型</span></div><div class="line"></div><div class="line"><span class="comment"># 保存整个网络和参数</span></div><div class="line">torch.save(net, <span class="string">'net.pkl'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 重新加载模型</span></div><div class="line">net = torch.load(<span class="string">'net.pkl'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 用新加载的模型进行预测</span></div><div class="line">prediction = net(x)</div><div class="line">plt.scatter(x.data.numpy(), y.data.numpy())</div><div class="line">plt.plot(x.data.numpy(), prediction.data.numpy(), <span class="string">'r-'</span>, lw = <span class="number">5</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/model_save_2_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 只保存网络的参数, 官方推荐的方式</span></div><div class="line">torch.save(net.state_dict(), <span class="string">'net_params.pkl'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义网络</span></div><div class="line">net = torch.nn.Sequential(</div><div class="line">    torch.nn.Linear(<span class="number">1</span>, <span class="number">10</span>),</div><div class="line">    torch.nn.ReLU(),</div><div class="line">    torch.nn.Linear(<span class="number">10</span>, <span class="number">1</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># 加载网络参数</span></div><div class="line">net.load_state_dict(torch.load(<span class="string">'net_params.pkl'</span>))</div><div class="line"></div><div class="line"><span class="comment"># 用新加载的参数进行预测</span></div><div class="line">prediction = net(x)</div><div class="line">plt.scatter(x.data.numpy(), y.data.numpy())</div><div class="line">plt.plot(x.data.numpy(), prediction.data.numpy(), <span class="string">'r-'</span>, lw = <span class="number">5</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/model_save_3_0.png" alt="png"></p>
]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(七)——模型的保存与加载
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(六)——快速搭建网络</title>
    <link href="noahsnail.com/2017/09/20/2017-9-20PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E5%85%AD)%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/"/>
    <id>noahsnail.com/2017/09/20/2017-9-20PyTorch基本用法(六)——快速搭建网络/</id>
    <published>2017-09-20T11:19:11.000Z</published>
    <updated>2017-09-20T11:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</div><div class="line"></div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"><span class="comment"># 许多没解释的东西可以去查文档, 文档中都有, 已查过</span></div><div class="line"><span class="comment"># pytorch文档: http://pytorch.org/docs/master/index.html</span></div><div class="line"><span class="comment"># matplotlib文档: https://matplotlib.org/</span></div><div class="line"></div><div class="line"><span class="comment"># 随机算法的生成种子</span></div><div class="line">torch.manual_seed(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 生成数据</span></div><div class="line">n_data = torch.ones(<span class="number">100</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 类别一的数据</span></div><div class="line">x0 = torch.normal(<span class="number">2</span> * n_data, <span class="number">1</span>)</div><div class="line"><span class="comment"># 类别一的标签</span></div><div class="line">y0 = torch.zeros(<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment"># 类别二的数据</span></div><div class="line">x1 = torch.normal(<span class="number">-2</span> * n_data, <span class="number">1</span>)</div><div class="line"><span class="comment"># 类别二的标签</span></div><div class="line">y1 = torch.ones(<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment"># x0, x1连接起来, 按维度0连接, 并指定数据的类型</span></div><div class="line">x = torch.cat((x0, x1), <span class="number">0</span>).type(torch.FloatTensor)</div><div class="line"><span class="comment"># y0, y1连接, 由于只有一维, 因此没有指定维度, torch中标签类型必须为LongTensor</span></div><div class="line">y = torch.cat((y0, y1), ).type(torch.LongTensor)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># x,y 转为变量, torch只支持变量的训练, 因为Variable中有grad</span></div><div class="line">x, y = Variable(x), Variable(y)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制数据散点图</span></div><div class="line">plt.scatter(x.data.numpy()[:, <span class="number">0</span>], x.data.numpy()[:, <span class="number">1</span>], c = y.data.numpy(), s = <span class="number">100</span>, lw = <span class="number">0</span>, cmap = <span class="string">'RdYlGn'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/classification_1_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 快速搭建分类网络</span></div><div class="line">net = torch.nn.Sequential(</div><div class="line">    torch.nn.Linear(<span class="number">2</span>, <span class="number">10</span>),</div><div class="line">    torch.nn.ReLU(),</div><div class="line">    torch.nn.Linear(<span class="number">10</span>, <span class="number">2</span>))</div><div class="line">print(net)</div></pre></td></tr></table></figure>
<pre><code>Sequential (
  (0): Linear (2 -&gt; 10)
  (1): ReLU ()
  (2): Linear (10 -&gt; 2)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义优化方法</span></div><div class="line">optimizer = torch.optim.SGD(net.parameters(), lr = <span class="number">0.02</span>)</div><div class="line"><span class="comment"># 定义损失函数</span></div><div class="line">loss_func = torch.nn.CrossEntropyLoss()</div><div class="line"></div><div class="line">plt.ion()</div><div class="line"></div><div class="line"><span class="comment"># 训练过程</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</div><div class="line">    prediction = net(x)</div><div class="line">    loss = loss_func(prediction, y)</div><div class="line"></div><div class="line">    optimizer.zero_grad()</div><div class="line">    loss.backward()</div><div class="line">    optimizer.step()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">        plt.cla()</div><div class="line">        <span class="comment"># 获取概率最大的类别的索引</span></div><div class="line">        prediction = torch.max(F.softmax(prediction), <span class="number">1</span>)[<span class="number">1</span>]</div><div class="line">        <span class="comment"># 将输出结果变为一维</span></div><div class="line">        pred_y = prediction.data.numpy().squeeze()</div><div class="line">        target_y = y.data.numpy()</div><div class="line">        plt.scatter(x.data.numpy()[:, <span class="number">0</span>], x.data.numpy()[:, <span class="number">1</span>], c = pred_y, s = <span class="number">100</span>, lw = <span class="number">0</span>, cmap = <span class="string">'RdYlGn'</span>)</div><div class="line">        <span class="comment"># 计算准确率</span></div><div class="line">        accuracy = sum(pred_y == target_y) / <span class="number">200.0</span></div><div class="line">        plt.text(<span class="number">1.5</span>, <span class="number">-4</span>, <span class="string">'Accuracy=%.2f'</span> % accuracy, fontdict = &#123;<span class="string">'size'</span>: <span class="number">10</span>, <span class="string">'color'</span>:  <span class="string">'red'</span>&#125;)</div><div class="line">        plt.pause(<span class="number">0.1</span>)</div><div class="line"></div><div class="line">plt.ioff()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/classification_4_0.png" alt="png"></p>
]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(六)——快速搭建网络
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(五)——分类</title>
    <link href="noahsnail.com/2017/09/19/2017-9-19-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%BA%94)%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB/"/>
    <id>noahsnail.com/2017/09/19/2017-9-19-PyTorch基本用法(五)——分类/</id>
    <published>2017-09-19T12:43:42.000Z</published>
    <updated>2017-09-19T12:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</div><div class="line"></div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"><span class="comment"># 许多没解释的东西可以去查文档, 文档中都有, 已查过</span></div><div class="line"><span class="comment"># pytorch文档: http://pytorch.org/docs/master/index.html</span></div><div class="line"><span class="comment"># matplotlib文档: https://matplotlib.org/</span></div><div class="line"></div><div class="line"><span class="comment"># 随机算法的生成种子</span></div><div class="line">torch.manual_seed(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 生成数据</span></div><div class="line">n_data = torch.ones(<span class="number">100</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 类别一的数据</span></div><div class="line">x0 = torch.normal(<span class="number">2</span> * n_data, <span class="number">1</span>)</div><div class="line"><span class="comment"># 类别一的标签</span></div><div class="line">y0 = torch.zeros(<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment"># 类别二的数据</span></div><div class="line">x1 = torch.normal(<span class="number">-2</span> * n_data, <span class="number">1</span>)</div><div class="line"><span class="comment"># 类别二的标签</span></div><div class="line">y1 = torch.ones(<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment"># x0, x1连接起来, 按维度0连接, 并指定数据的类型</span></div><div class="line">x = torch.cat((x0, x1), <span class="number">0</span>).type(torch.FloatTensor)</div><div class="line"><span class="comment"># y0, y1连接, 由于只有一维, 因此没有指定维度, torch中标签类型必须为LongTensor</span></div><div class="line">y = torch.cat((y0, y1), ).type(torch.LongTensor)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># x,y 转为变量, torch只支持变量的训练, 因为Variable中有grad</span></div><div class="line">x, y = Variable(x), Variable(y)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制数据散点图</span></div><div class="line">plt.scatter(x.data.numpy()[:, <span class="number">0</span>], x.data.numpy()[:, <span class="number">1</span>], c = y.data.numpy(), s = <span class="number">100</span>, lw = <span class="number">0</span>, cmap = <span class="string">'RdYlGn'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/classification_1_0.png" alt="png"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 定义分类网络</div><div class="line">class Net(torch.nn.Module):</div><div class="line">    </div><div class="line">    def __init__(self, n_feature, n_hidden, n_output):</div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.hidden = torch.nn.Linear(n_feature, n_hidden)</div><div class="line">        self.prediction = torch.nn.Linear(n_hidden, n_output)</div><div class="line"></div><div class="line">    def forward(self, x)</div><div class="line">        x = F.relu(self.hidden(x))</div><div class="line">        x = self.prediction(x)</div><div class="line">        return x</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义网络</span></div><div class="line">net = Net(n_feature = <span class="number">2</span>, n_hidden = <span class="number">10</span>, n_output = <span class="number">2</span>)</div><div class="line">print(net)</div></pre></td></tr></table></figure>
<pre><code>Net (
  (hidden): Linear (2 -&gt; 10)
  (prediction): Linear (10 -&gt; 2)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义优化方法</span></div><div class="line">optimizer = torch.optim.SGD(net.parameters(), lr = <span class="number">0.02</span>)</div><div class="line"><span class="comment"># 定义损失函数</span></div><div class="line">loss_func = torch.nn.CrossEntropyLoss()</div><div class="line"></div><div class="line">plt.ion()</div><div class="line"></div><div class="line"><span class="comment"># 训练过程</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</div><div class="line">    prediction = net(x)</div><div class="line">    loss = loss_func(prediction, y)</div><div class="line"></div><div class="line">    optimizer.zero_grad()</div><div class="line">    loss.backward()</div><div class="line">    optimizer.step()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">        plt.cla()</div><div class="line">        <span class="comment"># 获取概率最大的类别的索引</span></div><div class="line">        prediction = torch.max(F.softmax(prediction), <span class="number">1</span>)[<span class="number">1</span>]</div><div class="line">        <span class="comment"># 将输出结果变为一维</span></div><div class="line">        pred_y = prediction.data.numpy().squeeze()</div><div class="line">        target_y = y.data.numpy()</div><div class="line">        plt.scatter(x.data.numpy()[:, <span class="number">0</span>], x.data.numpy()[:, <span class="number">1</span>], c = pred_y, s = <span class="number">100</span>, lw = <span class="number">0</span>, cmap = <span class="string">'RdYlGn'</span>)</div><div class="line">        <span class="comment"># 计算准确率</span></div><div class="line">        accuracy = sum(pred_y == target_y) / <span class="number">200.0</span></div><div class="line">        plt.text(<span class="number">1.5</span>, <span class="number">-4</span>, <span class="string">'Accuracy=%.2f'</span> % accuracy, fontdict = &#123;<span class="string">'size'</span>: <span class="number">10</span>, <span class="string">'color'</span>:  <span class="string">'red'</span>&#125;)</div><div class="line">        plt.pause(<span class="number">0.1</span>)</div><div class="line"></div><div class="line">plt.ioff()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/classification_4_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># torch.max用法</span></div><div class="line">a = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> a</div><div class="line"><span class="keyword">print</span> torch.max(a, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>-1.8524 -1.0491  0.5382 -0.5129
 0.1233 -0.1821  2.1519 -1.4547
-1.0267  0.2644 -0.8832 -0.2647
 0.3944 -1.2512 -0.1158  0.5071
[torch.FloatTensor of size 4x4]

(
 0.5382
 2.1519
 0.2644
 0.5071
[torch.FloatTensor of size 4]
, 
 2
 2
 1
 3
[torch.LongTensor of size 4]
)
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(五)——分类
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(四)——回归</title>
    <link href="noahsnail.com/2017/09/19/2017-9-19-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E5%9B%9B)%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92/"/>
    <id>noahsnail.com/2017/09/19/2017-9-19-PyTorch基本用法(四)——回归/</id>
    <published>2017-09-19T07:47:28.000Z</published>
    <updated>2017-09-19T07:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line"><span class="comment"># 生成数据</span></div><div class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100</span>), dim = <span class="number">1</span>)</div><div class="line">y = x.pow(<span class="number">2</span>) + <span class="number">0.2</span> * torch.rand(x.size())</div><div class="line"></div><div class="line"><span class="comment"># 变为Variable</span></div><div class="line">x, y = Variable(x), Variable(y)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制数据图像</span></div><div class="line">plt.scatter(x.data.numpy(), y.data.numpy())</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/output_1_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义pytorch网络</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_features, n_hidden, n_output)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.hidden = torch.nn.Linear(n_features, n_hidden)</div><div class="line">        self.predict = torch.nn.Linear(n_hidden, n_output)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.relu(self.hidden(x))</div><div class="line">        y = self.predict(x)</div><div class="line">        <span class="keyword">return</span> y</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建网络</span></div><div class="line">net = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> net</div></pre></td></tr></table></figure>
<pre><code>Net (
  (hidden): Linear (1 -&gt; 10)
  (predict): Linear (10 -&gt; 1)
)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 选择优化方法</span></div><div class="line">optimizer = torch.optim.SGD(net.parameters(), lr = <span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="comment"># 选择损失函数</span></div><div class="line">loss_func = torch.nn.MSELoss()</div><div class="line"></div><div class="line">plt.ion()</div><div class="line"><span class="comment"># 训练</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</div><div class="line">    <span class="comment"># 对x进行预测</span></div><div class="line">    prediction = net(x)</div><div class="line">    <span class="comment"># 计算损失</span></div><div class="line">    loss = loss_func(prediction, y)</div><div class="line">    <span class="comment"># 每次迭代清空上一次的梯度</span></div><div class="line">    optimizer.zero_grad()</div><div class="line">    <span class="comment"># 反向传播</span></div><div class="line">    loss.backward()</div><div class="line">    <span class="comment"># 更新梯度</span></div><div class="line">    optimizer.step()</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">        plt.cla()</div><div class="line">        plt.scatter(x.data.numpy(), y.data.numpy())</div><div class="line">        plt.plot(x.data.numpy(), prediction.data.numpy(), <span class="string">'r-'</span>, lw = <span class="number">5</span>)</div><div class="line">        plt.text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">'Loss=%.4f'</span> % loss.data[<span class="number">0</span>], fontdict=&#123;<span class="string">'size'</span>: <span class="number">10</span>, <span class="string">'color'</span>:  <span class="string">'red'</span>&#125;)</div><div class="line">        plt.pause(<span class="number">0.1</span>)</div><div class="line">plt.ioff()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://ocs628urt.bkt.clouddn.com/output_4_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># unsqueeze用法, 一维变二维</span></div><div class="line">x = torch.Tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="keyword">print</span> x</div><div class="line"><span class="keyword">print</span> torch.unsqueeze(x, <span class="number">0</span>)</div><div class="line"><span class="keyword">print</span> torch.unsqueeze(x, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code> 1
 2
 3
 4
[torch.FloatTensor of size 4]


 1  2  3  4
[torch.FloatTensor of size 1x4]


 1
 2
 3
 4
[torch.FloatTensor of size 4x1]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rand用法, rand返回的是[0,1)之间的均匀分布</span></div><div class="line"><span class="keyword">print</span> torch.rand(<span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> torch.rand(<span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<pre><code> 0.8473
 0.2252
 0.0599
 0.0777
[torch.FloatTensor of size 4]


 0.2864  0.1693  0.1261
 0.9013  0.2009  0.9854
[torch.FloatTensor of size 2x3]
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(四)——回归
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Improving Deep Neural Networks学习笔记(二)</title>
    <link href="noahsnail.com/2017/09/18/2017-9-18-Improving%20Deep%20Neural%20Networks%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>noahsnail.com/2017/09/18/2017-9-18-Improving Deep Neural Networks学习笔记(二)/</id>
    <published>2017-09-18T13:53:18.000Z</published>
    <updated>2017-09-21T14:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="4-Optimization-algorithms"><a href="#4-Optimization-algorithms" class="headerlink" title="4. Optimization algorithms"></a>4. Optimization algorithms</h2><h4 id="4-1-Mini-batch-gradient-descent"><a href="#4-1-Mini-batch-gradient-descent" class="headerlink" title="4.1 Mini-batch gradient descent"></a>4.1 Mini-batch gradient descent</h4><p>$x^{\{t\}}$，$y^{\{t\}}$ is used to index into different mini batches. $x^{[t]}$，$y^{[t]}$ is used to index into different layer. $x^{(t)}$，$y^{(t)}$ is used to index into different examples.</p>
<p>Batch gradient descent is to process entire training set at the same time. Mini-batch gradient descent is to process single mini batch $x^{\{t\}}$，$y^{\{t\}}$ at the same time.</p>
<p>Run forward propagation and back propagation once on mini batch is called one iteration.</p>
<p>Mini-batch gradient descent runs much faster than batch gradient descent.</p>
<h4 id="4-2-Understanding-mini-batch-gradient-descent"><a href="#4-2-Understanding-mini-batch-gradient-descent" class="headerlink" title="4.2 Understanding mini-batch gradient descent"></a>4.2 Understanding mini-batch gradient descent</h4><p>If mini-batch size = m, it’s batch gradient descend.<br>If mini-batch size = 1, it’s stochastic gradient descend.<br>In pracice, mini-batch size between 1 and m.</p>
<p>Batch gradient descend: too long per iteration.<br>Stochastic gradient descend: lose speed up from vectorization.<br>Mini-batch gradient descend: Faster learning, 1. vectorization 2. Make progress without needing to wait.</p>
<p>Choosing mini-batch size:</p>
<p>If small training set(m &lt;= 2000), use batch gradient descend.<br>Typical mini-batch size: 64, 128, 256, 512, 1024(rare).</p>
<h4 id="4-3-Exponentially-weighted-averages"><a href="#4-3-Exponentially-weighted-averages" class="headerlink" title="4.3 Exponentially weighted averages"></a>4.3 Exponentially weighted averages</h4><p>$$V_t = \beta V_{t-1} + (1-\beta)\theta_t$$</p>
<p>View $V_t$ as approximately averaging over $\frac {1} {1 - \beta}$.</p>
<p>It’s called moving average in the statistics literature.</p>
<p>$\beta = 0.9$：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/ewa_1.png" alt="Figure 1"></p>
<p>$\beta = 0.9(red)$，$\beta = 0.98(green)$，$\beta = 0.5(yellow)$：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/ewa_2.png" alt="Figure 2"></p>
<h4 id="4-4-Understanding-exponentially-weighted-averages"><a href="#4-4-Understanding-exponentially-weighted-averages" class="headerlink" title="4.4 Understanding exponentially weighted averages"></a>4.4 Understanding exponentially weighted averages</h4><p>$\theta$ is the temperature of the day.</p>
<p>$$v_{100} = 0.9v_{99} + 0.1 \theta_{100}$$$$v_{99} = 0.9v_{98} + 0.1 \theta_{99}$$$$…$$</p>
<p>So $$v_{100} = 0.1 * \theta _{100} + 0.1 * 0.9 * \theta _{99} + … + 0.1 * 0.9^{i} * \theta _{100-i} + …$$</p>
<p>Th coefficients is $$0.1 + 0.1 * 0.9 + 0.1 * 0.9^2 + …$$</p>
<p>All of these coefficients, add up to one or add up to very close to one. It is called bias correction.</p>
<p>$$(1 - \epsilon)^{\frac {1} {\epsilon}} \approx \frac {1} {e}$$ $$\frac {1} {e} \approx 0.3679$$</p>
<p>Implement exponentially weighted average:</p>
<p>$$v_0 = 0$$$$v_1 = \beta v_0 + (1- \beta) \theta _1$$$$v_2 = \beta v_1 + (1- \beta) \theta _2$$$$…$$</p>
<p>Exponentially weighted average takes very low memory.</p>
<h4 id="4-5-Bias-correction-in-exponentially-weighted-averages"><a href="#4-5-Bias-correction-in-exponentially-weighted-averages" class="headerlink" title="4.5 Bias correction in exponentially weighted averages"></a>4.5 Bias correction in exponentially weighted averages</h4><p>It’s not a very good estimate of the first several day’s temperature. Bias correction is used to mofity this estimate that makes it much better. The formula is: $$\frac {v_t} {1 - \beta^t} = \beta v_{t-1} + (1- \beta) \theta _t.$$</p>
<h4 id="4-6-Gradient-descent-with-momentum"><a href="#4-6-Gradient-descent-with-momentum" class="headerlink" title="4.6 Gradient descent with momentum"></a>4.6 Gradient descent with momentum</h4><p>Gradient descent with momentum almost always works faster than the standard gradient descent algorithm. The basic idea is to compute an exponentially weighted average of gradients, and then use that gradient to update weights instead.</p>
<p>On iteration t:</p>
<ol>
<li>compute $dw$, db on current mini-batch.</li>
<li>compute $v_{dw}$, $v_{db}$<br>$$v_{dw} = \beta v_{dw} + (1 - \beta)dw$$$$v_{db} = \beta v_{db} + (1 - \beta)db$$</li>
<li>update dw, db<br>$$w = w - \alpha v_{dw}$$$$b = b - \alpha v_{db}$$</li>
</ol>
<p>There are two hyperparameters, the most common value for $\beta$ is 0.9.</p>
<p>Another formula is $v_{dw} = \beta v_{dw} + dw$, you need to modify corresponding $\alpha$.</p>
<h4 id="4-7-RMSprop"><a href="#4-7-RMSprop" class="headerlink" title="4.7 RMSprop"></a>4.7 RMSprop</h4><p>RMSprop stands for root mean square prop, that can also speed up gradient descent.</p>
<p>On iteration t:</p>
<ol>
<li>compute $dw$, db on current mini-batch.</li>
<li>compute $s_{dw}$, $s_{db}$<br>$$s_{dw} = \beta s_{dw} + (1 - \beta){dw}^2$$$$s_{db} = \beta s_{db} + (1 - \beta){db}^2$$</li>
<li>update dw, db<br>$$w = w - \alpha \frac {dw} {\sqrt {s_{dw}}}$$$$b = b - \alpha \frac {db} {\sqrt {s_{db}}}$$</li>
</ol>
<p>In practice, in order to avoid $\sqrt {s_{dw}}$ being very close zero:</p>
<p>$$w = w - \alpha \frac {dw} {\sqrt {s_{dw}} + \epsilon}$$$$b = b - \alpha \frac {db} {\sqrt {s_{db}} + \epsilon}$$</p>
<p>Usually $$\epsilon = 10^{-8}$$</p>
<h4 id="4-8-Adam-optimization-algorithm"><a href="#4-8-Adam-optimization-algorithm" class="headerlink" title="4.8 Adam optimization algorithm"></a>4.8 Adam optimization algorithm</h4><p>$$v_{dw}=0, s_{dw}=0,v_{db},s_{db}=0$$</p>
<p>On iteration t:</p>
<p>$$v_{dw} = \beta_1 v_{dw} + (1 - \beta_1)dw$$$$v_{db} = \beta_1 v_{db} + (1 - \beta_1)db$$</p>
<p>$$s_{dw} = \beta_2 s_{dw} + (1 - \beta_2){dw}^2$$$$s_{db} = \beta_2 s_{db} + (1 - \beta_2){db}^2$$</p>
<p>Bias correction:</p>
<p>$$v_{dw}^{bc} = \frac {v_{dw}} {1 - \beta_1^t}, v_{db}^{bc} = \frac {v_{db}} {1 - \beta_1^t}$$$$s_{dw}^{bc} = \frac {s_{dw}} {1 - \beta_2^t}, s_{db}^{bc} = \frac {s_{db}} {1 - \beta_2^t}$$</p>
<p>Update weight:</p>
<p>$$w = w - \alpha \frac {v_{dw}^{bc}} {\sqrt {s_{dw}^{bc}} + \epsilon}$$$$b = b - \alpha \frac {v_{db}^{bc}} {\sqrt {s_{db}^{bc}} + \epsilon}$$</p>
<p>Adam combines the effect of gradient descent with momentum together with gradient descent with RMSprop. It’s a commonly used learning algorithm that is proven to be very effective for many different neural networks of a very wide variety of architectures.\</p>
<p>$\alpha$ needs to be tuned. $\beta_1 = 0.9$, $\beta_2 = 0.999$, $\epsilon = 10^{-8}$.</p>
<p>Adam stands for Adaptive Moment Estimation.</p>
<h4 id="4-9-Learning-rate-decay"><a href="#4-9-Learning-rate-decay" class="headerlink" title="4.9 Learning rate decay"></a>4.9 Learning rate decay</h4><p>Learning rate decay is slowly reduce the learning rate.</p>
<p>$$\alpha = \frac {1} {1 + {decay rate} * epochs} \alpha_0$$</p>
<p>$\alpha_0$ is the initial learning rate.</p>
<p>Other learning rate decay methods:</p>
<p>$\alpha = 0.95^{epochs}\alpha_0$, this is called exponentially decay.</p>
<p>$\alpha = \frac {k} {\sqrt {epochs} } \alpha_0$, $\alpha = \frac {k} {\sqrt t} \alpha_0$.</p>
<p>$\alpha = {\frac {1} {2}}^{epochs} \alpha _0$, this is called a discrete staircase.</p>
<h4 id="4-10-The-problem-of-local-optima"><a href="#4-10-The-problem-of-local-optima" class="headerlink" title="4.10 The problem of local optima"></a>4.10 The problem of local optima</h4><p>In very high-dimensional spaces you’re actually much more likely to run into a saddle point, rather than local optimum.</p>
<ul>
<li>Unlikely to get stuck in a bad local optima.</li>
<li>Plateaus can make learning slow.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      Improving Deep Neural Networks学习笔记(二)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(三)——激活函数</title>
    <link href="noahsnail.com/2017/09/18/2017-9-18-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%B8%89)%E2%80%94%E2%80%94%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>noahsnail.com/2017/09/18/2017-9-18-PyTorch基本用法(三)——激活函数/</id>
    <published>2017-09-18T12:25:07.000Z</published>
    <updated>2017-09-18T13:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是关于PyTorch的激活函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> func</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 定义数据x</span></div><div class="line">x = torch.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">200</span>)</div><div class="line">x = Variable(x)</div><div class="line">np_x = x.data.numpy()</div><div class="line"></div><div class="line"><span class="comment"># 通过激活函数处理x</span></div><div class="line">y_relu = func.relu(x).data.numpy()</div><div class="line">y_sigmoid = func.sigmoid(x).data.numpy()</div><div class="line">y_tanh = func.tanh(x).data.numpy()</div><div class="line">y_softmax = func.softplus(x).data.numpy()</div><div class="line"></div><div class="line"><span class="comment"># 绘制激活函数图</span></div><div class="line">plt.figure(<span class="number">1</span>, figsize = (<span class="number">8</span>, <span class="number">6</span>))</div><div class="line">plt.subplot(<span class="number">221</span>)</div><div class="line">plt.plot(np_x, y_relu, c = <span class="string">'red'</span>, label = <span class="string">'relu'</span>)</div><div class="line">plt.ylim((<span class="number">-1</span>, <span class="number">5</span>))</div><div class="line">plt.legend(loc = <span class="string">'best'</span>)</div><div class="line"></div><div class="line">plt.figure(<span class="number">1</span>, figsize = (<span class="number">8</span>, <span class="number">6</span>))</div><div class="line">plt.subplot(<span class="number">222</span>)</div><div class="line">plt.plot(np_x, y_sigmoid, c = <span class="string">'red'</span>, label = <span class="string">'sigmoid'</span>)</div><div class="line">plt.ylim((<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">plt.legend(loc = <span class="string">'best'</span>)</div><div class="line"></div><div class="line">plt.figure(<span class="number">1</span>, figsize = (<span class="number">8</span>, <span class="number">6</span>))</div><div class="line">plt.subplot(<span class="number">223</span>)</div><div class="line">plt.plot(np_x, y_tanh, c = <span class="string">'red'</span>, label = <span class="string">'tanh'</span>)</div><div class="line">plt.ylim((<span class="number">-1</span>, <span class="number">1</span>))</div><div class="line">plt.legend(loc = <span class="string">'best'</span>)</div><div class="line"></div><div class="line">plt.figure(<span class="number">1</span>, figsize = (<span class="number">8</span>, <span class="number">6</span>))</div><div class="line">plt.subplot(<span class="number">224</span>)</div><div class="line">plt.plot(np_x, y_softmax, c = <span class="string">'red'</span>, label = <span class="string">'softmax'</span>)</div><div class="line">plt.ylim((<span class="number">-1</span>, <span class="number">5</span>))</div><div class="line">plt.legend(loc = <span class="string">'best'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/ac_func.png" alt="Figure"></p>
]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(三)——激活函数
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(二)——Variable</title>
    <link href="noahsnail.com/2017/09/18/2017-9-18-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%BA%8C)%E2%80%94%E2%80%94Variable/"/>
    <id>noahsnail.com/2017/09/18/2017-9-18-PyTorch基本用法(二)——Variable/</id>
    <published>2017-09-18T10:46:11.000Z</published>
    <updated>2017-09-18T12:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是PyTorch中Variable变量的一些用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div><div class="line"></div><div class="line">tensor = torch.FloatTensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</div><div class="line"></div><div class="line"><span class="comment"># 定义Variable, requires_grad用来指定是否需要计算梯度</span></div><div class="line">variable = Variable(tensor, requires_grad = <span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> tensor</div><div class="line"><span class="keyword">print</span> variable</div></pre></td></tr></table></figure>
<pre><code> 1  2
 3  4
[torch.FloatTensor of size 2x2]

Variable containing:
 1  2
 3  4
[torch.FloatTensor of size 2x2]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算x^2的均值</span></div><div class="line">tensor_mean = torch.mean(tensor * tensor)</div><div class="line">variable_mean = torch.mean(variable * variable)</div><div class="line"><span class="keyword">print</span> tensor_mean</div><div class="line"><span class="keyword">print</span> variable_mean</div></pre></td></tr></table></figure>
<pre><code>7.5
Variable containing:
 7.5000
[torch.FloatTensor of size 1]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># variable进行反向传播</span></div><div class="line"><span class="comment"># 梯度计算如下：</span></div><div class="line"><span class="comment"># variable_mean = 1/4 * sum(variable * variable)</span></div><div class="line"><span class="comment"># d(variable_mean)/d(variable) = 1/4 * 2 * variable = 1/2 * variable</span></div><div class="line">variable_mean.backward()</div><div class="line"></div><div class="line"><span class="comment"># 输出variable中的梯度</span></div><div class="line"><span class="keyword">print</span> variable.grad</div></pre></td></tr></table></figure>
<pre><code>Variable containing:
 0.5000  1.0000
 1.5000  2.0000
[torch.FloatTensor of size 2x2]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># *表示逐元素点乘,不是矩阵乘法</span></div><div class="line"><span class="keyword">print</span> tensor * tensor</div><div class="line"><span class="keyword">print</span> variable * variable</div></pre></td></tr></table></figure>
<pre><code>  1   4
  9  16
[torch.FloatTensor of size 2x2]

Variable containing:
  1   4
  9  16
[torch.FloatTensor of size 2x2]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出variable中的data, data是tensor</span></div><div class="line"><span class="keyword">print</span> variable.data</div></pre></td></tr></table></figure>
<pre><code> 1  2
 3  4
[torch.FloatTensor of size 2x2]
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(二)——Variable
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Python性能优化</title>
    <link href="noahsnail.com/2017/09/18/2017-9-18-Python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>noahsnail.com/2017/09/18/2017-9-18-Python性能优化/</id>
    <published>2017-09-18T02:15:08.000Z</published>
    <updated>2017-09-18T10:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>Python使用非常方便、灵活，因此很受欢迎。但正因为如此，导致实现同一功能时，Python代码有很多写法，但不同的写法有不同的性能。因此写Python代码要有良好的习惯，多写高性能的代码。作者原来平常写Python代码也很随意，直到某天处理大量数据时半天看不到结果，究其原因，是Python代码的性能问题导致的。</p>
<h2 id="1-列表解析与列表重建"><a href="#1-列表解析与列表重建" class="headerlink" title="1. 列表解析与列表重建"></a>1. 列表解析与列表重建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">fr = open(<span class="string">'words.txt'</span>)</div><div class="line">t1 = time.time()</div><div class="line">word_list = fr.readlines()</div><div class="line">t2 = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'read file time: '</span>, t2 -t1</div><div class="line">fr.close()</div><div class="line"></div><div class="line"><span class="comment"># for循环构建列表</span></div><div class="line">keywords = []</div><div class="line">t1 = time.time()</div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_list:</div><div class="line">    word = word.strip()</div><div class="line">    keywords.append(word)</div><div class="line">t2 = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'for loop time: '</span>, t2 - t1</div><div class="line"></div><div class="line"><span class="comment"># 列表解析</span></div><div class="line">t3 = time.time()</div><div class="line">keywords = [word.strip() <span class="keyword">for</span> word <span class="keyword">in</span> word_list]</div><div class="line">t4 = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'list pars time: '</span>, t4 - t3</div><div class="line"></div><div class="line">fr = open(<span class="string">'words.txt'</span>)</div><div class="line">t5 = time.time()</div><div class="line">keywords = [word.strip() <span class="keyword">for</span> word <span class="keyword">in</span> fr.readlines()]</div><div class="line">t6 = time.time()</div><div class="line">fr.close()</div><div class="line"><span class="keyword">print</span> <span class="string">'read file and list parse time: '</span>, t6 - t5</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'list length: '</span>, len(word_list)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read file time:  0.0318450927734</div><div class="line">for loop time:  0.137716054916</div><div class="line">list pars time:  0.0910630226135</div><div class="line">read file and list parse time:  0.124923944473</div><div class="line">list length:  441669</div></pre></td></tr></table></figure>
<p>结论：本次测试中，列表解析时间是for循环时间的<code>2/3</code>。</p>
<h2 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">import time</div><div class="line"></div><div class="line">fr = open(&apos;words.txt&apos;)</div><div class="line">keywords = [word.strip() for word in fr.readlines()]</div><div class="line">fr.close()</div><div class="line"></div><div class="line"># 加号拼接字符串</div><div class="line">t1 = time.time()</div><div class="line">str1 = &apos;&apos;</div><div class="line">for word in keywords:</div><div class="line">    str1 += word</div><div class="line">t2 = time.time()</div><div class="line">print &apos;string concat time: &apos;, t2 - t1</div><div class="line"></div><div class="line"># join拼接字符串</div><div class="line">t1 = time.time()</div><div class="line">str2 = &apos;&apos;.join(keywords)</div><div class="line">t2 = time.time()</div><div class="line">print &apos;string join time: &apos;, t2 - t1</div><div class="line"></div><div class="line">print &apos;list length: &apos;, len(keywords)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string concat time:  0.0814869403839</div><div class="line">string join time:  0.0123951435089</div><div class="line">list length:  441669</div></pre></td></tr></table></figure>
<p>结论：本次测试中，<code>join</code>函数拼接字符串比<code>+=</code>拼接字符串快<code>6倍多</code>。</p>
<h2 id="3-range与xrange"><a href="#3-range与xrange" class="headerlink" title="3. range与xrange"></a>3. range与xrange</h2><ul>
<li>range</li>
</ul>
<p>python中range会直接生成一个list对象。</p>
<ul>
<li>xrange</li>
</ul>
<p>用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器，它的类型为<code>xrange</code>。在生成非常大的数字序列时，xrange不会马上开辟很大的一块内存空间。如果不是需要返回列表，则尽可能使用<code>xrange</code>。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">import time</div><div class="line"></div><div class="line">t1 = time.time()</div><div class="line">for i in range(1000000):</div><div class="line">    pass</div><div class="line">t2 = time.time()</div><div class="line">print &apos;range time: &apos;, t2 -t1</div><div class="line"></div><div class="line">t1 = time.time()</div><div class="line">for i in xrange(1000000):</div><div class="line">    pass</div><div class="line">t2 = time.time()</div><div class="line">print &apos;xrange time: &apos;, t2 -t1</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range time:  0.0680990219116</div><div class="line">xrange time:  0.0329170227051</div></pre></td></tr></table></figure>
<p>结论：本次测试中，<code>xrange</code>比<code>range</code>快一倍多。</p>
<h2 id="4-待续。"><a href="#4-待续。" class="headerlink" title="4. 待续。"></a>4. 待续。</h2>]]></content>
    
    <summary type="html">
    
      Python性能优化
    
    </summary>
    
      <category term="Python" scheme="noahsnail.com/categories/Python/"/>
    
    
      <category term="Python" scheme="noahsnail.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch基本用法(一)——Numpy，Torch对比</title>
    <link href="noahsnail.com/2017/09/18/2017-9-18-PyTorch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(%E4%B8%80)%E2%80%94%E2%80%94Numpy%EF%BC%8CTorch%E5%AF%B9%E6%AF%94/"/>
    <id>noahsnail.com/2017/09/18/2017-9-18-PyTorch基本用法(一)——Numpy，Torch对比/</id>
    <published>2017-09-18T01:08:35.000Z</published>
    <updated>2017-09-18T03:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是对比Torch与Numpy的一些操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># numpy的array与torch的tensor的转换</span></div><div class="line">np_data = np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>))</div><div class="line">torch_data = torch.from_numpy(np_data)</div><div class="line">tensor2array = torch_data.numpy() </div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'numpy data: '</span>, np_data</div><div class="line"><span class="keyword">print</span> <span class="string">'torch data: '</span>, torch_data</div><div class="line"><span class="keyword">print</span> <span class="string">'tensor2array: '</span>, tensor2array</div></pre></td></tr></table></figure>
<pre><code>numpy data:  [[0 1 2]
 [3 4 5]]
torch data:  
 0  1  2
 3  4  5
[torch.LongTensor of size 2x3]

tensor2array:  [[0 1 2]
 [3 4 5]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Tensor的文档：http://pytorch.org/docs/master/tensors.html</span></div><div class="line">data = [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">float_data = torch.FloatTensor(data)</div><div class="line"><span class="keyword">print</span> float_data</div></pre></td></tr></table></figure>
<pre><code>-2
-1
 0
 1
 2
[torch.FloatTensor of size 5]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># abs操作</span></div><div class="line"><span class="keyword">print</span> np.abs(data)</div><div class="line"><span class="keyword">print</span> torch.abs(float_data)</div></pre></td></tr></table></figure>
<pre><code>[2 1 0 1 2]

 2
 1
 0
 1
 2
[torch.FloatTensor of size 5]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sin操作</span></div><div class="line"><span class="keyword">print</span> np.sin(data)</div><div class="line"><span class="keyword">print</span> torch.sin(float_data)</div></pre></td></tr></table></figure>
<pre><code>[-0.90929743 -0.84147098  0.          0.84147098  0.90929743]

-0.9093
-0.8415
 0.0000
 0.8415
 0.9093
[torch.FloatTensor of size 5]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mean操作</span></div><div class="line"><span class="keyword">print</span> np.mean(data)</div><div class="line"><span class="keyword">print</span> torch.mean(float_data)</div></pre></td></tr></table></figure>
<pre><code>0.0
0.0
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 矩阵相乘</span></div><div class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</div><div class="line">tensor = torch.FloatTensor(data)</div><div class="line"></div><div class="line"><span class="keyword">print</span> np.matmul(data, data)</div><div class="line"><span class="comment"># torch.mm不支持广播形式</span></div><div class="line"><span class="keyword">print</span> torch.mm(tensor, tensor)</div><div class="line"><span class="comment"># torch.matmul支持广播形式</span></div><div class="line"><span class="keyword">print</span> torch.matmul(tensor, tensor)</div></pre></td></tr></table></figure>
<pre><code>[[ 7 10]
 [15 22]]

  7  10
 15  22
[torch.FloatTensor of size 2x2]


  7  10
 15  22
[torch.FloatTensor of size 2x2]
</code></pre>]]></content>
    
    <summary type="html">
    
      PyTorch基本用法(一)——Numpy，Torch对比
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习——第一课笔记(上)</title>
    <link href="noahsnail.com/2017/09/17/2017-9-17-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <id>noahsnail.com/2017/09/17/2017-9-17-动手学深度学习——第一课/</id>
    <published>2017-09-17T10:09:47.000Z</published>
    <updated>2017-09-17T14:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是学习李沐直播课程的笔记。视频及内容的具体地址可参考：<a href="https://zhuanlan.zhihu.com/p/29125290" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/29125290</a>。</p>
<h2 id="第一课：从上手到多类分类"><a href="#第一课：从上手到多类分类" class="headerlink" title="第一课：从上手到多类分类"></a>第一课：从上手到多类分类</h2><p>课程首先介绍了深度学习的很多应用：例如增强学习、物体识别、语音识别、机器翻译、推荐系统、广告点击预测等。</p>
<p>课程目的：通过动手实现来理解深度学习，跟工业界应用相比，主要只是数据规模和模型复杂度的区别。</p>
<p>深度学习的轮子很多，例如Caffe，TensorFlow，mxnet，PyTorch，CNTK等。它们之间的主要区别在于：1.便利的开发；2.方便的部署。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/chapter1_1.png" alt="Figure 1"></p>
<p>mxnet之上的一个package是Gluon，主要目的是一次解决开发和部署。课程主要分为以下三个部分：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/chapter1_2.png" alt="Figure 2"></p>
<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>我的配置环境是Mac，Linux平台类似。</p>
<p>mxnet安装命令如下，前提是已经安装好了Anaconda，Anaconda的安装可以参考官网：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mxnet</div></pre></td></tr></table></figure>
<p>测试mxnet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import mxnet</div><div class="line">&gt;&gt;&gt; print mxnet.__version__</div><div class="line">0.11.0</div></pre></td></tr></table></figure>
<p>然后安装notedown，运行Jupyter并加载notedown插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install https://github.com/mli/notedown/tarball/master</div><div class="line">jupyter notebook --NotebookApp.contents_manager_class=&apos;notedown.NotedownContentsManager&apos;</div></pre></td></tr></table></figure>
<p>通过ExecutionTime插件来对每个cell的运行计时，国内使用豆瓣源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pip install jupyter_contrib_nbextensions -i https://pypi.douban.com/simple</div><div class="line">jupyter contrib nbextension install --user</div><div class="line">jupyter nbextension enable execute_time/ExecuteTime</div></pre></td></tr></table></figure>
<h3 id="2-NDArray"><a href="#2-NDArray" class="headerlink" title="2. NDArray"></a>2. NDArray</h3><p>NDArray是MXNet储存和变换数据的主要工具，它与numpy非常类似。NDArray提供了CPU和GPU的异步计算，还提供了自动求导。NDArray的基本用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> ndarray <span class="keyword">as</span> nd</div><div class="line"></div><div class="line"><span class="comment"># 创建矩阵</span></div><div class="line">nd.zeros((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">x = nd.ones((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">nd.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]])</div><div class="line">y = nd.random_normal(<span class="number">0</span>, <span class="number">1</span>, shape=(<span class="number">3</span>, <span class="number">4</span>))</div><div class="line"></div><div class="line"><span class="comment"># 查看矩阵大小</span></div><div class="line">y.shape</div><div class="line"></div><div class="line"><span class="comment"># 查看矩阵元素个数</span></div><div class="line">y.size</div><div class="line"></div><div class="line"><span class="comment"># 矩阵加法</span></div><div class="line">x + y</div><div class="line"></div><div class="line"><span class="comment"># 矩阵乘法</span></div><div class="line">x * y</div><div class="line"></div><div class="line"><span class="comment"># 指数运算</span></div><div class="line">nd.exp(y)</div><div class="line"></div><div class="line"><span class="comment"># 矩阵乘法</span></div><div class="line">nd.dot(x, y.T)</div><div class="line"></div><div class="line"><span class="comment"># 广播操作</span></div><div class="line">a = nd.arange(<span class="number">3</span>).reshape((<span class="number">3</span>,<span class="number">1</span>))</div><div class="line">b = nd.arange(<span class="number">2</span>).reshape((<span class="number">1</span>,<span class="number">2</span>))</div><div class="line">print(<span class="string">'a:'</span>, a)</div><div class="line">print(<span class="string">'b:'</span>, b)</div><div class="line">print(<span class="string">'a+b:'</span>, a+b)</div><div class="line"></div><div class="line"><span class="comment"># NDArray与Numpy的转换</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">x = np.ones((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">y = nd.array(x)  <span class="comment"># numpy -&gt; mxnet</span></div><div class="line">z = y.asnumpy()  <span class="comment"># mxnet -&gt; numpy</span></div><div class="line">print([z, y])</div></pre></td></tr></table></figure>
<p>NDArray的自动求导：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> mxnet.ndarray <span class="keyword">as</span> nd</div><div class="line"><span class="keyword">import</span> mxnet.autograd <span class="keyword">as</span> ag</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义矩阵</span></div><div class="line">x = nd.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</div><div class="line"></div><div class="line"><span class="comment"># 添加自动求导</span></div><div class="line">x.attach_grad()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 记录x的变化</span></div><div class="line"><span class="keyword">with</span> ag.record():</div><div class="line">    y = x * <span class="number">2</span></div><div class="line">    z = y * x</div><div class="line"></div><div class="line"><span class="comment"># 求导</span></div><div class="line">z.backward()</div><div class="line"></div><div class="line"><span class="comment"># 判断导数是否相等</span></div><div class="line">x.grad == <span class="number">4</span>*x</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      动手学深度学习——第一课笔记(上)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Improving Deep Neural Networks学习笔记(一)</title>
    <link href="noahsnail.com/2017/09/16/2017-9-16-Improving%20Deep%20Neural%20Networks%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>noahsnail.com/2017/09/16/2017-9-16-Improving Deep Neural Networks学习笔记(一)/</id>
    <published>2017-09-16T01:21:06.000Z</published>
    <updated>2017-09-16T14:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Setting-up-your-Machine-Learning-Application"><a href="#1-Setting-up-your-Machine-Learning-Application" class="headerlink" title="1. Setting up your Machine Learning Application"></a>1. Setting up your Machine Learning Application</h2><h4 id="1-1-Train-Dev-Test-sets"><a href="#1-1-Train-Dev-Test-sets" class="headerlink" title="1.1 Train/Dev/Test sets"></a>1.1 Train/Dev/Test sets</h4><p>Make sure that the dev and test sets come from the same distribution。</p>
<p>Not having a test set might be okay.(Only dev set.)</p>
<p>So having set up a train dev and test set will allow you to integrate more quickly. It will also allow you to more efficiently measure the bias and variance of your algorithm, so you can more efficiently select ways to improve your algorithm.</p>
<h4 id="1-2-Bias-Variance"><a href="#1-2-Bias-Variance" class="headerlink" title="1.2 Bias/Variance"></a>1.2 Bias/Variance</h4><p>High Bias: underfitting<br>High Variance: overfitting</p>
<p>Assumption——human: 0% (Optimal/Bayes error), train set and dev set are drawn from the same distribution.</p>
<table>
<thead>
<tr>
<th>Train set error</th>
<th>Dev set error</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1%</td>
<td>11%</td>
<td>high variance</td>
</tr>
<tr>
<td>15%</td>
<td>16%</td>
<td>high bias</td>
</tr>
<tr>
<td>15%</td>
<td>30%</td>
<td>high bias and high variance</td>
</tr>
<tr>
<td>0.5%</td>
<td>1%</td>
<td>low bias and low variance</td>
</tr>
</tbody>
</table>
<h4 id="1-3-Basic-Recipe-for-Machine-Learning"><a href="#1-3-Basic-Recipe-for-Machine-Learning" class="headerlink" title="1.3 Basic Recipe for Machine Learning"></a>1.3 Basic Recipe for Machine Learning</h4><p>High bias –&gt; Bigger network, Training longer, Advanced optimization algorithms, Try different netword.</p>
<p>High variance –&gt; More data, Try regularization, Find a more appropriate neural network architecture.</p>
<h2 id="2-Regularizing-your-neural-network"><a href="#2-Regularizing-your-neural-network" class="headerlink" title="2. Regularizing your neural network"></a>2. Regularizing your neural network</h2><h4 id="2-1-Regularization"><a href="#2-1-Regularization" class="headerlink" title="2.1 Regularization"></a>2.1 Regularization</h4><p>In logistic regression, $$w \in R^{n_x}, b \in R$$$$J(w, b) = \frac {1} {m} \sum _{i=1} ^m L(\hat y^{(i)}, y^{(i)}) + \frac {\lambda} {2m} ||w||_2^2$$$$||w||_2^2 = \sum _{j=1} ^{n_x} w_j^2 = w^Tw$$<br>This is called L2 regularization.</p>
<p>$$J(w, b) = \frac {1} {m} \sum _{i=1} ^m L(\hat y^{(i)}, y^{(i)}) + \frac {\lambda} {2m} ||w||_1$$<br>This is called L1 regularization. <code>w</code> will end up being sparse. $\lambda$ is called regularization parameter.</p>
<p>In neural network, the formula is $$J(w^{[1]},b^{[1]},…,w^{[L]},b^{[L]}) = \frac {1} {m} \sum _{i=1} ^m L(\hat y^{(i)}, y^{(i)}) + \frac {\lambda} {2m} \sum _{l=1}^L ||w^{[l]}||^2$$$$||w^{[l]}||^2 = \sum_{i=1}^{n^{[l-1]}}\sum _{j=1}^{n^{[l]}} (w_{ij}^{[l]})^2, w:(n^{[l-1]}, n^{[l]})$$</p>
<p>This matrix norm, it turns out is called the <code>Frobenius Norm</code> of the matrix, denoted with a <code>F</code> in the subscript.</p>
<p>L2 norm regularization is also called <code>weight decay</code>.</p>
<h4 id="2-2-Why-regularization-reduces-overfitting"><a href="#2-2-Why-regularization-reduces-overfitting" class="headerlink" title="2.2 Why regularization reduces overfitting?"></a>2.2 Why regularization reduces overfitting?</h4><p>If $\lambda$ is set too large, matrices <code>W</code> is set to be reasonabley close to zero, and it will zero out the impact of these hidden units. And that’s the case, then this much simplified neural network becomes a much smaller neural network. It will take you from overfitting to underfitting, but there is a <code>just right case</code> in the middle.</p>
<h4 id="2-3-Dropout-regularization"><a href="#2-3-Dropout-regularization" class="headerlink" title="2.3 Dropout regularization"></a>2.3 Dropout regularization</h4><p>Dropout will go through each of the layers of the network, and set some probability of eliminating a node in neural network. By far the most common implementation of dropouts today is inverted dropouts.</p>
<p>Inverted dropout, <code>kp</code> stands for <code>keep-prob</code>:</p>
<p>$$z^{[i + 1]} = w^{[i + 1]} a^{[i]} + b^{[i + 1]}$$$$a^{[i]} = a^{[i]} / kp$$</p>
<p>In test phase, we don’t use dropout and <code>keep-prob</code>.</p>
<h4 id="2-4-Understanding-dropout"><a href="#2-4-Understanding-dropout" class="headerlink" title="2.4 Understanding dropout"></a>2.4 Understanding dropout</h4><p>Why does dropout workd? Intuition: Can’t rely on any one feature, so have to spread out weights.</p>
<p>By spreading all the weights, this will tend to have an effect of shrinking the squared norm of the weights.</p>
<h4 id="2-5-Other-regularization-methods"><a href="#2-5-Other-regularization-methods" class="headerlink" title="2.5 Other regularization methods"></a>2.5 Other regularization methods</h4><ul>
<li>Data augmentation.</li>
<li>Early stopping</li>
</ul>
<h2 id="3-Setting-up-your-optimization-problem"><a href="#3-Setting-up-your-optimization-problem" class="headerlink" title="3. Setting up your optimization problem"></a>3. Setting up your optimization problem</h2><h4 id="3-1-Normalizing-inputs"><a href="#3-1-Normalizing-inputs" class="headerlink" title="3.1 Normalizing inputs"></a>3.1 Normalizing inputs</h4><p>Normalizing inputs can speed up training. Normalizing inputs corresponds to two steps. The first is to subtract out or to zero out the mean. And then the second step is to normalize the variances.</p>
<h4 id="3-2-Vanishing-Exploding-gradients"><a href="#3-2-Vanishing-Exploding-gradients" class="headerlink" title="3.2 Vanishing/Exploding gradients"></a>3.2 Vanishing/Exploding gradients</h4><p>If the network is very deeper, deep network suffer from the problems of vanishing or exploding gradients.</p>
<h4 id="3-3-Weight-initialization-for-deep-networks"><a href="#3-3-Weight-initialization-for-deep-networks" class="headerlink" title="3.3 Weight initialization for deep networks"></a>3.3 Weight initialization for deep networks</h4><p>If activation function is <code>ReLU</code> or <code>tanh</code>, <code>w</code> initialization is: $$w^{[l]} = np.random.randn(shape) * np.sqrt(\frac {2} {n^{[l-1]}}).$$ This is called Xavier initalization. </p>
<p>Another formula is $$w^{[l]} = np.random.randn(shape) * np.sqrt(\frac {2} {n^{[l-1]} + n^{[l]}}).$$</p>
<h4 id="3-4-Numberical-approximation-of-gradients"><a href="#3-4-Numberical-approximation-of-gradients" class="headerlink" title="3.4 Numberical approximation of gradients"></a>3.4 Numberical approximation of gradients</h4><p>In order to build up to gradient checking, you need to numerically approximate computatiions of gradients.</p>
<p>$$g(\theta) \approx \frac {f(\theta + \epsilon) - f(\theta - \epsilon)} {2 \epsilon}$$</p>
<h4 id="3-5-Gradient-checking"><a href="#3-5-Gradient-checking" class="headerlink" title="3.5 Gradient checking"></a>3.5 Gradient checking</h4><p>Take matrix <code>W</code>, vector <code>b</code> and reshape them into vectors, and then concatenate them, you have a giant vector $\theta$. For each <code>i</code>:</p>
<p>$$d\theta _{approx}[i]= \frac {J(\theta_1,…,\theta_i + \epsilon,…)-J(\theta_1,…,\theta_i - \epsilon,…)} {2\epsilon} \approx d\theta_i=\frac {\partial J} {\partial \theta_i}$$</p>
<p>If $$\frac {||d\theta_{approx} - d\theta ||_2} {||d\theta_{approx}||_2 + ||\theta||_2} \approx 10^{-7}$$, that’s great. If $\approx 10^{-5}$, you need to do double check, if $\approx 10^{-5}$, there may be a bug.</p>
<h4 id="3-6-Gradient-checking-implementation-notes"><a href="#3-6-Gradient-checking-implementation-notes" class="headerlink" title="3.6 Gradient checking implementation notes"></a>3.6 Gradient checking implementation notes</h4><ul>
<li>Don’t use gradient check in training, only to debug.</li>
<li>If algorithm fails gradient check, look at components to try to identify bug.</li>
<li>Remember regularization.</li>
<li>Doesn’t work with dropout.</li>
<li>Run at random initialization; perhaps again after some training.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      Improving Deep Neural Networks学习笔记(一)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
