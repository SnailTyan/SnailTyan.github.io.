<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://noahsnail.com/"/>
  <updated>2022-06-09T09:27:38.564Z</updated>
  <id>http://noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>即时配送的订单分配策略：从建模和优化-笔记</title>
    <link href="http://noahsnail.com/2022/06/07/2022-06-07-%E5%8D%B3%E6%97%B6%E9%85%8D%E9%80%81%E7%9A%84%E8%AE%A2%E5%8D%95%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E4%BB%8E%E5%BB%BA%E6%A8%A1%E5%92%8C%E4%BC%98%E5%8C%96-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/07/2022-06-07-即时配送的订单分配策略-从建模和优化-笔记/</id>
    <published>2022-06-07T07:13:09.856Z</published>
    <updated>2022-06-09T09:27:38.564Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>外卖平台中，配送时效、准时率作为履约环节的重要指标，是外卖平台的核心竞争力之一。要提升用户的配送时效和准时率，最直接的方法是配备较多的配送员，扩大运力规模，然而这也意味着配送成本会很高。怎么在配送体验和配送成本之间取得最佳的平衡，是即时配送平台生存的根基和关键所在。在用户满意度持续提升的同时，降低配送成本、提高骑手满意度、驱动配送系统的自动化和智能化，是外卖配送团队要解决的难题。</p>
<p>Note:<br>招募更多的配送员，配送成本很高，应该想办法减少成本，即用更少的骑手配送更多的订单。</p>
<h2 id="2-即时配送智能调度系统"><a href="#2-即时配送智能调度系统" class="headerlink" title="2. 即时配送智能调度系统"></a>2. 即时配送智能调度系统</h2><p><strong>措施</strong></p>
<ol>
<li>首先通过优化设定配送费以及预计送达时间来调整订单结构；</li>
<li>在接收订单之后，考虑骑手位置、在途订单情况、骑手能力、商家出餐、交付难度、天气、地理路况、未来单量等因素，在正确的时间将订单分配给最合适的骑手，并在骑手执行过程中随时预判订单超时情况并动态触发改派操作，实现订单和骑手的动态最优匹配；</li>
<li>系统派单后，为骑手提示该商家的预计出餐时间和合理的配送线路，并通过语音方式和骑手实现高效交互；</li>
<li>在骑手送完订单后，系统根据订单需求预测和运力分布情况，告知骑手不同商圈的运力需求情况，实现闲时的运力调度。</li>
</ol>
<p><strong>结果</strong><br>通过上述技术和模式的引入，持续改善了用户体验和配送成本：</p>
<ol>
<li>订单的平均配送时长从2015年的41分钟，下降到32分钟，进一步缩短至28分钟；</li>
<li>另一方面，在骑手薪资稳步提升的前提下，单均配送成本也有了20%以上的缩减。</li>
</ol>
<p>Note:</p>
<ul>
<li>缩短配送时间，如果配送时间本来就很短，可以考虑稍微牺牲配送时间，提高其它指标</li>
<li>降低配送成本，在保证订单完成率的情况下减少配送骑手，骑手多单配送并行，减少每单配送成本</li>
</ul>
<h2 id="3-订单分配问题"><a href="#3-订单分配问题" class="headerlink" title="3. 订单分配问题"></a>3. 订单分配问题</h2><h3 id="3-1-订单分配的发展"><a href="#3-1-订单分配的发展" class="headerlink" title="3.1 订单分配的发展"></a>3.1 订单分配的发展</h3><p>外卖订单的分配问题一般可建模为带有若干复杂约束的DVRP（Dynamic Vehicle Routing Problem）问题。这类问题一般可表述为：有一定数量的骑手，每名骑手身上有若干订单正在配送过程中，在过去一段时间（如1分钟）内产生了一批新订单，已知骑手的行驶速度、任意两点间的行驶距离、每个订单的出餐时间和交付时间（骑手到达用户所在地之后将订单交付至用户所需的时间），那么如何将这批新订单在正确的时间分配至正确的骑手，使得用户体验得到保证的同时，骑手的配送效率最高。</p>
<p>订单和服务提供方的匹配问题是一个非常关键的问题。在外卖行业发展初期主要依赖骑手抢单模式和人工派单模式。</p>
<ul>
<li>抢单模式<br>抢单模式的优势是开发难度低，服务提供者（如司机、骑手）的自由度较高，可以按照自身的需要进行抢单，但其缺点也很明显：骑手/司机只考虑自身的场景需求，做出一个局部近优的选择，然而由于每个骑手掌握的信息有限又只从自身利益出发来决策，导致配送整体效率低下，从用户端来看，还存在大量订单无人抢或者抢了之后造成服务质量无法保证（因为部分骑手无法准确预判自己的配送服务能力）的场景，用户体验比较差。</li>
<li>人工派单模式<br>人工派单的方式，从订单分配的结果上来看，<strong>一般优于抢单模式</strong>。在订单量、骑手数相对比较少的情形下，有经验的调度员可以根据订单的属性特点、骑手的能力、骑手已接单情况、环境因素等，在骑手中逐个比对，根据若干经验规则挑选一个比较合适的骑手来配送。一般而言，人工调度一个订单往往至少需要半分钟左右的时间才能完成。然而，随着外卖订单规模的日益增长，在热门商圈（方圆3公里左右）的高峰时段，1分钟的时间内可能会有50单以上，在这种情况下，要求人工调度员每1-2秒钟做出一次合理的调度决策，显然是不可能的。另一方面，由于即时配送过程的复杂性，要做出合理的匹配决策，要求调度员对配送范围内各商家的出餐速度、各用户地址的配送难度（例如有的写字楼午高峰要等很长时间的电梯）、各骑手自身的配送工具/熟悉的商家和用户范围/工作习惯等等要有非常深入的了解，在此基础上具备统筹优化能力，考虑未来进单量、减少空驶等因素，做出全局近优的选择，这对人工调度员而言，又是一项极其艰巨的任务。</li>
</ul>
<p>系统派单具备如下优势：</p>
<ul>
<li>系统可以在全局层面上掌握和配送有关的骑手、商家、用户、订单等各类信息，在此基础上，可以做出全局较优的方案，从而提升配送效率和配送体验，减少配送成本； </li>
<li>显著减轻人工调度员的工作，从而降低人工成本，人工调度员只需要在一些意外场景（如配送员出现紧急情况无法继续配送等）发生的时候进行干预即可。</li>
</ul>
<p>Note:<br>派单模式与抢单模式并存，派单一般优于抢单</p>
<h3 id="3-2-即时配送大数据平台"><a href="#3-2-即时配送大数据平台" class="headerlink" title="3.2 即时配送大数据平台"></a>3.2 即时配送大数据平台</h3><p>美团外卖每天产生巨量的订单配送日志、行驶轨迹数据。通过对配送大数据进行分析、挖掘，会得到每个用户、楼宇、商家、骑手、地理区域的个性化信息，以及有关各地理区块骑行路径的有效数据，那么订单智能分配系统的目标就是基于大数据平台，根据订单的配送需求、地理环境以及每名骑手的个性化特点，实现订单与骑手的高效动态最优匹配，从而为每个用户和商家提供最佳的配送服务，并降低配送成本。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-238de0c6.png" alt="订单分配系统"></p>
<p>即时配送大数据平台实现对骑手轨迹数据、配送业务数据、特征数据、指标数据的全面管理和监控，并通过模型平台、特征平台支持相关算法策略的快速迭代和优化。</p>
<ul>
<li><strong>机器学习模块</strong>负责从数据中寻求规律和知识，例如对商家的出餐时间、到用户所在楼宇上下楼的时间、未来的订单、骑行速度、红绿灯耗时、骑行导航路径等因素进行准确预估，为调度决策提供准确的基础信息；</li>
<li><strong>运筹优化模块</strong>则在即时配送大数据平台以及机器学习的预测数据基础上，采用最优化理论、强化学习等优化策略进行计算，做出全局最优的分配决策，并和骑手高效互动，处理执行过程中的问题，实现动态最优化。</li>
</ul>
<h3 id="3-3-订单分配问题建模"><a href="#3-3-订单分配问题建模" class="headerlink" title="3.3 订单分配问题建模"></a>3.3 订单分配问题建模</h3><p>准确建模是实际决策优化项目的第一步，也是最关键的一步。准确建模，包括两个方面的问题：</p>
<ul>
<li>正确理解了实际业务场景的优化问题，并且通过某种形式化语言进行了准确描述；</li>
<li>建立的模型中，涉及的各类参数和数据，能够准确得获取。</li>
</ul>
<p>在上述两个前提下，采用相应的高效优化算法求解模型所得到的最优解，就是符合实际场景需求的最优决策方案。第一个问题，一般是通过业务调研、分析并结合建模工具来得到；而解决第二个问题，则更多地需要依赖数据分析、机器学习、数据挖掘技术结合领域知识，对模型进行精确的量化表达。</p>
<p>一个决策优化问题的数学模型，一般包括三个要素：</p>
<ul>
<li>决策变量，决策变量说明了希望算法来帮助做哪些决策</li>
<li>优化目标，优化目标则是指通过调整决策变量，使得哪些指标得到优化</li>
<li>约束条件，约束条件则是在优化决策的过程中所考虑的各类限制性因素</li>
</ul>
<p>即时配送场景下的订单分配问题，符号定义：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-019f9815.png" alt="符号定义"></p>
<p>在即时配送调度场景下，决策变量包括各个订单需要分配的骑手，以及骑手的建议行驶路线：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c9a81df3.png" alt="决策变量"></p>
<p>优化目标一般包括希望用户的单均配送时长尽量短、骑手付出的劳动尽量少、超时率尽量低等。可表述为：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d418f611.png" alt="优化目标"></p>
<p>实际场景下的订单分配问题，设置目标函数是一个较为复杂的问题。</p>
<ol>
<li>该优化问题是多目标的，且各个目标在不同时段、不同环境下会有差别。</li>
<li>缺乏有助于量化优化目标的数据。针对该难题，首先通过深入调研业务痛点和目标，在此基础上，采用机理和数据相结合的办法，由人工设定目标函数的结构，通过仿真系统和实际数据去设定目标函数的参数，来确定最终采用的目标函数形态。</li>
</ol>
<p>即时配送调度问题的约束条件类型：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-a47cd4c2.png" alt="约束条件类型"></p>
<p>除了以上约束外，有时还需要考虑部分订单只能由具备某些特点的骑手来配送、载具的容量限制等。</p>
<p>Note:<br>载具容量限制，订单类型要求订单只能单独配送，不能与其它订单混合在一起。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d2ce29cb.png" alt="建模"></p>
<p>以上只是针对给定的一批订单进行匹配决策的优化问题在建模时所需考虑的部分因素。在外卖配送场景中，希望的不是单次决策的最优，而是策略在一段时间应用后的累积收益最大。不追求某一个订单的指派是最优的，而是希望一天下来，所有的订单指派结果整体上是全局最优的。在进行决策的时候，既需要考虑已确定的订单，还需要考虑未来的尚未确定的订单。运筹优化领域中的马尔可夫决策过程描述的就是这样的一类在不确定、信息不完备环境下的序贯决策优化问题。</p>
<p>Note:<br>最简单的方法是贪心，追求当前订单最优指派，实现简单，但可能不是全局最优的。追求全局最优复杂，不一定比局部最优好，只有全局最优明显优于局部最优时，才值得上。</p>
<p>即时配送订单分配场景下的数据包括两类：</p>
<ul>
<li>直接通过业务系统采集可获取的数据，例如订单数据、骑手负载数据、骑手状态数据等。</li>
<li>无法直接采集得到，需要预测或统计才能获取的数据，如商户出餐时间、用户驻留时间（骑手到达用户处将订单交付给用户的时间）、骑手配送能力等。</li>
</ul>
<p>第一类数据的获取一般由业务系统、骑手端App直接给出，其精度通过提升工程质量或操作规范可有效保证；而第二类数据的获取是即时配送调度的关键难点之一。</p>
<p>在订单的配送过程中，骑手在商家、用户处的取餐和交付时间会占到整个订单配送时长的一半以上。商家出餐时间的长短，跟品类、时段、天气等因素都有关，而交付时间更为复杂，用户在几楼，是否处于午高峰时段，有没有电梯等等，都会影响骑手交付订单给用户的时间。为解决这些问题，利用机器学习工具，利用历史的骑手到店、等餐、取餐的数据，并充分考虑天气等外部因素的影响，建立全面反映出餐能力的预测模型，并通过实时维度的特征进行修正，可以得到准确的出餐/交付时间估计。</p>
<p>Note:<br>骑手在路上的时间比较简单，也比较好估计，就是距离/骑手速度。但等餐、取餐时间，用户交付时间涉及的因素比较多，也比较杂。例如商户的订单积压情况，用户的楼层、电梯情况等。这也是将配送时间分成多段预测的原因之一。整体预测可能偏差较大，分成几部分，其中一部分的时间可以更准确的预测。</p>
<p>优化算法的作用则是在构建的解空间里找到最优的策略。配送调度问题属于典型的NP-Hard优化问题，解空间巨大。如何设计好的优化算法，从庞大的解空间中搜索得到一个满意解是一个很大的挑战，即时配送对于优化算法的另一个要求是高实时性。</p>
<p>针对此难题，采用了两个关键思路。一是问题特征分析。针对配送调度的场景，这个问题可以被分解为两个层次：骑手路径优化和订单分配方案的优化。骑手路径优化问题要解决的问题是：在新订单分配至骑手后，确定骑手的最佳配送线路；而订单分配优化问题要解决的问题是：把一批订单分配至相应的骑手，使得关注的指标（如配送时长、准时率、骑手的行驶距离等）达到最优。这两个问题的关系是：通过订单分配优化算法进行初始的订单分配，然后通过骑手路径优化算法获取各骑手的最佳行驶路线，进而，订单分配优化算法根据骑手路径优化结果调整分配方案。这两个层次不断反复迭代，最终获得比较满意的解。第二个思路是跨学科结合。订单分配问题在业内有两类方法，第一类方法是把订单分配问题转换成图论中的二分图匹配问题来解决。这种做法是一个不错的近似方案，优点是实现简单计算速度快，但它的缺点是会损失一部分满意解。第二类方法是直接采用个性化的算法进行订单分配方案的优化，优点是不损失获得满意解的可能性，但实际做起来难度较大。结合领域知识、优化算法、机器学习策略以及相关图论算法，基于分解协调思想，设计了骑手路径优化算法和订单分配优化算法。进一步，利用强化学习的思想，引入了离线学习和在线优化相结合的机制，离线学习得到策略模型，在线通过策略迭代，不断寻求更优解。通过不断地改进算法，在耗时下降的同时，算法的优化效果提升50%以上。为了有效降低算法运行时间，对优化算法进行并行化，并利用并行计算集群进行快速处理。</p>
<p>Note:<br>批量分配算法，二分图匹配问题，简单速度快，第2种需要集群。</p>
<p>即时配送过程的一个突出特点是线下的突发因素多、影响大，突发事件造成的一个恶劣结果是，虽然在指派订单的时刻，所指派的骑手是合理的，然而过了一段时间之后，由于骑手、订单等状态发生了变化，会变得不够合理。现有方法主要通过人工来完成，即：配送站长/调度员在配送信息系统里，查看各个骑手的位置、手中订单的状态及商户/用户的位置/期望送达时间等信息，同时接听骑手的电话改派请求，在此基础上，分析哪些订单应该改派，以及应该改派给哪位骑手，并执行操作。</p>
<p>Note:<br>突发事件需要人工介入(2017年)。</p>
<p>针对即时配送的不确定性特点，提出了两点创新：一是延迟调度策略，即在某些场景订单可以不被指派出去，在不影响订单超时的情况下，延迟做出决策；二是系统自动改派策略，即订单即便已经派给了骑手，后台的智能算法仍然会实时评估各个骑手的位置、订单情况，并帮助骑手进行分析，判断是否存在超时风险。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-7612e7e6.png" alt="随机性应对"></p>
<p>针对即时配送场景，建立了相应的仿真模型，开发了配送仿真系统。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-2d610033.png" alt="仿真系统"></p>
<p>Note:<br>算法需要在仿真系统上进行测试，调整。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2017/10/11/o2o-intelligent-distribution.html" target="_blank" rel="external">即时配送的订单分配策略：从建模和优化</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      即时配送的订单分配策略：从建模和优化-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>美团智能配送系统的运筹优化实战-笔记</title>
    <link href="http://noahsnail.com/2022/06/07/2022-06-07-%E7%BE%8E%E5%9B%A2%E6%99%BA%E8%83%BD%E9%85%8D%E9%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/07/2022-06-07-美团智能配送系统的运筹优化实战-笔记/</id>
    <published>2022-06-07T01:29:46.250Z</published>
    <updated>2022-06-09T09:27:39.916Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-美团智能配送系统架构"><a href="#1-美团智能配送系统架构" class="headerlink" title="1. 美团智能配送系统架构"></a>1. 美团智能配送系统架构</h2><p>美团配送业务场景复杂，单量规模大。在大规模的业务场景下，配送智能化就变得非常重要，而智能配送的核心就是做资源的优化配置。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-4d342ea038cfd9edcb3a741f247057df199909.png" alt="资源优化配置"></p>
<p>外卖配送既有线上的业务，也有线下的复杂运营。配送连接订单需求和运力供给。为了达到需求和供给的平衡，不仅要在线下运营商家、运营骑手，还要在线上将这些需求和运力供给做合理的配置，其目的是提高整体的效率。只有将配送效率最大化，才能带来良好的顾客体验，实现较低的配送成本。资源优化配置的过程，实际上是有分层的。在美团的理解中，可以分为三层：</p>
<ol>
<li>基础层是结构优化，它直接决定了配送系统效率的上限。这种基础结构的优化，周期比较长，频率比较低，包括配送网络规划、运力结构规划等等。</li>
<li>中间层是市场调节，相对来说是中短期的，主要通过定价或者营销手段，使供需达到一个相对理想的平衡状态。</li>
<li>再上层是实时匹配，通过调度做实时的资源最优匹配。 实时匹配的频率是最高的，决策的周期也最短。</li>
</ol>
<p>Note:</p>
<ul>
<li>基础层：例如调整运力，周期较长，频率较低，运力调整需要考虑的因素较多</li>
<li>中间层：动态定价，营销活动等，可以提前预估一定时间范围内的单量和运力，提前进行运力调度或动态定价</li>
<li>更高层：骑手的实时调度、实时订单分配</li>
</ul>
<p><img src="http://noahsnail.com/images/meituan/meituan-4d342ea038cfd9edcb3a741f247057df199909.png" alt="智能配送系统架构"></p>
<p>如上图所示，右边三个子系统分别对应这三层体系，最底层是规划系统，中间层是定价系统，最上层是调度系统。运筹优化是调度系统、定价系统、规划系统的核心技术。</p>
<p>Note:</p>
<ul>
<li>机器学习系统：例如ETA预估</li>
<li>调度系统：根据订单进行骑手的分配</li>
<li>LBS系统：路径规划</li>
<li>定价系统：根据时间、天气、运力情况进行动态定价</li>
<li>规划系统：可以使用行政区域划分，在此基础上再进行调整</li>
</ul>
<h2 id="2-实战业务项目"><a href="#2-实战业务项目" class="headerlink" title="2. 实战业务项目"></a>2. 实战业务项目</h2><h3 id="2-1-智能区域规划"><a href="#2-1-智能区域规划" class="headerlink" title="2.1 智能区域规划"></a>2.1 智能区域规划</h3><p><img src="http://noahsnail.com/images/meituan/meituan-357307a272f9223942b98515c2934ea7462635.png" alt="配送网络基本概念"></p>
<p>配送连接的是商家、顾客、骑手三方，配送网络决定了这三方的连接关系。当用户打开App，查看哪些商家可以点餐，这由<strong>商家配送范围</strong>决定，每个商家的配送范围不一样。用户在美团点外卖，为他服务的骑手是谁呢？又是怎么确定的呢？这些是由<strong>配送区域边界</strong>来决定的，配送区域边界指的是一些商家集合所对应的范围。</p>
<p>Note:</p>
<ul>
<li>商家：商家配送范围</li>
<li>骑手：配送区域边界</li>
</ul>
<p>在传统物流中，影响末端配送效率最关键的点，是配送员对他所负责区域的熟悉程度。越熟悉，配送效率就会越高。即时配送场景也类似，每个骑手需要尽量固定地去熟悉一片商家或者配送区域。对于管理而言，站点的管理范围也比较明确。如果有新商家上线，也很容易确定由哪个配送站来提供服务。所以，这个问题有很多运营管理的诉求在其中。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-08860973ff368a440b77ddbd16d07eb5994870.png" alt="区域规划影响配送效率"></p>
<p>区域规划项目要解决的问题：1.配送区域里的商家不聚合；2.区域奇形怪状，空驶严重；3.站点的大小不合理。什么是好的区域规划方案？基于统计分析的优化目标设定。</p>
<p>优化的三要素是：目标、约束、决策变量。</p>
<ol>
<li>首先要确定优化目标。区域规划影响的主要是骑手的顺路性、空驶率，也就是骑手平均为每一单付出的路程成本。所以，将问题的业务目标定为优化骑手的单均行驶距离。基于现有的大量区域和站点积累的数据，做大量的统计分析后，可以定义出这样几个指标：商家聚合度、订单的聚合度、订单重心和商家重心的偏离程度。数据分析结果说明，这几个指标和单均行驶距离的相关性很强。经过这一层的建模转化，问题明确为优化这三个指标。</li>
<li>梳理业务约束。区域单量有上限和下限；区域之间不能有重合，不能有商家归多个区域负责；所有的AOI(area of interest)不能有遗漏，都要被某个区域覆盖到，不能出现商家没有站点的服务；区域边界必须沿路网。</li>
</ol>
<p>在目标和约束条件确定了之后，整体技术方案分成三部分：</p>
<ol>
<li>首先，根据三个目标函数，确定商家最优集合。</li>
<li>配送团队和美团地图团队进行合作。先利用路网信息，把城市切成若干互不重叠的多边形，然后根据计算几何，将一批商家对应的多边形拼成完整的区域边界。</li>
<li>最后，用美团自主研发的配送仿真系统进行仿真评测。</li>
</ol>
<p>在区域规划过程中，人工介入还是非常必要的。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c0b3063d64e2d96176ad35dfe6bd3e03819986.png" alt="落地应用"></p>
<h3 id="2-2-智能骑手排班"><a href="#2-2-智能骑手排班" class="headerlink" title="2.2 智能骑手排班"></a>2.2 智能骑手排班</h3><p><img src="http://noahsnail.com/images/meituan/meituan-e5f5eff5a89854c0bbf6c67ea3873140188458.png" alt="外卖订单"></p>
<p>外卖配送场景的订单“峰谷效应”非常明显。上图是一个实际的进单曲线。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d1992cc627da30c9647319e10296a3c7106485.png" alt="排班方案选型"></p>
<p>配送团队最终选用的是按组排班的方式，把所有骑手分成几组，规定每个组的开工时段。然后大家可以按组轮岗，每个人的每个班次都会轮到。算法要有自己的优化目标，为了解决这个问题，首先要做设计决策变量，把时间做了离散化，以半小时为粒度。对于一天来讲，只有48个时间单元，决策空间大幅缩减。然后，目标定为运力需求满足订单量的时间单元最多。在建模层面，标准化和通用的模型才是最优选。美团把人数做了归一化，算法分配每个班次的骑手比例，但不分人数。在算法决策的时候，不决策人数、只决策比例，这样也可以把单量进行归一化。每个时间单元的进单量除以每天峰值时间单元的单量，也变成了0~1之间的数字。如果某个时间单元内人数比例大于单量比例，叫作运力得到满足。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-9b22391d9f14336717e2f4a032ae0114152458.png" alt="决策变量及目标设计"></p>
<p>算法核心思想：基于约束条件，根据启发式算法构造初始方案，再用局部搜索迭代优化。</p>
<h3 id="2-3-骑手路径规划"><a href="#2-3-骑手路径规划" class="headerlink" title="2.3 骑手路径规划"></a>2.3 骑手路径规划</h3><p>骑手的路径规划问题，不是简单的路线规划，一个骑手身上有很多配送任务，这些配送任务存在各种约束，怎样选择最优配送顺序去完成所有任务，这是一个NP难问题。当有5个订单、10个任务点的时候，就存在11万多条可能的顺序。系统派单、系统改派，都依赖路径规划算法。在骑手端，给每个骑手推荐任务执行顺序。路径规划算法核心的诉求是优化效果必须是稳定的好。不能这次的优化结果好，下次就不好。另外，运行时间一定要短。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c65652c6f08d6c73770e9de9288a348b154474.png" alt="核心设计思想"></p>
<p>求解路径规划这类问题经历过的阶段：起初，采用类似遗传算法的迭代搜索算法，但是随着业务的单量变大，发现算法耗时太慢，根本不可接受。然后，改为大规模邻域搜索算法，但算法依然有很强的随机性，因为没有随机性在就没办法得到比较好的解。而这种基于随机迭代的搜索策略，带来很强的不确定性，在问题规模大的场景会出现非常多的Bad Case。另外，迭代搜索耗时太长了。在这个项目中，基本可以确定这样的技术路线。首先，只能做启发式定向搜索，不能在算法中加随机扰动。不能允许同样的输入在不同运行时刻给出不一样的优化结果。然后，不能用普通迭代搜索，必须把这个问题结构特性挖掘出来，做基于知识的定制化搜索。</p>
<p>美团认为，最重要的是看待这个问题的视角。这里的路径规划问题，对应的经典问题模型，是开环TSP问题，或是开环VRP的变种么？可以是，也可以不是。美团做了一个有意思的建模转换，把它看作流水线调度问题：每个订单可以认为是job；一个订单的两个任务取餐和送餐，可以认为是一个job的operation。任意两个任务点之间的通行时间，可以认为是序列相关的准备时间。每一单承诺的送达时间，包括预订单和即时单，可以映射到流水线调度问题中的提前和拖期惩罚上。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-325594bc4c7e9dde88c0c05ac8723ac2138345.png" alt="问题建模转换"></p>
<p>美团把一个经典的基于问题特征的启发式算法做了适当适配和改进，得到了非常好的效果。相比于之前的算法，耗时下降70%，优化效果不错。</p>
<h3 id="2-4-订单智能调度"><a href="#2-4-订单智能调度" class="headerlink" title="2.4 订单智能调度"></a>2.4 订单智能调度</h3><p>配送调度场景，可以用数学语言描述。它不仅是一个业务问题，更是一个标准的组合优化问题，并且是一个马尔可夫决策过程。并非对于某个时刻的一批订单做最优分配就足够，还需要考虑整个时间窗维度，每一次指派对后面的影响。要考虑长周期的优化，而不是一个静态优化问题。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-30e6df539239ed15cb77f5e67fec4d69454401.png" alt="调度问题的数学描述"></p>
<p>这个问题的挑战：</p>
<ol>
<li>性能要求极高，要做到万单对万人的秒级求解。</li>
<li>动态性。作为一个MDP问题，需要考虑动态优化场景，这涉及大量的预估环节。目前的思路，是通过其它的建模转换手段进行解决。</li>
<li>配送业务的随机因素多。比如商家的出餐时间，也许是很长时间内都无法解决的随机性。就连历史每一个已完成订单，商家出餐时间的真值都很难获得。商家出餐时刻不确定，这个随机因素永远存在，并且非常制约配送效率的提升。另外，在顾客位置交付的时间也不确定。写字楼工作日的午高峰，上电梯、下电梯的时间，很难准确进行预估。对于骑手来说，平台没法规定每个骑手的任务执行顺序。骑手在配送过程中可以自由发挥，所以骑手执行顺序的不确定性也一直存在。</li>
</ol>
<p><img src="http://noahsnail.com/images/meituan/meituan-e89cfca4ff8c3881050a9016298a5542134543.png" alt="问题挑战"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2020/02/20/meituan-delivery-operations-research.html" target="_blank" rel="external">美团智能配送系统的运筹优化实战</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      美团智能配送系统的运筹优化实战
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1528. Shuffle String</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1528-Shuffle-String/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1528-Shuffle-String/</id>
    <published>2022-05-07T06:17:12.453Z</published>
    <updated>2022-05-07T06:37:40.666Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Shuffle_String.png" alt="Shuffle String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，根据要求，按顺序将字母填到对应位置即可。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></div><div class="line">        res = [<span class="string">'0'</span>] * len(s)</div><div class="line">        <span class="keyword">for</span> index, pos <span class="keyword">in</span> enumerate(indices):</div><div class="line">            res[pos] = s[index]</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/shuffle-string/" target="_blank" rel="external">https://leetcode.com/problems/shuffle-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1528. Shuffle String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1323. Maximum 69 Number</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1323-Maximum-69-Number/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1323-Maximum-69-Number/</id>
    <published>2022-05-07T05:49:40.505Z</published>
    <updated>2022-05-07T06:01:26.099Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_69_Number.png" alt="Maximum 69 Number"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，从左到右，找到第一个<code>6</code>，将其改为<code>9</code>，返回更改之后的数字。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> <span class="params">(self, num: int)</span> -&gt; int:</span></div><div class="line">        digits = list(str(num))</div><div class="line">        <span class="keyword">for</span> index, digit <span class="keyword">in</span> enumerate(digits):</div><div class="line">            <span class="keyword">if</span> digit == <span class="string">'6'</span>:</div><div class="line">                digits[index] = <span class="string">'9'</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(digits))</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> <span class="params">(self, num: int)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> int(str(num).replace(<span class="string">'6'</span>, <span class="string">'9'</span>, <span class="number">1</span>))</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-69-number/" target="_blank" rel="external">https://leetcode.com/problems/maximum-69-number/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1323. Maximum 69 Number
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 2078. Two Furthest Houses With Different Colors</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2078-Two-Furthest-Houses-With-Different-Colors/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2078-Two-Furthest-Houses-With-Different-Colors/</id>
    <published>2022-05-07T03:08:03.317Z</published>
    <updated>2022-05-07T05:41:37.983Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Two_Furthest_Houses_With_Different_Colors.png" alt="Two Furthest Houses With Different Colors"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> colors[i] != colors[j]:</div><div class="line">                    distance = max(distance, j - i)</div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，贪心算法，从右往左找与左边第一个不同颜色的房子，从左往右找与右边第一个不同颜色的房子，取距离最大的一个，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> colors[i] != colors[<span class="number">0</span>]:</div><div class="line">                distance = max(distance, i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> colors[i] != colors[length - <span class="number">1</span>]:</div><div class="line">                distance = max(distance, length - <span class="number">1</span> - i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 3，Version 2的另一个版本，通过一次循环完成，O(N)。</p>
<ul>
<li>Version 3</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> index, color <span class="keyword">in</span> enumerate(colors):</div><div class="line">            <span class="keyword">if</span> color != colors[<span class="number">0</span>]:</div><div class="line">                distance = max(distance, index)</div><div class="line">            <span class="keyword">if</span> color != colors[length<span class="number">-1</span>]:</div><div class="line">                distance = max(distance, length - <span class="number">1</span> - index)</div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/two-furthest-houses-with-different-colors/" target="_blank" rel="external">https://leetcode.com/problems/two-furthest-houses-with-different-colors/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 2078. Two Furthest Houses With Different Colors
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 2016. Maximum Difference Between Increasing Elements</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2016-Maximum-Difference-Between-Increasing-Elements/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2016-Maximum-Difference-Between-Increasing-Elements/</id>
    <published>2022-05-07T01:31:35.994Z</published>
    <updated>2022-05-07T05:40:43.075Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Difference_Between_Increasing_Elements.png" alt="Maximum Difference Between Increasing Elements"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        length = len(nums)</div><div class="line">        diff = <span class="number">-1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</div><div class="line">                    diff = max(diff, nums[j] - nums[i])</div><div class="line">        <span class="keyword">return</span> diff</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，从左向右遍历，<code>minimum</code>始终保持左半部分最小值，如果当前数字<code>num</code>比<code>minimum</code>大，求二者的<code>difference</code>，取<code>difference</code>最大值，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        length = len(nums)</div><div class="line">        diff = <span class="number">-1</span></div><div class="line">        minimum = nums[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            <span class="keyword">if</span> num &gt; minimum:</div><div class="line">                diff = max(diff, num - minimum)</div><div class="line">            minimum = min(minimum, num)</div><div class="line">        <span class="keyword">return</span> diff</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-difference-between-increasing-elements/" target="_blank" rel="external">https://leetcode.com/problems/maximum-difference-between-increasing-elements/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 2016. Maximum Difference Between Increasing Elements
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1464. Maximum Product of Two Elements in an Array</title>
    <link href="http://noahsnail.com/2022/05/05/2022-05-05-Leetcode-1464-Maximum-Product-of-Two-Elements-in-an-Array/"/>
    <id>http://noahsnail.com/2022/05/05/2022-05-05-Leetcode-1464-Maximum-Product-of-Two-Elements-in-an-Array/</id>
    <published>2022-05-05T03:31:45.599Z</published>
    <updated>2022-05-07T05:40:46.498Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Product_of_Two_Elements_in_an_Array.png" alt="Maximum Product of Two Elements in an Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        product = <span class="number">0</span></div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                product = max(product, (nums[i] - <span class="number">1</span>) * (nums[j] - <span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> product</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，找到数组里最大的两个元素即可，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        x1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        x2 = min(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">2</span>:]:</div><div class="line">            <span class="keyword">if</span> num &gt;= x1:</div><div class="line">                x2 = x1</div><div class="line">                x1 = num</div><div class="line">            <span class="keyword">elif</span> num &gt; x2:</div><div class="line">                x2 = num</div><div class="line">        product = (x1 - <span class="number">1</span>) * (x2 - <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> product</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="external">https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1464. Maximum Product of Two Elements in an Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1031. Maximum Sum of Two Non-Overlapping Subarrays</title>
    <link href="http://noahsnail.com/2021/09/02/2021-09-02-Leetcode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/"/>
    <id>http://noahsnail.com/2021/09/02/2021-09-02-Leetcode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/</id>
    <published>2021-09-02T06:31:49.035Z</published>
    <updated>2021-09-02T08:30:27.403Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Sum_of_Two_Non-Overlapping_Subarrays.png" alt="Maximum Sum of Two Non-Overlapping Subarrays"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，先分别计算两个数组对应长度的连续子数组和，然后枚举所有符合条件的可能组合，找出最大和。Version 2使用前缀和，遍历前缀和，分别假设第一个子数组和在前和第二个子数组在前，求其最大值，即<code>first</code>和<code>second</code>，求第一个子数组的前缀和与当前的第二个子数组前缀和、第二个子数组的前缀和与当前的第一个子数组前缀和、之前最大和之间的最大值。为了便于计算以及索引校正，前缀和数组长度加<code>1</code>，初始值为<code>0</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, nums: List[int], firstLen: int, secondLen: int)</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        sum1 = <span class="number">0</span></div><div class="line">        sum2 = <span class="number">0</span></div><div class="line">        first = []</div><div class="line">        second = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> i &lt; firstLen:</div><div class="line">                sum1 += nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                first.append(sum1)</div><div class="line">                sum1 = sum1 + nums[i] - nums[i - firstLen]</div><div class="line">            <span class="keyword">if</span> i &lt; secondLen:</div><div class="line">                sum2 += nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                second.append(sum2)</div><div class="line">                sum2 = sum2 + nums[i] - nums[i - secondLen]</div><div class="line">        first.append(sum1)</div><div class="line">        second.append(sum2)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(first)):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + firstLen, len(second)):</div><div class="line">                maximum = max(maximum, first[i] + second[j])</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(second)):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j + secondLen, len(first)):</div><div class="line">                maximum = max(maximum, first[i] + second[j])</div><div class="line">        <span class="keyword">return</span> maximum</div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, nums: List[int], firstLen: int, secondLen: int)</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        prefix = [<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            prefix.append(prefix[<span class="number">-1</span>] + nums[i])</div><div class="line">        first = <span class="number">0</span></div><div class="line">        second = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(firstLen + secondLen, len(prefix)):</div><div class="line">            first = max(first, prefix[i - secondLen] - prefix[i - firstLen - secondLen])</div><div class="line">            second = max(second, prefix[i - firstLen] - prefix[i - firstLen - secondLen])</div><div class="line">            maximum = max(maximum, prefix[i] - prefix[i - secondLen] + first, prefix[i] - prefix[i - firstLen] + second)</div><div class="line">        <span class="keyword">return</span> maximum</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/" target="_blank" rel="external">https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1031. Maximum Sum of Two Non-Overlapping Subarrays
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1512. Number of Good Pairs</title>
    <link href="http://noahsnail.com/2021/08/31/2021-08-31-Leetcode-1512-Number-of-Good-Pairs/"/>
    <id>http://noahsnail.com/2021/08/31/2021-08-31-Leetcode-1512-Number-of-Good-Pairs/</id>
    <published>2021-08-31T03:01:57.066Z</published>
    <updated>2021-09-02T00:52:13.191Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Number_of_Good_Pairs.png" alt="Number of Good Pairs"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，最容易想到的就是统计重复元素的个数，然后在此基础上进行数值对的统计，注意一个数只能构成<code>0</code>对，两个数只能构成<code>1</code>对，累加时应从<code>0</code>累加到<code>n-1</code>，<code>n</code>是重复元素的个数。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        stat = collections.defaultdict(int)</div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            count += stat[num]</div><div class="line">            stat[num] += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/number-of-good-pairs/" target="_blank" rel="external">https://leetcode.com/problems/number-of-good-pairs/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1512. Number of Good Pairs
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 459. Repeated Substring Pattern</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-459-Repeated-Substring-Pattern/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-459-Repeated-Substring-Pattern/</id>
    <published>2021-08-30T08:49:45.689Z</published>
    <updated>2021-08-31T03:08:02.645Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Repeated_Substring_Pattern.png" alt="Repeated Substring Pattern"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，字符串是子串的重复，则字符串的结尾字符为子串的结尾字符，且至少存在两个重复的子串，因此寻找子串时，阈值应为<code>n // 2</code>，找到与结尾字符相等的字符，设开始到结尾字符的子串为候选子串，遍历<code>s</code>，其如果满足条件，返回<code>True</code>，如果始终没找到，返回<code>False</code>。Version 2进行了进一步优化，利用了重复子串的性质，即拆下第一部分放到末尾仍等于字符串<code>s</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s)</div><div class="line">        end = s[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</div><div class="line">            <span class="keyword">if</span> s[i] == end:</div><div class="line">                pattern = s[:i+<span class="number">1</span>]</div><div class="line">                flag = <span class="keyword">True</span></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s), len(pattern)):</div><div class="line">                    <span class="keyword">if</span> s[i:i+len(pattern)] != pattern:</div><div class="line">                        flag = <span class="keyword">False</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">if</span> flag:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s)</div><div class="line">        end = s[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</div><div class="line">            <span class="keyword">if</span> s[i] == end <span class="keyword">and</span> s == s[i+<span class="number">1</span>:] + s[:i+<span class="number">1</span>]:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/repeated-substring-pattern/" target="_blank" rel="external">https://leetcode.com/problems/repeated-substring-pattern/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 459. Repeated Substring Pattern
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 392. Is Subsequence</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-392-Is-Subsequence/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-392-Is-Subsequence/</id>
    <published>2021-08-30T05:17:27.507Z</published>
    <updated>2021-08-30T05:35:03.698Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Is_Subsequence.png" alt="Is Subsequence"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，依次比较字符串<code>s</code>和<code>t</code>中的字符。Version 2，为Leetcode 792做铺垫，先将<code>t</code>中的字符以及对应的索引保存到字典中，相同字符对应的索引构成一个有序序列，然后依次<code>s</code>中的每个字符，在<code>t</code>中查找其对应的字符索引位置，如果字符在<code>t</code>中不存在，直接返回<code>False</code>，<code>pre</code>表示单词中前一个字符在<code>t</code>中的索引位置，每次查找使用二分查找，如果返回的序列索引位置等于序列的长度，即<code>pre</code>位置之后的<code>t</code>中没找到对应的当前字符，则返回<code>False</code>，否则，更新<code>pre</code>为当前字符在<code>t</code>中的索引位置。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> j &lt; len(t):</div><div class="line">            <span class="keyword">if</span> s[i] == t[j]:</div><div class="line">                i += <span class="number">1</span></div><div class="line">                j += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i == len(s):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></div><div class="line">        stat = collections.defaultdict(list)</div><div class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(t):</div><div class="line">            stat[ch].append(i)</div><div class="line">        pre = <span class="number">-1</span></div><div class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stat:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            index = bisect.bisect(stat[ch], pre)</div><div class="line">            <span class="keyword">if</span> index == len(stat[ch]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pre = stat[ch][index]</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/is-subsequence/" target="_blank" rel="external">https://leetcode.com/problems/is-subsequence/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 392. Is Subsequence
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 792. Number of Matching Subsequences</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-792-Number-of-Matching-Subsequences/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-792-Number-of-Matching-Subsequences/</id>
    <published>2021-08-30T01:43:28.916Z</published>
    <updated>2021-08-30T05:23:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Number_of_Matching_Subsequences.png" alt="Number of Matching Subsequences"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，每个单词都与<code>s</code>进行遍历比较，超时。Version 2，先将<code>s</code>中的字符以及对应的索引保存到字典中，相同字符对应的索引构成一个有序序列，然后依次遍历每个单词的每个字符，在<code>s</code>中查找其对应的字符索引位置，如果字符在<code>s</code>中不存在，直接跳出循环，<code>pre</code>表示单词中前一个字符在<code>s</code>中的索引位置，每次查找使用二分查找，如果返回的序列索引位置等于序列的长度，即<code>pre</code>位置之后的<code>s</code>中没找到对应的当前字符，否则，更新<code>pre</code>为当前字符在<code>s</code>中的索引位置，<code>flag</code>表示是否满足条件，初始设为<code>True</code>，当不满足条件跳出循环时，设为<code>False</code>，每个单词根据<code>flag</code>的值来统计满足条件的单词个数。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        n = len(s)</div><div class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">            m = len(word)</div><div class="line">            <span class="keyword">if</span> m &gt; n:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            i = <span class="number">0</span></div><div class="line">            j = <span class="number">0</span></div><div class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</div><div class="line">                <span class="keyword">if</span> s[i] == word[j]:</div><div class="line">                    i += <span class="number">1</span></div><div class="line">                    j += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    i += <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> m - j - <span class="number">1</span> &gt; n - i - <span class="number">1</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> j == m:</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        stat = collections.defaultdict(list)</div><div class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</div><div class="line">            stat[ch].append(i)</div><div class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">            flag = <span class="keyword">True</span></div><div class="line">            pre = <span class="number">-1</span></div><div class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</div><div class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stat:</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                index = bisect.bisect(stat[ch], pre)</div><div class="line">                <span class="keyword">if</span> index == len(stat[ch]):</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pre = stat[ch][index]</div><div class="line">            <span class="keyword">if</span> flag:</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/number-of-matching-subsequences/" target="_blank" rel="external">https://leetcode.com/problems/number-of-matching-subsequences/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 792. Number of Matching Subsequences
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 567. Permutation in String</title>
    <link href="http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-567-Permutation-in-String/"/>
    <id>http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-567-Permutation-in-String/</id>
    <published>2021-08-27T06:56:30.160Z</published>
    <updated>2021-08-27T06:58:03.067Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Permutation_in_String.png" alt="Permutation in String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，此题与leetcode 438非常类似，思路是一样的。判断<code>s2</code>是否包含<code>s1</code>的变换，可以采用字典的方法，即每个字母的个数及类型相等。先统计字符串<code>s1</code>的字母个数并记录其长度在<code>stat</code>中，遍历字符串<code>s2</code>，如果字母在<code>stat</code>中，则将其记录到字典<code>subs</code>中，否则重置<code>subs</code>，当<code>subs[&#39;length&#39;] = stat[&#39;length&#39;]</code>时，比较二者是否相等，如果相等，直接返回<code>True</code>，否则，字符串继续遍历，为保证<code>subs</code>长度与<code>stat</code>长度一致，此时，<code>subs</code>中移除<code>s2[index - n + 1]</code>字符，同时长度减<code>1</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s1)</div><div class="line">        stat = collections.Counter(s1)</div><div class="line">        stat[<span class="string">'length'</span>] = n</div><div class="line">        subs = collections.defaultdict(int)</div><div class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> enumerate(s2):</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> stat:</div><div class="line">                subs[ch] += <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                subs = collections.defaultdict(int)</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> subs[<span class="string">'length'</span>] == stat[<span class="string">'length'</span>]:</div><div class="line">                <span class="keyword">if</span> stat == subs:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                subs[s2[index - n + <span class="number">1</span>]] -= <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">https://leetcode.com/problems/permutation-in-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 567. Permutation in String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 438. Find All Anagrams in a String</title>
    <link href="http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-438-Find-All-Anagrams-in-a-String/"/>
    <id>http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-438-Find-All-Anagrams-in-a-String/</id>
    <published>2021-08-27T06:37:22.477Z</published>
    <updated>2021-08-27T06:45:28.077Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Find_All_Anagrams_in_a_String.png" alt="Find All Anagrams in a String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，判断两个字符串是否是Anagrams，可以采用字典的方法，即每个字母的个数及类型相等。先统计字符串<code>p</code>的字母个数并记录其长度在<code>stat</code>中，遍历字符串<code>s</code>，如果字母在<code>stat</code>中，则将其记录到字典<code>subs</code>中，否则重置<code>subs</code>，当<code>subs[&#39;length&#39;] = stat[&#39;length&#39;]</code>时，比较二者是否相等，如果相等，则记录索引<code>index - n + 1</code>到结果列表中，此时字符串继续遍历，为保证<code>subs</code>长度与<code>stat</code>长度一致，此时，<code>subs</code>中移除<code>s[index - n + 1]</code>字符，同时长度减<code>1</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></div><div class="line">        stat = collections.Counter(p)</div><div class="line">        n = len(p)</div><div class="line">        stat[<span class="string">'length'</span>] = n</div><div class="line">        result = []</div><div class="line">        subs = collections.defaultdict(int)</div><div class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> enumerate(s):</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> stat:</div><div class="line">                subs[ch] += <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                subs = collections.defaultdict(int)</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> subs[<span class="string">'length'</span>] == stat[<span class="string">'length'</span>]:</div><div class="line">                <span class="keyword">if</span> stat == subs:</div><div class="line">                    result.append(index - n + <span class="number">1</span>)</div><div class="line">                subs[s[index - n + <span class="number">1</span>]] -= <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="external">https://leetcode.com/problems/find-all-anagrams-in-a-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 438. Find All Anagrams in a String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 540. Single Element in a Sorted Array</title>
    <link href="http://noahsnail.com/2021/08/25/2021-08-25-Leetcode-540-Single-Element-in-a-Sorted-Array/"/>
    <id>http://noahsnail.com/2021/08/25/2021-08-25-Leetcode-540-Single-Element-in-a-Sorted-Array/</id>
    <published>2021-08-25T01:39:31.234Z</published>
    <updated>2021-08-25T01:58:18.339Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Single_Element_in_a_Sorted_Array.png" alt="Single Element in a Sorted Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，使用类似于二分查找的方式寻找单个元素，首先计算中间位置的索引<code>mid</code>，如果<code>mid</code>为奇数，说明数组左半部分有偶数个元素(索引从<code>0</code>开始)，比较<code>nums[mid]</code>与其左边的元素<code>nums[mid-1]</code>，如果二者相等，则表明左半部分一定不存在单个元素，因此<code>left=mid+1</code>，如果二者不相等，则其一定等于右边的元素，此时<code>right=mid-1</code>；如果<code>mid</code>为偶数，明数组左半部分有寄数个元素，比较<code>nums[mid]</code>与其左边的元素<code>nums[mid-1]</code>，如果二者相等，则表明左半部分一定存在单个元素，此时<code>right=mid-2</code>，即移除两个相等元素，如果不相等，则比较<code>nums[mid]</code>与右边的元素nums[mid+1]，如果二者相等，则表明右半部分一定存在单个元素，此时<code>left = mid + 2</code>，如果两者都不满足，说明<code>nums[mid]</code>就是要找的单个元素。注意<code>left &lt; right</code>的边界条件，这样不会出现数组越界的情况，要充分利用索引的奇偶性以及数组存在单个元素时的奇偶性，始终保持下一部分要查找的子数组含有奇数个元素。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = n - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right:</div><div class="line">            mid = (left + right) // <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span>:</div><div class="line">                <span class="keyword">if</span> nums[mid] == nums[mid - <span class="number">1</span>]:</div><div class="line">                    left = mid + <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    right = mid - <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> nums[mid] == nums[mid - <span class="number">1</span>]:</div><div class="line">                    right = mid - <span class="number">2</span></div><div class="line">                <span class="keyword">elif</span> nums[mid] == nums[mid + <span class="number">1</span>]:</div><div class="line">                    left = mid + <span class="number">2</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> nums[mid]</div><div class="line">        <span class="keyword">return</span> nums[left]</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="external">https://leetcode.com/problems/single-element-in-a-sorted-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 540. Single Element in a Sorted Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 941. Valid Mountain Array</title>
    <link href="http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-941-Valid-Mountain-Array/"/>
    <id>http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-941-Valid-Mountain-Array/</id>
    <published>2021-08-24T09:10:17.549Z</published>
    <updated>2021-08-24T09:33:23.434Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Valid_Mountain_Array.png" alt="Valid Mountain Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，通过<code>up</code>和<code>down</code>分别表示山脉的上下过程，比较数组前后两个数，如果相等，直接返回<code>False</code>，如果前者大于后者，没出现过下山<code>down=False</code>，则将上山设为<code>up=True</code>，如果前者小于后者，出现了上山<code>up=False</code>，则将下山设为<code>down=True</code>，不符合上述条件的都直接返回<code>False</code>，最后如果上山下山都出现了，则返回<code>True</code>，否则返回<code>False</code>。Version 2使用双指针分别从左右两侧移动，最后判断两个指针是否满足山脉条件，不满足返回<code>False</code>，满足返回<code>True</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></div><div class="line">        n = len(arr)</div><div class="line">        up = <span class="keyword">False</span></div><div class="line">        down = <span class="keyword">False</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> arr[i+<span class="number">1</span>] == arr[i]:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> arr[i+<span class="number">1</span>] &gt; arr[i]:</div><div class="line">                up = <span class="keyword">True</span></div><div class="line">                <span class="keyword">if</span> down:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> up:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                down = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> up <span class="keyword">and</span> down:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></div><div class="line">        n = len(arr)</div><div class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        i = <span class="number">1</span></div><div class="line">        j = n - <span class="number">2</span></div><div class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> arr[i] &gt; arr[i<span class="number">-1</span>]:</div><div class="line">            i += <span class="number">1</span></div><div class="line">        i -= <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> j &gt; <span class="number">-1</span> <span class="keyword">and</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        j += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == n - <span class="number">1</span> <span class="keyword">or</span> i != j:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="external">https://leetcode.com/problems/valid-mountain-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 941. Valid Mountain Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1671. Minimum Number of Removals to Make Mountain Array</title>
    <link href="http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-1671-Minimum-Number-of-Removals-to-Make-Mountain-Array/"/>
    <id>http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-1671-Minimum-Number-of-Removals-to-Make-Mountain-Array/</id>
    <published>2021-08-24T08:35:29.313Z</published>
    <updated>2021-08-24T09:09:05.943Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Minimum_Number_of_Removals_to_Make_Mountain_Array.png" alt="Minimum Number of Removals to Make Mountain Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，分别以数组中的元素作为中心点，在左右两侧分别求最长递增子序列，根据左右两侧的最长递增子序列的长度求出山脉的长度，则要删除的元素个数为数组长度减去最长的山脉长度，速度太慢。Version 2在Version 1的基础上进行了优化，分别求出数组正序和逆序各个位置的最长递增子序列，然后跟Version 1类似，累加左右对应位置的最长递增子序列的长度，即为山脉的长度，则要删除的元素个数为数组长度减去最长的山脉长度，速度明显有了大幅提升。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumMountainRemovals</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</div><div class="line">            left = [nums[index]]</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[index] <span class="keyword">or</span> nums[i] == left[<span class="number">0</span>]:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">elif</span> nums[i] &lt; left[<span class="number">0</span>]:</div><div class="line">                    bisect.insort(left, nums[i])</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pos = bisect.bisect(left, nums[i])</div><div class="line">                    left[pos<span class="number">-1</span>] = nums[i]</div><div class="line">            <span class="keyword">if</span> len(left) &lt; <span class="number">2</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            right = [nums[index]]</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index+<span class="number">1</span>, n):</div><div class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[index] <span class="keyword">or</span> nums[i] == right[<span class="number">0</span>]:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">if</span> nums[i] &lt; right[<span class="number">0</span>]:</div><div class="line">                    bisect.insort(right, nums[i])</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pos = bisect.bisect(right, nums[i])</div><div class="line">                    right[pos<span class="number">-1</span>] = nums[i]</div><div class="line">            <span class="keyword">if</span> len(right) &gt; <span class="number">1</span>:</div><div class="line">                maximum = max(maximum, len(left) + len(right) - <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> n - maximum</div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumMountainRemovals</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        left = self.LIS(nums)</div><div class="line">        right = self.LIS(nums[::<span class="number">-1</span>])</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> left[i] &gt; <span class="number">1</span> <span class="keyword">and</span> right[n-i<span class="number">-1</span>] &gt; <span class="number">1</span>:</div><div class="line">                maximum = max(maximum, left[i] + right[n-i<span class="number">-1</span>] - <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> n - maximum</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        dp = [<span class="number">1</span>] * n</div><div class="line">        arr = [nums[<span class="number">0</span>]]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt; arr[<span class="number">-1</span>]:</div><div class="line">                arr.append(nums[i])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pos = bisect.bisect_left(arr, nums[i])</div><div class="line">                arr[pos] = nums[i]</div><div class="line">            dp[i] = len(arr)</div><div class="line">        <span class="keyword">return</span> dp</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/" target="_blank" rel="external">https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1671. Minimum Number of Removals to Make Mountain Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 845. Longest Mountain in Array</title>
    <link href="http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-845-Longest-Mountain-in-Array/"/>
    <id>http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-845-Longest-Mountain-in-Array/</id>
    <published>2021-08-24T06:31:31.813Z</published>
    <updated>2021-08-24T09:21:23.306Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Longest_Mountain_in_Array.png" alt="Longest Mountain in Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，统计山脉元素个数，首先山脉是先上后下，<code>up</code>和<code>down</code>的状态分别表示山脉的上下状态，初始状态都为<code>False</code>，只有<code>down=True</code>时，才记录山脉的最大长度，即最大子数组的长度，当后一个元素大于前一元素时，如果<code>up=True</code>，说明已经记录了上坡长度，此时判断下坡是否也记录了，如果<code>down=True</code>，则说明此次上坡是下一山脉的开始，则<code>down=False, count=2</code>，如果<code>down=False</code>，说明还处于当前山脉的上坡阶段，此时<code>count+=1</code>，如果<code>up=False</code>，则说明是山脉的刚开始，此时<code>up=True, count=2</code>；当后一个元素小于前一元素时，如果<code>up=True</code>，说明此时是当前山脉的下坡阶段，<code>count+=1, down=True</code>；如果<code>up=False</code>，说明此时不处于任何山脉的记录阶段，如果两个元素相等，重置<code>up=False, down=False</code>，时间复杂度<code>O(n)</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></div><div class="line">        n = len(arr)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        up = <span class="keyword">False</span></div><div class="line">        down = <span class="keyword">False</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> arr[i+<span class="number">1</span>] &gt; arr[i]:</div><div class="line">                <span class="keyword">if</span> up:</div><div class="line">                    <span class="keyword">if</span> down:</div><div class="line">                        down = <span class="keyword">False</span></div><div class="line">                        count = <span class="number">2</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        count += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    up = <span class="keyword">True</span></div><div class="line">                    count = <span class="number">2</span></div><div class="line">            <span class="keyword">elif</span> arr[i+<span class="number">1</span>] &lt; arr[i]:</div><div class="line">                <span class="keyword">if</span> up:</div><div class="line">                    count += <span class="number">1</span></div><div class="line">                    down = <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                up = <span class="keyword">False</span></div><div class="line">                down = <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> down:</div><div class="line">                maximum = max(maximum, count)</div><div class="line">        <span class="keyword">if</span> maximum &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> maximum</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/longest-mountain-in-array/" target="_blank" rel="external">https://leetcode.com/problems/longest-mountain-in-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 845. Longest Mountain in Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 914. X of a Kind in a Deck of Cards</title>
    <link href="http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-914-X-of-a-Kind-in-a-Deck-of-Cards/"/>
    <id>http://noahsnail.com/2021/08/24/2021-08-24-Leetcode-914-X-of-a-Kind-in-a-Deck-of-Cards/</id>
    <published>2021-08-24T05:40:42.135Z</published>
    <updated>2021-08-24T05:43:49.327Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/X_of_a_Kind_in_a_Deck_of_Cards.png" alt="X of a Kind in a Deck of Cards"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，统计元素个数，遍历所有可能的分割数量，下限为<code>2</code>，上限为最少的元素个数，如果满足条件，返回<code>True</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasGroupsSizeX</span><span class="params">(self, deck: List[int])</span> -&gt; bool:</span></div><div class="line">        stat = collections.Counter(deck)</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, min(stat.values()) + <span class="number">1</span>):</div><div class="line">            flag = <span class="keyword">True</span></div><div class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> stat.values():</div><div class="line">                <span class="keyword">if</span> val % j != <span class="number">0</span>:</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> flag:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="external">https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 914. X of a Kind in a Deck of Cards
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 957. Prison Cells After N Days</title>
    <link href="http://noahsnail.com/2021/08/23/2021-08-23-Leetcode-957-Prison-Cells-After-N-Days/"/>
    <id>http://noahsnail.com/2021/08/23/2021-08-23-Leetcode-957-Prison-Cells-After-N-Days/</id>
    <published>2021-08-23T09:43:11.242Z</published>
    <updated>2021-08-23T09:53:37.698Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Prison_Cells_After_N_Days.png" alt="Prison Cells After N Days"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，根据变换规则可知，第一位和最后一位总是<code>0</code>，因此只有中间<code>6</code>位数在变，最大可能的变换周期为<code>2^6</code>。因此只要记录变换周期，因此周期中的所有状态就可得出变换结果，使用字典<code>stat</code>来判断每次变换是否与之前的重复，列表<code>state</code>记录状态变化，当出现重复状态时，计算变换的周期<code>peroid</code>，以及一个周期的状态变化，如果没出现周期，则直接返回变换后的结果，如果出现了，则返回计算后的状态。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prisonAfterNDays</span><span class="params">(self, cells: List[int], n: int)</span> -&gt; List[int]:</span></div><div class="line">        stat = &#123;&#125;</div><div class="line">        state = []</div><div class="line">        temp = <span class="string">''</span>.join(list(map(str, cells)))</div><div class="line">        stat[temp] = <span class="number">0</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        pre = cells[:]</div><div class="line">        state.append(pre)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            count += <span class="number">1</span></div><div class="line">            cells[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">            cells[<span class="number">7</span>] = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</div><div class="line">                <span class="keyword">if</span> (pre[j<span class="number">-1</span>] == <span class="number">1</span> <span class="keyword">and</span> pre[j+<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">or</span> (pre[j<span class="number">-1</span>] == <span class="number">0</span> <span class="keyword">and</span> pre[j+<span class="number">1</span>] == <span class="number">0</span>):</div><div class="line">                    cells[j] = <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    cells[j] = <span class="number">0</span></div><div class="line">            temp = <span class="string">''</span>.join(list(map(str, cells)))</div><div class="line">            <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> stat:</div><div class="line">                stat[temp] = count</div><div class="line">                pre = cells[:]</div><div class="line">                state.append(pre)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                peroid = count - stat[temp]</div><div class="line">                state = state[stat[temp]:]</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">if</span> count == n:</div><div class="line">            <span class="keyword">return</span> cells</div><div class="line">        <span class="keyword">return</span> state[(n - count) % peroid]</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/prison-cells-after-n-days/" target="_blank" rel="external">https://leetcode.com/problems/prison-cells-after-n-days/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 957. Prison Cells After N Days
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
