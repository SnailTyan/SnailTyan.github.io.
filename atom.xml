<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="noahsnail.com/"/>
  <updated>2017-04-07T07:05:53.000Z</updated>
  <id>noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROC，AUC，Precision，Recall，F1的介绍与计算</title>
    <link href="noahsnail.com/2017/04/06/2017-4-6-ROC%E5%92%8CAUC%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>noahsnail.com/2017/04/06/2017-4-6-ROC和AUC曲线的介绍与计算/</id>
    <published>2017-04-06T03:40:00.000Z</published>
    <updated>2017-04-07T07:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-ROC与AUC"><a href="#1-1-ROC与AUC" class="headerlink" title="1.1 ROC与AUC"></a>1.1 ROC与AUC</h3><p>ROC曲线和AUC常被用来评价一个二值分类器（binary classifier）的优劣，ROC曲线称为受试者工作特征曲线 （receiver operating characteristic curve，简称ROC曲线），又称为感受性曲线（sensitivity curve），AUC（Area Under Curve）是ROC曲线下的面积。在计算ROC曲线之前，首先要了解一些基本概念。在二元分类模型的预测结果有四种，以判断人是否有病为例：</p>
<ul>
<li>真阳性（TP）：诊断为有，实际上也有病。</li>
<li>伪阳性（FP）：诊断为有，实际却没有病。</li>
<li>真阴性（TN）：诊断为没有，实际上也没有病。</li>
<li>伪阴性（FN）：诊断为没有，实际却有病。</li>
</ul>
<p>其关系如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/roc.png" alt="TP、FP、TN、FN"></p>
<p>ROC空间将伪阳性率（FPR）定义为X轴，真阳性率（TPR）定义为Y轴。TPR：在所有实际为阳性的样本中，被正确地判断为阳性之比率，$TPR=\frac {TP} {TP+FN}$ 。FPR：在所有实际为阴性的样本中，被错误地判断为阳性之比率，$FPR=\frac {FP} {FP+TN}$。</p>
<h3 id="1-2-Precision、Recall与F1"><a href="#1-2-Precision、Recall与F1" class="headerlink" title="1.2 Precision、Recall与F1"></a>1.2 Precision、Recall与F1</h3><p>对于二分类问题另一个常用的评价指标是精确率（precision）与召回率（recall）以及F1值。精确率表示在预测为阳性的样本中，真正有阳性的样本所占的比例。精确率的定义为$P=\frac {TP} {TP+FP}$。召回率表示所有真正呈阳性的样本中，预测为阳性所占的比例。召回率的定义为$R=\frac {TP} {TP+FN}$，F1值是精确率和召回率的调和均值，公式为$F1=\frac {2PR} {P+R}$。精确率和召回率都高时，F1值也会高。通常情况下，Precision与Recall是相互矛盾的。</p>
<h2 id="2-曲线介绍"><a href="#2-曲线介绍" class="headerlink" title="2. 曲线介绍"></a>2. 曲线介绍</h2><h3 id="2-1-ROC曲线"><a href="#2-1-ROC曲线" class="headerlink" title="2.1 ROC曲线"></a>2.1 ROC曲线</h3><p>ROC曲线坐标系如下图所示，虚线为随机猜测的概率，即猜对跟猜错的概率是一样的。理想情况下，我们是希望FPR为0，没有一个假阳性，TPR为1，即全为真阳性，此时所有样本都被正确分类，点位于左上角(0,1)位置处，没有一个分错的数据，这是最完美的情况，实际情况中基本不可能。如果点位于虚线下方，例如C点，说明分类错误的多，分类正确的少，此时不是我们想要的。如果点位于虚线上方，例如$C \prime$点，说明分类错误的少，分类正确的多，此时是我们想要的，因此我们希望ROC曲线尽可能的靠近左上角。对于一个特定的分类器和测试数据集，只能得到一个分类结果，即ROC曲线坐标系中的一点，那么如何得到一条ROC曲线呢？分类问题中我们经常会得到某个样本是正样本的概率，根据概率值与阈值的比较来判断某个样本是否是正样本。在不同的阈值下可以得到不同的TPR和FPR值，即可以得到一系列的点，将它们在图中绘制出来，并依次连接起来就得到了ROC曲线，阈值取值越多，ROC曲线越平滑。</p>
<p>AUC为ROC曲线下的面积，它的面积不会大于1，由于ROC曲线一般都处于直线y=x的上方，因此AUC的取值范围通常在(0.5，1)之间。由于ROC曲线不能很好的看出分类器模型的好坏，因此采用AUC值来进行分类器模型的评估与比较。通常AUC值越大，分类器性能越好。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/700px-ROC_space-2.png" alt="ROC曲线"></p>
<p>在基本概念中我们提到了精确率、召回率以及F1值，既然有它们作为二分类的评价指标，为什么还要使用ROC和AUC呢？这是因为ROC曲线有个很好的特性：当测试集中的正负样本分布发生变化时，即正负样本数量相差较大时，ROC曲线仍能保持不变。实际数据集中经常会出现样本数量不平衡现象，并且测试数据中的正负样本的分布也可能随着时间发生变化。下图是两个分类器模型（算法）的ROC曲线比较图：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/roc_com.png" alt="ROC曲线比较"></p>
<h3 id="2-2-P-R曲线"><a href="#2-2-P-R曲线" class="headerlink" title="2.2 P-R曲线"></a>2.2 P-R曲线</h3><p>在P-R曲线中，Precision为横坐标，Recall为纵坐标。在ROC曲线中曲线越凸向左上角约好，在P-R曲线中，曲线越凸向右上角越好。P-R曲线判断模型的好坏要根据具体情况具体分析，有的项目要求召回率较高、有的项目要求精确率较高。P-R曲线的绘制跟ROC曲线的绘制是一样的，在不同的阈值下得到不同的Precision、Recall，得到一系列的点，将它们在P-R图中绘制出来，并依次连接起来就得到了P-R图。两个分类器模型（算法）P-R曲线比较的一个例子如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/p-r.png" alt="P-R曲线比较"></p>
<h3 id="2-3-ROC与P-R对比"><a href="#2-3-ROC与P-R对比" class="headerlink" title="2.3 ROC与P-R对比"></a>2.3 ROC与P-R对比</h3><p>从公式计算中可以看出，ROC曲线中真阳性率TPR的计算公式与P-R曲线中的召回率Recall计算公式是一样的，即二者是同一个东西在不同环境下的不同叫法。当正负样本差距不大的情况下，ROC曲线和P-R的趋势是差不多的，但是当负样本很多的时候，ROC曲线效果依然较好，但是P-R曲线效果一般。</p>
<h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h2><h3 id="3-1-ROC曲线"><a href="#3-1-ROC曲线" class="headerlink" title="3.1 ROC曲线"></a>3.1 ROC曲线</h3>]]></content>
    
    <summary type="html">
    
      ROC，AUC，Precision，Recall，F1的介绍与计算
    
    </summary>
    
      <category term="机器学习" scheme="noahsnail.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Machine Learning" scheme="noahsnail.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode109——Convert Sorted List to Binary Search Tree</title>
    <link href="noahsnail.com/2017/03/24/2017-3-24-Leetcode109%E2%80%94%E2%80%94Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/"/>
    <id>noahsnail.com/2017/03/24/2017-3-24-Leetcode109——Convert Sorted List to Binary Search Tree/</id>
    <published>2017-03-24T01:17:38.000Z</published>
    <updated>2017-03-24T01:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题主要是根据一个有序链表构造二叉查找树（树的左结点小于根节点，根节点小于右结点，子树具有同样的性质）。与有序数组最大的不同在于有序链表只能从前往后遍历，不能像有序数组一样访问任意位置的元素。因此构造时需要按顺序构造，其实有序链表是二叉查找树的中序遍历。因此需要按照中序遍历的顺序进行构建，先构建左子树，再构造根节点，最后构造右子树。由于是链表，每次构造之后头结点应该进行移动，Java中用了一个静态变量来保存根节点的位置。构造方法主要是递归，每次构建子树时都需要将数组分成左右两半，左边的构建左子树，右边的构建右子树，中间元素构造根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    static ListNode h;</div><div class="line">    </div><div class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</div><div class="line">        if(head == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int length = 0;</div><div class="line">        h = head;</div><div class="line">        //得到链表长度</div><div class="line">        while(head != null) &#123;</div><div class="line">            length++;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        return buildBinarySearchTree(h, 0, length - 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public TreeNode buildBinarySearchTree(ListNode head, int start, int end) &#123;</div><div class="line">        if(start &gt; end) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int mid = (start + end) / 2;</div><div class="line">        //先构建左子树</div><div class="line">        TreeNode left = buildBinarySearchTree(h, start, mid - 1);</div><div class="line">        //再构造根节点</div><div class="line">        TreeNode root = new TreeNode(h.val);</div><div class="line">        h = h.next;</div><div class="line">        //最后构造右子树</div><div class="line">        TreeNode right = buildBinarySearchTree(h, mid + 1, end);</div><div class="line">        root.left = left;</div><div class="line">        root.right = right;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode109——Convert Sorted List to Binary Search Tree
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode108——Convert Sorted Array to Binary Search Tree</title>
    <link href="noahsnail.com/2017/03/23/2017-3-23-Leetcode108%E2%80%94%E2%80%94Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/"/>
    <id>noahsnail.com/2017/03/23/2017-3-23-Leetcode108——Convert Sorted Array to Binary Search Tree/</id>
    <published>2017-03-23T09:53:39.000Z</published>
    <updated>2017-03-24T01:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题主要是根据一个有序数组构造二叉查找树（树的左结点小于根节点，根节点小于右结点，子树具有同样的性质）。构造方法主要是递归，每次构建子树时都需要将数组分成左右两半，左边的构建左子树，右边的构建右子树，中间元素构造根节点。其实有序数组是二叉查找树的中序遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</div><div class="line">        return buildBinarySearchTree(nums, 0, nums.length - 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public TreeNode buildBinarySearchTree(int[] nums, int start, int end) &#123;</div><div class="line">        if(start &gt; end) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        int mid = (start + end) / 2;</div><div class="line">        TreeNode root = new TreeNode(nums[mid]);</div><div class="line">        root.left = buildBinarySearchTree(nums, start, mid - 1);</div><div class="line">        root.right = buildBinarySearchTree(nums, mid + 1, end);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode108——Convert Sorted Array to Binary Search Tree
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode102——Binary Tree Level Order Traversal</title>
    <link href="noahsnail.com/2017/03/22/2017-3-22-Leetcode102%E2%80%94%E2%80%94Binary%20Tree%20Level%20Order%20Traversal/"/>
    <id>noahsnail.com/2017/03/22/2017-3-22-Leetcode102——Binary Tree Level Order Traversal/</id>
    <published>2017-03-22T03:42:38.000Z</published>
    <updated>2017-03-22T03:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [9,20],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的层次遍历问题，需要用到新的数据结构队列，把每一层的结点的子结点放入到队列中，依次遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        Queue&lt;TreeNode&gt; result = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;();</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            TreeNode temp = queue.poll();</div><div class="line">            level.add(temp.val);</div><div class="line">            if(temp.left != null) &#123;</div><div class="line">                result.add(temp.left);</div><div class="line">            &#125;</div><div class="line">            if(temp.right != null) &#123;</div><div class="line">                result.add(temp.right);</div><div class="line">            &#125;</div><div class="line">            if(queue.isEmpty()) &#123;</div><div class="line">                queue = result;</div><div class="line">                result = new LinkedList&lt;TreeNode&gt;();</div><div class="line">                list.add(level);</div><div class="line">                level = new ArrayList&lt;Integer&gt;();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode102——Binary Tree Level Order Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode145——Binary Tree Postorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode145%E2%80%94%E2%80%94Binary%20Tree%20Postorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode145——Binary Tree Postorder Traversal/</id>
    <published>2017-03-21T10:22:59.000Z</published>
    <updated>2017-03-21T10:24:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[3,2,1]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的后序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; left = postorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = postorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.addAll(right);</div><div class="line">        list.add(root.val);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode145——Binary Tree Postorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode94——Binary Tree Inorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode94%E2%80%94%E2%80%94Binary%20Tree%20Inorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode94——Binary Tree Inorder Traversal/</id>
    <published>2017-03-21T10:21:12.000Z</published>
    <updated>2017-03-21T10:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的中序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; left = inorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = inorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.add(root.val);</div><div class="line">        list.addAll(right);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode94——Binary Tree Inorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode144——Binary Tree Preorder Traversal</title>
    <link href="noahsnail.com/2017/03/21/2017-3-21-Leetcode144%E2%80%94%E2%80%94Binary%20Tree%20Preorder%20Traversal/"/>
    <id>noahsnail.com/2017/03/21/2017-3-21-Leetcode144——Binary Tree Preorder Traversal/</id>
    <published>2017-03-21T10:16:00.000Z</published>
    <updated>2017-03-21T10:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题就是一个树的先序遍历问题，最简单的方案就是递归的遍历子树，要注意递归退出的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(root == null) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        list.add(root.val);</div><div class="line">        List&lt;Integer&gt; left = preorderTraversal(root.left);</div><div class="line">        List&lt;Integer&gt; right = preorderTraversal(root.right);</div><div class="line">        list.addAll(left);</div><div class="line">        list.addAll(right);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode144——Binary Tree Preorder Traversal
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode3——Longest Substring Without Repeating Characters</title>
    <link href="noahsnail.com/2017/03/17/2017-3-17-Leetcode3%E2%80%94%E2%80%94Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>noahsnail.com/2017/03/17/2017-3-17-Leetcode3——Longest Substring Without Repeating Characters/</id>
    <published>2017-03-17T05:05:29.000Z</published>
    <updated>2017-04-01T10:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.</div><div class="line"></div><div class="line">Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.</div><div class="line"></div><div class="line">Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong></p>
<p>当遍历第i个字符时，需要判断<code>[index,i-1]</code>的字符中是否有与s[i]重复的字符，如果字符s[j]与s[i]重复，index直接变为j + 1，重新计算不重复字符的数量，如果<code>[index,i-1]</code>的字符中没有与s[i]重复的字符，则不重复字符计数<code>count++</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        int max = 0;</div><div class="line">        int count = 0;</div><div class="line">        int index = 0;</div><div class="line">        //[index,i-1]中是否有与s[i]重复的字符</div><div class="line">        boolean flag = false;</div><div class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            flag = false;</div><div class="line">            char ch = s.charAt(i);</div><div class="line">            //如果s[j]与s[i]重复，index直接变为j + 1，重新计算不重复字符数</div><div class="line">            for(int j = index; j &lt; i; j++) &#123;</div><div class="line">                if(s.charAt(j) == s.charAt(i)) &#123;</div><div class="line">                    flag = true;</div><div class="line">                    index = j + 1;</div><div class="line">                    count = i - j;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(!flag) &#123;</div><div class="line">                count++;</div><div class="line">                if(count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>方法二的思路是看到有重复问题，首先想到哈希表，由于求解的是不重复子串，因此需要将子串分为两部分，一部分为(i，n-1)，一部分为(j，i)，如果s[i]不在(j，i)中，则将s[i]放入哈希表中，同时计数器加1，如果s[i]在(j，i)中，则找到(j，i)中与s[i]重复的字符ch，将其移除，当然ch之前的字符也要将其从哈希表中移除，因为包含ch的子串一定与s[i]重复，每移除一个字符，j++。重复上述过程，直至i到字符串最后。每一个找的子串是从(j,i)不重复的最长子串。这里的j是方法一中的index。思路与方法一是一致的，区别是使用哈希表来判断重复而不是使用循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;();</div><div class="line">        int max = 0;</div><div class="line">        int count = 0;</div><div class="line">        int j = 0;</div><div class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            char ch = s.charAt(i);</div><div class="line">            //如果有重复字符，逐个移除字符，直到移除了与第i个字符重复的字符</div><div class="line">            if(map.containsKey(ch)) &#123;</div><div class="line">                while(map.containsKey(ch)) &#123;</div><div class="line">                    map.remove(s.charAt(j));</div><div class="line">                    j++;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">                count++;</div><div class="line">                map.put(ch, ch);</div><div class="line">            &#125;else &#123;</div><div class="line">                map.put(ch, ch);</div><div class="line">                count++;</div><div class="line">                if(count &gt; max) &#123;</div><div class="line">                    max = count;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>备注：</strong>Leetcode测试时，发现方法一比方法二速度更快。</p>
]]></content>
    
    <summary type="html">
    
      Leetcode3——Longest Substring Without Repeating Characters
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode2——Add Two Numbers</title>
    <link href="noahsnail.com/2017/03/16/2017-3-16-Leetcode2%E2%80%94%E2%80%94Add%20Two%20Numbers/"/>
    <id>noahsnail.com/2017/03/16/2017-3-16-Leetcode2——Add Two Numbers/</id>
    <published>2017-03-16T06:40:37.000Z</published>
    <updated>2017-03-16T07:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</div><div class="line">Output: 7 -&gt; 0 -&gt; 8</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong></p>
<p>先求解两个链表的和，直接一个链表结束或两个链表同时结束，然后再处理没结束链表的剩下部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</div><div class="line">        int sum = 0;</div><div class="line">        int a = 0;</div><div class="line">        int b = 0;</div><div class="line">        int quotient = 0;</div><div class="line">        ListNode head = new ListNode(0);</div><div class="line">        ListNode current = head;</div><div class="line">        while(l1 != null &amp;&amp; l2 !=null) &#123;</div><div class="line">            a = l1.val;</div><div class="line">            b = l2.val;</div><div class="line">            sum = a + b + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            l1 = l1.next;</div><div class="line">            l2 = l2.next;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        ListNode temp = null;</div><div class="line">        if(l1 != null) &#123;</div><div class="line">            temp = l1;</div><div class="line">        &#125;else if(l2 != null) &#123;</div><div class="line">            temp = l2;</div><div class="line">        &#125;else &#123;</div><div class="line">            if(quotient != 0) &#123;</div><div class="line">                temp = new ListNode(0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while(temp != null) &#123;</div><div class="line">            sum = temp.val + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            temp = temp.next;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        if(quotient != 0) &#123;</div><div class="line">             current.next = new ListNode(quotient);</div><div class="line">        &#125;</div><div class="line">        return head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p>方法一中的代码有较多的冗余，例如<code>current.next = new ListNode(sum % 10);</code>出现了两次，两次while循环的逻辑是非常类似的，经过代码的变换可以将两部分合成一部分，即同时处理两个链表直至两个链表都结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</div><div class="line">        int sum = 0;</div><div class="line">        int a = 0;</div><div class="line">        int b = 0;</div><div class="line">        int quotient = 0;</div><div class="line">        ListNode head = new ListNode(0);</div><div class="line">        ListNode current = head;</div><div class="line">        while(l1 != null || l2 !=null) &#123;</div><div class="line">            if(l1 ==null) &#123;</div><div class="line">                a = 0;</div><div class="line">            &#125;else &#123;</div><div class="line">                a = l1.val;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;</div><div class="line">            if(l2 == null) &#123;</div><div class="line">                b = 0;</div><div class="line">            &#125;else &#123;</div><div class="line">                b = l2.val;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            sum = a + b + quotient;</div><div class="line">            current.next = new ListNode(sum % 10);</div><div class="line">            quotient = sum / 10;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        if(quotient != 0) &#123;</div><div class="line">             current.next = new ListNode(quotient);</div><div class="line">        &#125;</div><div class="line">        return head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode2——Add Two Numbers
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二值卷积神经网络</title>
    <link href="noahsnail.com/2017/03/15/2017-3-15-%E4%BA%8C%E5%80%BC%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>noahsnail.com/2017/03/15/2017-3-15-二值卷积神经网络/</id>
    <published>2017-03-15T09:22:00.000Z</published>
    <updated>2017-03-16T00:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="XNOR-Net-ImageNet-Classification-Using-Binary-Convolutional-Neural-Networks"><a href="#XNOR-Net-ImageNet-Classification-Using-Binary-Convolutional-Neural-Networks" class="headerlink" title="XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks"></a>XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks</h1><h1 id="XNOR-Net：使用二值卷积神经网络对ImageNet分类"><a href="#XNOR-Net：使用二值卷积神经网络对ImageNet分类" class="headerlink" title="XNOR-Net：使用二值卷积神经网络对ImageNet分类"></a>XNOR-Net：使用二值卷积神经网络对ImageNet分类</h1>]]></content>
    
    <summary type="html">
    
      二值卷积神经网络
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1——Two Sum</title>
    <link href="noahsnail.com/2017/03/15/2017-3-15-Leetcode1%E2%80%94%E2%80%94Two%20Sum/"/>
    <id>noahsnail.com/2017/03/15/2017-3-15-Leetcode1——Two Sum/</id>
    <published>2017-03-15T01:41:41.000Z</published>
    <updated>2017-03-16T02:29:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>解法一</strong></p>
<p>这个题最简单也是最容易的就是两层循环遍历，这个没什么可说的，时间复杂度为O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] twoSum(int[] nums, int target) &#123;</div><div class="line">        int result[] = new int[2];</div><div class="line">        int n = nums.length;</div><div class="line">        for(int i = 0; i &lt; n; i++) &#123;</div><div class="line">            for(int j = i + 1; j &lt; n; j++) &#123;</div><div class="line">                int sum = nums[i] + nums[j];</div><div class="line">                if(sum == target) &#123;</div><div class="line">                    result[0] = i;</div><div class="line">                    result[1] = j;</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode Accepted，Runtime: 45 ms。</p>
<p><strong>解法二</strong></p>
<p>思考一下，如何进行优化呢？首先，条件为<code>nums[i] + nums[j] = target</code>，已知target和nums[i]的情况下，能不能直接确定nums[j]在数组中是否存在呢？这是可以的，很容易想到map结构，当然数据结构要变换一下，而map的查询复杂度为O(1)，map结构的设计有两种，要不是key为整数，要不key为整数的索引。由于我们求的是整数的索引，因此应该将key设为整数，value为整数的索引。但key为整数有一个问题就是，如果数组中存在相同整数，则后一个放入的数值会覆盖前一个，因此需要单独处理。题目中明确说了一个输入只有一个解，因此如果出现两个整数相等的情况，只需要找到另一个数字的索引即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] twoSum(int[] nums, int target) &#123;</div><div class="line">        int result[] = new int[2];</div><div class="line">        int n = nums.length;</div><div class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</div><div class="line">        for(int i = 0; i &lt; n; i++) &#123;</div><div class="line">            int other = target - nums[i];</div><div class="line">            map.put(nums[i], i);</div><div class="line">            if(map.containsKey(other)) &#123;</div><div class="line">                //两个数字不等情况</div><div class="line">                if(other != nums[i]) &#123;</div><div class="line">                    //注意顺序</div><div class="line">                    result[0] = map.get(other);</div><div class="line">                    result[1] = i;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    //数字相等情况</div><div class="line">                    result[0] = i;</div><div class="line">                    for(int j = i + 1; j &lt; n; j++) &#123;</div><div class="line">                        if(nums[j] == other) &#123;</div><div class="line">                            result[1] = j;</div><div class="line">                            return result;</div><div class="line">                        &#125;</div><div class="line">                    &#125;  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode Accepted，Runtime: 12 ms。</p>
]]></content>
    
    <summary type="html">
    
      Leetcode1——Two Sum
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode155——Min Stack</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode155%E2%80%94%E2%80%94Min%20Stack/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode155——Min Stack/</id>
    <published>2017-03-14T14:46:56.000Z</published>
    <updated>2017-03-18T02:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MinStack minStack = new MinStack();</div><div class="line">minStack.push(-2);</div><div class="line">minStack.push(0);</div><div class="line">minStack.push(-3);</div><div class="line">minStack.getMin();   --&gt; Returns -3.</div><div class="line">minStack.pop();</div><div class="line">minStack.top();      --&gt; Returns 0.</div><div class="line">minStack.getMin();   --&gt; Returns -2.</div></pre></td></tr></table></figure>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>方法一</strong><br>主要是模拟写一个最小栈。要注意push时可能会输入null。需要使用双栈实现，一个保存数据，一个保存最小值。由于随着数据出栈，最小值是不断变化的，因此需要一个最小值栈来保存最小值。方法一是最小值栈与普通栈大小不等的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class MinStack &#123;</div><div class="line">    private Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class="line">    private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</div><div class="line">            minStack.push(x);</div><div class="line">        &#125;</div><div class="line">        stack.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pop() &#123;</div><div class="line">        if(stack.peek().equals(minStack.peek())) &#123;</div><div class="line">            minStack.pop();</div><div class="line">        &#125;</div><div class="line">        stack.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int top() &#123;</div><div class="line">        return stack.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getMin() &#123;</div><div class="line">        return minStack.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>最小值栈与存储元素的栈大小始终相等的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class MinStack &#123;</div><div class="line">    private Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</div><div class="line">    private Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</div><div class="line">            minStack.push(x);</div><div class="line">        &#125;else &#123;</div><div class="line">            minStack.push(minStack.peek());</div><div class="line">        &#125;</div><div class="line">        stack.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pop() &#123;</div><div class="line">        minStack.pop();</div><div class="line">        stack.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int top() &#123;</div><div class="line">        return stack.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getMin() &#123;</div><div class="line">        return minStack.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode155——Min Stack
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode152——Maximum Product Subarray</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode152%E2%80%94%E2%80%94Maximum%20Product%20Subarray/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode152——Maximum Product Subarray/</id>
    <published>2017-03-14T10:37:05.000Z</published>
    <updated>2017-03-14T10:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>这个题跟Leetcode 53——Maximum Subarray类似，可以用三重循环，两种循环解决。但最好的还是用动态规划解决，找出状态转移方程最关键。由于乘积可能为负数，负负得正，因此第<code>i-1</code>次的乘积最大值（maxValuePre）与最小值（minValuePre）都需要保留。当然也可以定义最大值最小值数组来保存第i次乘积的最大值（maxValue）与最小值（minValue）。与Maximum Subarray相比，最大值为<code>maxValue = max(minValuePre * nums[i], maxValuePre * nums[i], nums[i])</code>，最小值同样如此。</p>
<p><strong>没有定义最大值数组与最小值数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        int n = nums.length;</div><div class="line">        int maxValue = nums[0];</div><div class="line">        int minValue = nums[0];</div><div class="line">        int result = nums[0];</div><div class="line">        int maxValuePre = nums[0], minValuePre = nums[0];</div><div class="line">        for(int i = 1; i &lt; n; i++) &#123;</div><div class="line">            maxValue = Math.max(minValuePre * nums[i], Math.max(maxValuePre * nums[i], nums[i]));</div><div class="line">            minValue = Math.min(minValuePre * nums[i], Math.min(maxValuePre * nums[i], nums[i]));</div><div class="line">            if(maxValue &gt; result) &#123;</div><div class="line">                result = maxValue;</div><div class="line">            &#125;</div><div class="line">            maxValuePre = maxValue;</div><div class="line">            minValuePre = minValue;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>定义最大值数组与最小值数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        int n = nums.length;</div><div class="line">        int maxValue[] = new int[nums.length];</div><div class="line">        int minValue[] = new int[nums.length];</div><div class="line">        maxValue[0] = nums[0];</div><div class="line">        minValue[0] = nums[0];</div><div class="line">        int result = nums[0];</div><div class="line">        for(int i = 1; i &lt; n; i++) &#123;</div><div class="line">            maxValue[i] = Math.max(minValue[i - 1] * nums[i], Math.max(maxValue[i - 1] * nums[i], nums[i]));</div><div class="line">            minValue[i] = Math.min(minValue[i - 1] * nums[i], Math.min(maxValue[i - 1] * nums[i], nums[i]));</div><div class="line">            if(maxValue[i] &gt; result) &#123;</div><div class="line">                result = maxValue[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode152——Maximum Product Subarray
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode128——Longest Consecutive Sequence</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode128%E2%80%94%E2%80%94Longest%20Consecutive%20Sequence/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode128——Longest Consecutive Sequence/</id>
    <published>2017-03-14T10:14:21.000Z</published>
    <updated>2017-03-14T10:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>题中明确要求时间复杂度为O(n)，因此这道题肯定不能使用循环遍历。这道题主要是考察哈希表，因为哈希表每次查询的时间复杂度为O(1)。因此首先要将数组转为Map。然后分别查询每个数字的前一个数与后一个数，统计数字连续的数量。如果在哈希表中存在相邻的数，查询后应该从哈希表中删除，当然不删也可以。如果哈希表为空，则直接跳出循环，不再遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">   	public int longestConsecutive(int[] nums) &#123;</div><div class="line">		int max = 0;</div><div class="line">		int count = 0;</div><div class="line">		Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">			map.put(String.valueOf(nums[i]), nums[i]);</div><div class="line">		&#125;</div><div class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">			count = 1;</div><div class="line">			int x = nums[i];</div><div class="line">			while(true) &#123;</div><div class="line">				int temp = --x;</div><div class="line">				if(map.containsKey(String.valueOf(temp))) &#123;</div><div class="line">					map.remove(String.valueOf(temp));</div><div class="line">					count++;</div><div class="line">				&#125;else &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			//必须重置x</div><div class="line">			x = nums[i];</div><div class="line">			while(true) &#123;</div><div class="line">				int temp = ++x;</div><div class="line">				if(map.containsKey(String.valueOf(temp))) &#123;</div><div class="line">					map.remove(String.valueOf(temp));</div><div class="line">					count++;</div><div class="line">				&#125;else &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if(count &gt; max) &#123;</div><div class="line">				max = count;</div><div class="line">			&#125;</div><div class="line">			if(map.isEmpty()) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Leetcode128——Longest Consecutive Sequence
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode394——Decode String</title>
    <link href="noahsnail.com/2017/03/14/2017-3-14-Leetcode394%E2%80%94%E2%80%94Decode%20String/"/>
    <id>noahsnail.com/2017/03/14/2017-3-14-Leetcode394——Decode String/</id>
    <published>2017-03-14T06:30:08.000Z</published>
    <updated>2017-03-14T06:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>Given an encoded string, return it’s decoded string.</p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<p>Examples:</p>
<p>s = “3[a]2[bc]”, return “aaabcbc”.<br>s = “3[a2[c]]”, return “accaccacc”.<br>s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”.</p>
<p><strong>中文</strong></p>
<p>给定一个经过编码的字符串，返回其解码字符串。编码规则为：k[encoded_string]，其中中括号内的encoded_string被重复k次。注意k一定是正整数。</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p>本题中明显有括号的匹配问题，因此需要使用栈来求解。当碰到右括号（<code>]</code>）时，字符串出栈，碰到左括号（<code>[</code>）时，保存左右括号内的字符串（<code>[]</code>），继续出栈，保存字符串重复次数，直至栈为空或碰到非数字。要注意重复次数不是个位数，将字符串重复之后压入栈中。继续处理剩余字符串，同样执行上述过程，直至处理完字符串。然后将栈中所有的字符出栈构成结果字符串返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">	public String decodeString(String s) &#123;</div><div class="line">		int n = s.length();</div><div class="line">		Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</div><div class="line">		String result = &quot;&quot;;</div><div class="line">		String temp = &quot;&quot;;</div><div class="line">		for (int i = 0; i &lt; n; i ++) &#123;</div><div class="line">			char str = s.charAt(i);</div><div class="line">			if (str != &apos;]&apos;) &#123;</div><div class="line">				stack.push(str);</div><div class="line">			&#125; else &#123;</div><div class="line">				char ch = stack.pop();</div><div class="line">				while (ch != &apos;[&apos;) &#123;</div><div class="line">					temp = ch + temp;</div><div class="line">					ch = stack.pop();</div><div class="line">				&#125;</div><div class="line">				//字符串重复次数</div><div class="line">				String times = &quot;&quot;;</div><div class="line">				while(!stack.isEmpty()) &#123;</div><div class="line">					ch = stack.pop();</div><div class="line">					if(Character.isDigit(ch)) &#123;</div><div class="line">						times = ch + times;</div><div class="line">					&#125;else &#123;</div><div class="line">						stack.push(ch);</div><div class="line">						break;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				//重复字符串，压入栈中</div><div class="line">				for(int j = 0; j &lt; Integer.parseInt(times); j++) &#123;</div><div class="line">					for(int k = 0; k &lt; temp.length(); k++) &#123;</div><div class="line">						stack.push(temp.charAt(k));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				temp = &quot;&quot;;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		while(!stack.isEmpty()) &#123;</div><div class="line">			result = stack.pop() + result;</div><div class="line">		&#125; </div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode394——Decode String
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux的tar命令</title>
    <link href="noahsnail.com/2017/03/13/2017-3-13-Linux%E7%9A%84tar%E5%91%BD%E4%BB%A4/"/>
    <id>noahsnail.com/2017/03/13/2017-3-13-Linux的tar命令/</id>
    <published>2017-03-13T02:48:58.000Z</published>
    <updated>2017-03-21T08:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>Linux下经常碰到需要解压文件的情况，需要用到<code>tar</code>命令，本文主要介绍一下<code>tar</code>命令。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Linux tar命令用于备份文件。tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。我的直观印象就是压缩解压文件。其参数如下：</p>
<ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F<script文件>或–info-script=<script文件> 每次更换磁带时，就执行指定的Script文件。</script文件></script文件></li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude=&lt;范本样式&gt; 排除符合范本样式的问家。</li>
<li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=<script文件> 此参数的效果和指定”-F”参数相同。</script文件></li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原问家你。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h2 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2. Demo"></a>2. Demo</h2><ul>
<li>查看压缩文件中的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tar -tvf inception-v3.tar.gz </div><div class="line">drwxrwxr-x  0 muli   muli        0 12 21  2015 model/</div><div class="line">-rw-rw-r--  0 muli   muli    31691 12 17  2015 model/synset.txt</div><div class="line">-rw-rw-r--  0 muli   muli 95575141 12 17  2015 model/Inception-7-0001.params</div><div class="line">-rw-rw-r--  0 muli   muli      879 12 17  2015 model/preprocessing.py</div><div class="line">-rw-rw-r--  0 muli   muli   134383 12 17  2015 model/Inception-7-symbol.json</div></pre></td></tr></table></figure>
<ul>
<li>解压文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tar -xvf inception-v3.tar.gz </div><div class="line">x model/</div><div class="line">x model/synset.txt</div><div class="line">x model/Inception-7-0001.params</div><div class="line">x model/preprocessing.py</div><div class="line">x model/Inception-7-symbol.json</div></pre></td></tr></table></figure>
<ul>
<li>解压到指定目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ mkdir test</div><div class="line">$ tar xvf inception-v3.tar.gz -C ./test</div><div class="line">x model/</div><div class="line">x model/synset.txt</div><div class="line">x model/Inception-7-0001.params</div><div class="line">x model/preprocessing.py</div><div class="line">x model/Inception-7-symbol.json</div></pre></td></tr></table></figure>
<ul>
<li>压缩指定文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -zcvf test.tar.gz test</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Linux的tar命令
    
    </summary>
    
      <category term="Linux" scheme="noahsnail.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="noahsnail.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode53——Maximum Subarray</title>
    <link href="noahsnail.com/2017/03/11/2017-3-11-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>noahsnail.com/2017/03/11/2017-3-11-最大子序列问题/</id>
    <published>2017-03-11T13:29:22.000Z</published>
    <updated>2017-03-16T02:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文主要是对最大子数组（序列）问题求解的学习与总结，最大子数组问题是一道经典的算法题，这道题解法有很多，因此可以学习到很多求解问题的思路，并可以学习到算法的优化过程。</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p><strong>英文：</strong></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<p><strong>中文：</strong></p>
<p>主要是给定一个数组，求解数组的子数组中，数组元素和最大的那一个子数组，返回的是最大子数组的和。</p>
<h2 id="2-求解"><a href="#2-求解" class="headerlink" title="2. 求解"></a>2. 求解</h2><p><strong>解法一</strong></p>
<p>最简单也是最容易想到的思路就是三层循环，对<code>(i,j),i&lt;=j</code>的情况进行遍历，这种情况下的算法复杂度为O($n^3$)。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果需要节省空间，可将n替换</span></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="comment">//注意k的边界，存在i=j的情况</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</div><div class="line">                    sum += nums[k];</div><div class="line">                    <span class="keyword">if</span>(sum &gt; max) &#123;</div><div class="line">                        max = sum;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode上的运行结果如下：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/max_subarray_1.png" alt="O(n^3)的情况"></p>
<p><strong>解法二</strong></p>
<p>从Leetcode结果可以看出，时间超时了，O($n^3$)的时间复杂度确实太高了，需要进行优化。分析上面的代码，在i不变的情况下，j每增加1，其和都是在上次求和基础上加上最新的元素，而在第三层循环中都是重新从i开始计算求和，因此存在数据冗余（求和的重复计算），因此需要需要去掉算法中的冗余部分。这种情况下的代码复杂度变为O($n^2$)，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</div><div class="line">                sum += nums[j];</div><div class="line">                <span class="keyword">if</span>(sum &gt; max) &#123;</div><div class="line">                    max = sum;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode上运行结果如下：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/max_subarray_2.png" alt="O(n^2)的情况"></p>
<p><strong>解法三</strong></p>
<p>从Leetcode结果可以看出，时间还是超时了，但从执行的测试数据数量上来看，比第一次多执行了两个，但在最后一个测试数据上时间超时了。那么能不能有进一步的优化呢？答案是肯定有的。可以使用分治法来求解，算法复杂度为O(nlogn)，但是其实本题并不适合使用分治法，太复杂。虽然算法复杂度降低了一些，因此这里略过分治法，直接寻找更优解法。</p>
<p><strong>解法四</strong></p>
<p>还有没有更好的方法呢？答案也是肯定的。首先假设存在最大子数组X，则最大子数组X中的任意一个子数组x都不应该为负数，如果x为负数，则X必定不是最大子数组（可用反证法证明）。根据这个思想，我们只需要以此累加数组元素，并将和与0比较，如果小于0，则需要在剩下的元素中重新寻找是否存在最大子数组，如果不小于0，则与保存的最大子数组值进行比较，如果大于最大子数组值，则更新最大子数组值。这样只需要一次遍历就能找到最大子数组，这种解法的算法复杂度为O(n)。根据这个思路，解决这个问题的算法复杂度代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(sum &gt; max) &#123;</div><div class="line">                max = sum;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</div><div class="line">                sum = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode通过了。</p>
<p><strong>解法五</strong></p>
<p>还有没有别的方法呢？答案还是肯定的。使用动态规划求解。动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 使用动态规划求解问题，最重要的就是确定动态规划三要素：（1）问题的阶段；（2）每个阶段的状态；（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>1.起始阶段<code>(i=0)</code>，<code>max = nums[0]</code>；2.第<code>i(i &gt; 0)</code>个阶段，<code>max = curMax[i]</code>，<code>curMax</code>是第i个阶段的最大子序列和；3.第<code>i-1</code>和第<code>i</code>个阶段的关系，<code>curMax[i] = Math.max(curMax[i - 1] + nums[i], nums[i])</code>；4.根据前面动态规划的定义，则最大子序列和<code>max = Math.max(max, curMax[i])</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">	public int maxSubArray(int[] nums) &#123;</div><div class="line">		int n = nums.length;</div><div class="line">		//curMax是当前的最大子序列和</div><div class="line">		int[] curMax = new int[n];</div><div class="line">		curMax[0] = nums[0];</div><div class="line">		int max = nums[0];</div><div class="line">		for (int i = 1; i &lt; n; i ++) &#123;</div><div class="line">			curMax[i] = Math.max(curMax[i - 1] + nums[i], nums[i]);</div><div class="line">			max = Math.max(max, curMax[i]);</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Leetcode通过了。</p>
<p><strong>分析解法四与解法五</strong></p>
<p>其实解法四与解法五是一致的，解法四中的sum等于解法五中的curMax[i]，解法五中如果<code>curMax[i-1]</code>小于0，则<code>curMax[i] = nums[i]</code>，而在解法四中由于第<code>i-1</code>次时<code>sum=curMax[i-1]</code>，因此需要将sum重置为0，则<code>sum + nums[i] = nums[i]</code>，与<code>curMax[i] = nums[i]</code>是一致的。如果解法五中<code>curMax[i-1]</code>大于等于0，则curMax[i] = <code>curMax[i - 1] + nums[i]</code>，此时方法四中<code>sum = sum + nums[i]</code>。而第<code>i-1</code>次时，<code>sum = curMax[i - 1]</code>，两者也是等价的。解法五中的curMax[0]替换为sum，curMax[i]替换为sum，将<code>curMax[i] = Math.max(curMax[i - 1] + nums[i], nums[i]);</code>变换为<code>sum  += nums[i];</code>和<code>if(sum &lt; 0) {    sum = 0; }</code>，即可将代码从解法五变换为解法四的代码。</p>
]]></content>
    
    <summary type="html">
    
      Leetcode53——Maximum Subarray
    
    </summary>
    
      <category term="基础算法" scheme="noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存分析与清理</title>
    <link href="noahsnail.com/2017/03/09/2017-3-9-Linux%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>noahsnail.com/2017/03/09/2017-3-9-Linux内存分析与清理/</id>
    <published>2017-03-09T03:00:25.000Z</published>
    <updated>2017-03-09T09:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-free命令"><a href="#1-free命令" class="headerlink" title="1. free命令"></a>1. free命令</h2><p>Linux中查看内存的命令为<code>free</code>，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ free -h</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:            62G        4.9G        627M        520K         57G         57G</div><div class="line">Swap:          4.0G        335M        3.7G</div></pre></td></tr></table></figure>
<p>每一列的解释如下：</p>
<ul>
<li>total：内存总数</li>
<li>used：已经使用的内存数</li>
<li>free：空闲的内存数</li>
<li>shared：当前已经废弃不用</li>
<li>buffers Buffer：缓存内存数</li>
<li>cached Page：缓存内存数</li>
</ul>
<p>可以看出<code>buff/cache</code>占用的内存份额很大，有时候程序运行结束后，大量内存仍位于<code>buff/cache</code>中，有时运行程序会导致内存不足，因此需要将这部分内存释放出来。</p>
<h2 id="2-Linux中的缓存分类"><a href="#2-Linux中的缓存分类" class="headerlink" title="2. Linux中的缓存分类"></a>2. Linux中的缓存分类</h2><p>要清理Linux中的cache，首先要明白buff和cache的区别(free中的buff/cache)，以及pagecache，dentries和inodes的区别。</p>
<ul>
<li><p>buff<br>作为buffer cache的内存，是块设备的读写缓冲区</p>
</li>
<li><p>cache<br>作为page cache的内存，文件系统的cache。Buffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中。</p>
</li>
<li><p>pagecache</p>
</li>
</ul>
<p>页面缓存（pagecache）可以包含磁盘块的任何内存映射。这可以是缓冲I/O，内存映射文件，可执行文件的分页区域——操作系统可以从文件保存在内存中的任何内容。Page cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。</p>
<ul>
<li><p>dentries<br>表示目录的数据结构</p>
</li>
<li><p>inodes<br>表示文件的数据结构 </p>
</li>
</ul>
<p><strong>总结：</strong>cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题。buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的。</p>
<p>缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除。</p>
<p>缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。</p>
<h2 id="3-清理cache"><a href="#3-清理cache" class="headerlink" title="3. 清理cache"></a>3. 清理cache</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/proc/sys/vm/drop_caches (since Linux 2.6.16)</div><div class="line">Writing to this file causes the kernel to drop clean caches,dentries and inodes from memory, causing that memory to become free.</div><div class="line">To free pagecache, use echo 1 &gt; /proc/sys/vm/drop_caches;</div><div class="line">to free dentries and inodes, use echo 2 &gt; /proc/sys/vm/drop_caches;</div><div class="line">to free pagecache, dentries and inodes, use echo 3 &gt; /proc/sys/vm/drop_caches.</div><div class="line">Because this is a non-destructive operation and dirty objects are not freeable, the user should run sync first.</div></pre></td></tr></table></figure>
<p>/proc是一个虚拟文件系统，我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段。也就是说可以通过修改/proc中的文件，来对当前kernel的行为做出调整。那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存。<code>/proc/sys/vm/drop_caches</code>中的默认值为0，值为1时表示可以释放pagecache缓存，值为2时可以释放pagecache和inode缓存，值为3时可以释放pagecache, dentries和inodes缓存。当然在释放内存之前需要执行<code>sync</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sync &amp;&amp; echo 1 &gt; /proc/sys/vm/drop_caches</div><div class="line">sync &amp;&amp; echo 2 &gt; /proc/sys/vm/drop_caches</div><div class="line">sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches</div></pre></td></tr></table></figure>
<p>参考资料</p>
<p>1.<a href="http://www.linuxde.net/2011/07/402.html" target="_blank" rel="external">http://www.linuxde.net/2011/07/402.html</a></p>
]]></content>
    
    <summary type="html">
    
      Linux内存分析与清理
    
    </summary>
    
      <category term="Linux" scheme="noahsnail.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="noahsnail.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法(一)——统计学习方法概论</title>
    <link href="noahsnail.com/2017/03/08/2017-3-8-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95(%E4%B8%80)%E2%80%94%E2%80%94%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/"/>
    <id>noahsnail.com/2017/03/08/2017-3-8-统计学习方法(一)——统计学习方法概论/</id>
    <published>2017-03-08T01:12:48.000Z</published>
    <updated>2017-04-07T08:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h1 id="1-统计学习方法概论"><a href="#1-统计学习方法概论" class="headerlink" title="1. 统计学习方法概论"></a>1. 统计学习方法概论</h1><p>本文是统计学习方法（李航）第一章的学习总结。</p>
<h2 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h2><p><strong>1.统计学习的特点</strong></p>
<p>统计学习（statistical learning）是关于计算机基于<strong>数据</strong>构建<strong>概率统计模型</strong>并运用模型对数据进行预测和分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。现在人们提到的机器学习往往是指统计机器学习。</p>
<p>统计学习的特点：(1)以计算机和网络为平台；(2)以数据为研究对象，是数据驱动的学科；(3)目的是对数据进行分析和预测；(4)以方法为中心，构建模型并应用模型进行分析和预测；(5)是概率论、统计学、信息论、优化理论和计算机科学等多个领域的交叉学科。</p>
<p><strong>2.统计学习的对象</strong></p>
<p>统计学习的对象是<strong>数据</strong>（data）。它从数据出发，提取数据特征，抽象出数据模型，根据模型对数据进行分析和预测。统计学习的前提是假设同类数据（具有某种共同性质）具有一定的统计规律性。统计学习过程中，以变量或变量组表示数据，数据分为连续变量和离散变量表示的类型。</p>
<p><strong>3.统计学习的目的</strong></p>
<p>统计学习总的目标就是考虑学习什么的模型和如何学习模型，以使模型能够对数据进行准确的预测和分析，同时也要考虑学习效率。</p>
<p><strong>4.统计学习的方法</strong></p>
<p>统计学习分为监督学习（supervised learning）、非监督学习（unsupervised learning）、半监督学习(semi-supervised learning)和强化学习(reinforcement learning)等。统计学习方法包括模型的假设空间、模型选择的准则及模型选择的算法，称为统计学习方法的三要素，简称模型（model）、策略（strategy）和算法（algorithm）。</p>
<p><strong>5.统计学习的研究</strong></p>
<p>统计学习的研究包括统计学习方法（算法创新）、统计学习理论（算法效率及有效性）及统计学习应用（解决问题）三个方面。</p>
<p><strong>6.统计学习的重要性</strong></p>
<p>统计学习的重要性体现在三个方面：（1）统计学习是处理海量数据的有效方法。（2）统计学习是计算机智能化的有效手段。（3）统计学习是计算机发展的重要组成部分。</p>
<h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h2><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p>
<h3 id="1-2-1-基本概念"><a href="#1-2-1-基本概念" class="headerlink" title="1.2.1 基本概念"></a>1.2.1 基本概念</h3><p><strong>1.输入空间、特征空间与输出空间</strong></p>
<p>在监督学习中，输入与输出的所有可能的取值集合分别称为输入空间（input space）和输出空间（output space）。通常输出空间远远小于输入空间。</p>
<p>每个具体的输入是一个实例（instance），通常由特征向量（feature vector）表示。所有特征向量存在的空间称为特征空间（feature space）。特征空间的每一维对应一个特征。当输入空间与特征空间不同时，需要将实例从输入空间映射到特征空间，模型实际上都是定义在特征空间上的。</p>
<p>监督学习过程中，将输入和输出看作是定义在输入空间和输出空间上的<strong>随机变量</strong>的取值。习惯上输入变量写作<code>X</code>，其取值写作<code>x</code>，输出变量写作<code>Y</code>，其取值写作<code>y</code>。输入实例的<code>x</code>的特征向量记作</p>
<p>$$x = (x^{(1)}, x^{(2)},…, x^{(i)} ,…,x^{(n)})^T$$</p>
<p>$x^{(i)}$表示向量<code>x</code>的第<code>i</code>个特征，而$x_i$表示第<code>i</code>个输入变量。</p>
<p>$$x_i = (x_i^{(1)}, x_i^{(2)},…, x_i^{(i)} ,…,x_i^{(n)})^T$$</p>
<p>监督学习从训练数据中学习模型，对测试数据进行预测。训练集通常表示为</p>
<p>$$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$$</p>
<p>$(x_i,y_i)$表示样本或样本点。</p>
<p>输入变量和输出变量可以是离散型的，也可以是连续型的。输入变量和输出变量都是连续型变量的预测问题称为回归问题；输出变量为有限个离散型变量的预测问题称为分类问题；输入变量和输出变量均为变量序列的预测问题称为标注问题。</p>
<p><strong>2.联合概率分布</strong></p>
<p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布<code>P(X,Y)</code>，<code>P(X,Y)</code>表示分布函数或分布密度函数。训练数据和测试数据被看作是依联合概率分布<code>P(X,Y)</code>独立同分布产生的。统计学习假设数据存在一定的统计规律。</p>
<p><strong>3.假设空间</strong></p>
<p>监督学习的目的在于学习一个由输入到输出的映射，映射关系用模型表示。输入到输出的映射集合就是假设空间（hypothesis space）。简单学习的模型可以是概率模型或非概率模型。由条件概率分布<code>P(Y|X)</code>或决策函数<code>Y=f(X)</code>表示。对具体的输入进行输出预测时，写作<code>P(y|x)</code>或<code>y=f(x)</code>。</p>
<h3 id="1-2-2-问题的形式化"><a href="#1-2-2-问题的形式化" class="headerlink" title="1.2.2 问题的形式化"></a>1.2.2 问题的形式化</h3><p>监督学习利用训练数据学习模型，再用模型对测试数据进行预测。学习过程中的训练数据往往是人工给出的，因此称为监督学习。监督学习分为学习和预测两个过程，如下图：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/supervised-learning.png" alt="监督学习"></p>
<p>首先给定数据集$T={(x_1,y_1),(x_3,y_2),…,(x_N,y_N)}$，其中$(x_i,y_i)，i=1,2,…,N$，称为样本或样本点，$x_i \in X \subseteq R^n$是输入的观测值，称为输入或实例，$y_i \in Y$是输出的观测值，也称为输出。通过学习得到的模型表示为条件概率分布$P(Y|X)$和决策函数$Y=f(X)$，模型表示的是输入与输出之间的映射关系。</p>
<p>预测过程中，对于测试数据中的输入$x_{N+1}$,由模型$y_{N+1}=argmax P(y_{N+1}|x_{N+1})$或$y_{N+1}=f(x_{N+1})$给出对应的输出$y_{N+1}$。</p>
<h2 id="1-3-统计学习三要素"><a href="#1-3-统计学习三要素" class="headerlink" title="1.3 统计学习三要素"></a>1.3 统计学习三要素</h2><p>统计学习方法的三要素为模型、策略和算法，它们关系为：<code>统计学习方法 = 模型 + 策略 + 算法</code>。</p>
<h3 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h3><p>在监督学习过程中，模型是要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。假设空间用F表示：<br>$$F=\lbrace f|Y=f(X)\rbrace $$<br>X和Y是定义在输入输出空间上的变量，F通常是由一个参数向量决定的函数族：<br>$$F=\lbrace f|Y=f_\theta (X),\theta \in R^n \rbrace$$<br>参数向量$\theta$取值于n维欧式空间$R^n$，称为参数空间（parameter space）。假设空间也可以定义为条件概率的集合：</p>
<p>$$F=\lbrace P|P(Y|X)\rbrace$$<br>X和Y是定义在输入输出空间上的随机变量，F通常是一个由参数向量决定的条件概率分布族：</p>
<p>$$F=\lbrace P|P_\theta (Y|X)，\theta \in R^n \rbrace$$<br>参数向量$\theta$取值于n维欧式空间$R^n$，也称为参数空间。</p>
<h3 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h3><p>有了模型的假设空间，统计学习接着考虑的是按照什么样的准则学习或选择最优的模型，统计学习的目标在于从假设空间中选取最优的模型。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。</p>
<p><strong>1.损失函数和风险函数</strong></p>
<p>监督学习问题是在假设空间F中选取f作为决策函数，对于给定的输入X，f(X)给出对应的输出Y，输出预测值f(X)与真实值Y可能一致也可能不一致，用一个损失函数（loss function）或代价函数（cost function）。损失函数是f(X)和Y的非负实值函数，记作$L(Y,f(X))$。统计学习常用的损失函数有以下几种：</p>
<ul>
<li><p>0-1损失函数（0-1 loss function）<br>$$<br>L(Y,f(X))=<br>\begin{cases}<br>1, Y \neq f(X) \\<br>0, Y=f(X)<br>\end{cases}<br>$$</p>
</li>
<li><p>平方损失函数（quadratic loss function）<br>$$L(Y,f(X))=(Y-f(X))^2$$</p>
</li>
<li><p>绝对损失函数（absolute loss function）<br>$$L(Y,f(X))=|(Y-f(X))|$$</p>
</li>
<li><p>对数损失函数（logarithmic loss function）或对数似然损失函数(log-likelihood loss function)<br>$$L(Y,f(X))=-\log P(Y|X)$$</p>
</li>
</ul>
<p>损失函数越小，模型越好。由于模型输入、输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是</p>
<p>$$R_{exp}(f)=E_p[L(Y,f(X))]=\int_{x*y}L(y,f(x))P(x,y)dxdy$$</p>
<p>这是理论上模型f(X)关于联合分布P(x,y)的平均意义下的损失，称为风险函数（risk function）或期望损失（expected loss）。学习的目标就是选择期望风险最小的模型。由于联合分布P(X,Y)是未知的，$R_{exp}(f)$不能直接计算。如果知道联合分布P(X,Y)，从联合分布可以直接求出条件概率分布P(Y|X)，也就不需要学习了。一方面根据期望风险最小学习模型需要用到联合分布，一方面联合分布又是未知的，因此监督学习就称为一个病态问题（ill-formed problem）。</p>
<p>给定一个训练数据集</p>
<p>$$T = {(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$$</p>
<p>模型f(X)关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失（empirical loss），记作$R_{emp}$：</p>
<p>$$R_{emp}(f)=\frac {1} {N} \sum_{i=1}^N L(y_i,f(x_i))$$</p>
<p>期望风险$R_{exp}(f)$是模型关于联合分布的期望损失，经验风险$R_{emp}(f)$是模型关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷时，经验风险$R_{emp}(f)$趋于期望风险$R_{exp}(f)$。因此很自然的一个想法就是用经验风险估计期望风险，但由于训练数据是有限的，因此要对经验风险进行一定的矫正。这关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。</p>
<p><strong>2.经验风险最小化和结构风险最小化</strong></p>
<p>在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数就可以确定。经验风险最小化（empirical risk minimization，ERM）策略认为，经验风险最小的模型就是最优的模型。求解经验最小化最优模型就是求解最优化问题：</p>
<p>$$^{min} _{f \in F} \frac {1} {N}  \sum_{i=1}^N L(y_i, f(x_i))$$</p>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。当模型是条件概率分布时，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。但是，当样本容量很小时，经验风险最小化未必会很好，有可能产生“过拟合”现象。</p>
<p>结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略，结构化风险最小化等价于正则化（regularization）。结构风险在经验风险的基础上加上了表示模型复杂度的正则项（regularizer）或惩罚项（penalty term）。在假设空间、损失函数和训练数据集确定的情况下，结构风险定义为：</p>
<p>$$R_{srm}(f)=\frac {1} {N} \sum_{i=1}^N L(y_i,f(x_i)) + \lambda J(f) $$</p>
<p>$J(f)$为模型的复杂度，模型f越复杂，J(f)越大。$\lambda&gt;=0$是权衡经验风险和模型复杂度的系数。</p>
<p>结构风险最小化策略认为，结构风险最小的模型就是最优的模型。求解最优模型就是求解最优化问题：</p>
<p>$$^{min} _{f \in F} \frac {1} {N}  \sum_{i=1}^N L(y_i, f(x_i)) + \lambda J(f) $$</p>
<p>这样，监督学习问题变成了经验风险或结构风险的最优化问题。</p>
<h3 id="1-3-3算法"><a href="#1-3-3算法" class="headerlink" title="1.3.3算法"></a>1.3.3算法</h3><p>算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选取最优模型，然后考虑用什么计算方法求解最有模型。统计学习问题变为了最优化问题，统计学习的算法变味求解最优化问题的算法。如何保证找到全局最优解，并使求解过程非常高效，就称为一个重要问题。</p>
<h2 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h2><h3 id="1-4-1-训练误差与测试误差"><a href="#1-4-1-训练误差与测试误差" class="headerlink" title="1.4.1 训练误差与测试误差"></a>1.4.1 训练误差与测试误差</h3><p>当损失函数给定时，基于损失函数的模型的训练误差和模型的测试误差就自然称为学习方法评估的标准。假设学习到的模型为$ Y=f\hat (X)$，训练误差是模型关于训练数据集的平均损失：</p>
<p>$$R_{emp}(f \hat)=\frac {1} {N} \sum_{i=1}^N L(y_i,f \hat(x_i)) $$</p>
<p>测试误差是关于测试数据集的平均损失：</p>
<p>$$e_{test}(f \hat)=\frac {1} {N \prime} \sum_{i=1}^{N\prime} L(y_i,f \hat(x_i)) $$</p>
<p>N和$N\prime$分别为训练数据集和测试数据集的样本容量。</p>
<p>通常将学习方法对未知数据的预测能力称为泛化能力（generalization ability）。</p>
<h3 id="1-4-2-过拟合和模型选择"><a href="#1-4-2-过拟合和模型选择" class="headerlink" title="1.4.2 过拟合和模型选择"></a>1.4.2 过拟合和模型选择</h3><p>过拟合是指学习时选择的模型包含参数过多，以至于模型对已知数据预测很好，而对未知数据预测很差的现象。模型选择旨在避免过拟合并提供模型的预测能力。模型选择时，不仅要考虑对已知数据的预测能力，而且还要考虑对未知数据的预测能力。下图展示了训练误差、测试误差与模型复杂度之间的关系。当模型复杂度增大时，训练误差会逐渐减少并趋向于0；而测试误差会先减少，达到最小值后又增大。当选择的模型复杂度过大时，过拟合现象就会发生。学习时要防止过拟合，进行最优的模型选择，即选择模型复杂度适当的模型，以使测试误差达到最小。</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/relations.png" alt="训练误差、测试误差与模型复杂度之间的关系"></p>
<h2 id="1-5-正则化与交叉验证"><a href="#1-5-正则化与交叉验证" class="headerlink" title="1.5 正则化与交叉验证"></a>1.5 正则化与交叉验证</h2><h3 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h3><p>模型选择的方法是正则化（regularization）。正则化是结构风险最小化策略的实现，是在经验风险上加上一个正则化项（regularizer）或惩罚项（penalty term）。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。正则化一般具有以下形式：</p>
<p>$$^{min}_{f \in F } \frac {1} {N} \sum_{i=1}^{N} L(y_i,f(x_i)) + \lambda J(f)$$</p>
<p>其中，第一项是经验风险，第二项是正则化项，$\lambda &gt;= 0$为调整两者之间关系的系数。</p>
<p>正则化项可以取不同的形式，回归问题中，损失函数是平方损失，正则化项可以是参数向量的$L_2$范数：</p>
<p>$$L(w)=\frac {1} {N} \sum_{i=1}^{N} (f(x_i;w) - y_i)^2 + \frac {\lambda} {2} ||w||^2$$</p>
<p>$||w||$表示参数向量w的$L_2$范数。正则化项也可以是参数向量的$L_1$范数：</p>
<p>$$L(w)=\frac {1} {N} \sum_{i=1}^{N} (f(x_i;w) - y_i)^2 + \frac {\lambda} {2} ||w||_1$$</p>
<p>$||w|_1$表示参数向量w的$L_1$范数。</p>
<p>正则化的作用是选择经验风险和模型复杂度同时较小的模型。正则化符合奥卡姆剃刀原理：在所有可能选择的模型中，应该选择能够很好的解释已知数据并且十分简单的模型。从贝叶斯估计的角度来看，正则化项对应模型的先验概率，可以假设复杂的模型具有较小的先验概率，简单的模型具有较大的先验概率。</p>
<h3 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h3><p>另一种常用的模型选择方法是交叉验证（cross validation）。如果给定的样本数据充足，进行模型选择的一种简单方法是随机的将数据分为训练集（training set）、测试集（test set）和验证集（validation set）。训练集用来训练模型，测试集用于模型的评估，验证集用于模型的选择。在学习到的模型中，选择对验证集有最小预测误差的模型。当数据集不充足时，可以采用交叉验证的方法。交叉验证的基本思想是重复的使用数据；吧核定的数据分为训练集和测试集，在此基础上进行反复的训练、测试和模型选择。</p>
<p><strong>1.简单交叉验证</strong></p>
<p>简单交叉验证方法是：首先随机地将数据分为两部分——训练集(70%)和测试集(30%)；然后用训练集在各种条件下训练得到不同的模型，在测试集上评价各个模型的测试误差，选择测试误差最小的模型。</p>
<p><strong>2.S折交叉验证</strong></p>
<p>应用最多的是S折交叉验证（S-fold cross validation），首先随机地将数据分为S个互不相交的大小相同的子集，然后利用$S-1$个子集的数据进行训练，用剩下的子集进行测试；重复上述过程，最后选出S次测试中平均测试误差最小的模型。</p>
<p><strong>3.留一交叉验证</strong></p>
<p>S折交叉验证特殊情况是$S=N$，称为留一交叉验证（leave-one cross validation），往往在数据缺乏的情况下使用。</p>
<h2 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h2><h3 id="1-6-1-泛化误差"><a href="#1-6-1-泛化误差" class="headerlink" title="1.6.1 泛化误差"></a>1.6.1 泛化误差</h3><p>学习方法的泛化能力（generalization ability）是指由该方法学习到的模型对未知数据的预测能力，是学习方法本质上最重要的性质。通常采用测试误差来评价学习方法的泛化能力，但这种方法依赖于测试数据，但数据较少时评价结果有可能不可靠。统计学试图从理论上对学习方法的泛化能力进行分析。</p>
<p>首先给出泛化误差的定义，如果学到的模型是$\hat f$，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error）</p>
<p>$$R_{exp}(\hat f)=E_p[L(Y,\hat f(X))] = \int_{x*y}L(y,\hat f(x))P(x,y)dxdy$$</p>
<p>泛化误差反映了学习方法的泛化能力，泛化误差就是所学习到的模型的期望风险。</p>
<h3 id="1-6-2-泛化误差上界"><a href="#1-6-2-泛化误差上界" class="headerlink" title="1.6.2 泛化误差上界"></a>1.6.2 泛化误差上界</h3><p>学习方法的泛化能力分析往往是通过研究误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。泛化误差上界通常具有以下性质：它是样本容量的函数，当样本容量增加时，泛化上界趋向于0；它是假设空间容量的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。</p>
<h2 id="1-7-生成模型和判别模型"><a href="#1-7-生成模型和判别模型" class="headerlink" title="1.7 生成模型和判别模型"></a>1.7 生成模型和判别模型</h2><p>监督学习方法可分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：</p>
<p>$$P(Y|X)=\frac {P(X,Y)} {P(X)}$$</p>
<p>之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。</p>
<p>判别方法由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。典型的判别模型包括：k近邻法、感知机、决策树、逻辑回归模型、最大熵模型、支持向量机、提升方法和条件随机场。</p>
<p>在监督学习中，生成方法和判别方法各有优缺点，适合于不同条件下的学习问题。生成方法的特点：生成方法可以还原出联合概率分布P(X,Y)，而判别方法则不能；生成方法的收敛速度更快，当存在隐变量时，仍可以使用生成方法，此时判别方法不可用。判别方法的特点：判别方法直接学习的是条件概率P(Y|X)或决策函数f(X)，直接面对预测，往往学习的准确率更高；由于直接学习P(Y|X)或f(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</p>
<h2 id="1-8-分类问题"><a href="#1-8-分类问题" class="headerlink" title="1.8 分类问题"></a>1.8 分类问题</h2><p>分类是监督学习的一个核心问题。在监督学习中，当输出变量Y取有限个离散值时，预测问题便称为分类问题。监督学习从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。分类的类别为多个时，称为多分类问题。分类问题包括学习和分类两个过程。学习过程中，根据已知的训练数据集学习一个分类器，分类过程中，根据学习的分类器对新实例进行分类。分类问题如图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/classity_problem.png" alt="分类问题"></p>
<p>精确率的定义为$P=\frac {TP} {TP+FP}$，召回率的定义为$R=\frac {TP} {TP+FN}$，F1值是精确率和召回率的调和均值，公式为$F1=\frac {2PR} {P+R}$。精确率和召回率都高时，F1值也会高。</p>
<h2 id="1-9-标注问题"><a href="#1-9-标注问题" class="headerlink" title="1.9 标注问题"></a>1.9 标注问题</h2><p>标注（tagging）也是一个监督学习问题，可以认为标注问题是分类问题的一个推广，标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。标注问题分为学习和标记过程。学习系统基于训练数据集构建一个模型，表示为条件概率，标注系统按照学习到的条件概率分布模型，对新的输入观测序列找到相应的输出标记序列。标注问题如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/tagging.png" alt="标注问题"></p>
<p>评价标注模型的指标与评价分类模型的指标一样，常用的有标注准确率、精确率和召回率。标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。标注问题在信息抽取、自然语言处理等领域被广泛应用，是这些领域的基本问题。</p>
<h2 id="1-10-回归问题"><a href="#1-10-回归问题" class="headerlink" title="1.10 回归问题"></a>1.10 回归问题</h2><p>回归（regression）是监督学习的另一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生变化。回归模型正是表示从输入变量到输出变量之间的映射的函数。回归问题等价于函数拟合，选择一条函数曲线使其很好地拟合已知数据且很好的预测未知数据。</p>
<p>回归问题分为学习和预测两个过程。学习系统基于训练数据构建一个模型，预测系统根据学习的模型确定相应的输出。回归问题如下图所示：</p>
<p><img src="http://ocs628urt.bkt.clouddn.com/regression.png" alt="回归问题"></p>
<p>回归问题按照变量的个数分为一元回归和多元回归；按照输入变量和输出变量之间关系的类型即模型的类型，分为线性回归和非线性回归。回归学习最常用的损失函数是平方损失函数，此情况下回归问题可以用最小二乘法求解。</p>
]]></content>
    
    <summary type="html">
    
      统计学习方法(一)——统计学习方法概论
    
    </summary>
    
      <category term="机器学习" scheme="noahsnail.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="统计学习方法" scheme="noahsnail.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux查询CPU信息</title>
    <link href="noahsnail.com/2017/03/06/2017-3-6-Linux%E6%9F%A5%E8%AF%A2CPU%E4%BF%A1%E6%81%AF/"/>
    <id>noahsnail.com/2017/03/06/2017-3-6-Linux查询CPU信息/</id>
    <published>2017-03-06T05:44:15.000Z</published>
    <updated>2017-03-06T10:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li><p>物理CPU数<br>主板上实际插入的CPU数量，可以数不重复的physical id 有几个（physical id）</p>
</li>
<li><p>CPU核数<br>单块CPU上面能处理数据的芯片组的数量，如双核、四核等（CPU cores）</p>
</li>
<li><p>逻辑CPU数<br>一般情况下，逻辑CPU数=物理CPU个数<em>每颗核数，如果不相等的话，则表示服务器的CPU支持超线程技术（简单来说，它可使处理器中的1颗内核如2颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时逻辑CPU=物理CPU个数</em>每颗核数*2）</p>
</li>
<li><p>它们之间的关系<br>总核数 = 物理CPU个数 <em> 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 </em> 每颗物理CPU的核数 * 超线程数</p>
</li>
</ul>
<h2 id="2-查看物理CPU的个数"><a href="#2-查看物理CPU的个数" class="headerlink" title="2.查看物理CPU的个数"></a>2.查看物理CPU的个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="3-查看逻辑CPU个数"><a href="#3-查看逻辑CPU个数" class="headerlink" title="3.查看逻辑CPU个数"></a>3.查看逻辑CPU个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</div><div class="line">24</div></pre></td></tr></table></figure>
<h2 id="4-查看CPU核数"><a href="#4-查看CPU核数" class="headerlink" title="4.查看CPU核数"></a>4.查看CPU核数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/cpuinfo |grep &quot;cores&quot;|uniq</div><div class="line">cpu cores       : 6</div></pre></td></tr></table></figure>
<h2 id="5-查看CPU型号信息"><a href="#5-查看CPU型号信息" class="headerlink" title="5.查看CPU型号信息"></a>5.查看CPU型号信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</div><div class="line">     24  Intel(R) Xeon(R) CPU E5-2630L v2 @ 2.40GHz</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux查询CPU信息
    
    </summary>
    
      <category term="Linux" scheme="noahsnail.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="noahsnail.com/tags/Linux/"/>
    
  </entry>
  
</feed>
