<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="noahsnail.com/"/>
  <updated>2018-01-12T10:08:50.000Z</updated>
  <id>noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jupyter Notebook的使用</title>
    <link href="noahsnail.com/2018/01/12/2018-01-12-Jupyter%20Notebook%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>noahsnail.com/2018/01/12/2018-01-12-Jupyter Notebook的快捷键/</id>
    <published>2018-01-12T06:33:19.000Z</published>
    <updated>2018-01-12T10:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Jupyter Notebook有两种不同的键盘输入模式。编辑模式允许输入代码/文本到一个单元格中，并以绿色单元格边框表示，此时命令模式的快捷键不起作用。命令模式将键盘绑定到计算机级别的操作，并由具有蓝色左边距的灰色单元格边框指示，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等，此时编辑模式下的快捷键不起作用。</p>
<h2 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2. 快捷键"></a>2. 快捷键</h2><p>快捷键可以在Jupyter Notebook的顶部<code>Help &gt; Keyboard Shortcuts</code>查看。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-4b1b471b4000769e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mac键盘"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-cd725ab926c6e94c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-af5158fe2348a7bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑模式"></p>
<h2 id="3-设置自动显示变量值"><a href="#3-设置自动显示变量值" class="headerlink" title="3. 设置自动显示变量值"></a>3. 设置自动显示变量值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from IPython.core.interactiveshell import InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = &quot;all&quot;</div></pre></td></tr></table></figure>
<h2 id="4-查看文档"><a href="#4-查看文档" class="headerlink" title="4. 查看文档"></a>4. 查看文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?str.split</div></pre></td></tr></table></figure>
<h2 id="5-展示绘制的图像"><a href="#5-展示绘制的图像" class="headerlink" title="5. 展示绘制的图像"></a>5. 展示绘制的图像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure>
<h2 id="6-查看魔法命令"><a href="#6-查看魔法命令" class="headerlink" title="6. 查看魔法命令"></a>6. 查看魔法命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%lsmagic</div></pre></td></tr></table></figure>
<p><a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="external">魔法命令文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># 设置环境变量</div><div class="line">%env TEST = &apos;test&apos;</div><div class="line"></div><div class="line"># 执行其它的ipynb文件</div><div class="line">%run ./a.ipynb</div><div class="line"></div><div class="line"># 导入文件内容</div><div class="line">%load utils.py</div><div class="line"></div><div class="line"></div><div class="line"># 列出所有的全局变量(str类型)</div><div class="line">%who str</div><div class="line"></div><div class="line"># 显示当前代码的执行时间</div><div class="line">%%time</div><div class="line"></div><div class="line"># 执行当前代码100000次，显示最快三次的均值</div><div class="line">%%timeit</div><div class="line"></div><div class="line"># 将当前单元的代码输出到文件中</div><div class="line">%%writefile a.py</div><div class="line"></div><div class="line"># 显示文件内容</div><div class="line">%pycat a.py</div><div class="line"></div><div class="line"># 执行shell命令，以!开头</div><div class="line">!ls</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/" target="_blank" rel="external">https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/</a></p>
]]></content>
    
    <summary type="html">
    
      Jupyter Notebook的使用
    
    </summary>
    
      <category term="Python" scheme="noahsnail.com/categories/Python/"/>
    
    
      <category term="Python" scheme="noahsnail.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu的apt-file解决依赖问题</title>
    <link href="noahsnail.com/2018/01/12/2018-01-12-Ubuntu%E7%9A%84apt-file%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>noahsnail.com/2018/01/12/2018-01-12-Ubuntu的apt-file解决依赖问题/</id>
    <published>2018-01-12T06:00:47.000Z</published>
    <updated>2018-01-12T06:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>平常我们在安装应用时，经常会碰到缺少各种文件、依赖等问题，例如缺少<code>.so</code>文件。Ubuntu中提供了一个强大的工具<code>apt-file</code>来查找依赖。最适合的场景是在Docker中使用，因为Docker Image的系统通常是Ubuntu。</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p><code>apt-file</code>的安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Install</div><div class="line">$ apt-get update</div><div class="line">$ apt-get install apt-file</div><div class="line"></div><div class="line"># Update apt-file</div><div class="line">$ apt-file update</div></pre></td></tr></table></figure>
<h2 id="3-搜索缺少的文件"><a href="#3-搜索缺少的文件" class="headerlink" title="3. 搜索缺少的文件"></a>3. 搜索缺少的文件</h2><p>如果缺少<code>cv.py</code>文件，则搜索<code>cv.py</code>文件，<code>apt-file</code>会列出包含<code>cv.py</code>的包，发现需要的包是<code>python-opencv</code>，然后安装<code>ython-opencv</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># 命令格式</div><div class="line">$ apt-file seach [filename]</div><div class="line"></div><div class="line"># Demo</div><div class="line">$ apt-file search cv.py</div><div class="line">gnuradio: /usr/lib/python2.7/dist-packages/gnuradio/analog/wfm_rcv.py</div><div class="line">gnuradio: /usr/share/gnuradio/examples/uhd/usrp_am_mw_rcv.py</div><div class="line">gnuradio: /usr/share/gnuradio/examples/uhd/usrp_nbfm_rcv.py</div><div class="line">gnuradio: /usr/share/gnuradio/examples/uhd/usrp_tv_rcv.py</div><div class="line">gnuradio: /usr/share/gnuradio/examples/uhd/usrp_wfm_rcv.py</div><div class="line">gnuradio: /usr/share/gnuradio/examples/uhd/usrp_wxapt_rcv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/db_recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/direct_recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/messenger/recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/reactor/recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/selected_recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/simple_recv.py</div><div class="line">libqpid-proton2-dev-examples: /usr/share/proton-0.10/examples/python/tx_recv.py</div><div class="line">lowpan-test-tools: /usr/lib/x86_64-linux-gnu/lowpan-tools/test_recv.py</div><div class="line">python-kivy: /usr/lib/python2.7/dist-packages/kivy/core/camera/camera_opencv.py</div><div class="line">python-mvpa2-doc: /usr/share/doc/python-mvpa2-doc/examples/nested_cv.py</div><div class="line">python-opencv: /usr/lib/python2.7/dist-packages/cv.py</div><div class="line">python-pyavm: /usr/lib/python2.7/dist-packages/pyavm/cv.py</div><div class="line">python-pysnmp4: /usr/lib/python2.7/dist-packages/pysnmp/entity/rfc3413/ntfrcv.py</div><div class="line">python-pysnmp4: /usr/share/pyshared/pysnmp/entity/rfc3413/ntfrcv.py</div><div class="line">python-pysnmp4-doc: /usr/share/doc/python-pysnmp4-doc/examples/v1arch/manager/ntfrcv.py</div><div class="line">python-scapy: /usr/lib/python2.7/dist-packages/scapy/sendrecv.py</div><div class="line">python-scapy: /usr/share/pyshared/scapy/sendrecv.py</div><div class="line">python3-kivy: /usr/lib/python3/dist-packages/kivy/core/camera/camera_opencv.py</div><div class="line">python3-pyavm: /usr/lib/python3/dist-packages/pyavm/cv.py</div><div class="line">python3-pysnmp4: /usr/lib/python3/dist-packages/pysnmp/entity/rfc3413/ntfrcv.py</div></pre></td></tr></table></figure>
<h2 id="4-列出包中的文件"><a href="#4-列出包中的文件" class="headerlink" title="4. 列出包中的文件"></a>4. 列出包中的文件</h2><p>查看<code>python-opencv</code>中的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"># 命令格式</div><div class="line">$ apt-file list [package name]</div><div class="line"></div><div class="line"># Demo</div><div class="line">$ apt-file list python-opencv</div><div class="line">python-opencv: /usr/lib/python2.7/dist-packages/cv.py</div><div class="line">python-opencv: /usr/lib/python2.7/dist-packages/cv2.x86_64-linux-gnu.so</div><div class="line">python-opencv: /usr/share/doc/python-opencv/changelog.Debian.gz</div><div class="line">python-opencv: /usr/share/doc/python-opencv/copyright</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/__init__.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/CamShiftConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/ContourMomentsConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/ConvexHullConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/EdgeDetectionConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/FBackFlowConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/FaceDetectionConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/FindContoursConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/GeneralContoursConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/GoodfeatureTrackConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/HoughCirclesConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/HoughLinesConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/LKFlowConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/PeopleDetectConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/PhaseCorrConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/SegmentObjectsConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/SimpleFlowConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/WatershedSegmentationConfig.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/cfg/__init__.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Circle.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_CircleArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_CircleArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Contour.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_ContourArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_ContourArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Face.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_FaceArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_FaceArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Flow.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_FlowArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_FlowArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_FlowStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Line.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_LineArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_LineArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Moment.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_MomentArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_MomentArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Point2D.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Point2DArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Point2DArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Point2DStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Rect.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RectArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RectArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RotatedRect.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RotatedRectArray.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RotatedRectArrayStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_RotatedRectStamped.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/_Size.py</div><div class="line">python-opencv-apps: /usr/lib/python2.7/dist-packages/opencv_apps/msg/__init__.py</div><div class="line">python-opencv-apps: /usr/share/doc/python-opencv-apps/changelog.Debian.gz</div><div class="line">python-opencv-apps: /usr/share/doc/python-opencv-apps/copyright</div></pre></td></tr></table></figure>
<h2 id="5-其它系统"><a href="#5-其它系统" class="headerlink" title="5. 其它系统"></a>5. 其它系统</h2><p>在其它系统中，例如CentOS中，可以用<code>yum whatprovides</code>命令来查询命令所在的包。</p>
]]></content>
    
    <summary type="html">
    
      Ubuntu的apt-file解决依赖问题
    
    </summary>
    
      <category term="Linux" scheme="noahsnail.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="noahsnail.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python设置系统默认编码</title>
    <link href="noahsnail.com/2018/01/12/2018-01-12-Python%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%BC%96%E7%A0%81/"/>
    <id>noahsnail.com/2018/01/12/2018-01-12-Python设置系统默认编码/</id>
    <published>2018-01-12T03:20:43.000Z</published>
    <updated>2018-01-12T03:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>Python默认的系统编码为ASCII编码，在日程的编码中经常会碰到Python的编码问题，为了一劳永逸的解决这个问题，可以将Python的系统默认编码设置为<code>utf-8</code>。</p>
<ul>
<li>常见错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position</div></pre></td></tr></table></figure>
<ul>
<li>查看系统默认编码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.getdefaultencoding()</div></pre></td></tr></table></figure>
<ul>
<li>修改系统默认编码<br>在<code>site-packages</code>文件夹下建立<code>sitecustomize.py</code>文件，文件内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys  </div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div></pre></td></tr></table></figure>
<ul>
<li>site-packages的目录</li>
</ul>
<p>anaconda目录通常为<code>yourpath/anaconda/lib/python2.7/site-packages</code>。<br>Mac目录通常为<code>/usr/local/lib/python2.7/site-packages</code>。</p>
]]></content>
    
    <summary type="html">
    
      Python设置系统默认编码
    
    </summary>
    
      <category term="Python" scheme="noahsnail.com/categories/Python/"/>
    
    
      <category term="Python" scheme="noahsnail.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>求1000000以内的素数</title>
    <link href="noahsnail.com/2018/01/09/2018-01-09-%E6%B1%821000000%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/"/>
    <id>noahsnail.com/2018/01/09/2018-01-09-求1000000以内的素数/</id>
    <published>2018-01-09T10:57:49.000Z</published>
    <updated>2018-01-09T11:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-素数"><a href="#1-素数" class="headerlink" title="1. 素数"></a>1. 素数</h2><p>质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为合数。</p>
<h2 id="2-求1000000以内的素数"><a href="#2-求1000000以内的素数" class="headerlink" title="2. 求1000000以内的素数"></a>2. 求1000000以内的素数</h2><ul>
<li>方法一 遍历法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 1000000</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">clock_t</span> start, end;</div><div class="line">    <span class="keyword">double</span> duration;</div><div class="line">    start = clock();</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= NUM; i++) &#123;</div><div class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j == i) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    end = clock();</div><div class="line">    duration = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f seconds.\n"</span>, duration);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：上面的方法最容易想到，但同时效率也最低。其运行时间：<code>133.186849 seconds.</code>。</p>
<ul>
<li>方法二 在上面的基础上进行改进</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 1000000</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">clock_t</span> start, end;</div><div class="line">    <span class="keyword">double</span> duration;</div><div class="line">    start = clock();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= NUM; i += <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(j = <span class="number">3</span>; j &lt; i; j += <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span> || j * j &gt; i) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j * j &gt; i) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    end = clock();</div><div class="line">    duration = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f seconds.\n"</span>, duration);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：在上面的基础上，首先我们可以确定除了2之外的偶数都可以排除，同时如果执行到某个数的平方根（邻近的整数）都不能被其整除，则其后的数字都不能被其整除，如果可以整除，则另一个因子必定在平方根之前的数中。其运行时间：<code>0.194340 seconds.</code>。</p>
<ul>
<li>方法三 筛法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 1000000</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> is_prime[NUM + <span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">clock_t</span> start, end;</div><div class="line">    <span class="keyword">double</span> duration;</div><div class="line">    start = clock();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; NUM; m++) &#123;</div><div class="line">        is_prime[m] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= NUM; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(is_prime[i]) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; NUM; j += i) &#123;</div><div class="line">                is_prime[j] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= NUM; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(is_prime[i]) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    end = clock();</div><div class="line">    duration = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f seconds.\n"</span>, duration);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：筛法是指假设所有数都为素数，然后遍历，如果其为素数，则其倍数皆为和数，遍历所有数即可。其运行时间：<code>0.021246 seconds.</code>。</p>
<p><strong>总结：</strong>从上面的运行时间可以看出，不同的方法运行时间差异非常大，代码要注意优化。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（一）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      求1000000以内的素数
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="素数" scheme="noahsnail.com/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSH的介绍与应用</title>
    <link href="noahsnail.com/2018/01/07/2018-01-07-SSH%E5%BA%94%E7%94%A8/"/>
    <id>noahsnail.com/2018/01/07/2018-01-07-SSH应用/</id>
    <published>2018-01-07T14:07:16.000Z</published>
    <updated>2018-01-08T11:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-什么是SSH"><a href="#1-什么是SSH" class="headerlink" title="1. 什么是SSH"></a>1. 什么是SSH</h2><p>SSH是一种网络协议，主要用于计算机之间的加密登录，默认端口为22。具体可参考<a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="external">Secure Shell</a>。</p>
<h2 id="2-远程登录"><a href="#2-远程登录" class="headerlink" title="2. 远程登录"></a>2. 远程登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh user@host</div></pre></td></tr></table></figure>
<p><code>user</code>是远程服务器的用户名，<code>host</code>是远程服务器的地址，可以是IP。</p>
<h2 id="3-免密码登录"><a href="#3-免密码登录" class="headerlink" title="3. 免密码登录"></a>3. 免密码登录</h2><p>如果需要免密码登录，则需要配置SSH KEY。生成SSH KEY的方法可以参考<a href="http://noahsnail.com/2016/08/31/2016-9-1-Git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/">Git多用户配置</a>。</p>
<p>生成SSH KEY之后，将自己的<code>id_rsa.pub</code>拷贝到远程服务器的<code>.ssh</code>目录，执行<code>cat id_rsa.pub &gt;&gt; authorized_keys</code>。</p>
<p>然后在本地的<code>.ssh</code>目录下编辑<code>config</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host abc</div><div class="line">   port 22 </div><div class="line">   User server_name</div><div class="line">   Hostname server_address</div><div class="line">   IdentityFile ~/.ssh/id_rsa</div></pre></td></tr></table></figure>
<p><code>Host</code>是给远程服务器起的名字，<code>User</code>是远程服务器的用户名，<code>port</code>是SSH端口，<code>Hostname</code>是远程服务器的地址，<code>IdentityFile</code>是本地的验证文件，与拷贝到远程服务器上的<code>id_rsa.pub</code>相对应。</p>
<p>此时连接远程服务器只需执行<code>ssh abc</code>即可，不需要再输入密码了。</p>
<h2 id="4-远程操作"><a href="#4-远程操作" class="headerlink" title="4. 远程操作"></a>4. 远程操作</h2><ul>
<li>在远程机器上执行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh user@host &apos;mkdir test_ssh&apos;</div></pre></td></tr></table></figure>
<p><code>&#39;&#39;</code>里的内容是在远程服务器上执行的命令，即在远程服务器上创建一个<code>test_ssh</code>目录。</p>
<h2 id="5-端口转发"><a href="#5-端口转发" class="headerlink" title="5. 端口转发"></a>5. 端口转发</h2><ul>
<li>背景</li>
</ul>
<p>现在有三台机器，本地机器称为A，中转机器称为B，服务器称为C。A可以访问B，B可以访问C，但是A不能直接访问C。大公司的服务器通常是这样，不可以直接访问，需要通过一层Gateway，即中转机器B来访问C。</p>
<p>假设在服务器C上启动了一个jupyter-notebook，但没法直接在服务器上直接操作，此时就需要端口转发。</p>
<ul>
<li>流程</li>
</ul>
<p>首先需要将C的端口8888转发到B上，端口也为8888。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 命令在B机器上执行</div><div class="line">$ ssh C_user@C_host -L 8888:localhost:8888</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ ssh -L 8888:localhost:8888 C_user@C_host</div></pre></td></tr></table></figure>
<p>具体解析为：<code>-L 本地网卡地址:本地端口:目标地址:目标端口</code>，即<code>-L localhost:8888:localhost:8888</code>，前一个<code>localhost:8888</code>表示本机的本地端口，后一个<code>localhost:8888</code>表示服务器的本地端口，意思是将服务器的端口<code>localhost:8888</code>，即C的端口8888转发到B的端口8888，这意味着在B上可以通过<code>localhost:8888</code>访问C的<code>localhost:8888</code>。本地网卡地址<code>localhost</code>通常可省略。</p>
<p>通过上一步将C的8888转到B的8888了，下一步同理将B的8888转到本机A的8888端口上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 命令在A机器上执行</div><div class="line">$ ssh B_user@B_host -L 8888:localhost:8888</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ ssh -L 8888:localhost:8888 B_user@B_host</div></pre></td></tr></table></figure>
<p>此时，在本地浏览器输入<code>localhost:8888</code>即可访问到C服务器上的jupyter-notebook。</p>
<p>上面的端口转发称为本地端口转发，即本地机器A访问的8888端口转发到B机器的8888端口，B再将它的8888端口转发到C的8888端口，此时A通过B访问到了C。</p>
<p>远程端口转发正好反过来，即C通过B访问本机A的8888端口。远程端口转发命令为<code>-R 远程网卡地址:远程端口:目标地址:目标端口</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/" target="_blank" rel="external">https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      SSH的介绍与应用
    
    </summary>
    
      <category term="Linux" scheme="noahsnail.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="noahsnail.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac下图像标注工具labelImg的安装</title>
    <link href="noahsnail.com/2018/01/05/2017-01-05-Mac%E4%B8%8B%E5%9B%BE%E5%83%8F%E6%A0%87%E6%B3%A8%E5%B7%A5%E5%85%B7labelImg%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>noahsnail.com/2018/01/05/2017-01-05-Mac下图像标注工具labelImg的安装/</id>
    <published>2018-01-05T05:42:47.000Z</published>
    <updated>2018-01-05T05:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>目标检测时需要对训练数据进行标注，标注工具为labelImg，其在Mac下的安装教程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Install PyQt4, it must be this version</div><div class="line">brew install cartr/qt4/pyqt</div><div class="line">  </div><div class="line">brew install libxml2</div><div class="line">  </div><div class="line">pip install labelImg</div><div class="line">  </div><div class="line"># Run</div><div class="line">labelImg</div></pre></td></tr></table></figure>
<p>其它版本的安装参考：<a href="http://tzutalin.github.io/labelImg/" target="_blank" rel="external">http://tzutalin.github.io/labelImg/</a>。<br>Github地址：<a href="https://github.com/tzutalin/labelImg" target="_blank" rel="external">https://github.com/tzutalin/labelImg</a>。</p>
]]></content>
    
    <summary type="html">
    
      Mac下图像标注工具labelImg的安装
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Faster R-CNN论文翻译——中英文对照</title>
    <link href="noahsnail.com/2018/01/03/2018-01-03-Faster%20R-CNN%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
    <id>noahsnail.com/2018/01/03/2018-01-03-Faster R-CNN论文翻译——中英文对照/</id>
    <published>2018-01-03T03:40:43.000Z</published>
    <updated>2018-01-12T10:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="Faster-R-CNN-Towards-Real-Time-Object-Detection-with-Region-Proposal-Networks"><a href="#Faster-R-CNN-Towards-Real-Time-Object-Detection-with-Region-Proposal-Networks" class="headerlink" title="Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks"></a>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>State-of-the-art object detection networks depend on region proposal algorithms to hypothesize object locations. Advances like SPPnet [1] and Fast R-CNN [2] have reduced the running time of these detection networks, exposing region proposal computation as a bottleneck. In this work, we introduce a Region Proposal Network (RPN) that shares full-image convolutional features with the detection network, thus enabling nearly cost-free region proposals. An RPN is a fully convolutional network that simultaneously predicts object bounds and objectness scores at each position. The RPN is trained end-to-end to generate high-quality region proposals, which are used by Fast R-CNN for detection. We further merge RPN and Fast R-CNN into a single network by sharing their convolutional features——using the recently popular terminology of neural networks with “attention” mechanisms, the RPN component tells the unified network where to look. For the very deep VGG-16 model [3], our detection system has a frame rate of 5fps (including all steps) on a GPU, while achieving state-of-the-art object detection accuracy on PASCAL VOC 2007, 2012, and MS COCO datasets with only 300 proposals per image. In ILSVRC and COCO 2015 competitions, Faster R-CNN and RPN are the foundations of the 1st-place winning entries in several tracks. Code has been made publicly available.</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最先进的目标检测网络依靠区域提出算法来假设目标的位置。SPPnet[1]和Fast R-CNN[2]等研究已经减少了这些检测网络的运行时间，使得区域提出计算成为一个瓶颈。在这项工作中，我们引入了一个区域提出网络（RPN），该网络与检测网络共享全图像的卷积特征，从而使近乎零成本的区域提出成为可能。RPN是一个全卷积网络，可以同时在每个位置预测目标边界和目标分数。RPN经过端到端的训练，可以生成高质量的区域提出，由Fast R-CNN用于检测。我们将RPN和Fast R-CNN通过共享卷积特征进一步合并为一个单一的网络——使用最近流行的具有“注意力”机制的神经网络术语，RPN组件告诉统一网络在哪里寻找。对于非常深的VGG-16模型[3]，我们的检测系统在GPU上的帧率为5fps（包括所有步骤），同时在PASCAL VOC 2007，2012和MS COCO数据集上实现了最新的目标检测精度，每个图像只有300个提出。在ILSVRC和COCO 2015竞赛中，Faster R-CNN和RPN是多个比赛中获得第一名输入的基础。代码可公开获得。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Recent advances in object detection are driven by the success of region proposal methods (e.g., [4]) and region-based convolutional neural networks (R-CNNs) [5]. Although region-based CNNs were computationally expensive as originally developed in [5], their cost has been drastically reduced thanks to sharing convolutions across proposals [1], [2]. The latest incarnation, Fast R-CNN [2], achieves near real-time rates using very deep networks [3], <em>when ignoring the time spent on region proposals</em>. Now, proposals are the test-time computational bottleneck in state-of-the-art detection systems.</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>目标检测的最新进展是由区域提出方法（例如[4]）和基于区域的卷积神经网络（R-CNN）[5]的成功驱动的。尽管在[5]中最初开发的基于区域的CNN计算成本很高，但是由于在各种提议中共享卷积，所以其成本已经大大降低了[1]，[2]。<em>忽略花费在区域提议上的时间</em>，最新版本Fast R-CNN[2]利用非常深的网络[3]实现了接近实时的速率。现在，提议是最新的检测系统中测试时间的计算瓶颈。</p>
<p>Region proposal methods typically rely on inexpensive features and economical inference schemes. Selective Search [4], one of the most popular methods, greedily merges superpixels based on engineered low-level features. Yet when compared to efficient detection networks [2], Selective Search is an order of magnitude slower, at 2 seconds per image in a CPU implementation. EdgeBoxes [6] currently provides the best tradeoff between proposal quality and speed, at 0.2 seconds per image. Nevertheless, the region proposal step still consumes as much running time as the detection network.</p>
<p>区域提议方法通常依赖廉价的特征和简练的推断方案。选择性搜索[4]是最流行的方法之一，它贪婪地合并基于设计的低级特征的超级像素。然而，与有效的检测网络[2]相比，选择性搜索速度慢了一个数量级，在CPU实现中每张图像的时间为2秒。EdgeBoxes[6]目前提供了在提议质量和速度之间的最佳权衡，每张图像0.2秒。尽管如此，区域提议步骤仍然像检测网络那样消耗同样多的运行时间。</p>
<p>One may note that fast region-based CNNs take advantage of GPUs, while the region proposal methods used in research are implemented on the CPU, making such runtime comparisons inequitable. An obvious way to accelerate proposal computation is to re-implement it for the GPU. This may be an effective engineering solution, but re-implementation ignores the down-stream detection network and therefore misses important opportunities for sharing computation.</p>
<p>有人可能会注意到，基于区域的快速CNN利用GPU，而在研究中使用的区域提议方法在CPU上实现，使得运行时间比较不公平。加速区域提议计算的一个显而易见的方法是将其在GPU上重新实现。这可能是一个有效的工程解决方案，但重新实现忽略了下游检测网络，因此错过了共享计算的重要机会。</p>
<p>In this paper, we show that an algorithmic change——computing proposals with a deep convolutional neural network——leads to an elegant and effective solution where proposal computation is nearly cost-free given the detection network’s computation. To this end, we introduce novel <em>Region Proposal Networks</em> (RPNs) that share convolutional layers with state-of-the-art object detection networks [1], [2]. By sharing convolutions at test-time, the marginal cost for computing proposals is small (e.g., 10ms per image).</p>
<p>在本文中，我们展示了算法的变化——用深度卷积神经网络计算区域提议——导致了一个优雅和有效的解决方案，其中在给定检测网络计算的情况下区域提议计算接近领成本。为此，我们引入了新的<em>区域提议网络</em>（RPN），它们共享最先进目标检测网络的卷积层[1]，[2]。通过在测试时共享卷积，计算区域提议的边际成本很小（例如，每张图像10ms）。</p>
<p>Our observation is that the convolutional feature maps used by region-based detectors, like Fast R-CNN, can also be used for generating region proposals. On top of these convolutional features, we construct an RPN by adding a few additional convolutional layers that simultaneously regress region bounds and objectness scores at each location on a regular grid. The RPN is thus a kind of fully convolutional network (FCN) [7] and can be trained end-to-end specifically for the task for generating detection proposals.</p>
<p>我们的观察是，基于区域的检测器所使用的卷积特征映射，如Fast R-CNN，也可以用于生成区域提议。在这些卷积特征之上，我们通过添加一些额外的卷积层来构建RPN，这些卷积层同时在规则网格上的每个位置上回归区域边界和目标分数。因此RPN是一种全卷积网络（FCN）[7]，可以针对生成检测区域建议的任务进行端到端的训练。</p>
<p>RPNs are designed to efficiently predict region proposals with a wide range of scales and aspect ratios. In contrast to prevalent methods [8], [9], [1], [2] that use pyramids of images (Figure 1, a) or pyramids of filters (Figure 1, b), we introduce novel “anchor” boxes that serve as references at multiple scales and aspect ratios. Our scheme can be thought of as a pyramid of regression references (Figure 1, c), which avoids enumerating images or filters of multiple scales or aspect ratios. This model performs well when trained and tested using single-scale images and thus benefits running speed.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c642d73ad24cb3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p>Figure 1: Different schemes for addressing multiple scales and sizes. (a) Pyramids of images and feature maps are built, and the classifier is run at all scales. (b) Pyramids of filters with multiple scales/sizes are run on the feature map. (c) We use pyramids of reference boxes in the regression functions.</p>
<p>RPN旨在有效预测具有广泛尺度和长宽比的区域提议。与使用图像金字塔（图1，a）或滤波器金字塔（图1，b）的流行方法[8]，[9]，[1]相比，我们引入新的“锚”盒作为多种尺度和长宽比的参考。我们的方案可以被认为是回归参考金字塔（图1，c），它避免了枚举多种比例或长宽比的图像或滤波器。这个模型在使用单尺度图像进行训练和测试时运行良好，从而有利于运行速度。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c642d73ad24cb3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p>图1：解决多尺度和尺寸的不同方案。（a）构建图像和特征映射金字塔，分类器以各种尺度运行。（b）在特征映射上运行具有多个比例/大小的滤波器的金字塔。（c）我们在回归函数中使用参考边界框金字塔。</p>
<p>To unify RPNs with Fast R-CNN [2] object detection networks, we propose a training scheme that alternates between fine-tuning for the region proposal task and then fine-tuning for object detection, while keeping the proposals fixed. This scheme converges quickly and produces a unified network with convolutional features that are shared between both tasks.</p>
<p>为了将RPN与Fast R-CNN 2]目标检测网络相结合，我们提出了一种训练方案，在微调区域提议任务和微调目标检测之间进行交替，同时保持区域提议的固定。该方案快速收敛，并产生两个任务之间共享的具有卷积特征的统一网络。</p>
<p>We comprehensively evaluate our method on the PASCAL VOC detection benchmarks [11] where RPNs with Fast R-CNNs produce detection accuracy better than the strong baseline of Selective Search with Fast R-CNNs. Meanwhile, our method waives nearly all computational burdens of Selective Search at test-time——the effective running time for proposals is just 10 milliseconds. Using the expensive very deep models of [3], our detection method still has a frame rate of 5fps (including all steps) on a GPU, and thus is a practical object detection system in terms of both speed and accuracy. We also report results on the MS COCO dataset [12] and investigate the improvements on PASCAL VOC using the COCO data. Code has been made publicly available at <a href="https://github.com/shaoqingren/faster_rcnn" target="_blank" rel="external">https://github.com/shaoqingren/faster_rcnn</a> (in MATLAB) and <a href="https://github.com/rbgirshick/py-faster-rcnn" target="_blank" rel="external">https://github.com/rbgirshick/py-faster-rcnn</a> (in Python).</p>
<p>我们在PASCAL VOC检测基准数据集上[11]综合评估了我们的方法，其中具有Fast R-CNN的RPN产生的检测精度优于使用选择性搜索的Fast R-CNN的强基准。同时，我们的方法在测试时几乎免除了选择性搜索的所有计算负担——区域提议的有效运行时间仅为10毫秒。使用[3]的昂贵的非常深的模型，我们的检测方法在GPU上仍然具有5fps的帧率（包括所有步骤），因此在速度和准确性方面是实用的目标检测系统。我们还报告了在MS COCO数据集上[12]的结果，并使用COCO数据研究了在PASCAL VOC上的改进。代码可公开获得<a href="https://github.com/shaoqingren/faster_rcnn" target="_blank" rel="external">https://github.com/shaoqingren/faster_rcnn</a>（在MATLAB中）和<a href="https://github.com/rbgirshick/py-faster-rcnn" target="_blank" rel="external">https://github.com/rbgirshick/py-faster-rcnn</a>（在Python中）。</p>
<p>A preliminary version of this manuscript was published previously [10]. Since then, the frameworks of RPN and Faster R-CNN have been adopted and generalized to other methods, such as 3D object detection [13], part-based detection [14], instance segmentation [15], and image captioning [16]. Our fast and effective object detection system has also been built in commercial systems such as at Pinterests [17], with user engagement improvements reported.</p>
<p>这个手稿的初步版本是以前发表的[10]。从那时起，RPN和Faster R-CNN的框架已经被采用并推广到其他方法，如3D目标检测[13]，基于部件的检测[14]，实例分割[15]和图像标题[16]。我们快速和有效的目标检测系统也已经在Pinterest[17]的商业系统中建立了，并报告了用户参与度的提高。</p>
<p>In ILSVRC and COCO 2015 competitions, Faster R-CNN and RPN are the basis of several 1st-place entries [18] in the tracks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation. RPNs completely learn to propose regions from data, and thus can easily benefit from deeper and more expressive features (such as the 101-layer residual nets adopted in [18]). Faster R-CNN and RPN are also used by several other leading entries in these competitions. These results suggest that our method is not only a cost-efficient solution for practical usage, but also an effective way of improving object detection accuracy.</p>
<p>在ILSVRC和COCO 2015竞赛中，Faster R-CNN和RPN是ImageNet检测，ImageNet定位，COCO检测和COCO分割中几个第一名参赛者[18]的基础。RPN完全从数据中学习提议区域，因此可以从更深入和更具表达性的特征（例如[18]中采用的101层残差网络）中轻松获益。Faster R-CNN和RPN也被这些比赛中的其他几个主要参赛者所使用。这些结果表明，我们的方法不仅是一个实用合算的解决方案，而且是一个提高目标检测精度的有效方法。</p>
<h2 id="2-RELATED-WORK"><a href="#2-RELATED-WORK" class="headerlink" title="2. RELATED WORK"></a>2. RELATED WORK</h2><p><strong>Object Proposals</strong>. There is a large literature on object proposal methods. Comprehensive surveys and comparisons of object proposal methods can be found in [19], [20], [21]. Widely used object proposal methods include those based on grouping super-pixels (e.g., Selective Search [4], CPMC [22], MCG [23]) and those based on sliding windows (e.g., objectness in windows [24], EdgeBoxes [6]). Object proposal methods were adopted as external modules independent of the detectors (e.g., Selective Search [4] object detectors, R-CNN [5], and Fast R-CNN [2]).</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><p><strong>目标提议</strong>。目标提议方法方面有大量的文献。目标提议方法的综合调查和比较可以在[19]，[20]，[21]中找到。广泛使用的目标提议方法包括基于超像素分组（例如，选择性搜索[4]，CPMC[22]，MCG[23]）和那些基于滑动窗口的方法（例如窗口中的目标[24]，EdgeBoxes[6]）。目标提议方法被采用为独立于检测器（例如，选择性搜索[4]目标检测器，R-CNN[5]和Fast R-CNN[2]）的外部模块。</p>
<p>Deep Networks for Object Detection. The R-CNN method [5] trains CNNs end-to-end to classify the proposal regions into object categories or background. R-CNN mainly plays as a classifier, and it does not predict object bounds (except for refining by bounding box regression). Its accuracy depends on the performance of the region proposal module (see comparisons in [20]). Several papers have proposed ways of using deep networks for predicting object bounding boxes [25], [9], [26], [27]. In the OverFeat method [9], a fully-connected layer is trained to predict the box coordinates for the localization task that assumes a single object. The fully-connected layer is then turned into a convolutional layer for detecting multiple classspecific objects. The MultiBox methods [26], [27] generate region proposals from a network whose last fully-connected layer simultaneously predicts multiple class-agnostic boxes, generalizing the “single-box” fashion of OverFeat. These class-agnostic boxes are used as proposals for R-CNN [5]. The MultiBox proposal network is applied on a single image crop or multiple large image crops (e.g., 224×224), in contrast to our fully convolutional scheme. MultiBox does not share features between the proposal and detection networks. We discuss OverFeat and MultiBox in more depth later in context with our method. Concurrent with our work, the DeepMask method [28] is developed for learning segmentation proposals.</p>
<p>用于目标检测的深度网络。R-CNN方法[5]端到端地对CNN进行训练，将提议区域分类为目标类别或背景。R-CNN主要作为分类器，并不能预测目标边界（除了通过边界框回归进行细化）。其准确度取决于区域提议模块的性能（参见[20]中的比较）。一些论文提出了使用深度网络来预测目标边界框的方法[25]，[9]，[26]，[27]。在OverFeat方法[9]中，训练一个全连接层来预测假定单个目标定位任务的边界框坐标。然后将全连接层变成卷积层，用于检测多个类别的目标。MultiBox方法[26]，[27]从网络中生成区域提议，网络最后的全连接层同时预测多个类别不相关的边界框，并推广到OverFeat的“单边界框”方式。这些类别不可知的边界框框被用作R-CNN的提议区域[5]。与我们的全卷积方案相比，MultiBox提议网络适用于单张裁剪图像或多张大型裁剪图像（例如224×224）。MultiBox在提议区域和检测网络之间不共享特征。稍后在我们的方法上下文中会讨论OverFeat和MultiBox。与我们的工作同时进行的，DeepMask方法[28]是为学习分割提议区域而开发的。</p>
<p>Shared computation of convolutions [9], [1], [29], [7], [2] has been attracting increasing attention for efficient, yet accurate, visual recognition. The OverFeat paper [9] computes convolutional features from an image pyramid for classification, localization, and detection. Adaptively-sized pooling (SPP) [1] on shared convolutional feature maps is developed for efficient region-based object detection [1], [30] and semantic segmentation [29]. Fast R-CNN [2] enables end-to-end detector training on shared convolutional features and shows compelling accuracy and speed.</p>
<p>卷积[9]，[1]，[29]，[7]，[2]的共享计算已经越来越受到人们的关注，因为它可以有效而准确地进行视觉识别。OverFeat论文[9]计算图像金字塔的卷积特征用于分类，定位和检测。共享卷积特征映射的自适应大小池化（SPP）[1]被开发用于有效的基于区域的目标检测[1]，[30]和语义分割[29]。Fast R-CNN[2]能够对共享卷积特征进行端到端的检测器训练，并显示出令人信服的准确性和速度。</p>
<h2 id="3-FASTER-R-CNN"><a href="#3-FASTER-R-CNN" class="headerlink" title="3. FASTER R-CNN"></a>3. FASTER R-CNN</h2><p>Our object detection system, called Faster R-CNN, is composed of two modules. The first module is a deep fully convolutional network that proposes regions, and the second module is the Fast R-CNN detector [2] that uses the proposed regions. The entire system is a single, unified network for object detection (Figure 2). Using the recently popular terminology of neural networks with <code>attention</code> [31] mechanisms, the RPN module tells the Fast R-CNN module where to look. In Section 3.1 we introduce the designs and properties of the network for region proposal. In Section 3.2 we develop algorithms for training both modules with features shared.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-98e52746671d844a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p>Figure 2: Faster R-CNN is a single, unified network for object detection. The RPN module serves as the ‘attention’ of this unified network.</p>
<h2 id="3-FASTER-R-CNN-1"><a href="#3-FASTER-R-CNN-1" class="headerlink" title="3. FASTER R-CNN"></a>3. FASTER R-CNN</h2><p>我们的目标检测系统，称为Faster R-CNN，由两个模块组成。第一个模块是提议区域的深度全卷积网络，第二个模块是使用提议区域的Fast R-CNN检测器[2]。整个系统是一个单个的，统一的目标检测网络（图2）。使用最近流行的“注意力”[31]机制的神经网络术语，RPN模块告诉Fast R-CNN模块在哪里寻找。在第3.1节中，我们介绍了区域提议网络的设计和属性。在第3.2节中，我们开发了用于训练具有共享特征模块的算法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-98e52746671d844a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p>图2：Faster R-CNN是一个单一，统一的目标检测网络。RPN模块作为这个统一网络的“注意力”。</p>
<h3 id="3-1-Region-Proposal-Networks"><a href="#3-1-Region-Proposal-Networks" class="headerlink" title="3.1 Region Proposal Networks"></a>3.1 Region Proposal Networks</h3><p>A Region Proposal Network (RPN) takes an image (of any size) as input and outputs a set of rectangular object proposals, each with an objectness score.3 We model this process with a fully convolutional network [7], which we describe in this section. Because our ultimate goal is to share computation with a Fast R-CNN object detection network [2], we assume that both nets share a common set of convolutional layers. In our experiments, we investigate the Zeiler and Fergus model <a href="ZF">32</a>, which has 5 shareable convolutional layers and the Simonyan and Zisserman model <a href="VGG-16">3</a>, which has 13 shareable convolutional layers.</p>
<h3 id="3-1-区域提议网络"><a href="#3-1-区域提议网络" class="headerlink" title="3.1 区域提议网络"></a>3.1 区域提议网络</h3><p>区域提议网络（RPN）以任意大小的图像作为输入，输出一组矩形的目标提议，每个提议都有一个目标得分。我们用全卷积网络[7]对这个过程进行建模，我们将在本节进行描述。因为我们的最终目标是与Fast R-CNN目标检测网络[2]共享计算，所以我们假设两个网络共享一组共同的卷积层。在我们的实验中，我们研究了具有5个共享卷积层的Zeiler和Fergus模型[32]（ZF）和具有13个共享卷积层的Simonyan和Zisserman模型[3]（VGG-16）。</p>
<p>To generate region proposals, we slide a small network over the convolutional feature map output by the last shared convolutional layer. This small network takes as input an $n × n$ spatial window of the input convolutional feature map. Each sliding window is mapped to a lower-dimensional feature (256-d for ZF and 512-d for VGG, with ReLU [33] following). This feature is fed into two sibling fully-connected layers——a box-regression layer (reg) and a box-classification layer (cls). We use $n = 3$ in this paper, noting that the effective receptive field on the input image is large (171 and 228 pixels for ZF and VGG, respectively). This mini-network is illustrated at a single position in Figure 3 (left). Note that because the mini-network operates in a sliding-window fashion, the fully-connected layers are shared across all spatial locations. This architecture is naturally implemented with an n×n convolutional layer followed by two sibling 1 × 1 convolutional layers (for reg and cls, respectively).</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-abef3f8be1f00b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p>Figure 3: Left: Region Proposal Network (RPN). Right: Example detections using RPN proposals on PASCAL VOC 2007 test. Our method detects objects in a wide range of scales and aspect ratios.</p>
<p>为了生成区域提议，我们在最后的共享卷积层输出的卷积特征映射上滑动一个小网络。这个小网络将输入卷积特征映射的$n×n$空间窗口作为输入。每个滑动窗口映射到一个低维特征（ZF为256维，VGG为512维，后面是ReLU[33]）。这个特征被输入到两个子全连接层——一个边界框回归层（reg）和一个边界框分类层（cls）。在本文中，我们使用$n=3$，注意输入图像上的有效感受野是大的（ZF和VGG分别为171和228个像素）。图3（左）显示了这个小型网络的一个位置。请注意，因为小网络以滑动窗口方式运行，所有空间位置共享全连接层。这种架构通过一个n×n卷积层，后面是两个子1×1卷积层（分别用于reg和cls）自然地实现。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-abef3f8be1f00b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p>图3：左：区域提议网络（RPN）。右：在PASCAL VOC 2007测试集上使用RPN提议的示例检测。我们的方法可以检测各种尺度和长宽比的目标。</p>
<h4 id="3-1-1-Anchors"><a href="#3-1-1-Anchors" class="headerlink" title="3.1.1 Anchors"></a>3.1.1 Anchors</h4><p>At each sliding-window location, we simultaneously predict multiple region proposals, where the number of maximum possible proposals for each location is denoted as $k$. So the <em>reg</em> layer has $4k$ outputs encoding the coordinates of $k$ boxes, and the <em>cls</em> layer outputs $2k$ scores that estimate probability of object or not object for each proposal. The $k$ proposals are parameterized <em>relative</em> to $k$ reference boxes, which we call anchors. An anchor is centered at the sliding window in question, and is associated with a scale and aspect ratio (Figure 3, left). By default we use 3 scales and 3 aspect ratios, yielding $k=9$ anchors at each sliding position. For a convolutional feature map of a size W × H (typically ∼2,400), there are $WHk$ anchors in total.</p>
<h4 id="3-1-1-锚点"><a href="#3-1-1-锚点" class="headerlink" title="3.1.1 锚点"></a>3.1.1 锚点</h4><p>在每个滑动窗口位置，我们同时预测多个区域提议，其中每个位置可能提议的最大数目表示为$k$。因此，<em>reg</em>层具有$4k$个输出，编码$k$个边界框的坐标，<em>cls</em>层输出$2k$个分数，估计每个提议是目标或不是目标的概率。相对于我们称之为锚点的$k$个参考边界框，$k$个提议是参数化的。锚点位于所讨论的滑动窗口的中心，并与一个尺度和长宽比相关（图3左）。默认情况下，我们使用3个尺度和3个长宽比，在每个滑动位置产生$k=9$个锚点。对于大小为W×H（通常约为2400）的卷积特征映射，总共有$WHk$个锚点。</p>
<p><strong>Translation-Invariant Anchors</strong></p>
<p>An important property of our approach is that it is <em>translation invariant</em>, both in terms of the anchors and the functions that compute proposals relative to the anchors. If one translates an object in an image, the proposal should translate and the same function should be able to predict the proposal in either location. This translation-invariant property is guaranteed by our method. As a comparison, the MultiBox method [27] uses k-means to generate 800 anchors, which are not translation invariant. So MultiBox does not guarantee that the same proposal is generated if an object is translated.</p>
<p><strong>平移不变的锚点</strong></p>
<p>我们的方法的一个重要特性是它是<em>平移不变</em>的，无论是在锚点还是计算相对于锚点的区域提议的函数。如果在图像中平移目标，提议应该平移，并且同样的函数应该能够在任一位置预测提议。平移不变特性是由我们的方法保证的。作为比较，MultiBox方法[27]使用k-means生成800个锚点，这不是平移不变的。所以如果平移目标，MultiBox不保证会生成相同的提议。</p>
<p>The translation-invariant property also reduces the model size. MultiBox has a $(4+1)\times 800$-dimensional fully-connected output layer, whereas our method has a $(4+2)\times 9$-dimensional convolutional output layer in the case of $k=9$ anchors. As a result, our output layer has $2.8\times10^4$ parameters ($512\times(4+2)\times9$ for VGG-16), two orders of magnitude fewer than MultiBox’s output layer that has $6.1\times10^6$ parameters ($1536\times(4+1)\times800$ for GoogleNet [34] in MultiBox [27]. If considering the feature projection layers, our proposal layers still have an order of magnitude fewer parameters than MultiBox. We expect our method to have less risk of overfitting on small datasets, like PASCAL VOC.</p>
<p>平移不变特性也减小了模型的大小。MultiBox有$(4+1)\times 800$维的全连接输出层，而我们的方法在$k=9$个锚点的情况下有$(4+2)\times 9$维的卷积输出层。因此，对于VGG-16，我们的输出层具有$2.8\times10^4$个参数（对于VGG-16为$512\times(4+2)\times9$），比MultiBox输出层的$6.1\times10^6$个参数少了两个数量级（对于MultiBox [27]中的GoogleNet[34]为$1536\times(4+1)\times800$）。如果考虑到特征投影层，我们的提议层仍然比MultiBox少一个数量级。我们期望我们的方法在PASCAL VOC等小数据集上有更小的过拟合风险。</p>
<p><strong>Multi-Scale Anchors as Regression References</strong></p>
<p>Our design of anchors presents a novel scheme for addressing multiple scales (and aspect ratios). As shown in Figure 1, there have been two popular ways for multi-scale predictions. The first way is based on image/feature pyramids, e.g., in DPM [8] and CNN-based methods [9], [1], [2]. The images are resized at multiple scales, and feature maps (HOG [8] or deep convolutional features [9], [1], [2]) are computed for each scale (Figure 1(a)). This way is often useful but is time-consuming. The second way is to use sliding windows of multiple scales (and/or aspect ratios) on the feature maps. For example, in DPM [8], models of different aspect ratios are trained separately using different filter sizes (such as 5×7 and 7×5). If this way is used to address multiple scales, it can be thought of as a “pyramid of filters” (Figure 1(b)). The second way is usually adopted jointly with the first way [8].</p>
<p><strong>多尺度锚点作为回归参考</strong></p>
<p>我们的锚点设计提出了一个新的方案来解决多尺度（和长宽比）。如图1所示，多尺度预测有两种流行的方法。第一种方法是基于图像/特征金字塔，例如DPM[8]和基于CNN的方法[9]，[1]，[2]中。图像在多个尺度上进行缩放，并且针对每个尺度（图1（a））计算特征映射（HOG[8]或深卷积特征[9]，[1]，[2]）。这种方法通常是有用的，但是非常耗时。第二种方法是在特征映射上使用多尺度（和/或长宽比）的滑动窗口。例如，在DPM[8]中，使用不同的滤波器大小（例如5×7和7×5）分别对不同长宽比的模型进行训练。如果用这种方法来解决多尺度问题，可以把它看作是一个“滤波器金字塔”（图1（b））。第二种方法通常与第一种方法联合采用[8]。</p>
<p>As a comparison, our anchor-based method is built on a pyramid of anchors, which is more cost-efficient. Our method classifies and regresses bounding boxes with reference to anchor boxes of multiple scales and aspect ratios. It only relies on images and feature maps of a single scale, and uses filters (sliding windows on the feature map) of a single size. We show by experiments the effects of this scheme for addressing multiple scales and sizes (Table 8).</p>
<p>Table 8: Detection results of Faster R-CNN on PAS- CAL VOC 2007 test set using different settings of anchors. The network is VGG-16. The training data is VOC 2007 trainval. The default setting of using 3 scales and 3 aspect ratios ($69.9\%$) is the same as that in Table 3.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-826524060db73235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 8"></p>
<p>作为比较，我们的基于锚点方法建立在锚点金字塔上，这是更具成本效益的。我们的方法参照多尺度和长宽比的锚盒来分类和回归边界框。它只依赖单一尺度的图像和特征映射，并使用单一尺寸的滤波器（特征映射上的滑动窗口）。我们通过实验来展示这个方案解决多尺度和尺寸的效果（表8）。</p>
<p>表8：Faster R-CNN在PAS-CAL VOC 2007测试数据集上使用不同锚点设置的检测结果。网络是VGG-16。训练数据是VOC 2007训练集。使用3个尺度和3个长宽比（$69.9\%$）的默认设置，与表3中的相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-826524060db73235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 8"></p>
<p>Because of this multi-scale design based on anchors, we can simply use the convolutional features computed on a single-scale image, as is also done by the Fast R-CNN detector [2]. The design of multi-scale anchors is a key component for sharing features without extra cost for addressing scales.</p>
<p>由于这种基于锚点的多尺度设计，我们可以简单地使用在单尺度图像上计算的卷积特征，Fast R-CNN检测器也是这样做的[2]。多尺度锚点设计是共享特征的关键组件，不需要额外的成本来处理尺度。</p>
<h4 id="3-1-2-Loss-Function"><a href="#3-1-2-Loss-Function" class="headerlink" title="3.1.2 Loss Function"></a>3.1.2 Loss Function</h4><p>For training RPNs, we assign a binary class label (of being an object or not) to each anchor. We assign a positive label to two kinds of anchors: (i) the anchor/anchors with the highest Intersection-over-Union (IoU) overlap with a ground-truth box, or (ii) an anchor that has an IoU overlap higher than 0.7 with any ground-truth box. Note that a single ground-truth box may assign positive labels to multiple anchors. Usually the second condition is sufficient to determine the positive samples; but we still adopt the first condition for the reason that in some rare cases the second condition may find no positive sample. We assign a negative label to a non-positive anchor if its IoU ratio is lower than 0.3 for all ground-truth boxes. Anchors that are neither positive nor negative do not contribute to the training objective.</p>
<h4 id="3-1-2-损失函数"><a href="#3-1-2-损失函数" class="headerlink" title="3.1.2 损失函数"></a>3.1.2 损失函数</h4><p>为了训练RPN，我们为每个锚点分配一个二值类别标签（是目标或不是目标）。我们给两种锚点分配一个正标签：（i）具有与实际边界框的重叠最高交并比（IoU）的锚点，或者（ii）具有与实际边界框的重叠超过0.7 IoU的锚点。注意，单个真实边界框可以为多个锚点分配正标签。通常第二个条件足以确定正样本；但我们仍然采用第一个条件，因为在一些极少数情况下，第二个条件可能找不到正样本。对于所有的真实边界框，如果一个锚点的IoU比率低于0.3，我们给非正面的锚点分配一个负标签。既不正面也不负面的锚点不会有助于训练目标函数。</p>
<p>With these definitions, we minimize an objective function following the multi-task loss in Fast R-CNN [2]. Our loss function for an image is defined as:$$<br>L(\lbrace p_i \rbrace, \lbrace t_i \rbrace) = \frac{1}{N_{cls}}\sum_i L_{cls}(p_i, p^{*}_i) \\ + \lambda\frac{1}{N_{reg}}\sum_i p^{*}_i L_{reg}(t_i, t^{*}_i).<br>$$Here, $i$ is the index of an anchor in a mini-batch and $p_i$ is the predicted probability of anchor $i$ being an object. The ground-truth label $p^{*}_i$ is 1 if the anchor is positive, and is 0 if the anchor is negative. $t_i$ is a vector representing the 4 parameterized coordinates of the predicted bounding box, and $t^{*}_i$ is that of the ground-truth box associated with a positive anchor. The classification loss $L_{cls}$ is log loss over two classes (object vs not object). For the regression loss, we use $L_{reg}(t_i, t^{*}_i)=R(t_i - t^{*}_i)$ where $R$ is the robust loss function (smooth $L_1$) defined in [2]. The term $p^{*}_i L_{reg}$ means the regression loss is activated only for positive anchors ($p^{*}_i=1$) and is disabled otherwise ($p^{*}_i=0$). The outputs of the <em>cls</em> and <em>reg</em> layers consist of ${p_i}$ and ${t_i}$ respectively.</p>
<p>根据这些定义，我们对目标函数Fast R-CNN[2]中的多任务损失进行最小化。我们对图像的损失函数定义为：$$<br>L(\lbrace p_i \rbrace, \lbrace t_i \rbrace) = \frac{1}{N_{cls}}\sum_i L_{cls}(p_i, p^{*}_i) \\ + \lambda\frac{1}{N_{reg}}\sum_i p^{*}_i L_{reg}(t_i, t^{*}_i).<br>$$其中，$i$是一个小批量数据中锚点的索引，$p_i$是锚点$i$作为目标的预测概率。如果锚点为正，真实标签$p^{*}_i$为1，如果锚点为负，则为0。$t_i$是表示预测边界框4个参数化坐标的向量，而$t^{*}_i$是与正锚点相关的真实边界框的向量。分类损失$L_{cls}$是两个类别上（目标或不是目标）的对数损失。对于回归损失，我们使用$L_{reg}(t_i, t^{*}_i)=R(t_i - t^{*}_i)$，其中$R$是在[2]中定义的鲁棒损失函数（平滑$L_1$）。项$p^{*}_i L_{reg}$表示回归损失仅对于正锚点激活，否则被禁用（$p^{*}_i=0$）。<em>cls</em>和<em>reg</em>层的输出分别由${p_i}$和${t_i}$组成。</p>
<p>The two terms are normalized by $N_{cls}$ and $N_{reg}$ and weighted by a balancing parameter $\lambda$. In our current implementation (as in the released code), the $cls$ term in Eqn.(1) is normalized by the mini-batch size (ie, $N_{cls}=256$) and the $reg$ term is normalized by the number of anchor locations (ie, $N_{reg} \sim 2,400$). By default we set $\lambda=10$, and thus both <em>cls</em> and <em>reg</em> terms are roughly equally weighted. We show by experiments that the results are insensitive to the values of $\lambda$ in a wide range(Table 9). We also note that the normalization as above is not required and could be simplified.</p>
<p>Table 9: Detection results of Faster R-CNN on PASCAL VOC 2007 test set using <strong>different values</strong> of $\lambda$ in Equation (1). The network is VGG-16. The training data is VOC 2007 trainval. The default setting of using $\lambda = 10$ ($69.9\%$) is the same as that in Table 3.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-bc1c54a298806dc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 9"></p>
<p>这两个项用$N_{cls}$和$N_{reg}$进行标准化，并由一个平衡参数$\lambda$加权。在我们目前的实现中（如在发布的代码中），方程（1）中的$cls$项通过小批量数据的大小（即$N_{cls}=256$）进行归一化，$reg$项根据锚点位置的数量（即，$N_{reg}\sim 24000$）进行归一化。默认情况下，我们设置$\lambda=10$，因此<em>cls</em>和<em>reg</em>项的权重大致相等。我们通过实验显示，结果对宽范围的$\lambda$值不敏感(表9)。我们还注意到，上面的归一化不是必需的，可以简化。</p>
<p>表9：Faster R-CNN使用方程(1)中不同的$\lambda$值在PASCAL VOC 2007测试集上的检测结果。网络是VGG-16。训练数据是VOC 2007训练集。使用$\lambda = 10$（$69.9\%$）的默认设置与表3中的相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-bc1c54a298806dc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 9"></p>
<p>For bounding box regression, we adopt the parameterizations of the 4 coordinates following [5]:<br>$$<br>t_{\textrm{x}} =  (x - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t_{\textrm{y}} = (y - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t_{\textrm{w}} = \log(w / w_{\textrm{a}}), \quad<br>t_{\textrm{h}} = \log(h / h_{\textrm{a}}),\\<br>t^{*}_{\textrm{x}} =  (x^{*} - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t^{*}_{\textrm{y}} = (y^{*} - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t^{*}_{\textrm{w}} = \log(w^{*} / w_{\textrm{a}}),\quad<br>t^{*}_{\textrm{h}} = \log(h^{*} / h_{\textrm{a}}),<br>$$ where $x$, $y$, $w$, and $h$ denote the box’s center coordinates and its width and height. Variables $x$, $x_{\textrm{a}}$, and $x^{*}$ are for the predicted box, anchor box, and ground-truth box respectively (likewise for $y, w, h$). This can be thought of as bounding-box regression from an anchor box to a nearby ground-truth box.</p>
<p>对于边界框回归，我们采用[5]中的4个坐标参数化：$$<br>t_{\textrm{x}} =  (x - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t_{\textrm{y}} = (y - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t_{\textrm{w}} = \log(w / w_{\textrm{a}}), \quad<br>t_{\textrm{h}} = \log(h / h_{\textrm{a}}),\\<br>t^{*}_{\textrm{x}} =  (x^{*} - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t^{*}_{\textrm{y}} = (y^{*} - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t^{*}_{\textrm{w}} = \log(w^{*} / w_{\textrm{a}}),\quad<br>t^{*}_{\textrm{h}} = \log(h^{*} / h_{\textrm{a}}),<br>$$ 其中，$x$，$y$，$w$和$h$表示边界框的中心坐标及其宽和高。变量$x$，$x_{\textrm{a}}$和$x^{*}$分别表示预测边界框，锚盒和实际边界框（类似于$y, w, h$）。这可以被认为是从锚盒到邻近的实际边界框的回归。</p>
<p>Nevertheless, our method achieves bounding-box regression by a different manner from previous RoI-based (Region of Interest) methods [1], [2]. In [1], [2], bounding-box regression is performed on features pooled from <em>arbitrarily</em> sized RoIs, and the regression weights are <em>shared</em> by all region sizes. In our formulation, the features used for regression are of the same spatial size (3 × 3) on the feature maps. To account for varying sizes, a set of $k$ bounding-box regressors are learned. Each regressor is responsible for one scale and one aspect ratio, and the $k$ regressors do not share weights. As such, it is still possible to predict boxes of various sizes even though the features are of a fixed size/scale, thanks to the design of anchors.</p>
<p>然而，我们的方法通过与之前的基于RoI（感兴趣区域）方法[1]，[2]不同的方式来实现边界框回归。在[1]，[2]中，对任意大小的RoI池化的特征执行边界框回归，并且回归权重由所有区域大小共享。在我们的公式中，用于回归的特征在特征映射上具有相同的空间大小（3×3）。为了说明不同的大小，学习一组$k$个边界框回归器。每个回归器负责一个尺度和一个长宽比，而$k$个回归器不共享权重。因此，由于锚点的设计，即使特征具有固定的尺度/比例，仍然可以预测各种尺寸的边界框。</p>
<h4 id="3-1-3-Training-RPNs"><a href="#3-1-3-Training-RPNs" class="headerlink" title="3.1.3 Training RPNs"></a>3.1.3 Training RPNs</h4><p>The RPN can be trained end-to-end by back-propagation and stochastic gradient descent (SGD) [35]. We follow the “image-centric” sampling strategy from [2] to train this network. Each mini-batch arises from a single image that contains many positive and negative example anchors. It is possible to optimize for the loss functions of all anchors, but this will bias towards negative samples as they are dominate. Instead, we randomly sample 256 anchors in an image to compute the loss function of a mini-batch, where the sampled positive and negative anchors have a ratio of up to 1:1. If there are fewer than 128 positive samples in an image, we pad the mini-batch with negative ones.</p>
<h4 id="3-1-3-训练RPN"><a href="#3-1-3-训练RPN" class="headerlink" title="3.1.3 训练RPN"></a>3.1.3 训练RPN</h4><p>RPN可以通过反向传播和随机梯度下降（SGD）进行端对端训练[35]。我们遵循[2]的“以图像为中心”的采样策略来训练这个网络。每个小批量数据都从包含许多正面和负面示例锚点的单张图像中产生。对所有锚点的损失函数进行优化是可能的，但是这样会偏向于负样本，因为它们是占主导地位的。取而代之的是，我们在图像中随机采样256个锚点，计算一个小批量数据的损失函数，其中采样的正锚点和负锚点的比率可达1:1。如果图像中的正样本少于128个，我们使用负样本填充小批量数据。</p>
<p>We randomly initialize all new layers by drawing weights from a zero-mean Gaussian distribution with standard deviation 0.01. All other layers (i.e., the shared convolutional layers) are initialized by pre-training a model for ImageNet classification [36], as is standard practice [5]. We tune all layers of the ZF net, and conv3_1 and up for the VGG net to conserve memory [2]. We use a learning rate of 0.001 for 60k mini-batches, and 0.0001 for the next 20k mini-batches on the PASCAL VOC dataset. We use a momentum of 0.9 and a weight decay of 0.0005 [37]. Our implementation uses Caffe [38].</p>
<p>我们通过从标准方差为0.01的零均值高斯分布中提取权重来随机初始化所有新层。所有其他层（即共享卷积层）通过预训练的ImageNet分类模型[36]来初始化，如同标准实践[5]。我们调整ZF网络的所有层，以及VGG网络的conv3_1及其之上的层以节省内存[2]。对于60k的小批量数据，我们使用0.001的学习率，对于PASCAL VOC数据集中的下一个20k小批量数据，使用0.0001。我们使用0.9的动量和0.0005的重量衰减[37]。我们的实现使用Caffe[38]。</p>
<h3 id="3-2-Sharing-Features-for-RPN-and-Fast-R-CNN"><a href="#3-2-Sharing-Features-for-RPN-and-Fast-R-CNN" class="headerlink" title="3.2 Sharing Features for RPN and Fast R-CNN"></a>3.2 Sharing Features for RPN and Fast R-CNN</h3><p>Thus far we have described how to train a network for region proposal generation, without considering the region-based object detection CNN that will utilize these proposals. For the detection network, we adopt Fast R-CNN [2]. Next we describe algorithms that learn a unified network composed of RPN and Fast R-CNN with shared convolutional layers (Figure 2).</p>
<h3 id="3-2-RPN和Fast-R-CNN共享特征"><a href="#3-2-RPN和Fast-R-CNN共享特征" class="headerlink" title="3.2 RPN和Fast R-CNN共享特征"></a>3.2 RPN和Fast R-CNN共享特征</h3><p>到目前为止，我们已经描述了如何训练用于区域提议生成的网络，而不考虑将利用这些提议的基于区域的目标检测CNN。对于检测网络，我们采用Fast R-CNN[2]。接下来我们介绍一些算法，学习由RPN和Fast R-CNN组成的具有共享卷积层的统一网络（图2）。</p>
<p>Both RPN and Fast R-CNN, trained independently, will modify their convolutional layers in different ways. We therefore need to develop a technique that allows for sharing convolutional layers between the two networks, rather than learning two separate net- works. We discuss three ways for training networks with features shared:</p>
<p>独立训练的RPN和Fast R-CNN将以不同的方式修改卷积层。 因此，我们需要开发一种允许在两个网络之间共享卷积层的技术，而不是学习两个独立的网络。 我们讨论三个方法来训练具有共享功能的网络：</p>
<p>(i) Alternating training. In this solution, we first train RPN, and use the proposals to train Fast R-CNN. The network tuned by Fast R-CNN is then used to initialize RPN, and this process is iterated. This is the solution that is used in all experiments in this paper.</p>
<p>（一）交替训练。在这个解决方案中，我们首先训练RPN，并使用这些建议来训练Fast R-CNN。 由Fast R-CNN调谐的网络然后被用于初始化RPN，并且这个过程被重复。 这是本文所有实验中使用的解决方案。</p>
<p>(ii) Approximate joint training. In this solution, the RPN and Fast R-CNN networks are merged into one network during training as in Figure 2. In each SGD iteration, the forward pass generates region proposals which are treated just like fixed, pre-computed proposals when training a Fast R-CNN detector. The backward propagation takes place as usual, where for the shared layers the backward propagated signals from both the RPN loss and the Fast R-CNN loss are combined. This solution is easy to implement. But this solution ignores the derivative w.r.t. the proposal boxes’ coordinates that are also network responses, so is approximate. In our experiments, we have empirically found this solver produces close results, yet reduces the training time by about 25-50% comparing with alternating training. This solver is included in our released Python code.</p>
<p>（二）大概的联合培训。 在这个解决方案中，RPN和Fast R-CNN网络在训练期间合并成一个网络，如图2所示。在每次SGD迭代中，正向传递生成区域提议，在训练Fast R-CNN检测器。 反向传播像往常一样发生，其中对于共享层，来自RPN丢失和快速R-CNN丢失的反向传播信号被组合。 这个解决方案很容易实现。 但是这个解决方案忽略了导数w.r.t. 提案框的坐标也是网络响应，所以是近似的。 在我们的实验中，我们实验发现这个求解器产生了相当的结果，与交替训练相比，训练时间减少了大约25-50％。 这个求解器包含在我们发布的Python代码中。</p>
<p>(iii) Non-approximate joint training. As discussed above, the bounding boxes predicted by RPN are also functions of the input. The RoI pooling layer [2] in Fast R-CNN accepts the convolutional features and also the predicted bounding boxes as input, so a theoretically valid backpropagation solver should also involve gradients w.r.t. the box coordinates. These gradients are ignored in the above approximate joint training. In a non-approximate joint training solution, we need an RoI pooling layer that is differentiable w.r.t. the box coordinates. This is a nontrivial problem and a solution can be given by an “RoI warping” layer as developed in [15], which is beyond the scope of this paper.</p>
<p>（三）非近似的联合训练。 如上所述，由RPN预测的边界框也是输入的函数。 Fast R-CNN中的RoI池层[2]接受卷积特征以及预测的边界框作为输入，所以理论上有效的反向传播求解器也应该包括梯度w.r.t. 箱子坐标。 在上述近似联合训练中，这些梯度被忽略。 在一个非近似的联合训练解决方案中，我们需要一个可区分的RoI池层。 箱子坐标。 这是一个非平凡的问题，可以通过[15]中提出的“RoI翘曲”层给出解决方案，这超出了本文的范围。</p>
<p>4-Step Alternating Training. In this paper, we adopt a pragmatic 4-step training algorithm to learn shared features via alternating optimization. In the first step, we train the RPN as described in Section 3.1.3. This network is initialized with an ImageNet-pre-trained model and fine-tuned end-to-end for the region proposal task. In the second step, we train a separate detection network by Fast R-CNN using the proposals generated by the step-1 RPN. This detection network is also initialized by the ImageNet-pre-trained model. At this point the two networks do not share convolutional layers. In the third step, we use the detector network to initialize RPN training, but we fix the shared convolutional layers and only fine-tune the layers unique to RPN. Now the two networks share convolutional layers. Finally, keeping the shared convolutional layers fixed, we fine-tune the unique layers of Fast R-CNN. As such, both networks share the same convolutional layers and form a unified network. A similar alternating training can be run for more iterations, but we have observed negligible improvements.</p>
<p>四步交替训练。在本文中，我们采用实用的四步训练算法，通过交替优化学习共享特征。在第一步中，我们按照3.1.3节的描述训练RPN。该网络使用ImageNet预先训练的模型进行初始化，并针对区域建议任务进行了端到端的微调。在第二步中，我们使用由第一步RPN生成的建议，由Fast R-CNN训练单独的检测网络。该检测网络也由ImageNet预先训练的模型初始化。此时两个网络不共享卷积层。在第三步中，我们使用探测器网络来初始化RPN训练，但是我们修复共享的卷积层，并且只对RPN特有的层进行微调。现在这两个网络共享卷积层。最后，保持共享卷积层的固定，我们对Fast R-CNN的独特层进行微调。因此，两个网络共享相同的卷积层并形成统一的网络。类似的交替训练可以运行更多的迭代，但是我们观察到可以忽略的改进。</p>
<h3 id="3-3-Implementation-Details"><a href="#3-3-Implementation-Details" class="headerlink" title="3.3 Implementation Details"></a>3.3 Implementation Details</h3><p>We train and test both region proposal and object detection networks on images of a single scale [1], [2]. We re-scale the images such that their shorter side is s = 600 pixels [2]. Multi-scale feature extraction (using an image pyramid) may improve accuracy but does not exhibit a good speed-accuracy trade-off [2]. On the re-scaled images, the total stride for both ZF and VGG nets on the last convolutional layer is 16 pixels, and thus is ∼10 pixels on a typical PASCAL image before resizing (∼500×375). Even such a large stride provides good results, though accuracy may be further improved with a smaller stride.</p>
<p>For anchors, we use 3 scales with box areas of $128^2$, $256^2$, and $512^2$ pixels, and 3 aspect ratios of 1:1, 1:2, and 2:1. These hyper-parameters are not carefully chosen for a particular dataset, and we provide ablation experiments on their effects in the next section. As discussed, our solution does not need an image pyramid or filter pyramid to predict regions of multiple scales, saving considerable running time. Figure 3 (right) shows the capability of our method for a wide range of scales and aspect ratios. Table 1 shows the learned average proposal size for each anchor using the ZF net. We note that our algorithm allows predictions that are larger than the underlying receptive field. Such predictions are not impossible—one may still roughly infer the extent of an object if only the middle of the object is visible.</p>
<p>The anchor boxes that cross image boundaries need to be handled with care. During training, we ignore all cross-boundary anchors so they do not contribute to the loss. For a typical $1000 \times 600$ image, there will be roughly 20000 ($\approx 60 \times 40 \times 9$) anchors in total. With the cross-boundary anchors ignored, there are about 6000 anchors per image for training. If the boundary-crossing outliers are not ignored in training, they introduce large, difficult to correct error terms in the objective, and training does not converge. During testing, however, we still apply the fully convolutional RPN to the entire image. This may generate cross- boundary proposal boxes, which we clip to the image boundary.</p>
<p>Some RPN proposals highly overlap with each other. To reduce redundancy, we adopt non-maximum suppression (NMS) on the proposal regions based on their cls scores. We fix the IoU threshold for NMS at 0.7, which leaves us about 2000 proposal regions per image. As we will show, NMS does not harm the ultimate detection accuracy, but substantially reduces the number of proposals. After NMS, we use the top-N ranked proposal regions for detection. In the following, we train Fast R-CNN using 2000 RPN proposals, but evaluate different numbers of proposals at test-time.</p>
<h2 id="4-EXPERIMENTS"><a href="#4-EXPERIMENTS" class="headerlink" title="4. EXPERIMENTS"></a>4. EXPERIMENTS</h2><h3 id="4-1-Experiments-on-PASCAL-VOC"><a href="#4-1-Experiments-on-PASCAL-VOC" class="headerlink" title="4.1 Experiments on PASCAL VOC"></a>4.1 Experiments on PASCAL VOC</h3><h2 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h2><p>[1] K. He, X. Zhang, S. Ren, and J. Sun, “Spatial pyramid pooling in deep convolutional networks for visual recognition,” in European Conference on Computer Vision (ECCV), 2014.</p>
<p>[2] R. Girshick, “Fast R-CNN,” in IEEE International Conference on Computer Vision (ICCV), 2015.</p>
<p>[3] K. Simonyan and A. Zisserman, “Very deep convolutional networks for large-scale image recognition,” in International Conference on Learning Representations (ICLR), 2015.</p>
<p>[4] J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W. Smeulders, “Selective search for object recognition,” International<br>Journal of Computer Vision (IJCV), 2013.</p>
<p>[5] R. Girshick, J. Donahue, T. Darrell, and J. Malik, “Rich feature hierarchies for accurate object detection and semantic segmentation,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[6] C. L. Zitnick and P. Dollár, “Edge boxes: Locating object proposals from edges,” in European Conference on Computer Vision(ECCV),2014.</p>
<p>[7] J. Long, E. Shelhamer, and T. Darrell, “Fully convolutional networks for semantic segmentation,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.</p>
<p>[8] P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and D. Ramanan, “Object detection with discriminatively trained part-based models,” IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2010.</p>
<p>[9] P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus, and Y. LeCun, “Overfeat: Integrated recognition, localization and detection using convolutional networks,” in International Conference on Learning Representations (ICLR), 2014.</p>
<p>[10] S. Ren, K. He, R. Girshick, and J. Sun, “FasterR-CNN: Towards real-time object detection with region proposal networks,” in<br>Neural Information Processing Systems (NIPS), 2015.</p>
<p>[11] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman, “The PASCAL Visual Object Classes Challenge 2007 (VOC2007) Results,” 2007.</p>
<p>[12] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollár, and C. L. Zitnick, “Microsoft COCO: Common Objects in Context,” in European Conference on Computer Vision (ECCV), 2014.</p>
<p>[13] S. Song and J. Xiao, “Deep sliding shapes for amodal 3d object detection in rgb-d images,” arXiv:1511.02300, 2015.</p>
<p>[14] J. Zhu, X. Chen, and A. L. Yuille, “DeePM: A deep part-based model for object detection and semantic part localization,” arXiv:1511.07131, 2015.</p>
<p>[15] J. Dai, K. He, and J. Sun, “Instance-aware semantic segmentation via multi-task network cascades,” arXiv:1512.04412, 2015.</p>
<p>[16] J. Johnson, A. Karpathy, and L. Fei-Fei, “Densecap: Fully convolutional localization networks for dense captioning,” arXiv:1511.07571, 2015.</p>
<p>[17] D. Kislyuk, Y. Liu, D. Liu, E. Tzeng, and Y. Jing, “Human curation and convnets: Powering item-to-item recommendations on pinterest,” arXiv:1511.04003, 2015.</p>
<p>[18] K. He, X. Zhang, S. Ren, and J. Sun, “Deep residual learning for image recognition,” arXiv:1512.03385, 2015.</p>
<p>[19] J. Hosang, R. Benenson, and B. Schiele, “How good are detection proposals, really?” in British Machine Vision Conference (BMVC), 2014.</p>
<p>[20] J. Hosang, R. Benenson, P. Dollar, and B. Schiele, “What makes for effective detection proposals?” IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2015.</p>
<p>[21] N. Chavali, H. Agrawal, A. Mahendru, and D. Batra, “Object-Proposal Evaluation Protocol is ’Gameable’,” arXiv: 1505.05836, 2015.</p>
<p>[22] J. Carreira and C. Sminchisescu, “CPMC: Automatic object segmentation using constrained parametric min-cuts,” IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2012.</p>
<p>[23] P. Arbelaez, J. Pont-Tuset, J. T. Barron, F. Marques, and J. Malik, “Multiscale combinatorial grouping,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[24] B. Alexe, T. Deselaers, and V. Ferrari, “Measuring the objectness of image windows,” IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2012.</p>
<p>[25] C. Szegedy, A. Toshev, and D. Erhan, “Deep neural networks for object detection,” in Neural Information Processing Systems (NIPS), 2013.</p>
<p>[26] D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov, “Scalable object detection using deep neural networks,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.</p>
<p>[27] C. Szegedy, S. Reed, D. Erhan, and D. Anguelov, “Scalable, high-quality object detection,” arXiv:1412.1441 (v1), 2015.</p>
<p>[28] P. O. Pinheiro, R. Collobert, and P. Dollar, “Learning to segment object candidates,” in Neural Information Processing Systems (NIPS), 2015.</p>
<p>[29] J. Dai, K. He, and J. Sun, “Convolutional feature masking for joint object and stuff segmentation,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.</p>
<p>[30] S. Ren, K. He, R. Girshick, X. Zhang, and J. Sun, “Object detection networks on convolutional feature maps,” arXiv:1504.06066, 2015.</p>
<p>[31] J. K. Chorowski, D. Bahdanau, D. Serdyuk, K. Cho, and Y. Bengio, “Attention-based models for speech recognition,” in Neural Information Processing Systems (NIPS), 2015.</p>
<p>[32] M. D. Zeiler and R. Fergus, “Visualizing and understanding convolutional neural networks,” in European Conference on Computer Vision (ECCV), 2014.</p>
<p>[33] V. Nair and G. E. Hinton, “Rectified linear units improve restricted boltzmann machines,” in International Conference on Machine Learning (ICML), 2010.</p>
<p>[34] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, and A. Rabinovich, “Going deeper with convolutions,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.</p>
<p>[35] Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel, “Backpropagation applied to handwritten zip code recognition,” Neural computation, 1989.</p>
<p>[36] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei, “ImageNet Large Scale Visual Recognition Challenge,” in International Journal of Computer Vision (IJCV), 2015.</p>
<p>[37] A. Krizhevsky, I. Sutskever, and G. Hinton, “Imagenet classification with deep convolutional neural networks,” in Neural Information Processing Systems (NIPS), 2012.</p>
<p>[38] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick, S. Guadarrama, and T. Darrell, “Caffe: Convolutional architecture for fast feature embedding,” arXiv:1408.5093, 2014.</p>
<p>[39] K. Lenc and A. Vedaldi, “R-CNN minus R,” in British Machine Vision Conference (BMVC), 2015.</p>
]]></content>
    
    <summary type="html">
    
      Faster R-CNN论文翻译——中英文对照
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Faster R-CNN论文翻译——中文版</title>
    <link href="noahsnail.com/2018/01/03/2018-01-03-Faster%20R-CNN%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>noahsnail.com/2018/01/03/2018-01-03-Faster R-CNN论文翻译——中文版/</id>
    <published>2018-01-03T03:39:54.000Z</published>
    <updated>2018-01-12T07:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="Faster-R-CNN-Towards-Real-Time-Object-Detection-with-Region-Proposal-Networks"><a href="#Faster-R-CNN-Towards-Real-Time-Object-Detection-with-Region-Proposal-Networks" class="headerlink" title="Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks"></a>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最先进的目标检测网络依靠区域提出算法来假设目标的位置。SPPnet[1]和Fast R-CNN[2]等研究已经减少了这些检测网络的运行时间，使得区域提出计算成为一个瓶颈。在这项工作中，我们引入了一个区域提出网络（RPN），该网络与检测网络共享全图像的卷积特征，从而使近乎零成本的区域提出成为可能。RPN是一个全卷积网络，可以同时在每个位置预测目标边界和目标分数。RPN经过端到端的训练，可以生成高质量的区域提出，由Fast R-CNN用于检测。我们将RPN和Fast R-CNN通过共享卷积特征进一步合并为一个单一的网络——使用最近流行的具有“注意力”机制的神经网络术语，RPN组件告诉统一网络在哪里寻找。对于非常深的VGG-16模型[3]，我们的检测系统在GPU上的帧率为5fps（包括所有步骤），同时在PASCAL VOC 2007，2012和MS COCO数据集上实现了最新的目标检测精度，每个图像只有300个提出。在ILSVRC和COCO 2015竞赛中，Faster R-CNN和RPN是多个比赛中获得第一名输入的基础。代码可公开获得。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>目标检测的最新进展是由区域提出方法（例如[4]）和基于区域的卷积神经网络（R-CNN）[5]的成功驱动的。尽管在[5]中最初开发的基于区域的CNN计算成本很高，但是由于在各种提议中共享卷积，所以其成本已经大大降低了[1][2]。<em>忽略花费在区域提议上的时间</em>，最新版本Fast R-CNN[2]利用非常深的网络[3]实现了接近实时的速率。现在，提议是最新的检测系统中测试时间的计算瓶颈。</p>
<p>区域提议方法通常依赖廉价的特征和简练的推断方案。选择性搜索[4]是最流行的方法之一，它贪婪地合并基于设计的低级特征的超级像素。然而，与有效的检测网络[2]相比，选择性搜索速度慢了一个数量级，在CPU实现中每张图像的时间为2秒。EdgeBoxes[6]目前提供了在提议质量和速度之间的最佳权衡，每张图像0.2秒。尽管如此，区域提议步骤仍然像检测网络那样消耗同样多的运行时间。</p>
<p>有人可能会注意到，基于区域的快速CNN利用GPU，而在研究中使用的区域提议方法在CPU上实现，使得运行时间比较不公平。加速提议计算的一个显而易见的方法是将其在GPU上重新实现。这可能是一个有效的工程解决方案，但重新实现忽略了下游检测网络，因此错过了共享计算的重要机会。</p>
<p>在本文中，我们展示了算法的变化——用深度卷积神经网络计算区域提议——导致了一个优雅和有效的解决方案，其中在给定检测网络计算的情况下区域提议计算接近领成本。为此，我们引入了新的<em>区域提议网络</em>（RPN），它们共享最先进目标检测网络的卷积层[1]，[2]。通过在测试时共享卷积，计算区域提议的边际成本很小（例如，每张图像10ms）。</p>
<p>我们的观察是，基于区域的检测器所使用的卷积特征映射，如Fast R-CNN，也可以用于生成区域提议。在这些卷积特征之上，我们通过添加一些额外的卷积层来构建RPN，这些卷积层同时在规则网格上的每个位置上回归区域边界和目标分数。因此RPN是一种全卷积网络（FCN）[7]，可以针对生成检测区域建议的任务进行端到端的训练。</p>
<p>RPN旨在有效预测具有广泛尺度和长宽比的区域提议。与使用图像金字塔（图1，a）或滤波器金字塔（图1，b）的流行方法[8]，[9]，[1]相比，我们引入新的“锚”盒作为多种尺度和长宽比的参考。我们的方案可以被认为是回归参考金字塔（图1，c），它避免了枚举多种比例或长宽比的图像或滤波器。这个模型在使用单尺度图像进行训练和测试时运行良好，从而有利于运行速度。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c642d73ad24cb3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p>图1：解决多尺度和尺寸的不同方案。（a）构建图像和特征映射金字塔，分类器以各种尺度运行。（b）在特征映射上运行具有多个比例/大小的滤波器的金字塔。（c）我们在回归函数中使用参考边界框金字塔。</p>
<p>为了将RPN与Fast R-CNN 2]目标检测网络相结合，我们提出了一种训练方案，在微调区域提议任务和微调目标检测之间进行交替，同时保持区域提议的固定。该方案快速收敛，并产生两个任务之间共享的具有卷积特征的统一网络。</p>
<p>我们在PASCAL VOC检测基准数据集上[11]综合评估了我们的方法，其中具有Fast R-CNN的RPN产生的检测精度优于使用选择性搜索的Fast R-CNN的强基准。同时，我们的方法在测试时几乎免除了选择性搜索的所有计算负担——区域提议的有效运行时间仅为10毫秒。使用[3]的昂贵的非常深的模型，我们的检测方法在GPU上仍然具有5fps的帧率（包括所有步骤），因此在速度和准确性方面是实用的目标检测系统。我们还报告了在MS COCO数据集上[12]的结果，并使用COCO数据研究了在PASCAL VOC上的改进。代码可公开获得<a href="https://github.com/shaoqingren/faster_rcnn" target="_blank" rel="external">https://github.com/shaoqingren/faster_rcnn</a>（在MATLAB中）和<a href="https://github.com/rbgirshick/py-faster-rcnn" target="_blank" rel="external">https://github.com/rbgirshick/py-faster-rcnn</a>（在Python中）。</p>
<p>这个手稿的初步版本是以前发表的[10]。从那时起，RPN和Faster R-CNN的框架已经被采用并推广到其他方法，如3D目标检测[13]，基于部件的检测[14]，实例分割[15]和图像标题[16]。我们快速和有效的目标检测系统也已经在Pinterest[17]的商业系统中建立了，并报告了用户参与度的提高。</p>
<p>在ILSVRC和COCO 2015竞赛中，Faster R-CNN和RPN是ImageNet检测，ImageNet定位，COCO检测和COCO分割中几个第一名参赛者[18]的基础。RPN完全从数据中学习提议区域，因此可以从更深入和更具表达性的特征（例如[18]中采用的101层残差网络）中轻松获益。Faster R-CNN和RPN也被这些比赛中的其他几个主要参赛者所使用。这些结果表明，我们的方法不仅是一个实用合算的解决方案，而且是一个提高目标检测精度的有效方法。</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><p><strong>目标提议</strong>。目标提议方法方面有大量的文献。目标提议方法的综合调查和比较可以在[19]，[20]，[21]中找到。广泛使用的目标提议方法包括基于超像素分组（例如，选择性搜索[4]，CPMC[22]，MCG[23]）和那些基于滑动窗口的方法（例如窗口中的目标[24]，EdgeBoxes[6]）。目标提议方法被采用为独立于检测器（例如，选择性搜索[4]目标检测器，R-CNN[5]和Fast R-CNN[2]）的外部模块。</p>
<p>用于目标检测的深度网络。R-CNN方法[5]端到端地对CNN进行训练，将提议区域分类为目标类别或背景。R-CNN主要作为分类器，并不能预测目标边界（除了通过边界框回归进行细化）。其准确度取决于区域提议模块的性能（参见[20]中的比较）。一些论文提出了使用深度网络来预测目标边界框的方法[25]，[9]，[26]，[27]。在OverFeat方法[9]中，训练一个全连接层来预测假定单个目标定位任务的边界框坐标。然后将全连接层变成卷积层，用于检测多个类别的目标。MultiBox方法[26]，[27]从网络中生成区域提议，网络最后的全连接层同时预测多个类别不相关的边界框，并推广到OverFeat的“单边界框”方式。这些类别不可知的边界框框被用作R-CNN的提议区域[5]。与我们的全卷积方案相比，MultiBox提议网络适用于单张裁剪图像或多张大型裁剪图像（例如224×224）。MultiBox在提议区域和检测网络之间不共享特征。稍后在我们的方法上下文中会讨论OverFeat和MultiBox。与我们的工作同时进行的，DeepMask方法[28]是为学习分割提议区域而开发的。</p>
<p>卷积[9]，[1]，[29]，[7]，[2]的共享计算已经越来越受到人们的关注，因为它可以有效而准确地进行视觉识别。OverFeat论文[9]计算图像金字塔的卷积特征用于分类，定位和检测。共享卷积特征映射的自适应大小池化（SPP）[1]被开发用于有效的基于区域的目标检测[1]，[30]和语义分割[29]。Fast R-CNN[2]能够对共享卷积特征进行端到端的检测器训练，并显示出令人信服的准确性和速度。</p>
<h2 id="3-FASTER-R-CNN"><a href="#3-FASTER-R-CNN" class="headerlink" title="3. FASTER R-CNN"></a>3. FASTER R-CNN</h2><p>我们的目标检测系统，称为Faster R-CNN，由两个模块组成。第一个模块是提议区域的深度全卷积网络，第二个模块是使用提议区域的Fast R-CNN检测器[2]。整个系统是一个单个的，统一的目标检测网络（图2）。使用最近流行的“注意力”[31]机制的神经网络术语，RPN模块告诉Fast R-CNN模块在哪里寻找。在第3.1节中，我们介绍了区域提议网络的设计和属性。在第3.2节中，我们开发了用于训练具有共享特征模块的算法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-98e52746671d844a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p>图2：Faster R-CNN是一个单一，统一的目标检测网络。RPN模块作为这个统一网络的“注意力”。</p>
<h3 id="3-1-区域提议网络"><a href="#3-1-区域提议网络" class="headerlink" title="3.1 区域提议网络"></a>3.1 区域提议网络</h3><p>区域提议网络（RPN）以任意大小的图像作为输入，输出一组矩形的目标提议，每个提议都有一个目标得分。我们用全卷积网络[7]对这个过程进行建模，我们将在本节进行描述。因为我们的最终目标是与Fast R-CNN目标检测网络[2]共享计算，所以我们假设两个网络共享一组共同的卷积层。在我们的实验中，我们研究了具有5个共享卷积层的Zeiler和Fergus模型[32]（ZF）和具有13个共享卷积层的Simonyan和Zisserman模型[3]（VGG-16）。</p>
<p>为了生成区域提议，我们在最后的共享卷积层输出的卷积特征映射上滑动一个小网络。这个小网络将输入卷积特征映射的$n×n$空间窗口作为输入。每个滑动窗口映射到一个低维特征（ZF为256维，VGG为512维，后面是ReLU[33]）。这个特征被输入到两个子全连接层——一个边界框回归层（reg）和一个边界框分类层（cls）。在本文中，我们使用$n=3$，注意输入图像上的有效感受野是大的（ZF和VGG分别为171和228个像素）。图3（左）显示了这个小型网络的一个位置。请注意，因为小网络以滑动窗口方式运行，所有空间位置共享全连接层。这种架构通过一个n×n卷积层，后面是两个子1×1卷积层（分别用于reg和cls）自然地实现。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-abef3f8be1f00b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p>图3：左：区域提议网络（RPN）。右：在PASCAL VOC 2007测试集上使用RPN提议的示例检测。我们的方法可以检测各种尺度和长宽比的目标。</p>
<h4 id="3-1-1-锚点"><a href="#3-1-1-锚点" class="headerlink" title="3.1.1 锚点"></a>3.1.1 锚点</h4><p>在每个滑动窗口位置，我们同时预测多个区域提议，其中每个位置可能提议的最大数目表示为$k$。因此，<em>reg</em>层具有$4k$个输出，编码$k$个边界框的坐标，<em>cls</em>层输出$2k$个分数，估计每个提议是目标或不是目标的概率。相对于我们称之为锚点的$k$个参考边界框，$k$个提议是参数化的。锚点位于所讨论的滑动窗口的中心，并与一个尺度和长宽比相关（图3左）。默认情况下，我们使用3个尺度和3个长宽比，在每个滑动位置产生$k=9$个锚点。对于大小为W×H（通常约为2400）的卷积特征映射，总共有$WHk$个锚点。</p>
<p><strong>平移不变的锚点</strong></p>
<p>我们的方法的一个重要特性是它是<em>平移不变</em>的，无论是在锚点还是计算相对于锚点的区域提议的函数。如果在图像中平移目标，提议应该平移，并且同样的函数应该能够在任一位置预测提议。这个平移不变的属性是由我们的方法保证的。作为比较，MultiBox方法[27]使用k-means生成800个锚点，这不是平移不变的。所以如果平移目标，MultiBox不保证会生成相同的提议。</p>
<p>平移不变特性也减小了模型的大小。MultiBox有$(4+1)\times 800$维的全连接输出层，而我们的方法在$k=9$个锚点的情况下有$(4+2)\times 9$维的卷积输出层。因此，对于VGG-16，我们的输出层具有$2.8\times10^4$个参数（对于VGG-16为$512\times(4+2)\times9$），比MultiBox输出层的$6.1\times10^6$个参数少了两个数量级（对于MultiBox [27]中的GoogleNet[34]为$1536\times(4+1)\times800$）。如果考虑到特征投影层，我们的提议层仍然比MultiBox少一个数量级。我们期望我们的方法在PASCAL VOC等小数据集上有更小的过拟合风险。</p>
<p><strong>多尺度锚点作为回归参考</strong></p>
<p>我们的锚点设计提出了一个新的方案来解决多尺度（和长宽比）。如图1所示，多尺度预测有两种流行的方法。第一种方法是基于图像/特征金字塔，例如DPM[8]和基于CNN的方法[9]，[1]，[2]中。图像在多个尺度上进行缩放，并且针对每个尺度（图1（a））计算特征映射（HOG[8]或深卷积特征[9]，[1]，[2]）。这种方法通常是有用的，但是非常耗时。第二种方法是在特征映射上使用多尺度（和/或长宽比）的滑动窗口。例如，在DPM[8]中，使用不同的滤波器大小（例如5×7和7×5）分别对不同长宽比的模型进行训练。如果用这种方法来解决多尺度问题，可以把它看作是一个“滤波器金字塔”（图1（b））。第二种方法通常与第一种方法联合采用[8]。</p>
<p>作为比较，我们的基于锚点方法建立在锚点金字塔上，这是更具成本效益的。我们的方法参照多尺度和长宽比的锚盒来分类和回归边界框。它只依赖单一尺度的图像和特征映射，并使用单一尺寸的滤波器（特征映射上的滑动窗口）。我们通过实验来展示这个方案解决多尺度和尺寸的效果（表8）。</p>
<p>表8：Faster R-CNN在PAS-CAL VOC 2007测试数据集上使用不同锚点设置的检测结果。网络是VGG-16。训练数据是VOC 2007训练集。使用3个尺度和3个长宽比（$69.9\%$）的默认设置，与表3中的相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-826524060db73235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 8"></p>
<p>由于这种基于锚点的多尺度设计，我们可以简单地使用在单尺度图像上计算的卷积特征，Fast R-CNN检测器也是这样做的[2]。多尺度锚点设计是共享特征的关键组件，不需要额外的成本来处理尺度。</p>
<h4 id="3-1-2-损失函数"><a href="#3-1-2-损失函数" class="headerlink" title="3.1.2 损失函数"></a>3.1.2 损失函数</h4><p>为了训练RPN，我们为每个锚点分配一个二值类别标签（是目标或不是目标）。我们给两种锚点分配一个正标签：（i）具有与实际边界框的重叠最高交并比（IoU）的锚点，或者（ii）具有与实际边界框的重叠超过0.7 IoU的锚点。注意，单个真实边界框可以为多个锚点分配正标签。通常第二个条件足以确定正样本；但我们仍然采用第一个条件，因为在一些极少数情况下，第二个条件可能找不到正样本。对于所有的真实边界框，如果一个锚点的IoU比率低于0.3，我们给非正面的锚点分配一个负标签。既不正面也不负面的锚点不会有助于训练目标函数。</p>
<p>根据这些定义，我们对目标函数Fast R-CNN[2]中的多任务损失进行最小化。我们对图像的损失函数定义为：$$<br>L(\lbrace p_i \rbrace, \lbrace t_i \rbrace) = \frac{1}{N_{cls}}\sum_i L_{cls}(p_i, p^{*}_i) \\ + \lambda\frac{1}{N_{reg}}\sum_i p^{*}_i L_{reg}(t_i, t^{*}_i).<br>$$其中，$i$是一个小批量数据中锚点的索引，$p_i$是锚点$i$作为目标的预测概率。如果锚点为正，真实标签$p^{*}_i$为1，如果锚点为负，则为0。$t_i$是表示预测边界框4个参数化坐标的向量，而$t^{*}_i$是与正锚点相关的真实边界框的向量。分类损失$L_{cls}$是两个类别上（目标或不是目标）的对数损失。对于回归损失，我们使用$L_{reg}(t_i, t^{*}_i)=R(t_i - t^{*}_i)$，其中$R$是在[2]中定义的鲁棒损失函数（平滑$L_1$）。项$p^{*}_i L_{reg}$表示回归损失仅对于正锚点激活，否则被禁用（$p^{*}_i=0$）。<em>cls</em>和<em>reg</em>层的输出分别由${p_i}$和${t_i}$组成。</p>
<p>这两个项用$N_{cls}$和$N_{reg}$进行标准化，并由一个平衡参数$\lambda$加权。在我们目前的实现中（如在发布的代码中），方程（1）中的$cls$项通过小批量数据的大小（即$N_{cls}=256$）进行归一化，$reg$项根据锚点位置的数量（即，$N_{reg}\sim 24000$）进行归一化。默认情况下，我们设置$\lambda=10$，因此<em>cls</em>和<em>reg</em>项的权重大致相等。我们通过实验显示，结果对宽范围的$\lambda$值不敏感(表9)。我们还注意到，上面的归一化不是必需的，可以简化。</p>
<p>表9：Faster R-CNN使用方程(1)中不同的$\lambda$值在PASCAL VOC 2007测试集上的检测结果。网络是VGG-16。训练数据是VOC 2007训练集。使用$\lambda = 10$（$69.9\%$）的默认设置与表3中的相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-bc1c54a298806dc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 9"></p>
<p>对于边界框回归，我们采用[5]中的4个坐标参数化：$$<br>t_{\textrm{x}} =  (x - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t_{\textrm{y}} = (y - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t_{\textrm{w}} = \log(w / w_{\textrm{a}}), \quad<br>t_{\textrm{h}} = \log(h / h_{\textrm{a}}),\\<br>t^{*}_{\textrm{x}} =  (x^{*} - x_{\textrm{a}})/w_{\textrm{a}},\quad<br>t^{*}_{\textrm{y}} = (y^{*} - y_{\textrm{a}})/h_{\textrm{a}},\\<br>t^{*}_{\textrm{w}} = \log(w^{*} / w_{\textrm{a}}),\quad<br>t^{*}_{\textrm{h}} = \log(h^{*} / h_{\textrm{a}}),<br>$$ 其中，$x$，$y$，$w$和$h$表示边界框的中心坐标及其宽和高。变量$x$，$x_{\textrm{a}}$和$x^{*}$分别表示预测边界框，锚盒和实际边界框（类似于$y, w, h$）。这可以被认为是从锚盒到邻近的实际边界框的回归。</p>
<p>然而，我们的方法通过与之前的基于RoI（感兴趣区域）方法[1]，[2]不同的方式来实现边界框回归。在[1]，[2]中，对任意大小的RoI池化的特征执行边界框回归，并且回归权重由所有区域大小共享。在我们的公式中，用于回归的特征在特征映射上具有相同的空间大小（3×3）。为了说明不同的大小，学习一组$k$个边界框回归器。每个回归器负责一个尺度和一个长宽比，而$k$个回归器不共享权重。因此，由于锚点的设计，即使特征具有固定的尺度/比例，仍然可以预测各种尺寸的边界框。</p>
<h4 id="3-1-3-训练RPN"><a href="#3-1-3-训练RPN" class="headerlink" title="3.1.3 训练RPN"></a>3.1.3 训练RPN</h4><p>RPN可以通过反向传播和随机梯度下降（SGD）进行端对端训练[35]。我们遵循[2]的“以图像为中心”的采样策略来训练这个网络。每个小批量数据都从包含许多正面和负面示例锚点的单张图像中产生。对所有锚点的损失函数进行优化是可能的，但是这样会偏向于负样本，因为它们是占主导地位的。取而代之的是，我们在图像中随机采样256个锚点，计算一个小批量数据的损失函数，其中采样的正锚点和负锚点的比率可达1:1。如果图像中的正样本少于128个，我们使用负样本填充小批量数据。</p>
<p>我们通过从标准方差为0.01的零均值高斯分布中提取权重来随机初始化所有新层。所有其他层（即共享卷积层）通过预训练的ImageNet分类模型[36]来初始化，如同标准实践[5]。我们调整ZF网络的所有层，以及VGG网络的conv3_1及其之上的层以节省内存[2]。对于60k的小批量数据，我们使用0.001的学习率，对于PASCAL VOC数据集中的下一个20k小批量数据，使用0.0001。我们使用0.9的动量和0.0005的重量衰减[37]。我们的实现使用Caffe[38]。</p>
]]></content>
    
    <summary type="html">
    
      Faster R-CNN论文翻译——中文版
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>递归——汉诺塔</title>
    <link href="noahsnail.com/2017/12/28/2017-12-28-%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>noahsnail.com/2017/12/28/2017-12-28-递归——汉诺塔/</id>
    <published>2017-12-28T08:14:55.000Z</published>
    <updated>2017-12-28T08:27:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>一个函数调用其自身，就是递归。</p>
<h2 id="2-汉诺塔"><a href="#2-汉诺塔" class="headerlink" title="2. 汉诺塔"></a>2. 汉诺塔</h2><ul>
<li>问题描述</li>
</ul>
<p>有一个梵塔，塔内有三个座A、B、C，A座上有诺干个盘子，盘子大小不等，大的在下，小的在上。把这些个盘子从A座移到C座，中间可以借用B座但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-ff813c41cf57033f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="汉诺塔问题"></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> src, <span class="keyword">char</span> mid, <span class="keyword">char</span> dest)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; src &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; dest &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Hanoi(n - <span class="number">1</span>, src, dest, mid);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; src &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; dest &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    Hanoi(n - <span class="number">1</span>, mid, src, dest);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    Hanoi(n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结：汉诺塔问题是递归中的经典问题了。</strong></p>
<p>源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/hanoi.cpp" target="_blank" rel="external">汉诺塔</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      递归——汉诺塔
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="noahsnail.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>递归——求阶乘</title>
    <link href="noahsnail.com/2017/12/26/2017-12-26-%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E6%B1%82%E9%98%B6%E4%B9%98/"/>
    <id>noahsnail.com/2017/12/26/2017-12-26-递归——求阶乘/</id>
    <published>2017-12-26T14:02:18.000Z</published>
    <updated>2017-12-28T08:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>一个函数调用其自身，就是递归。</p>
<h2 id="2-求阶乘"><a href="#2-求阶乘" class="headerlink" title="2. 求阶乘"></a>2. 求阶乘</h2><ul>
<li><p>问题描述<br>求n的阶乘，n&gt;=0。</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># _*_ coding: utf-8</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div><div class="line">    </div><div class="line"><span class="keyword">print</span> factorial(<span class="number">5</span>)</div></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">120</div></pre></td></tr></table></figure>
<p><strong>总结：求阶乘问题算是递归中最简单的问题了。</strong></p>
<p>源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/factorial.py" target="_blank" rel="external">求阶乘</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      递归——求阶乘
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="noahsnail.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>YOLO9000, Better, Faster, Stronger论文翻译——中文版</title>
    <link href="noahsnail.com/2017/12/26/2017-12-26-YOLO9000,%20Better,%20Faster,%20Stronger%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>noahsnail.com/2017/12/26/2017-12-26-YOLO9000, Better, Faster, Stronger论文翻译——中文版/</id>
    <published>2017-12-26T08:42:26.000Z</published>
    <updated>2017-12-29T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="YOLO9000-Better-Faster-Stronger"><a href="#YOLO9000-Better-Faster-Stronger" class="headerlink" title="YOLO9000: Better, Faster, Stronger"></a>YOLO9000: Better, Faster, Stronger</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们引入了一个先进的实时目标检测系统YOLO9000，可以检测超过9000个目标类别。首先，我们提出了对YOLO检测方法的各种改进，既有新颖性，也有前期的工作。改进后的模型YOLOv2在PASCAL VOC和COCO等标准检测任务上是最先进的。使用一种新颖的，多尺度训练方法，同样的YOLOv2模型可以以不同的尺寸运行，从而在速度和准确性之间提供了一个简单的折衷。在67FPS时，YOLOv2在VOC 2007上获得了76.8 mAP。在40FPS时，YOLOv2获得了78.6 mAP，比使用ResNet的Faster R-CNN和SSD等先进方法表现更出色，同时仍然运行速度显著更快。最后我们提出了一种联合训练目标检测与分类的方法。使用这种方法，我们在COCO检测数据集和ImageNet分类数据集上同时训练YOLO9000。我们的联合训练允许YOLO9000预测未标注的检测数据目标类别的检测结果。我们在ImageNet检测任务上验证了我们的方法。YOLO9000在ImageNet检测验证集上获得19.7 mAP，尽管200个类别中只有44个具有检测数据。在没有COCO的156个类别上，YOLO9000获得16.0 mAP。但YOLO可以检测到200多个类别；它预测超过9000个不同目标类别的检测结果。并且它仍然能实时运行。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>通用目的的目标检测应该快速，准确，并且能够识别各种各样的目标。自从引入神经网络以来，检测框架变得越来越快速和准确。但是，大多数检测方法仍然受限于一小部分目标。</p>
<p>与分类和标记等其他任务的数据集相比，目前目标检测数据集是有限的。最常见的检测数据集包含成千上万到数十万张具有成百上千个标签的图像[3][10][2]。分类数据集有数以百万计的图像，数十或数十万个类别[20][2]。</p>
<p>我们希望检测能够扩展到目标分类的级别。但是，标注检测图像要比标注分类或贴标签要昂贵得多（标签通常是用户免费提供的）。因此，我们不太可能在近期内看到与分类数据集相同规模的检测数据集。</p>
<p>我们提出了一种新的方法来利用我们已经拥有的大量分类数据，并用它来扩大当前检测系统的范围。我们的方法使用目标分类的分层视图，允许我们将不同的数据集组合在一起。</p>
<p>我们还提出了一种联合训练算法，使我们能够在检测和分类数据上训练目标检测器。我们的方法利用标记的检测图像来学习精确定位物体，同时使用分类图像来增加词表和鲁棒性。</p>
<p>使用这种方法我们训练YOLO9000，一个实时的目标检测器，可以检测超过9000种不同的目标类别。首先，我们改进YOLO基础检测系统，产生最先进的实时检测器YOLOv2。然后利用我们的数据集组合方法和联合训练算法对来自ImageNet的9000多个类别以及COCO的检测数据训练了一个模型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-d55daf8a11cf7f5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p><strong>图1：YOLO9000</strong>。YOLO9000可以实时检测许多目标类别。</p>
<p>我们的所有代码和预训练模型都可在线获得：<a href="http://pjreddie.com/yolo9000/" target="_blank" rel="external">http://pjreddie.com/yolo9000/</a>。</p>
<h2 id="2-更好"><a href="#2-更好" class="headerlink" title="2. 更好"></a>2. 更好</h2><p>与最先进的检测系统相比，YOLO有许多缺点。YOLO与Fast R-CNN相比的误差分析表明，YOLO造成了大量的定位误差。此外，与基于区域提出的方法相比，YOLO召回率相对较低。因此，我们主要侧重于提高召回率和改进定位，同时保持分类准确性。</p>
<p>计算机视觉一般趋向于更大，更深的网络[6][18][17]。更好的性能通常取决于训练更大的网络或将多个模型组合在一起。但是，在YOLOv2中，我们需要一个更精确的检测器，它仍然很快。我们不是扩大我们的网络，而是简化网络，然后让表示更容易学习。我们将过去的工作与我们自己的新概念汇集起来，以提高YOLO的性能。表2列出了结果总结。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c241c5fec7ef581b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 2"></p>
<p><strong>表2：从YOLO到YOLOv2的路径</strong>。列出的大部分设计决定都会导致mAP的显著增加。有两个例外是切换到具有锚盒的一个全卷积网络和使用新网络。切换到锚盒风格的方法增加了召回，而不改变mAP，而使用新网络会削减$33\%$的计算量。</p>
<p><strong>批标准化</strong>。批标准化导致收敛性的显著改善，同时消除了对其他形式正则化的需求[7]。通过在YOLO的所有卷积层上添加批标准化，我们在mAP中获得了超过$2\%$的改进。批标准化也有助于模型正则化。通过批标准化，我们可以从模型中删除丢弃而不会过拟合。</p>
<p><strong>高分辨率分类器</strong>。所有最先进的检测方法都使用在ImageNet[16]上预训练的分类器。从AlexNet开始，大多数分类器对小于256×256[8]的输入图像进行操作。原来的YOLO以224×224的分辨率训练分类器网络，并将分辨率提高到448进行检测。这意味着网络必须同时切换到学习目标检测和调整到新的输入分辨率。</p>
<p>对于YOLOv2，我们首先ImageNet上以448×448的分辨率对分类网络进行10个迭代周期的微调。这给了网络时间来调整其滤波器以便更好地处理更高分辨率的输入。然后，我们在检测上微调得到的网络。这个高分辨率分类网络使我们增加了近$4\%$的mAP。</p>
<p><strong>具有锚盒的卷积</strong>。YOLO直接使用卷积特征提取器顶部的全连接层来预测边界框的坐标。Faster R-CNN使用手动选择的先验来预测边界框而不是直接预测坐标[15]。Faster R-CNN中的区域提出网络（RPN）仅使用卷积层来预测锚盒的偏移和置信度。由于预测层是卷积的，所以RPN在特征映射的每个位置上预测这些偏移。预测偏移而不是坐标简化了问题，并且使网络更容易学习。</p>
<p>我们从YOLO中移除全连接层，并使用锚盒来预测边界框。首先，我们消除了一个池化层，使网络卷积层输出具有更高的分辨率。我们还缩小了网络，操作416×416的输入图像而不是448×448。我们这样做是因为我们要在我们的特征映射中有奇数个位置，所以只有一个中心单元。目标，特别是大目标，往往占据图像的中心，所以在中心有一个单独的位置来预测这些目标，而不是四个都在附近的位置是很好的。YOLO的卷积层将图像下采样32倍，所以通过使用416的输入图像，我们得到了13×13的输出特征映射。</p>
<p>当我们移动到锚盒时，我们也将类预测机制与空间位置分离，预测每个锚盒的类别和目标。在YOLO之后，目标预测仍然预测了实际值和提出的边界框的IOU，并且类别预测预测了当存在目标时该类别的条件概率。</p>
<p>使用锚盒，我们在精度上得到了一个小下降。YOLO每张图像只预测98个边界框，但是使用锚盒我们的模型预测超过一千。如果没有锚盒，我们的中间模型将获得69.5的mAP，召回率为$81\%$。具有锚盒我们的模型得到了69.2 mAP，召回率为$88\%$。尽管mAP下降，但召回率的上升意味着我们的模型有更大的提升空间。</p>
<p><strong>维度聚类</strong>。当锚盒与YOLO一起使用时，我们遇到了两个问题。首先是边界框尺寸是手工挑选的。网络可以学习适当调整边界框，但如果我们为网络选择更好的先验，我们可以使网络更容易学习它以便预测好的检测。</p>
<p>我们不用手工选择先验，而是在训练集边界框上运行k-means聚类，自动找到好的先验。如果我们使用具有欧几里得距离的标准k-means，那么较大的边界框比较小的边界框产生更多的误差。然而，我们真正想要的是导致好的IOU分数的先验，这是独立于边界框大小的。因此，对于我们的距离度量，我们使用：$$d(\text{box}, \text{centroid}) = 1 - \text{IOU}(\text{box}, \text{centroid})$$我们运行各种$k$值的k-means，并画出平均IOU与最接近的几何中心，见图2。我们选择$k=5$作为模型复杂性和高召回率之间的良好折衷。聚类中心与手工挑选的锚盒明显不同。有更短更宽的边界框和更高更细的边界框。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-162ddaa683691557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p><strong>图2：VOC和COCO的聚类边界框尺寸</strong>。我们对边界框的维度进行k-means聚类，以获得我们模型的良好先验。左图显示了我们通过对$k$的各种选择得到的平均IOU。我们发现$k = 5$给出了一个很好的召回率与模型复杂度的权衡。右图显示了VOC和COCO的相对中心。这两种先验都赞成更薄更高的边界框，而COCO比VOC在尺寸上有更大的变化。</p>
<p>在表1中我们将平均IOU与我们聚类策略中最接近的先验以及手工选取的锚盒进行了比较。仅有5个先验中心的平均IOU为61.0，其性能类似于9个锚盒的60.9。如果我们使用9个中心，我们会看到更高的平均IOU。这表明使用k-means来生成我们的边界框会以更好的表示开始训练模型，并使得任务更容易学习。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2bcc892861fb0b0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 1"></p>
<p><strong>表1：VOC 2007上最接近先验的边界框平均IOU</strong>。VOC 2007上目标的平均IOU与其最接近的，使用不同生成方法之前未经修改的平均值。聚类结果比使用手工选择的先验结果要更好。</p>
<p><strong>直接位置预测</strong>。当YOLO使用锚盒时，我们会遇到第二个问题：模型不稳定，特别是在早期的迭代过程中。大部分的不稳定来自预测边界框的$(x,y)$位置。在区域提出网络中，网络预测值$t_x$和$t_y$，$(x,y)$中心坐标计算如下：<br>$$<br>x = (t_x * w_a) - x_a\\<br>y = (t_y * h_a) - y_a<br>$$</p>
<p>这个公式是不受限制的，所以任何锚盒都可以在图像任一点结束，而不管在哪个位置预测该边界框。随机初始化模型需要很长时间才能稳定以预测合理的偏移量。</p>
<p>我们没有预测偏移量，而是按照YOLO的方法预测相对于网格单元位置的位置坐标。这限制了落到$0$和$1$之间的真实值。我们使用逻辑激活来限制网络的预测落在这个范围内。</p>
<p>网络预测输出特征映射中每个单元的5个边界框。网络预测每个边界框的5个坐标，$t_x$，$t_y$，$t_w$，$t_h$和$t_o$。如果单元从图像的左上角偏移了$(c_x, c_y)$，并且边界框先验的宽度和高度为$p_w$，$p_h$，那么预测对应：<br>$$<br>b_x = \sigma(t_x) + c_x \\<br>b_y = \sigma(t_y)  + c_y\\<br>b_w = p_w e^{t_w}\\<br>b_h = p_h e^{t_h}\\<br>Pr(\text{object}) * IOU(b, \text{object}) = \sigma(t_o)<br>$$</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-b783aaa8bf51da01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p><strong>图3：具有维度先验和位置预测的边界框</strong>。我们预测边界框的宽度和高度作为聚类中心的偏移量。我们使用sigmoid函数预测边界框相对于滤波器应用位置的中心坐标。</p>
<p>由于我们限制位置预测参数化更容易学习，使网络更稳定。使用维度聚类以及直接预测边界框中心位置的方式比使用锚盒的版本将YOLO提高了近$5\%$。</p>
<p><strong>细粒度功能</strong>。这个修改后的YOLO在13×13特征映射上预测检测结果。虽然这对于大型目标来说已经足够了，但它可以从用于定位较小目标的更细粒度的特征中受益。Faster R-CNN和SSD都在网络的各种特征映射上运行他们提出的网络，以获得一系列的分辨率。我们采用不同的方法，仅仅添加一个通道层，从26x26分辨率的更早层中提取特征。</p>
<p><strong>多尺度训练</strong>。原来的YOLO使用448×448的输入分辨率。通过添加锚盒，我们将分辨率更改为416×416。但是，由于我们的模型只使用卷积层和池化层，因此它可以实时调整大小。我们希望YOLOv2能够鲁棒的运行在不同大小的图像上，因此我们可以将其训练到模型中。</p>
<p>我们没有固定的输入图像大小，每隔几次迭代就改变网络。每隔10个批次我们的网络会随机选择一个新的图像尺寸大小。由于我们的模型缩减了32倍，我们从下面的32的倍数中选择：{320,352，…，608}。因此最小的选项是320×320，最大的是608×608。我们调整网络的尺寸并继续训练。</p>
<p>这个制度迫使网络学习如何在各种输入维度上做好预测。这意味着相同的网络可以预测不同分辨率下的检测结果。在更小尺寸上网络运行速度更快，因此YOLOv2在速度和准确性之间提供了一个简单的折衷。</p>
<p>在低分辨率YOLOv2作为一个便宜，相当准确的检测器。在288×288时，其运行速度超过90FPS，mAP与Fast R-CNN差不多。这使其成为小型GPU，高帧率视频或多视频流的理想选择。</p>
<p>在高分辨率下，YOLOv2是VOC 2007上最先进的检测器，达到了78.6 mAP，同时仍保持运行在实时速度之上。请参阅表3，了解YOLOv2与VOC 2007其他框架的比较。图4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-81d88933e66593ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 3"></p>
<p><strong>表3：PASCAL VOC 2007的检测框架</strong>。YOLOv2比先前的检测方法更快，更准确。它也可以以不同的分辨率运行，以便在速度和准确性之间进行简单折衷。每个YOLOv2条目实际上是具有相同权重的相同训练模型，只是以不同的大小进行评估。所有的时间信息都是在Geforce GTX Titan X（原始的，而不是Pascal模型）上测得的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-addcb9e360378378.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 4"></p>
<p><strong>图4：VOC 2007上的准确性与速度。</strong></p>
<p><strong>进一步实验</strong>。我们在VOC 2012上训练YOLOv2进行检测。表4显示了YOLOv2与其他最先进的检测系统的比较性能。YOLOv2取得了73.4 mAP同时运行速度比竞争方法快的多。我们在COCO上进行了训练，并在表5中与其他方法进行比较。在VOC度量（IOU = 0.5）上，YOLOv2得到44.0 mAP，与SSD和Faster R-CNN相当。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-6f95b93c86276dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 4"></p>
<p><strong>表4：PASCAL VOC2012 <code>test</code>上的检测结果</strong>。YOLOv2与最先进的检测器如具有ResNet的Faster R-CNN、SSD512在标准数据集上运行，YOLOv2比它们快2-10倍。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2041029fefb69883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 5"></p>
<p><strong>表5：在COCO <code>test-dev2015</code>上的结果。表参考[11]</strong></p>
<h2 id="3-更快"><a href="#3-更快" class="headerlink" title="3. 更快"></a>3. 更快</h2><p>我们希望检测是准确的，但我们也希望它快速。大多数检测应用（如机器人或自动驾驶机车）依赖于低延迟预测。为了最大限度提高性能，我们从头开始设计YOLOv2。</p>
<p>大多数检测框架依赖于VGG-16作为的基本特征提取器[17]。VGG-16是一个强大的，准确的分类网络，但它是不必要的复杂。在单张图像224×224分辨率的情况下VGG-16的卷积层运行一次传递需要306.90亿次浮点运算。</p>
<p>YOLO框架使用基于Googlenet架构[19]的自定义网络。这个网络比VGG-16更快，一次前馈传播只有85.2亿次的操作。然而，它的准确性比VGG-16略差。在ImageNet上，对于单张裁剪图像，224×224分辨率下的<code>top-5</code>准确率，YOLO的自定义模型获得了$88.0\%$，而VGG-16则为$90.0\%$。</p>
<p><strong>Darknet-19</strong>。我们提出了一个新的分类模型作为YOLOv2的基础。我们的模型建立在网络设计先前工作以及该领域常识的基础上。与VGG模型类似，我们大多使用3×3滤波器，并在每个池化步骤之后使通道数量加倍[17]。按照Network in Network（NIN）的工作，我们使用全局平均池化做预测以及1×1滤波器来压缩3×3卷积之间的特征表示[9]。我们使用批标准化来稳定训练，加速收敛，并正则化模型[7]。</p>
<p>我们的最终模型叫做Darknet-19，它有19个卷积层和5个最大池化层。完整描述请看表6。Darknet-19只需要55.8亿次运算来处理图像，但在ImageNet上却达到了$72.9\%$的<code>top-1</code>准确率和$91.2\%$的<code>top-5</code>准确率。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-a2e2ce952c7cbc46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 6"></p>
<p><strong>表6：Darknet-19。</strong></p>
<p>如上所述，在我们对224×224的图像进行初始训练之后，我们对网络在更大的尺寸448上进行了微调。对于这种微调，我们使用上述参数进行训练，但是只有10个迭代周期，并且以$10^{−3}$的学习率开始。在这种更高的分辨率下，我们的网络达到了$76.5\%$的<code>top-1</code>准确率和$93.3\%$的<code>top-5</code>准确率。</p>
<p><strong>检测训练</strong>。我们修改这个网络进行检测，删除了最后一个卷积层，加上了三个具有1024个滤波器的3×3卷积层，其后是最后的1×1卷积层与我们检测需要的输出数量。对于VOC，我们预测5个边界框，每个边界框有5个坐标和20个类别，所以有125个滤波器。我们还添加了从最后的3×3×512层到倒数第二层卷积层的直通层，以便我们的模型可以使用细粒度特征。</p>
<p>我们训练网络160个迭代周期，初始学习率为$10^{−3}$，在60个和90个迭代周期时将学习率除以10。我们使用0.0005的权重衰减和0.9的动量。我们对YOLO和SSD进行类似的数据增强，随机裁剪，色彩偏移等。我们对COCO和VOC使用相同的训练策略。</p>
<h2 id="4-更强"><a href="#4-更强" class="headerlink" title="4. 更强"></a>4. 更强</h2><p>我们提出了一个联合训练分类和检测数据的机制。我们的方法使用标记为检测的图像来学习边界框坐标预测和目标之类的特定检测信息以及如何对常见目标进行分类。它使用仅具有类别标签的图像来扩展可检测类别的数量。</p>
<p>在训练期间，我们混合来自检测和分类数据集的图像。当我们的网络看到标记为检测的图像时，我们可以基于完整的YOLOv2损失函数进行反向传播。当它看到一个分类图像时，我们只能从该架构的分类特定部分反向传播损失。</p>
<p>这种方法提出了一些挑战。检测数据集只有通用目标和通用标签，如“狗”或“船”。分类数据集具有更广更深的标签范围。ImageNet有超过一百种品种的狗，包括<code>Norfolk terrier</code>，<code>Yorkshire terrier</code>和<code>Bedlington terrier</code>。如果我们想在两个数据集上训练，我们需要一个连贯的方式来合并这些标签。</p>
<p>大多数分类方法使用跨所有可能类别的softmax层来计算最终的概率分布。使用softmax假定这些类是相互排斥的。这给数据集的组合带来了问题，例如你不想用这个模型来组合ImageNet和COCO，因为类<code>Norfolk terrier</code>和<code>dog</code>不是相互排斥的。</p>
<p>我们可以改为使用多标签模型来组合不假定互斥的数据集。这种方法忽略了我们已知的关于数据的所有结构，例如，所有的COCO类是互斥的。</p>
<p><strong>分层分类</strong>。ImageNet标签是从WordNet中提取的，这是一个构建概念及其相互关系的语言数据库[12]。在WordNet中，<code>Norfolk terrier</code>和<code>Yorkshire terrier</code>都是<code>terrier</code>的下义词，<code>terrier</code>是一种<code>hunting dog</code>，<code>hunting dog</code>是<code>dog</code>，<code>dog</code>是<code>canine</code>等。分类的大多数方法为标签假设一个扁平结构，但是对于组合数据集，结构正是我们所需要的。</p>
<p>WordNet的结构是有向图，而不是树，因为语言是复杂的。例如，<code>dog</code>既是一种<code>canine</code>，也是一种<code>domestic animal</code>，它们都是WordNet中的同义词。我们不是使用完整的图结构，而是通过从ImageNet的概念中构建分层树来简化问题。</p>
<p>为了构建这棵树，我们检查了ImageNet中的视觉名词，并查看它们通过WordNet图到根节点的路径，在这种情况下是“物理对象”。许多同义词通过图只有一条路径，所以首先我们将所有这些路径添加到我们的树中。然后我们反复检查我们留下的概念，并尽可能少地添加生长树的路径。所以如果一个概念有两条路径到一个根，一条路径会给我们的树增加三条边，另一条只增加一条边，我们选择更短的路径。</p>
<p>最终的结果是WordTree，一个视觉概念的分层模型。为了使用WordTree进行分类，我们预测每个节点的条件概率，以得到同义词集合中每个同义词下义词的概率。例如，在<code>terrier</code>节点我们预测：<br>$$<br>Pr(\text{Norfolk terrier} | \text{terrier}) \\<br>Pr(\text{Yorkshire terrier} | \text{terrier}) \\<br>Pr(\text{Bedlington terrier} | \text{terrier})\\<br>…\\<br>$$</p>
<p>如果我们想要计算一个特定节点的绝对概率，我们只需沿着通过树到达根节点的路径，再乘以条件概率。所以如果我们想知道一张图片是否是<code>Norfolk terrier</code>，我们计算：<br>$$<br>Pr(\text{Norfolk terrier}) = Pr(\text{Norfolk terrier} | \text{terrier})\\<br>* Pr(\text{terrier} | \text{hunting dog}) \\<br>* \ldots * \\<br>*Pr(\text{mammal} | Pr(\text{animal})\\<br> * Pr(\text{animal} | \text{physical object})<br>$$</p>
<p>为了分类目的，我们假定图像包含一个目标：$Pr(\text{physical object}) = 1$。</p>
<p>为了验证这种方法，我们在使用1000类ImageNet构建的WordTree上训练Darknet-19模型。为了构建WordTree1k，我们添加了所有将标签空间从1000扩展到1369的中间节点。在训练过程中，我们将真实标签向树上面传播，以便如果图像被标记为<code>Norfolk terrier</code>，则它也被标记为<code>dog</code>和<code>mammal</code>等。为了计算条件概率，我们的模型预测了具有1369个值的向量，并且我们计算了相同概念的下义词在所有同义词集上的softmax，见图5。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-ea0e04e34b0741ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 5"></p>
<p><strong>图5：在ImageNet与WordTree上的预测</strong>。大多数ImageNet模型使用一个较大的softmax来预测概率分布。使用WordTree，我们可以在共同的下义词上执行多次softmax操作。</p>
<p>使用与以前相同的训练参数，我们的分级Darknet-19达到$71.9\%$的<code>top-1</code>准确率和$90.4\%$的<code>top-5</code>准确率。尽管增加了369个额外的概念，而且我们的网络预测了一个树状结构，但我们的准确率仅下降了一点点。以这种方式进行分类也有一些好处。在新的或未知的目标类别上性能会优雅地降低。例如，如果网络看到一只狗的照片，但不确定它是什么类型的狗，它仍然会高度自信地预测“狗”，但是在下义位扩展之间有更低的置信度。</p>
<p>这个构想也适用于检测。现在，我们不是假定每张图像都有一个目标，而是使用YOLOv2的目标预测器给我们$Pr(\text{physical object})$的值。检测器预测边界框和概率树。我们遍历树，在每个分割中采用最高的置信度路径，直到达到某个阈值，然后我们预测目标类。</p>
<p><strong>联合分类和检测</strong>。现在我们可以使用WordTree组合数据集，我们可以在分类和检测上训练联合模型。我们想要训练一个非常大规模的检测器，所以我们使用COCO检测数据集和完整的ImageNet版本中的前9000个类来创建我们的组合数据集。我们还需要评估我们的方法，以便从ImageNet检测挑战中添加任何尚未包含的类。该数据集的相应WordTree有9418个类别。ImageNet是一个更大的数据集，所以我们通过对COCO进行过采样来平衡数据集，使得ImageNet仅仅大于4:1的比例。</p>
<p>使用这种联合训练，YOLO9000学习使用COCO中的检测数据来查找图像中的目标，并学习使用来自ImageNet的数据对各种目标进行分类。</p>
<p>我们在ImageNet检测任务上评估YOLO9000。ImageNet的检测任务与COCO共享44个目标类别，这意味着YOLO9000只能看到大多数测试图像的分类数据，而不是检测数据。YOLO9000在从未见过任何标记的检测数据的情况下，整体上获得了19.7 mAP，在不相交的156个目标类别中获得了16.0 mAP。这个mAP高于DPM的结果，但是YOLO9000在不同的数据集上训练，只有部分监督[4]。它也同时检测9000个其他目标类别，所有的都是实时的。</p>
<p>当我们分析YOLO9000在ImageNet上的表现时，我们发现它很好地学习了新的动物种类，但是却在像服装和设备这样的学习类别中挣扎。新动物更容易学习，因为目标预测可以从COCO中的动物泛化的很好。相反，COCO没有任何类型的衣服的边界框标签，只针对人，因此YOLO9000正在努力建模“墨镜”或“泳裤”等类别。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>我们介绍了YOLOv2和YOLO9000，两个实时检测系统。YOLOv2在各种检测数据集上都是最先进的，也比其他检测系统更快。此外，它可以运行在各种图像大小，以提供速度和准确性之间的平滑折衷。</p>
<p>YOLO9000是一个通过联合优化检测和分类来检测9000多个目标类别的实时框架。我们使用WordTree将各种来源的数据和我们的联合优化技术相结合，在ImageNet和COCO上同时进行训练。YOLO9000是在检测和分类之间缩小数据集大小差距的重要一步。</p>
<p>我们的许多技术都可以泛化到目标检测之外。我们对ImageNet的WordTree表示为图像分类提供了更丰富，更详细的输出空间。使用分层分类的数据集组合在分类和分割领域将是有用的。像多尺度训练这样的训练技术可以为各种视觉任务提供益处。</p>
<p>对于未来的工作，我们希望使用类似的技术来进行弱监督的图像分割。我们还计划使用更强大的匹配策略来改善我们的检测结果，以在训练期间将弱标签分配给分类数据。计算机视觉受到大量标记数据的祝福。我们将继续寻找方法，将不同来源和数据结构的数据整合起来，形成更强大的视觉世界模型。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] S. Bell, C. L. Zitnick, K. Bala, and R. Girshick. Inside-outside net: Detecting objects in context with skip pooling and recurrent neural networks. arXiv preprint arXiv:1512.04143, 2015. 6</p>
<p>[2] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei- Fei. Imagenet: A large-scale hierarchical image database. In Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on, pages 248–255. IEEE, 2009. 1</p>
<p>[3] M. Everingham, L. Van Gool, C. K. Williams, J. Winn, and A. Zisserman. The pascal visual object classes (voc) challenge. International journal of computer vision, 88(2):303– 338, 2010. 1</p>
<p>[4] P. F. Felzenszwalb, R. B. Girshick, and D. McAllester. Discriminatively trained deformable part models, release 4. <a href="http://people.cs.uchicago.edu/pff/latent-release4/" target="_blank" rel="external">http://people.cs.uchicago.edu/pff/latent-release4/</a>. 8</p>
<p>[5] R. B. Girshick. Fast R-CNN. CoRR, abs/1504.08083, 2015. 4, 5, 6</p>
<p>[6] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. arXiv preprint arXiv:1512.03385, 2015. 2, 4, 5</p>
<p>[7] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015. 2, 5</p>
<p>[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012. 2</p>
<p>[9] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv preprint arXiv:1312.4400, 2013. 5</p>
<p>[10] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick. Microsoft coco: Common objects in context. In European Conference on Computer Vision, pages 740–755. Springer, 2014. 1, 6</p>
<p>[11] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, and S. E. Reed. SSD: single shot multibox detector. CoRR, abs/1512.02325, 2015. 4, 5, 6</p>
<p>[12] G. A. Miller, R. Beckwith, C. Fellbaum, D. Gross, and K. J. Miller. Introduction to wordnet: An on-line lexical database. International journal of lexicography, 3(4):235–244, 1990. 6</p>
<p>[13] J. Redmon. Darknet: Open source neural networks in c. <a href="http://pjreddie.com/darknet/" target="_blank" rel="external">http://pjreddie.com/darknet/</a>, 2013–2016. 5</p>
<p>[14] J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You only look once: Unified, real-time object detection. arXiv preprint arXiv:1506.02640, 2015. 4, 5</p>
<p>[15] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards real-time object detection with region proposal net- works. arXiv preprint arXiv:1506.01497, 2015. 2, 3, 4, 5, 6</p>
<p>[16] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei. ImageNet Large Scale Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 2015. 2</p>
<p>[17] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014. 2, 5</p>
<p>[18] C. Szegedy, S. Ioffe, and V. Vanhoucke. Inception-v4, inception-resnet and the impact of residual connections on learning. CoRR, abs/1602.07261, 2016. 2</p>
<p>[19] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. CoRR, abs/1409.4842, 2014. 5</p>
<p>[20] B. Thomee, D. A. Shamma, G. Friedland, B. Elizalde, K. Ni, D. Poland, D. Borth, and L.-J. Li. Yfcc100m: The new data in multimedia research. Communications of the ACM, 59(2):64–73, 2016. 1</p>
]]></content>
    
    <summary type="html">
    
      YOLO9000, Better, Faster, Stronger论文翻译——中文版
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>YOLO9000, Better, Faster, Stronger论文翻译——中英文对照</title>
    <link href="noahsnail.com/2017/12/26/2017-12-26-YOLO9000,%20Better,%20Faster,%20Stronger%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
    <id>noahsnail.com/2017/12/26/2017-12-26-YOLO9000, Better, Faster, Stronger论文翻译——中英文对照/</id>
    <published>2017-12-26T08:42:04.000Z</published>
    <updated>2017-12-29T08:09:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="YOLO9000-Better-Faster-Stronger"><a href="#YOLO9000-Better-Faster-Stronger" class="headerlink" title="YOLO9000: Better, Faster, Stronger"></a>YOLO9000: Better, Faster, Stronger</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We introduce YOLO9000, a state-of-the-art, real-time object detection system that can detect over 9000 object categories. First we propose various improvements to the YOLO detection method, both novel and drawn from prior work. The improved model, YOLOv2, is state-of-the-art on standard detection tasks like PASCAL VOC and COCO. Using a novel, multi-scale training method the same YOLOv2 model can run at varying sizes, offering an easy tradeoff between speed and accuracy. At 67 FPS, YOLOv2 gets 76.8 mAP on VOC 2007. At 40 FPS, YOLOv2 gets 78.6 mAP, outperforming state-of-the-art methods like Faster R-CNN with ResNet and SSD while still running significantly faster. Finally we propose a method to jointly train on object detection and classification. Using this method we train YOLO9000 simultaneously on the COCO detection dataset and the ImageNet classification dataset. Our joint training allows YOLO9000 to predict detections for object classes that don’t have labelled detection data. We validate our approach on the ImageNet detection task. YOLO9000 gets 19.7 mAP on the ImageNet detection validation set despite only having detection data for 44 of the 200 classes. On the 156 classes not in COCO, YOLO9000 gets 16.0 mAP. But YOLO can detect more than just 200 classes; it predicts detections for more than 9000 different object categories. And it still runs in real-time.</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们引入了一个先进的实时目标检测系统YOLO9000，可以检测超过9000个目标类别。首先，我们提出了对YOLO检测方法的各种改进，既有新颖性，也有前期的工作。改进后的模型YOLOv2在PASCAL VOC和COCO等标准检测任务上是最先进的。使用一种新颖的，多尺度训练方法，同样的YOLOv2模型可以以不同的尺寸运行，从而在速度和准确性之间提供了一个简单的折衷。在67FPS时，YOLOv2在VOC 2007上获得了76.8 mAP。在40FPS时，YOLOv2获得了78.6 mAP，比使用ResNet的Faster R-CNN和SSD等先进方法表现更出色，同时仍然运行速度显著更快。最后我们提出了一种联合训练目标检测与分类的方法。使用这种方法，我们在COCO检测数据集和ImageNet分类数据集上同时训练YOLO9000。我们的联合训练允许YOLO9000预测未标注的检测数据目标类别的检测结果。我们在ImageNet检测任务上验证了我们的方法。YOLO9000在ImageNet检测验证集上获得19.7 mAP，尽管200个类别中只有44个具有检测数据。在没有COCO的156个类别上，YOLO9000获得16.0 mAP。但YOLO可以检测到200多个类别；它预测超过9000个不同目标类别的检测结果。并且它仍然能实时运行。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>General purpose object detection should be fast, accurate, and able to recognize a wide variety of objects. Since the introduction of neural networks, detection frameworks have become increasingly fast and accurate. However, most detection methods are still constrained to a small set of objects.</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>通用目的的目标检测应该快速，准确，并且能够识别各种各样的目标。自从引入神经网络以来，检测框架变得越来越快速和准确。但是，大多数检测方法仍然受限于一小部分目标。</p>
<p>Current object detection datasets are limited compared to datasets for other tasks like classification and tagging. The most common detection datasets contain thousands to hundreds of thousands of images with dozens to hundreds of tags [3] [10] [2]. Classification datasets have millions of images with tens or hundreds of thousands of categories [20] [2].</p>
<p>与分类和标记等其他任务的数据集相比，目前目标检测数据集是有限的。最常见的检测数据集包含成千上万到数十万张具有成百上千个标签的图像[3][10][2]。分类数据集有数以百万计的图像，数十或数十万个类别[20][2]。</p>
<p>We would like detection to scale to level of object classification. However, labelling images for detection is far more expensive than labelling for classification or tagging (tags are often user-supplied for free). Thus we are unlikely to see detection datasets on the same scale as classification datasets in the near future.</p>
<p>我们希望检测能够扩展到目标分类的级别。但是，标注检测图像要比标注分类或贴标签要昂贵得多（标签通常是用户免费提供的）。因此，我们不太可能在近期内看到与分类数据集相同规模的检测数据集。</p>
<p>We propose a new method to harness the large amount of classification data we already have and use it to expand the scope of current detection systems. Our method uses a hierarchical view of object classification that allows us to combine distinct datasets together.</p>
<p>我们提出了一种新的方法来利用我们已经拥有的大量分类数据，并用它来扩大当前检测系统的范围。我们的方法使用目标分类的分层视图，允许我们将不同的数据集组合在一起。</p>
<p>We also propose a joint training algorithm that allows us to train object detectors on both detection and classification data. Our method leverages labeled detection images to learn to precisely localize objects while it uses classification images to increase its vocabulary and robustness.</p>
<p>我们还提出了一种联合训练算法，使我们能够在检测和分类数据上训练目标检测器。我们的方法利用标记的检测图像来学习精确定位物体，同时使用分类图像来增加词表和鲁棒性。</p>
<p>Using this method we train YOLO9000, a real-time object detector that can detect over 9000 different object categories. First we improve upon the base YOLO detection system to produce YOLOv2, a state-of-the-art, real-time detector. Then we use our dataset combination method and joint training algorithm to train a model on more than 9000 classes from ImageNet as well as detection data from COCO.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-d55daf8a11cf7f5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p><strong>Figure 1: YOLO9000</strong>. YOLO9000 can detect a wide variety of object classes in real-time.</p>
<p>使用这种方法我们训练YOLO9000，一个实时的目标检测器，可以检测超过9000种不同的目标类别。首先，我们改进YOLO基础检测系统，产生最先进的实时检测器YOLOv2。然后利用我们的数据集组合方法和联合训练算法对来自ImageNet的9000多个类别以及COCO的检测数据训练了一个模型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-d55daf8a11cf7f5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"></p>
<p><strong>图1：YOLO9000</strong>。YOLO9000可以实时检测许多目标类别。</p>
<p>All of our code and pre-trained models are available online at <a href="http://pjreddie.com/yolo9000/" target="_blank" rel="external">http://pjreddie.com/yolo9000/</a>.</p>
<p>我们的所有代码和预训练模型都可在线获得：<a href="http://pjreddie.com/yolo9000/" target="_blank" rel="external">http://pjreddie.com/yolo9000/</a>。</p>
<h2 id="2-Better"><a href="#2-Better" class="headerlink" title="2. Better"></a>2. Better</h2><p>YOLO suffers from a variety of shortcomings relative to state-of-the-art detection systems. Error analysis of YOLO compared to Fast R-CNN shows that YOLO makes a significant number of localization errors. Furthermore, YOLO has relatively low recall compared to region proposal-based methods. Thus we focus mainly on improving recall and localization while maintaining classification accuracy.</p>
<h2 id="2-更好"><a href="#2-更好" class="headerlink" title="2. 更好"></a>2. 更好</h2><p>与最先进的检测系统相比，YOLO有许多缺点。YOLO与Fast R-CNN相比的误差分析表明，YOLO造成了大量的定位误差。此外，与基于区域提出的方法相比，YOLO召回率相对较低。因此，我们主要侧重于提高召回率和改进定位，同时保持分类准确性。</p>
<p>Computer vision generally trends towards larger, deeper networks [6] [18] [17]. Better performance often hinges on training larger networks or ensembling multiple models together. However, with YOLOv2 we want a more accurate detector that is still fast. Instead of scaling up our network, we simplify the network and then make the representation easier to learn. We pool a variety of ideas from past work with our own novel concepts to improve YOLO’s performance. A summary of results can be found in Table 2.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c241c5fec7ef581b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 2"></p>
<p><strong>Table 2: The path from YOLO to YOLOv2</strong>. Most of the listed design decisions lead to significant increases in mAP. Two exceptions are switching to a fully convolutional network with anchor boxes and using the new network. Switching to the anchor box style approach increased recall without changing mAP while using the new network cut computation by $33\%$.</p>
<p>计算机视觉一般趋向于更大，更深的网络[6][18][17]。更好的性能通常取决于训练更大的网络或将多个模型组合在一起。但是，在YOLOv2中，我们需要一个更精确的检测器，它仍然很快。我们不是扩大我们的网络，而是简化网络，然后让表示更容易学习。我们将过去的工作与我们自己的新概念汇集起来，以提高YOLO的性能。表2列出了结果总结。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-c241c5fec7ef581b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 2"></p>
<p><strong>表2：从YOLO到YOLOv2的路径</strong>。列出的大部分设计决定都会导致mAP的显著增加。有两个例外是切换到具有锚盒的一个全卷积网络和使用新网络。切换到锚盒风格的方法增加了召回，而不改变mAP，而使用新网络会削减$33\%$的计算量。</p>
<p><strong>Batch Normalization</strong>. Batch normalization leads to significant improvements in convergence while eliminating the need for other forms of regularization [7]. By adding batch normalization on all of the convolutional layers in YOLO we get more than $2\%$ improvement in mAP. Batch normalization also helps regularize the model. With batch normalization we can remove dropout from the model without overfitting.</p>
<p><strong>批标准化</strong>。批标准化导致收敛性的显著改善，同时消除了对其他形式正则化的需求[7]。通过在YOLO的所有卷积层上添加批标准化，我们在mAP中获得了超过$2\%$的改进。批标准化也有助于模型正则化。通过批标准化，我们可以从模型中删除丢弃而不会过拟合。</p>
<p><strong>High Resolution Classifier</strong>. All state-of-the-art detection methods use classifier pre-trained on ImageNet [16]. Starting with AlexNet most classifiers operate on input images smaller than 256 × 256 [8]. The original YOLO trains the classifier network at 224 × 224 and increases the resolution to 448 for detection. This means the network has to simultaneously switch to learning object detection and adjust to the new input resolution.</p>
<p><strong>高分辨率分类器</strong>。所有最先进的检测方法都使用在ImageNet[16]上预训练的分类器。从AlexNet开始，大多数分类器对小于256×256[8]的输入图像进行操作。原来的YOLO以224×224的分辨率训练分类器网络，并将分辨率提高到448进行检测。这意味着网络必须同时切换到学习目标检测和调整到新的输入分辨率。</p>
<p>For YOLOv2 we first fine tune the classification network at the full 448 × 448 resolution for 10 epochs on ImageNet. This gives the network time to adjust its filters to work better on higher resolution input. We then fine tune the resulting network on detection. This high resolution classification network gives us an increase of almost $4\%$ mAP.</p>
<p>对于YOLOv2，我们首先ImageNet上以448×448的分辨率对分类网络进行10个迭代周期的微调。这给了网络时间来调整其滤波器以便更好地处理更高分辨率的输入。然后，我们在检测上微调得到的网络。这个高分辨率分类网络使我们增加了近$4\%$的mAP。</p>
<p><strong>Convolutional With Anchor Boxes</strong>. YOLO predicts the coordinates of bounding boxes directly using fully connected layers on top of the convolutional feature extractor. Instead of predicting coordinates directly Faster R-CNN predicts bounding boxes using hand-picked priors [15]. Using only convolutional layers the region proposal network (RPN) in Faster R-CNN predicts offsets and confidences for anchor boxes. Since the prediction layer is convolutional, the RPN predicts these offsets at every location in a feature map. Predicting offsets instead of coordinates simplifies the problem and makes it easier for the network to learn.</p>
<p><strong>具有锚盒的卷积</strong>。YOLO直接使用卷积特征提取器顶部的全连接层来预测边界框的坐标。Faster R-CNN使用手动选择的先验来预测边界框而不是直接预测坐标[15]。Faster R-CNN中的区域提出网络（RPN）仅使用卷积层来预测锚盒的偏移和置信度。由于预测层是卷积的，所以RPN在特征映射的每个位置上预测这些偏移。预测偏移而不是坐标简化了问题，并且使网络更容易学习。</p>
<p>We remove the fully connected layers from YOLO and use anchor boxes to predict bounding boxes. First we eliminate one pooling layer to make the output of the network’s convolutional layers higher resolution. We also shrink the network to operate on 416 input images instead of 448×448. We do this because we want an odd number of locations in our feature map so there is a single center cell. Objects, especially large objects, tend to occupy the center of the image so it’s good to have a single location right at the center to predict these objects instead of four locations that are all nearby. YOLO’s convolutional layers downsample the image by a factor of 32 so by using an input image of 416 we get an output feature map of 13 × 13.</p>
<p>我们从YOLO中移除全连接层，并使用锚盒来预测边界框。首先，我们消除了一个池化层，使网络卷积层输出具有更高的分辨率。我们还缩小了网络，操作416×416的输入图像而不是448×448。我们这样做是因为我们要在我们的特征映射中有奇数个位置，所以只有一个中心单元。目标，特别是大目标，往往占据图像的中心，所以在中心有一个单独的位置来预测这些目标，而不是四个都在附近的位置是很好的。YOLO的卷积层将图像下采样32倍，所以通过使用416的输入图像，我们得到了13×13的输出特征映射。</p>
<p>When we move to anchor boxes we also decouple the class prediction mechanism from the spatial location and instead predict class and objectness for every anchor box. Following YOLO, the objectness prediction still predicts the IOU of the ground truth and the proposed box and the class predictions predict the conditional probability of that class given that there is an object.</p>
<p>当我们移动到锚盒时，我们也将类预测机制与空间位置分离，预测每个锚盒的类别和目标。在YOLO之后，目标预测仍然预测了实际值和提出的边界框的IOU，并且类别预测预测了当存在目标时该类别的条件概率。</p>
<p>Using anchor boxes we get a small decrease in accuracy. YOLO only predicts 98 boxes per image but with anchor boxes our model predicts more than a thousand. Without anchor boxes our intermediate model gets 69.5 mAP with a recall of $81\%$. With anchor boxes our model gets 69.2 mAP with a recall of $88\%$. Even though the mAP decreases, the increase in recall means that our model has more room to improve.</p>
<p>使用锚盒，我们在精度上得到了一个小下降。YOLO每张图像只预测98个边界框，但是使用锚盒我们的模型预测超过一千。如果没有锚盒，我们的中间模型将获得69.5的mAP，召回率为$81\%$。具有锚盒我们的模型得到了69.2 mAP，召回率为$88\%$。尽管mAP下降，但召回率的上升意味着我们的模型有更大的提升空间。</p>
<p><strong>Dimension Clusters</strong>. We encounter two issues with anchor boxes when using them with YOLO. The first is that the box dimensions are hand picked. The network can learn to adjust the boxes appropriately but if we pick better priors for the network to start with we can make it easier for the network to learn to predict good detections.</p>
<p><strong>维度聚类</strong>。当锚盒与YOLO一起使用时，我们遇到了两个问题。首先是边界框尺寸是手工挑选的。网络可以学习适当调整边界框，但如果我们为网络选择更好的先验，我们可以使网络更容易学习它以便预测好的检测。</p>
<p>Instead of choosing priors by hand, we run k-means clustering on the training set bounding boxes to automatically find good priors. If we use standard k-means with Euclidean distance larger boxes generate more error than smaller boxes. However, what we really want are priors that lead to good IOU scores, which is independent of the size of the box. Thus for our distance metric we use:$$d(\text{box}, \text{centroid}) = 1 - \text{IOU}(\text{box}, \text{centroid})$$ We run k-means for various values of $k$ and plot the average IOU with closest centroid, see Figure 2. We choose $k=5$ as a good tradeoff between model complexity and high recall. The cluster centroids are significantly different than hand-picked anchor boxes. There are fewer short, wide boxes and more tall, thin boxes.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-162ddaa683691557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p><strong>Figure 2: Clustering box dimensions on VOC and COCO</strong>. We run k-means clustering on the dimensions of bounding boxes to get good priors for our model. The left image shows the average IOU we get with various choices for $k$. We find that $k = 5$ gives a good tradeoff for recall vs. complexity of the model. The right image shows the relative centroids for VOC and COCO. Both sets of priors favor thinner, taller boxes while COCO has greater variation in size than VOC.</p>
<p>我们不用手工选择先验，而是在训练集边界框上运行k-means聚类，自动找到好的先验。如果我们使用具有欧几里得距离的标准k-means，那么较大的边界框比较小的边界框产生更多的误差。然而，我们真正想要的是导致好的IOU分数的先验，这是独立于边界框大小的。因此，对于我们的距离度量，我们使用：$$d(\text{box}, \text{centroid}) = 1 - \text{IOU}(\text{box}, \text{centroid})$$我们运行各种$k$值的k-means，并画出平均IOU与最接近的几何中心，见图2。我们选择$k=5$作为模型复杂性和高召回率之间的良好折衷。聚类中心与手工挑选的锚盒明显不同。有更短更宽的边界框和更高更细的边界框。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-162ddaa683691557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"></p>
<p><strong>图2：VOC和COCO的聚类边界框尺寸</strong>。我们对边界框的维度进行k-means聚类，以获得我们模型的良好先验。左图显示了我们通过对$k$的各种选择得到的平均IOU。我们发现$k = 5$给出了一个很好的召回率与模型复杂度的权衡。右图显示了VOC和COCO的相对中心。这两种先验都赞成更薄更高的边界框，而COCO比VOC在尺寸上有更大的变化。</p>
<p>We compare the average IOU to closest prior of our clustering strategy and the hand-picked anchor boxes in Table 1. At only 5 priors the centroids perform similarly to 9 anchor boxes with an average IOU of 61.0 compared to 60.9. If we use 9 centroids we see a much higher average IOU. This indicates that using k-means to generate our bounding box starts the model off with a better representation and makes the task easier to learn.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2bcc892861fb0b0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 1"></p>
<p><strong>Table 1: Average IOU of boxes to closest priors on VOC 2007</strong>. The average IOU of objects on VOC 2007 to their closest, unmodified prior using different generation methods. Clustering gives much better results than using hand-picked priors.</p>
<p>在表1中我们将平均IOU与我们聚类策略中最接近的先验以及手工选取的锚盒进行了比较。仅有5个先验中心的平均IOU为61.0，其性能类似于9个锚盒的60.9。如果我们使用9个中心，我们会看到更高的平均IOU。这表明使用k-means来生成我们的边界框会以更好的表示开始训练模型，并使得任务更容易学习。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2bcc892861fb0b0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 1"></p>
<p><strong>表1：VOC 2007上最接近先验的边界框平均IOU</strong>。VOC 2007上目标的平均IOU与其最接近的，使用不同生成方法之前未经修改的平均值。聚类结果比使用手工选择的先验结果要更好。</p>
<p><strong>Direct location prediction</strong>. When using anchor boxes with YOLO we encounter a second issue: model instability, especially during early iterations. Most of the instability comes from predicting the $(x,y)$ locations for the box. In region proposal networks the network predicts values $t_x$ and $t_y$ and the $(x,y)$ center coordinates are calculated as:<br>$$<br>x = (t_x * w_a) - x_a\\<br>y = (t_y * h_a) - y_a<br>$$</p>
<p><strong>直接位置预测</strong>。当YOLO使用锚盒时，我们会遇到第二个问题：模型不稳定，特别是在早期的迭代过程中。大部分的不稳定来自预测边界框的$(x,y)$位置。在区域提出网络中，网络预测值$t_x$和$t_y$，$(x,y)$中心坐标计算如下：<br>$$<br>x = (t_x * w_a) - x_a\\<br>y = (t_y * h_a) - y_a<br>$$</p>
<p>For example, a prediction of $t_x = 1$ would shift the box to the right by the width of the anchor box, a prediction of $t_x = -1$ would shift it to the left by the same amount.</p>
<p>例如，预测$t_x = 1$会将边界框向右移动锚盒的宽度，预测$t_x = -1$会将其向左移动相同的宽度。</p>
<p>This formulation is unconstrained so any anchor box can end up at any point in the image, regardless of what location predicted the box. With random initialization the model takes a long time to stabilize to predicting sensible offsets.</p>
<p>这个公式是不受限制的，所以任何锚盒都可以在图像任一点结束，而不管在哪个位置预测该边界框。随机初始化模型需要很长时间才能稳定以预测合理的偏移量。</p>
<p>Instead of predicting offsets we follow the approach of YOLO and predict location coordinates relative to the location of the grid cell. This bounds the ground truth to fall between $0$ and $1$. We use a logistic activation to constrain the network’s predictions to fall in this range.</p>
<p>我们没有预测偏移量，而是按照YOLO的方法预测相对于网格单元位置的位置坐标。这限制了落到$0$和$1$之间的真实值。我们使用逻辑激活来限制网络的预测落在这个范围内。</p>
<p>The network predicts 5 bounding boxes at each cell in the output feature map. The network predicts 5 coordinates for each bounding box, $t_x$, $t_y$, $t_w$, $t_h$, and $t_o$. If the cell is offset from the top left corner of the image by $(c_x, c_y)$ and the bounding box prior has width and height $p_w$, $p_h$, then the predictions correspond to:<br>$$<br>b_x = \sigma(t_x) + c_x \\<br>b_y = \sigma(t_y)  + c_y\\<br>b_w = p_w e^{t_w}\\<br>b_h = p_h e^{t_h}\\<br>Pr(\text{object}) * IOU(b, \text{object}) = \sigma(t_o)<br>$$</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-b783aaa8bf51da01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p><strong>Figure 3: Bounding boxes with dimension priors and location prediction</strong>. We predict the width and height of the box as offsets from cluster centroids. We predict the center coordinates of the box relative to the location of filter application using a sigmoid function.</p>
<p>网络预测输出特征映射中每个单元的5个边界框。网络预测每个边界框的5个坐标，$t_x$，$t_y$，$t_w$，$t_h$和$t_o$。如果单元从图像的左上角偏移了$(c_x, c_y)$，并且边界框先验的宽度和高度为$p_w$，$p_h$，那么预测对应：<br>$$<br>b_x = \sigma(t_x) + c_x \\<br>b_y = \sigma(t_y)  + c_y\\<br>b_w = p_w e^{t_w}\\<br>b_h = p_h e^{t_h}\\<br>Pr(\text{object}) * IOU(b, \text{object}) = \sigma(t_o)<br>$$</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-b783aaa8bf51da01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 3"></p>
<p><strong>图3：具有维度先验和位置预测的边界框</strong>。我们预测边界框的宽度和高度作为聚类中心的偏移量。我们使用sigmoid函数预测边界框相对于滤波器应用位置的中心坐标。</p>
<p>Since we constrain the location prediction the parametrization is easier to learn, making the network more stable. Using dimension clusters along with directly predicting the bounding box center location improves YOLO by almost $5\%$ over the version with anchor boxes.</p>
<p>由于我们限制位置预测参数化更容易学习，使网络更稳定。使用维度聚类以及直接预测边界框中心位置的方式比使用锚盒的版本将YOLO提高了近$5\%$。</p>
<p><strong>Fine-Grained Features</strong>. This modified YOLO predicts detections on a 13 × 13 feature map. While this is sufficient for large objects, it may benefit from finer grained features for localizing smaller objects. Faster R-CNN and SSD both run their proposal networks at various feature maps in the network to get a range of resolutions. We take a different approach, simply adding a passthrough layer that brings features from an earlier layer at 26 × 26 resolution.</p>
<p><strong>细粒度功能</strong>。这个修改后的YOLO在13×13特征映射上预测检测结果。虽然这对于大型目标来说已经足够了，但它可以从用于定位较小目标的更细粒度的特征中受益。Faster R-CNN和SSD都在网络的各种特征映射上运行他们提出的网络，以获得一系列的分辨率。我们采用不同的方法，仅仅添加一个直通层，从26x26分辨率的更早层中提取特征。</p>
<p>The passthrough layer concatenates the higher resolution features with the low resolution features by stacking adjacent features into different channels instead of spatial locations, similar to the identity mappings in ResNet. This turns the 26 × 26 × 512 feature map into a 13 × 13 × 2048 feature map, which can be concatenated with the original features. Our detector runs on top of this expanded feature map so that it has access to fine grained features. This gives a modest $1\%$ performance increase.</p>
<p>直通层通过将相邻特征堆叠到不同的通道而不是空间位置来连接较高分辨率特征和较低分辨率特征，类似于ResNet中的恒等映射。这将26×26×512特征映射变成13×13×2048特征映射，其可以与原始特征连接。我们的检测器运行在这个扩展的特征映射的顶部，以便它可以访问细粒度的特征。这会使性能提高$1\%$。</p>
<p><strong>Multi-Scale Training</strong>. The original YOLO uses an input resolution of 448 × 448. With the addition of anchor boxes we changed the resolution to 416×416. However, since our model only uses convolutional and pooling layers it can be resized on the fly. We want YOLOv2 to be robust to running on images of different sizes so we train this into the model.</p>
<p><strong>多尺度训练</strong>。原来的YOLO使用448×448的输入分辨率。通过添加锚盒，我们将分辨率更改为416×416。但是，由于我们的模型只使用卷积层和池化层，因此它可以实时调整大小。我们希望YOLOv2能够鲁棒的运行在不同大小的图像上，因此我们可以将其训练到模型中。</p>
<p>Instead of fixing the input image size we change the network every few iterations. Every 10 batches our network randomly chooses a new image dimension size. Since our model downsamples by a factor of 32, we pull from the following multiples of 32: {320, 352, …, 608}. Thus the smallest option is 320 × 320 and the largest is 608 × 608. We resize the network to that dimension and continue training.</p>
<p>我们没有固定的输入图像大小，每隔几次迭代就改变网络。每隔10个批次我们的网络会随机选择一个新的图像尺寸大小。由于我们的模型缩减了32倍，我们从下面的32的倍数中选择：{320,352，…，608}。因此最小的选项是320×320，最大的是608×608。我们调整网络的尺寸并继续训练。</p>
<p>This regime forces the network to learn to predict well across a variety of input dimensions. This means the same network can predict detections at different resolutions. The network runs faster at smaller sizes so YOLOv2 offers an easy tradeoff between speed and accuracy.</p>
<p>这个制度迫使网络学习如何在各种输入维度上做好预测。这意味着相同的网络可以预测不同分辨率下的检测结果。在更小尺寸上网络运行速度更快，因此YOLOv2在速度和准确性之间提供了一个简单的折衷。</p>
<p>At low resolutions YOLOv2 operates as a cheap, fairly accurate detector. At 288 × 288 it runs at more than 90 FPS with mAP almost as good as Fast R-CNN. This makes it ideal for smaller GPUs, high framerate video, or multiple video streams.</p>
<p>在低分辨率YOLOv2作为一个便宜，相当准确的检测器。在288×288时，其运行速度超过90FPS，mAP与Fast R-CNN差不多。这使其成为小型GPU，高帧率视频或多视频流的理想选择。</p>
<p>At high resolution YOLOv2 is a state-of-the-art detector with 78.6 mAP on VOC 2007 while still operating above real-time speeds. See Table 3 for a comparison of YOLOv2 with other frameworks on VOC 2007. Figure 4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-81d88933e66593ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 3"></p>
<p><strong>Table 3: Detection frameworks on PASCAL VOC 2007</strong>. YOLOv2 is faster and more accurate than prior detection methods. It can also run at different resolutions for an easy tradeoff between speed and accuracy. Each YOLOv2 entry is actually the same trained model with the same weights, just evaluated at a different size. All timing information is on a Geforce GTX Titan X (original, not Pascal model).</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-addcb9e360378378.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 4"></p>
<p><strong>Figure 4: Accuracy and speed on VOC 2007.</strong></p>
<p>在高分辨率下，YOLOv2是VOC 2007上最先进的检测器，达到了78.6 mAP，同时仍保持运行在实时速度之上。请参阅表3，了解YOLOv2与VOC 2007其他框架的比较。图4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-81d88933e66593ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 3"></p>
<p><strong>表3：PASCAL VOC 2007的检测框架</strong>。YOLOv2比先前的检测方法更快，更准确。它也可以以不同的分辨率运行，以便在速度和准确性之间进行简单折衷。每个YOLOv2条目实际上是具有相同权重的相同训练模型，只是以不同的大小进行评估。所有的时间信息都是在Geforce GTX Titan X（原始的，而不是Pascal模型）上测得的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-addcb9e360378378.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 4"></p>
<p><strong>图4：VOC 2007上的准确性与速度。</strong></p>
<p><strong>Further Experiments</strong>. We train YOLOv2 for detection on VOC 2012. Table 4 shows the comparative performance of YOLOv2 versus other state-of-the-art detection systems. YOLOv2 achieves 73.4 mAP while running far faster than competing methods. We also train on COCO and compare to other methods in Table 5. On the VOC metric (IOU = .5) YOLOv2 gets 44.0 mAP, comparable to SSD and Faster R-CNN.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-6f95b93c86276dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 4"></p>
<p><strong>Table 4: PASCAL VOC2012 test detection results</strong>. YOLOv2 performs on par with state-of-the-art detectors like Faster R-CNN with ResNet and SSD512 and is 2−10× faster.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2041029fefb69883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 5"></p>
<p><strong>Table 5: Results on COCO <code>test-dev2015</code>. Table adapted from [11]</strong></p>
<p><strong>进一步实验</strong>。我们在VOC 2012上训练YOLOv2进行检测。表4显示了YOLOv2与其他最先进的检测系统的比较性能。YOLOv2取得了73.4 mAP同时运行速度比竞争方法快的多。我们在COCO上进行了训练，并在表5中与其他方法进行比较。在VOC度量（IOU = 0.5）上，YOLOv2得到44.0 mAP，与SSD和Faster R-CNN相当。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-6f95b93c86276dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 4"></p>
<p><strong>表4：PASCAL VOC2012 <code>test</code>上的检测结果</strong>。YOLOv2与最先进的检测器如具有ResNet的Faster R-CNN、SSD512在标准数据集上运行，YOLOv2比它们快2-10倍。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-2041029fefb69883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 5"></p>
<p><strong>表5：在COCO <code>test-dev2015</code>上的结果。表参考[11]</strong></p>
<h2 id="3-Faster"><a href="#3-Faster" class="headerlink" title="3. Faster"></a>3. Faster</h2><p>We want detection to be accurate but we also want it to be fast. Most applications for detection, like robotics or self-driving cars, rely on low latency predictions. In order to maximize performance we design YOLOv2 to be fast from the ground up.</p>
<h2 id="3-更快"><a href="#3-更快" class="headerlink" title="3. 更快"></a>3. 更快</h2><p>我们希望检测是准确的，但我们也希望它快速。大多数检测应用（如机器人或自动驾驶机车）依赖于低延迟预测。为了最大限度提高性能，我们从头开始设计YOLOv2。</p>
<p>Most detection frameworks rely on VGG-16 as the base feature extractor [17]. VGG-16 is a powerful, accurate classification network but it is needlessly complex. The convolutional layers of VGG-16 require 30.69 billion floating point operations for a single pass over a single image at 224 × 224 resolution.</p>
<p>大多数检测框架依赖于VGG-16作为的基本特征提取器[17]。VGG-16是一个强大的，准确的分类网络，但它是不必要的复杂。在单张图像224×224分辨率的情况下VGG-16的卷积层运行一次前馈传播需要306.90亿次浮点运算。</p>
<p>The YOLO framework uses a custom network based on the Googlenet architecture [19]. This network is faster than VGG-16, only using 8.52 billion operations for a forward pass. However, it’s accuracy is slightly worse than VGG-16. For single-crop, top-5 accuracy at 224 × 224, YOLO’s custom model gets $88.0\%$ ImageNet compared to $90.0\%$ for VGG-16.</p>
<p>YOLO框架使用基于Googlenet架构[19]的自定义网络。这个网络比VGG-16更快，一次前馈传播只有85.2亿次的操作。然而，它的准确性比VGG-16略差。在ImageNet上，对于单张裁剪图像，224×224分辨率下的<code>top-5</code>准确率，YOLO的自定义模型获得了$88.0\%$，而VGG-16则为$90.0\%$。</p>
<p><strong>Darknet-19</strong>. We propose a new classification model to be used as the base of YOLOv2. Our model builds off of prior work on network design as well as common knowledge in the field. Similar to the VGG models we use mostly 3 × 3 filters and double the number of channels after every pooling step [17]. Following the work on Network in Network (NIN) we use global average pooling to make predictions as well as 1 × 1 filters to compress the feature representation between 3 × 3 convolutions [9]. We use batch normalization to stabilize training, speed up convergence, and regularize the model [7].</p>
<p><strong>Darknet-19</strong>。我们提出了一个新的分类模型作为YOLOv2的基础。我们的模型建立在网络设计先前工作以及该领域常识的基础上。与VGG模型类似，我们大多使用3×3滤波器，并在每个池化步骤之后使通道数量加倍[17]。按照Network in Network（NIN）的工作，我们使用全局平均池化做预测以及1×1滤波器来压缩3×3卷积之间的特征表示[9]。我们使用批标准化来稳定训练，加速收敛，并正则化模型[7]。</p>
<p>Our final model, called Darknet-19, has 19 convolutional layers and 5 maxpooling layers. For a full description see Table 6. Darknet-19 only requires 5.58 billion operations to process an image yet achieves $72.9\%$ top-1 accuracy and $91.2\%$ top-5 accuracy on ImageNet.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-a2e2ce952c7cbc46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 6"></p>
<p><strong>Table 6: Darknet-19.</strong></p>
<p>我们的最终模型叫做Darknet-19，它有19个卷积层和5个最大池化层。完整描述请看表6。Darknet-19只需要55.8亿次运算来处理图像，但在ImageNet上却达到了$72.9\%$的<code>top-1</code>准确率和$91.2\%$的<code>top-5</code>准确率。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-a2e2ce952c7cbc46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Table 6"></p>
<p><strong>表6：Darknet-19。</strong></p>
<p><strong>Training for classification</strong>. We train the network on the standard ImageNet 1000 class classification dataset for 160 epochs using stochastic gradient descent with a starting learning rate of 0.1, polynomial rate decay with a power of 4, weight decay of 0.0005 and momentum of 0.9 using the Darknet neural network framework [13]. During training we use standard data augmentation tricks including random crops, rotations, and hue, saturation, and exposure shifts.</p>
<p><strong>分类训练</strong>。我们使用Darknet神经网络结构，使用随机梯度下降，初始学习率为0.1，学习率多项式衰减系数为4，权重衰减为0.0005，动量为0.9，在标准ImageNet 1000类分类数据集上训练网络160个迭代周期[13]。在训练过程中，我们使用标准的数据增强技巧，包括随机裁剪，旋转，色调，饱和度和曝光偏移。</p>
<p>As discussed above, after our initial training on images at 224 × 224 we fine tune our network at a larger size, 448. For this fine tuning we train with the above parameters but for only 10 epochs and starting at a learning rate of $10^{−3}$. At this higher resolution our network achieves a top-1 accuracy of $76.5\%$ and a top-5 accuracy of $93.3\%$.</p>
<p>如上所述，在我们对224×224的图像进行初始训练之后，我们对网络在更大的尺寸448上进行了微调。对于这种微调，我们使用上述参数进行训练，但是只有10个迭代周期，并且以$10^{−3}$的学习率开始。在这种更高的分辨率下，我们的网络达到了$76.5\%$的<code>top-1</code>准确率和$93.3\%$的<code>top-5</code>准确率。</p>
<p><strong>Training for detection</strong>. We modify this network for detection by removing the last convolutional layer and instead adding on three 3 × 3 convolutional layers with 1024 filters each followed by a final 1 × 1 convolutional layer with the number of outputs we need for detection. For VOC we predict 5 boxes with 5 coordinates each and 20 classes per box so 125 filters. We also add a passthrough layer from the final 3 × 3 × 512 layer to the second to last convolutional layer so that our model can use fine grain features.</p>
<p><strong>检测训练</strong>。我们修改这个网络进行检测，删除了最后一个卷积层，加上了三个具有1024个滤波器的3×3卷积层，其后是最后的1×1卷积层与我们检测需要的输出数量。对于VOC，我们预测5个边界框，每个边界框有5个坐标和20个类别，所以有125个滤波器。我们还添加了从最后的3×3×512层到倒数第二层卷积层的直通层，以便我们的模型可以使用细粒度特征。</p>
<p>We train the network for 160 epochs with a starting learning rate of $10^{−3}$, dividing it by 10 at 60 and 90 epochs. We use a weight decay of 0.0005 and momentum of 0.9. We use a similar data augmentation to YOLO and SSD with random crops, color shifting, etc. We use the same training strategy on COCO and VOC.</p>
<p>我们训练网络160个迭代周期，初始学习率为$10^{−3}$，在60个和90个迭代周期时将学习率除以10。我们使用0.0005的权重衰减和0.9的动量。我们对YOLO和SSD进行类似的数据增强，随机裁剪，色彩偏移等。我们对COCO和VOC使用相同的训练策略。</p>
<h2 id="4-Stronger"><a href="#4-Stronger" class="headerlink" title="4. Stronger"></a>4. Stronger</h2><p>We propose a mechanism for jointly training on classification and detection data. Our method uses images labelled for detection to learn detection-specific information like bounding box coordinate prediction and objectness as well as how to classify common objects. It uses images with only class labels to expand the number of categories it can detect.</p>
<h2 id="4-更强"><a href="#4-更强" class="headerlink" title="4. 更强"></a>4. 更强</h2><p>我们提出了一个联合训练分类和检测数据的机制。我们的方法使用标记为检测的图像来学习边界框坐标预测和目标之类的特定检测信息以及如何对常见目标进行分类。它使用仅具有类别标签的图像来扩展可检测类别的数量。</p>
<p>During training we mix images from both detection and classification datasets. When our network sees an image labelled for detection we can backpropagate based on the full YOLOv2 loss function. When it sees a classification image we only backpropagate loss from the classification-specific parts of the architecture.</p>
<p>在训练期间，我们混合来自检测和分类数据集的图像。当我们的网络看到标记为检测的图像时，我们可以基于完整的YOLOv2损失函数进行反向传播。当它看到一个分类图像时，我们只能从该架构的分类特定部分反向传播损失。</p>
<p>This approach presents a few challenges. Detection datasets have only common objects and general labels, like <code>dog</code> or <code>boat</code>. Classification datasets have a much wider and deeper range of labels. ImageNet has more than a hundred breeds of dog, including <code>Norfolk terrier</code>, <code>Yorkshire terrier</code>, and <code>Bedlington terrier</code>. If we want to train on both datasets we need a coherent way to merge these labels.</p>
<p>这种方法提出了一些挑战。检测数据集只有通用目标和通用标签，如“狗”或“船”。分类数据集具有更广更深的标签范围。ImageNet有超过一百种品种的狗，包括<code>Norfolk terrier</code>，<code>Yorkshire terrier</code>和<code>Bedlington terrier</code>。如果我们想在两个数据集上训练，我们需要一个连贯的方式来合并这些标签。</p>
<p>Most approaches to classification use a softmax layer across all the possible categories to compute the final probability distribution. Using a softmax assumes the classes are mutually exclusive. This presents problems for combining datasets, for example you would not want to combine ImageNet and COCO using this model because the classes <code>Norfolk terrier</code> and <code>dog</code> are not mutually exclusive.</p>
<p>大多数分类方法使用跨所有可能类别的softmax层来计算最终的概率分布。使用softmax假定这些类是互斥的。这给数据集的组合带来了问题，例如你不想用这个模型来组合ImageNet和COCO，因为类<code>Norfolk terrier</code>和<code>dog</code>不是互斥的。</p>
<p>We could instead use a multi-label model to combine the datasets which does not assume mutual exclusion. This approach ignores all the structure we do know about the data, for example that all of the COCO classes are mutually exclusive.</p>
<p>我们可以改为使用多标签模型来组合不假定互斥的数据集。这种方法忽略了我们已知的关于数据的所有结构，例如，所有的COCO类是互斥的。</p>
<p><strong>Hierarchical classification</strong>. ImageNet labels are pulled from WordNet, a language database that structures concepts and how they relate [12]. In WordNet, <code>Norfolk terrier</code> and <code>Yorkshire terrier</code> are both hyponyms of <code>terrier</code> which is a type of <code>hunting dog</code>, which is a type of <code>dog</code>, which is a <code>canine</code>, etc. Most approaches to classification assume a flat structure to the labels however for combining datasets, structure is exactly what we need.</p>
<p><strong>分层分类</strong>。ImageNet标签是从WordNet中提取的，这是一个构建概念及其相互关系的语言数据库[12]。在WordNet中，<code>Norfolk terrier</code>和<code>Yorkshire terrier</code>都是<code>terrier</code>的下义词，<code>terrier</code>是一种<code>hunting dog</code>，<code>hunting dog</code>是<code>dog</code>，<code>dog</code>是<code>canine</code>等。分类的大多数方法为标签假设一个扁平结构，但是对于组合数据集，结构正是我们所需要的。</p>
<p>WordNet is structured as a directed graph, not a tree, because language is complex. For example a <code>dog</code> is both a type of <code>canine</code> and a type of <code>domestic animal</code> which are both synsets in WordNet. Instead of using the full graph structure, we simplify the problem by building a hierarchical tree from the concepts in ImageNet.</p>
<p>WordNet的结构是有向图，而不是树，因为语言是复杂的。例如，<code>dog</code>既是一种<code>canine</code>，也是一种<code>domestic animal</code>，它们都是WordNet中的同义词。我们不是使用完整的图结构，而是通过从ImageNet的概念中构建分层树来简化问题。</p>
<p>To build this tree we examine the visual nouns in ImageNet and look at their paths through the WordNet graph to the root node, in this case “physical object”. Many synsets only have one path through the graph so first we add all of those paths to our tree. Then we iteratively examine the concepts we have left and add the paths that grow the tree by as little as possible. So if a concept has two paths to the root and one path would add three edges to our tree and the other would only add one edge, we choose the shorter path.</p>
<p>为了构建这棵树，我们检查了ImageNet中的视觉名词，并查看它们通过WordNet图到根节点的路径，在这种情况下是“物理对象”。许多同义词通过图只有一条路径，所以首先我们将所有这些路径添加到我们的树中。然后我们反复检查我们留下的概念，并尽可能少地添加生长树的路径。所以如果一个概念有两条路径到一个根，一条路径会给我们的树增加三条边，另一条只增加一条边，我们选择更短的路径。</p>
<p>The final result is WordTree, a hierarchical model of visual concepts. To perform classification with WordTree we predict conditional probabilities at every node for the probability of each hyponym of that synset given that synset. For example, at the <code>terrier</code> node we predict:<br>$$<br>Pr(\text{Norfolk terrier} | \text{terrier}) \\<br>Pr(\text{Yorkshire terrier} | \text{terrier}) \\<br>Pr(\text{Bedlington terrier} | \text{terrier})\\<br>…\\<br>$$</p>
<p>最终的结果是WordTree，一个视觉概念的分层模型。为了使用WordTree进行分类，我们预测每个节点的条件概率，以得到同义词集合中每个同义词下义词的概率。例如，在<code>terrier</code>节点我们预测：<br>$$<br>Pr(\text{Norfolk terrier} | \text{terrier}) \\<br>Pr(\text{Yorkshire terrier} | \text{terrier}) \\<br>Pr(\text{Bedlington terrier} | \text{terrier})\\<br>…\\<br>$$</p>
<p>If we want to compute the absolute probability for a particular node we simply follow the path through the tree to the root node and multiply to conditional probabilities. So if we want to know if a picture is of a <code>Norfolk terrier</code> we compute:<br>$$<br>Pr(\text{Norfolk terrier}) = Pr(\text{Norfolk terrier} | \text{terrier})\\<br>* Pr(\text{terrier} | \text{hunting dog}) \\<br>* \ldots * \\<br>*Pr(\text{mammal} | Pr(\text{animal})\\<br> * Pr(\text{animal} | \text{physical object})<br>$$</p>
<p>如果我们想要计算一个特定节点的绝对概率，我们只需沿着通过树到达根节点的路径，再乘以条件概率。所以如果我们想知道一张图片是否是<code>Norfolk terrier</code>，我们计算：<br>$$<br>Pr(\text{Norfolk terrier}) = Pr(\text{Norfolk terrier} | \text{terrier})\\<br>* Pr(\text{terrier} | \text{hunting dog}) \\<br>* \ldots * \\<br>*Pr(\text{mammal} | Pr(\text{animal})\\<br> * Pr(\text{animal} | \text{physical object})<br>$$</p>
<p>For classification purposes we assume that the the image contains an object: $Pr(\text{physical object}) = 1$. </p>
<p>为了分类目的，我们假定图像包含一个目标：$Pr(\text{physical object}) = 1$。</p>
<p>To validate this approach we train the Darknet-19 model on WordTree built using the 1000 class ImageNet. To build WordTree1k we add in all of the intermediate nodes which expands the label space from 1000 to 1369. During training we propagate ground truth labels up the tree so that if an image is labelled as a <code>Norfolk terrier</code> it also gets labelled as a <code>dog</code> and a <code>mammal</code>, etc. To compute the conditional probabilities our model predicts a vector of 1369 values and we compute the softmax over all sysnsets that are hyponyms of the same concept, see Figure 5.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-ea0e04e34b0741ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 5"></p>
<p><strong>Figure 5: Prediction on ImageNet vs WordTree</strong>. Most ImageNet models use one large softmax to predict a probability distribution. Using WordTree we perform multiple softmax operations over co-hyponyms.</p>
<p>为了验证这种方法，我们在使用1000类ImageNet构建的WordTree上训练Darknet-19模型。为了构建WordTree1k，我们添加了所有将标签空间从1000扩展到1369的中间节点。在训练过程中，我们将真实标签向树上面传播，以便如果图像被标记为<code>Norfolk terrier</code>，则它也被标记为<code>dog</code>和<code>mammal</code>等。为了计算条件概率，我们的模型预测了具有1369个值的向量，并且我们计算了相同概念的下义词在所有同义词集上的softmax，见图5。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3232548-ea0e04e34b0741ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 5"></p>
<p><strong>图5：在ImageNet与WordTree上的预测</strong>。大多数ImageNet模型使用一个较大的softmax来预测概率分布。使用WordTree，我们可以在共同的下义词上执行多次softmax操作。</p>
<p>Using the same training parameters as before, our hierarchical Darknet-19 achieves $71.9\%$ top-1 accuracy and $90.4\%$ top-5 accuracy. Despite adding 369 additional concepts and having our network predict a tree structure our accuracy only drops marginally. Performing classification in this manner also has some benefits. Performance degrades gracefully on new or unknown object categories. For example, if the network sees a picture of a dog but is uncertain what type of dog it is, it will still predict <code>dog</code> with high confidence but have lower confidences spread out among the hyponyms.</p>
<p>使用与以前相同的训练参数，我们的分级Darknet-19达到$71.9\%$的<code>top-1</code>准确率和$90.4\%$的<code>top-5</code>准确率。尽管增加了369个额外的概念，而且我们的网络预测了一个树状结构，但我们的准确率仅下降了一点点。以这种方式进行分类也有一些好处。在新的或未知的目标类别上性能会优雅地降低。例如，如果网络看到一只狗的照片，但不确定它是什么类型的狗，它仍然会高度自信地预测“狗”，但是在下义位扩展之间有更低的置信度。</p>
<p>This formulation also works for detection. Now, instead of assuming every image has an object, we use YOLOv2’s objectness predictor to give us the value of $Pr(\text{physical object})$. The detector predicts a bounding box and the tree of probabilities. We traverse the tree down, taking the highest confidence path at every split until we reach some threshold and we predict that object class.</p>
<p>这个构想也适用于检测。现在，我们不是假定每张图像都有一个目标，而是使用YOLOv2的目标预测器给我们$Pr(\text{physical object})$的值。检测器预测边界框和概率树。我们遍历树，在每个分割中采用最高的置信度路径，直到达到某个阈值，然后我们预测目标类。</p>
<p><strong>Dataset combination with WordTree</strong>. We can use WordTree to combine multiple datasets together in a sensible fashion. We simply map the categories in the datasets to synsets in the tree. Figure 6 shows an example of using WordTree to combine the labels from ImageNet and COCO. WordNet is extremely diverse so we can use this technique with most datasets.</p>
<p><strong>与WordTree的数据集组合</strong>。我们可以使用WordTree以合理的方式将多个数据集组合在一起。我们只需将数据集中的类别映射到树中的synsets即可。图6显示了使用WordTree来组合来自ImageNet和COCO的标签的示例。WordNet是非常多样化的，所以我们可以在大多数数据集中使用这种技术。</p>
<p><strong>Joint classification and detection</strong>. Now that we can combine datasets using WordTree we can train our joint model on classification and detection. We want to train an extremely large scale detector so we create our combined dataset using the COCO detection dataset and the top 9000 classes from the full ImageNet release. We also need to evaluate our method so we add in any classes from the ImageNet detection challenge that were not already included. The corresponding WordTree for this dataset has 9418 classes. ImageNet is a much larger dataset so we balance the dataset by oversampling COCO so that ImageNet is only larger by a factor of 4:1.</p>
<p><strong>联合分类和检测</strong>。现在我们可以使用WordTree组合数据集，我们可以在分类和检测上训练联合模型。我们想要训练一个非常大规模的检测器，所以我们使用COCO检测数据集和完整的ImageNet版本中的前9000个类来创建我们的组合数据集。我们还需要评估我们的方法，以便从ImageNet检测挑战中添加任何尚未包含的类。该数据集的相应WordTree有9418个类别。ImageNet是一个更大的数据集，所以我们通过对COCO进行过采样来平衡数据集，使得ImageNet仅仅大于4:1的比例。</p>
<p>Using this dataset we train YOLO9000. We use the base YOLOv2 architecture but only 3 priors instead of 5 to limit the output size. When our network sees a detection image we backpropagate loss as normal. For classification loss, we only backpropagate loss at or above the corresponding level of the label. For example, if the label is <code>dog</code> we do assign any error to predictions further down in the tree, <code>German Shepherd</code> versus <code>Golden Retriever</code>, because we do not have that information.</p>
<p>使用这个数据集我们训练YOLO9000。我们使用基础的YOLOv2架构，但只有3个先验而不是5个来限制输出大小。当我们的网络看到一个检测图像时，我们正常的反向传播损失。对于分类损失，我们仅在等于或高于标签对应的层反向传播损失。例如，如果标签是“狗”，我们确实沿着树向下进一步预测“德国牧羊犬”与“金毛猎犬”之间的差异，因为我们没有这些信息。</p>
<p>When it sees a classification image we only backpropagate classification loss. To do this we simply find the bounding box that predicts the highest probability for that class and we compute the loss on just its predicted tree. We also assume that the predicted box overlaps what would be the ground truth label by at least 0.3 IOU and we backpropagate objectness loss based on this assumption.</p>
<p>当它看到分类图像时，我们只能反向传播分类损失。要做到这一点，我们只需找到预测该类别最高概率的边界框，然后计算其预测树上的损失。我们还假设预测边界框与真实标签重叠至少0.3的IOU，并且基于这个假设反向传播目标损失。</p>
<p>Using this joint training, YOLO9000 learns to find objects in images using the detection data in COCO and it learns to classify a wide variety of these objects using data from ImageNet.</p>
<p>使用这种联合训练，YOLO9000学习使用COCO中的检测数据来查找图像中的目标，并学习使用来自ImageNet的数据对各种目标进行分类。</p>
<p>We evaluate YOLO9000 on the ImageNet detection task. The detection task for ImageNet shares on 44 object categories with COCO which means that YOLO9000 has only seen classification data for the majority of the test images, not detection data. YOLO9000 gets 19.7 mAP overall with 16.0 mAP on the disjoint 156 object classes that it has never seen any labelled detection data for. This mAP is higher than results achieved by DPM but YOLO9000 is trained on different datasets with only partial supervision [4]. It also is simultaneously detecting 9000 other object categories, all in real-time.</p>
<p>我们在ImageNet检测任务上评估YOLO9000。ImageNet的检测任务与COCO共享44个目标类别，这意味着YOLO9000只能看到大多数测试图像的分类数据，而不是检测数据。YOLO9000在从未见过任何标记的检测数据的情况下，整体上获得了19.7 mAP，在不相交的156个目标类别中获得了16.0 mAP。这个mAP高于DPM的结果，但是YOLO9000在不同的数据集上训练，只有部分监督[4]。它也同时检测9000个其他目标类别，所有的都是实时的。</p>
<p>When we analyze YOLO9000’s performance on ImageNet we see it learns new species of animals well but struggles with learning categories like clothing and equipment. New animals are easier to learn because the objectness predictions generalize well from the animals in COCO. Conversely, COCO does not have bounding box label for any type of clothing, only for person, so YOLO9000 struggles to model categories like “sunglasses” or “swimming trunks”.</p>
<p>当我们分析YOLO9000在ImageNet上的表现时，我们发现它很好地学习了新的动物种类，但是却在像服装和设备这样的学习类别中挣扎。新动物更容易学习，因为目标预测可以从COCO中的动物泛化的很好。相反，COCO没有任何类型的衣服的边界框标签，只针对人，因此YOLO9000正在努力建模“墨镜”或“泳裤”等类别。</p>
<h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h2><p>We introduce YOLOv2 and YOLO9000, real-time detection systems. YOLOv2 is state-of-the-art and faster than other detection systems across a variety of detection datasets. Furthermore, it can be run at a variety of image sizes to provide a smooth tradeoff between speed and accuracy.</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>我们介绍了YOLOv2和YOLO9000，两个实时检测系统。YOLOv2在各种检测数据集上都是最先进的，也比其他检测系统更快。此外，它可以运行在各种图像大小，以提供速度和准确性之间的平滑折衷。</p>
<p>YOLO9000 is a real-time framework for detection more than 9000 object categories by jointly optimizing detection and classification. We use WordTree to combine data from various sources and our joint optimization technique to train simultaneously on ImageNet and COCO. YOLO9000 is a strong step towards closing the dataset size gap between detection and classification.</p>
<p>YOLO9000是一个通过联合优化检测和分类来检测9000多个目标类别的实时框架。我们使用WordTree将各种来源的数据和我们的联合优化技术相结合，在ImageNet和COCO上同时进行训练。YOLO9000是在检测和分类之间缩小数据集大小差距的重要一步。</p>
<p>Many of our techniques generalize outside of object detection. Our WordTree representation of ImageNet offers a richer, more detailed output space for image classification. Dataset combination using hierarchical classification would be useful in the classification and segmentation domains. Training techniques like multi-scale training could provide benefit across a variety of visual tasks.</p>
<p>我们的许多技术都可以泛化到目标检测之外。我们对ImageNet的WordTree表示为图像分类提供了更丰富，更详细的输出空间。使用分层分类的数据集组合在分类和分割领域将是有用的。像多尺度训练这样的训练技术可以为各种视觉任务提供益处。</p>
<p>For future work we hope to use similar techniques for weakly supervised image segmentation. We also plan to improve our detection results using more powerful matching strategies for assigning weak labels to classification data during training. Computer vision is blessed with an enormous amount of labelled data. We will continue looking for ways to bring different sources and structures of data together to make stronger models of the visual world.</p>
<p>对于未来的工作，我们希望使用类似的技术来进行弱监督的图像分割。我们还计划使用更强大的匹配策略来改善我们的检测结果，以在训练期间将弱标签分配给分类数据。计算机视觉受到大量标记数据的祝福。我们将继续寻找方法，将不同来源和数据结构的数据整合起来，形成更强大的视觉世界模型。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] S. Bell, C. L. Zitnick, K. Bala, and R. Girshick. Inside-outside net: Detecting objects in context with skip pooling and recurrent neural networks. arXiv preprint arXiv:1512.04143, 2015. 6</p>
<p>[2] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei- Fei. Imagenet: A large-scale hierarchical image database. In Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on, pages 248–255. IEEE, 2009. 1</p>
<p>[3] M. Everingham, L. Van Gool, C. K. Williams, J. Winn, and A. Zisserman. The pascal visual object classes (voc) challenge. International journal of computer vision, 88(2):303– 338, 2010. 1</p>
<p>[4] P. F. Felzenszwalb, R. B. Girshick, and D. McAllester. Discriminatively trained deformable part models, release 4. <a href="http://people.cs.uchicago.edu/pff/latent-release4/" target="_blank" rel="external">http://people.cs.uchicago.edu/pff/latent-release4/</a>. 8</p>
<p>[5] R. B. Girshick. Fast R-CNN. CoRR, abs/1504.08083, 2015. 4, 5, 6</p>
<p>[6] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. arXiv preprint arXiv:1512.03385, 2015. 2, 4, 5</p>
<p>[7] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015. 2, 5</p>
<p>[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012. 2</p>
<p>[9] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv preprint arXiv:1312.4400, 2013. 5</p>
<p>[10] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick. Microsoft coco: Common objects in context. In European Conference on Computer Vision, pages 740–755. Springer, 2014. 1, 6</p>
<p>[11] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, and S. E. Reed. SSD: single shot multibox detector. CoRR, abs/1512.02325, 2015. 4, 5, 6</p>
<p>[12] G. A. Miller, R. Beckwith, C. Fellbaum, D. Gross, and K. J. Miller. Introduction to wordnet: An on-line lexical database. International journal of lexicography, 3(4):235–244, 1990. 6</p>
<p>[13] J. Redmon. Darknet: Open source neural networks in c. <a href="http://pjreddie.com/darknet/" target="_blank" rel="external">http://pjreddie.com/darknet/</a>, 2013–2016. 5</p>
<p>[14] J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You only look once: Unified, real-time object detection. arXiv preprint arXiv:1506.02640, 2015. 4, 5</p>
<p>[15] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards real-time object detection with region proposal net- works. arXiv preprint arXiv:1506.01497, 2015. 2, 3, 4, 5, 6</p>
<p>[16] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei. ImageNet Large Scale Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 2015. 2</p>
<p>[17] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014. 2, 5</p>
<p>[18] C. Szegedy, S. Ioffe, and V. Vanhoucke. Inception-v4, inception-resnet and the impact of residual connections on learning. CoRR, abs/1602.07261, 2016. 2</p>
<p>[19] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich. Going deeper with convolutions. CoRR, abs/1409.4842, 2014. 5</p>
<p>[20] B. Thomee, D. A. Shamma, G. Friedland, B. Elizalde, K. Ni, D. Poland, D. Borth, and L.-J. Li. Yfcc100m: The new data in multimedia research. Communications of the ACM, 59(2):64–73, 2016. 1</p>
]]></content>
    
    <summary type="html">
    
      YOLO9000, Better, Faster, Stronger论文翻译——中英文对照
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>枚举——熄灯问题</title>
    <link href="noahsnail.com/2017/12/21/2017-12-21-%E6%9E%9A%E4%B8%BE%E2%80%94%E2%80%94%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98/"/>
    <id>noahsnail.com/2017/12/21/2017-12-21-枚举——熄灯问题/</id>
    <published>2017-12-21T13:40:31.000Z</published>
    <updated>2017-12-26T02:13:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h2><p>枚举是基于逐个尝试答案的一种问题求解策略。</p>
<h2 id="2-熄灯问题（POJ1222）"><a href="#2-熄灯问题（POJ1222）" class="headerlink" title="2. 熄灯问题（POJ1222）"></a>2. 熄灯问题（POJ1222）</h2><ul>
<li><p>问题描述<br>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。<br><img src="http://upload-images.jianshu.io/upload_images/3232548-cc19012d907ceb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 1"><br>如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。<br><img src="http://upload-images.jianshu.io/upload_images/3232548-a4dbfb424bd5e04b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 2"><br>与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。</p>
</li>
<li><p>输入<br>5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p>
</li>
<li><p>输出<br>5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p>
</li>
<li><p>输入样例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 1 1 0 1 0</div><div class="line">1 0 0 1 1 1</div><div class="line">0 0 1 0 0 1</div><div class="line">1 0 0 1 0 1</div><div class="line">0 1 1 1 0 0</div></pre></td></tr></table></figure>
</li>
<li><p>输出样例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 0 1 0 0 1</div><div class="line">1 1 0 1 0 1</div><div class="line">0 0 1 0 1 1</div><div class="line">1 0 0 1 0 0</div><div class="line">0 1 0 0 0 0</div></pre></td></tr></table></figure>
</li>
<li><p>分析<br>假设当前灯亮，按钮按一次，灯变灭，再按一次，灯又变亮，恢复到了初始状态，因此，按钮按两次是没意义的。结论：按钮按偶数次没意义，按钮按奇数次与按一次一样，因此，每个按钮最多按一次。</p>
</li>
<li><p>解题思路</p>
</li>
</ul>
<ol>
<li>枚举所有可能的按钮状态，每种状态计算一下最后的情况，看是否都熄灭。所有状态数为$2^{30}$，因此这种方案不可行。</li>
<li>如果存在某个局部，一旦这个局部的状态确定，那么剩下的其它状态只能是确定的一种，或不多的n种，则只需要枚举这个局部即可。以第一行为例，假设它就是那个局部，如果第一行的状态确定了，是不是第二行的状态就确定了呢？答案是是的，因为第一行按钮按过之后，亮的灯只有按第二行才能将其熄灭。同理，第二行按钮按下后，只能通过第三行按钮来控制灯熄灭。</li>
<li>枚举第一行的所有可能状态，每个位置有0和1两种状态，共6个位置，因此第一行的所有可能状态为$2^6=64$种，枚举状态可以通过递归实现。如果使用每个比特位代表一个灯的话，则可能的状态为数字0-63。</li>
</ol>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 枚举第一行的所有可能状态</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_status</span><span class="params">(status_list, status, depth)</span>:</span></div><div class="line">    rows, columns = status.shape</div><div class="line">    other = status.copy()</div><div class="line">    other[<span class="number">0</span>, depth] = <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> depth == columns - <span class="number">1</span>:</div><div class="line">        status_list.append(status.copy())    </div><div class="line">        status_list.append(other.copy())</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        all_status(status_list, status.copy(), depth + <span class="number">1</span>)</div><div class="line">        all_status(status_list, other.copy(), depth + <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 如果按钮按下，更改灯的状态</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">light_change</span><span class="params">(input_data, i, j)</span>:</span></div><div class="line">    rows, columns = input_data.shape</div><div class="line">    input_data[i, j] = (input_data[i, j] + <span class="number">1</span>) % <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>) &gt;= <span class="number">0</span>:</div><div class="line">        input_data[i - <span class="number">1</span>, j] = (input_data[i - <span class="number">1</span>, j] + <span class="number">1</span>) % <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) &lt; rows:</div><div class="line">        input_data[i + <span class="number">1</span>, j] = (input_data[i + <span class="number">1</span>, j] + <span class="number">1</span>) % <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (j - <span class="number">1</span>) &gt;= <span class="number">0</span>:</div><div class="line">        input_data[i, j - <span class="number">1</span>] = (input_data[i, j - <span class="number">1</span>] + <span class="number">1</span>) % <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (j + <span class="number">1</span>) &lt; columns:</div><div class="line">        input_data[i, j + <span class="number">1</span>] = (input_data[i, j + <span class="number">1</span>] + <span class="number">1</span>) % <span class="number">2</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 尝试关闭所有灯</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">light_off</span><span class="params">(input_data, output_data)</span>:</span></div><div class="line">    rows, columns = input_data.shape</div><div class="line">    <span class="comment"># 根据第一行按钮的状态修改灯的亮灭</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, columns):</div><div class="line">        <span class="keyword">if</span> output_data[<span class="number">0</span>, i] == <span class="number">1</span>:</div><div class="line">            light_change(input_data, <span class="number">0</span>, i)</div><div class="line">    <span class="comment"># 从第二行开始，每一行的按钮都使上一行的灯熄灭</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rows):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, columns):</div><div class="line">            <span class="keyword">if</span> input_data[i - <span class="number">1</span>, j] == <span class="number">1</span>:</div><div class="line">                light_change(input_data, i, j)</div><div class="line">                output_data[i, j] = <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> np.sum(input_data) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span>, output_data</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span>, output_data</div><div class="line"></div><div class="line"><span class="comment"># 输出指定格式的结果</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(output_data)</span>:</span></div><div class="line">    rows, columns = output_data.shape</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(rows):</div><div class="line">        binary_string = <span class="string">''</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(columns):</div><div class="line">            binary_string += str(output_data[i, j])</div><div class="line">        <span class="keyword">print</span> binary_string</div><div class="line"></div><div class="line">input_list = []</div><div class="line">input_data = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</div><div class="line">                       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</div><div class="line">                       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</div><div class="line">                       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype = <span class="string">'int8'</span>)</div><div class="line">input_list.append(input_data)</div><div class="line">input_data = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</div><div class="line">                       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">                       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype = <span class="string">'int8'</span>)</div><div class="line">input_list.append(input_data)</div><div class="line">status_list = []</div><div class="line">status = np.zeros((<span class="number">5</span>, <span class="number">6</span>), dtype = <span class="string">'int8'</span>)</div><div class="line">all_status(status_list, status, <span class="number">0</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(input_list)):</div><div class="line">    input_data = input_list[i]</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(status_list)):</div><div class="line">        flag, output_data = light_off(input_data.copy(), status_list[j].copy())</div><div class="line">        <span class="keyword">if</span> flag:</div><div class="line">            <span class="keyword">print</span> j</div><div class="line">            <span class="keyword">print</span> <span class="string">'PUZZLE #%d'</span> % (i + <span class="number">1</span>)</div><div class="line">            print_result(output_data)</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PUZZLE #1</div><div class="line">101001</div><div class="line">110101</div><div class="line">001011</div><div class="line">100100</div><div class="line">010000</div><div class="line">PUZZLE #2</div><div class="line">100111</div><div class="line">110000</div><div class="line">000100</div><div class="line">110101</div><div class="line">101101</div></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 取特定位置上的比特，索引从0开始</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bit</span><span class="params">(number, index)</span>:</span></div><div class="line">    <span class="keyword">return</span> (number &gt;&gt; index) &amp; <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 设定特定位置上的比特</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_bit</span><span class="params">(number, index, value)</span>:</span></div><div class="line">    <span class="keyword">return</span> number | (value &lt;&lt; index)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 特定位置上的比特反转</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip</span><span class="params">(number, index)</span>:</span></div><div class="line">    <span class="keyword">return</span> number ^ (<span class="number">1</span> &lt;&lt; index)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 如果按钮按下，更改灯的状态</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">light_change</span><span class="params">(input_data, i, j)</span>:</span></div><div class="line">    rows = <span class="number">5</span></div><div class="line">    columns = <span class="number">6</span></div><div class="line">    input_data[i] = flip(input_data[i], j)</div><div class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>) &gt;= <span class="number">0</span>:</div><div class="line">        input_data[i - <span class="number">1</span>] = flip(input_data[i - <span class="number">1</span>], j)</div><div class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) &lt; rows:</div><div class="line">        input_data[i + <span class="number">1</span>] = flip(input_data[i + <span class="number">1</span>], j)</div><div class="line">    <span class="keyword">if</span> (j - <span class="number">1</span>) &gt;= <span class="number">0</span>:</div><div class="line">        input_data[i] = flip(input_data[i], j - <span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> (j + <span class="number">1</span>) &lt; columns:</div><div class="line">        input_data[i] = flip(input_data[i], j + <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 尝试关闭所有灯</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">light_off</span><span class="params">(input_data, output_data)</span>:</span></div><div class="line">    rows = <span class="number">5</span></div><div class="line">    columns = <span class="number">6</span></div><div class="line">    <span class="comment"># 根据第一行按钮的状态修改灯的亮灭</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, columns):</div><div class="line">        <span class="keyword">if</span> get_bit(output_data[<span class="number">0</span>], i) == <span class="number">1</span>:</div><div class="line">            light_change(input_data, <span class="number">0</span>, i)</div><div class="line">    <span class="comment"># 从第二行开始，每一行的按钮都使上一行的灯熄灭</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rows):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, columns):</div><div class="line">            <span class="keyword">if</span> get_bit(input_data[i - <span class="number">1</span>], j) == <span class="number">1</span>:</div><div class="line">                light_change(input_data, i, j)</div><div class="line">                output_data[i] = set_bit(output_data[i], j, <span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> input_data[<span class="number">-1</span>] == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 输出指定格式的结果</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(output_data)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(output_data)):</div><div class="line">        binary_string = bin(output_data[i])[<span class="number">2</span>:]</div><div class="line">        diff = <span class="number">6</span> - len(binary_string)</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(diff):</div><div class="line">            binary_string = <span class="string">'0'</span> + binary_string</div><div class="line">        <span class="keyword">print</span> binary_string</div><div class="line"></div><div class="line"></div><div class="line">input_list = []</div><div class="line">input_data = [int(<span class="string">'011010'</span>, <span class="number">2</span>), int(<span class="string">'100111'</span>, <span class="number">2</span>), int(<span class="string">'001001'</span>, <span class="number">2</span>), int(<span class="string">'100101'</span>, <span class="number">2</span>), int(<span class="string">'011100'</span>, <span class="number">2</span>)]</div><div class="line">input_list.append(input_data)</div><div class="line">input_data = [int(<span class="string">'001010'</span>, <span class="number">2</span>), int(<span class="string">'101011'</span>, <span class="number">2</span>), int(<span class="string">'001011'</span>, <span class="number">2</span>), int(<span class="string">'101100'</span>, <span class="number">2</span>), int(<span class="string">'010100'</span>, <span class="number">2</span>)]</div><div class="line">input_list.append(input_data)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(input_list)):</div><div class="line">    input_data = input_list[i]</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">64</span>):</div><div class="line">        copy = [input_data[x] <span class="keyword">for</span> x <span class="keyword">in</span> xrange(len(input_data))]</div><div class="line">        output_data = [<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">5</span>)]</div><div class="line">        output_data[<span class="number">0</span>] = j</div><div class="line">        flag = light_off(copy, output_data)</div><div class="line">        <span class="keyword">if</span> flag:</div><div class="line">            <span class="keyword">print</span> <span class="string">'PUZZLE #%d'</span> % (i + <span class="number">1</span>)</div><div class="line">            print_result(output_data)</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PUZZLE #1</div><div class="line">101001</div><div class="line">110101</div><div class="line">001011</div><div class="line">100100</div><div class="line">010000</div><div class="line">PUZZLE #2</div><div class="line">100111</div><div class="line">110000</div><div class="line">000100</div><div class="line">110101</div><div class="line">101101</div></pre></td></tr></table></figure>
<p><strong>总结：这个问题比较复杂，其中隐含的一点就是局部状态确定后，后面的状态都会被确定，此时需要枚举局部状态。方法一与方法二的求解思路是一样，但实现方式不一样，方法一使用Numpy来处理数据，而方法二使用比特来处理数据。</strong></p>
<p>源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/turn_off_light_numpy.py" target="_blank" rel="external">Numpy方法</a>，<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/turn_off_light_binary.py" target="_blank" rel="external">二进制比特方法</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      枚举——熄灯问题
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="枚举" scheme="noahsnail.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>枚举——称硬币</title>
    <link href="noahsnail.com/2017/12/20/2017-12-20-%E6%9E%9A%E4%B8%BE%E2%80%94%E2%80%94%E7%A7%B0%E7%A1%AC%E5%B8%81/"/>
    <id>noahsnail.com/2017/12/20/2017-12-20-枚举——称硬币/</id>
    <published>2017-12-20T12:36:16.000Z</published>
    <updated>2017-12-21T13:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h2><p>枚举是基于逐个尝试答案的一种问题求解策略。</p>
<h2 id="2-称硬币（POJ1013）"><a href="#2-称硬币（POJ1013）" class="headerlink" title="2. 称硬币（POJ1013）"></a>2. 称硬币（POJ1013）</h2><ul>
<li><p>问题描述<br>有12枚硬币。其中有11枚真币和1枚假币。假币和真币重量不同，但不知道假币比真币轻还是重。现在，用一架天平称了这些币三次，告诉你称的结果，请你找出假币并且确定假币是轻是重（数据保证一定能找出来）。</p>
</li>
<li><p>输入<br>第一行是测试数据组数。<br>每组数据有三行，每行表示一次称量的结果。银币标号为A-L。每次称量的结果用三个以空格隔开的字符串表示：天平左边放置的硬币、天平右边放置的硬币、平衡状态。其中平衡状态用<code>up</code>，<code>down</code>或<code>even</code>表示，分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p>
</li>
<li><p>输出<br>输出哪一个标号的银币是假币，并说明它比真币轻还是重。</p>
</li>
<li><p>输入样例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">ABCD EFGH even</div><div class="line">ABCI EFJK up</div><div class="line">ABIJ EFGH even</div></pre></td></tr></table></figure>
</li>
<li><p>输出样例<br>K is the counterfeit coin and it is light.</p>
</li>
<li><p>解题思路</p>
</li>
</ul>
<p>对于每一枚硬币先假设它是轻的，看这样是否符合称量结果。如果符合，问题即解决。如果不符合，就假设它是重的，看是否符合称量结果。把所有硬币都试一遍，一定能找到特殊硬币。</p>
<ul>
<li>分析</li>
</ul>
<p>根据硬币的状态（轻重）和硬币所处的位置（左右或无）可以判断出称重结果，如果三次判断的结果与真实结果都相符，则当前硬币及当前状态即为结果。</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">input_data = [[&apos;ABCD&apos;, &apos;EFGH&apos;, &apos;even&apos;], [&apos;ABCI&apos;, &apos;EFJK&apos;, &apos;up&apos;], [&apos;ABIJ&apos;, &apos;EFGH&apos;, &apos;even&apos;]]</div><div class="line">labels = &apos;ABCDEFGHIJKL&apos;</div><div class="line">label_status = [&apos;light&apos;, &apos;heavy&apos;]</div><div class="line">for label in labels:</div><div class="line">    for status in label_status:</div><div class="line">        for data in input_data:</div><div class="line">            flag = True</div><div class="line">            left = data[0]</div><div class="line">            right = data[1]</div><div class="line">            result = data[2]</div><div class="line">            if label in left:</div><div class="line">                if status == &apos;light&apos;:</div><div class="line">                    should_be = &apos;down&apos;</div><div class="line">                else:</div><div class="line">                    should_be = &apos;up&apos;</div><div class="line">            elif label in right:</div><div class="line">                if status == &apos;light&apos;:</div><div class="line">                    should_be = &apos;up&apos;</div><div class="line">                else:</div><div class="line">                    should_be = &apos;down&apos;</div><div class="line">            else:</div><div class="line">                should_be = &apos;even&apos;</div><div class="line">            if should_be != result:</div><div class="line">                flag = False</div><div class="line">                break</div><div class="line">        if flag:</div><div class="line">            print &apos;%s is the counterfeit coin and it is %s.&apos; % (label, status)</div></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">K is the counterfeit coin and it is light.</div></pre></td></tr></table></figure>
<p><strong>总结：有时候枚举问题并不像那么明显，需要仔细的分析与思考才能想到，当问题不是非常复杂时，有时可以先从枚举开始尝试解决问题。</strong></p>
<p>源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/weigh_coins.py" target="_blank" rel="external">https://github.com/SnailTyan/programming-and-algorithms/blob/master/weigh_coins.py</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      枚举——称硬币
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="枚举" scheme="noahsnail.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>枚举——生理周期</title>
    <link href="noahsnail.com/2017/12/19/2017-12-19-%E6%9E%9A%E4%B8%BE%E2%80%94%E2%80%94%E7%94%9F%E7%90%86%E5%91%A8%E6%9C%9F/"/>
    <id>noahsnail.com/2017/12/19/2017-12-19-枚举——生理周期/</id>
    <published>2017-12-19T12:49:34.000Z</published>
    <updated>2017-12-20T12:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h2><p>枚举是基于逐个尝试答案的一种问题求解策略。</p>
<h2 id="2-生理周期"><a href="#2-生理周期" class="headerlink" title="2. 生理周期"></a>2. 生理周期</h2><ul>
<li><p>问题描述<br>人有体力、情商、智商的高峰日子，它们分别每隔23天、28天和33天出现一次。对于每个人，我们想知道何时三个高峰落在同一天。给定三个高峰出现的日子p，e和i(不一定是第一次高峰出现的日子)，再给定另一个指定的日子d，你的任务是输出日子d之后,下一次三个高峰落在同一天的日子(用距离d的天数表示)。例如：给定日子为10，下次出现三个高峰同一天的日子是12,则输出2。</p>
</li>
<li><p>输入<br>输入四个整数：p，e，i和d。p，e，i分别表示体力、情感和智力高峰出现的日子。d是给定的日子，可能小于p，e或i。所有给定日子是非负的并且小于或等于365，所求的日子小于或等于21252。</p>
</li>
<li><p>输出<br>从给定日子起，下一次三个高峰同一天的日子(距离给定日子的天数)。</p>
</li>
<li><p>输入样例<br>0 0 0 0<br>0 0 0 100<br>5 20 34 325<br>4 5 6 7<br>283 102 23 320<br>203 301 203 40<br>-1 -1 -1 -1<br>四个-1表示输入结果，四个数字分别表示p，e，i，d。</p>
</li>
<li><p>输出样例<br>Case 1: the next triple peak occurs in 21252 days.<br>Case 2: the next triple peak occurs in 21152 days.<br>Case 3: the next triple peak occurs in 19575 days.<br>Case 4: the next triple peak occurs in 16994 days.<br>Case 5: the next triple peak occurs in 8910 days.<br>Case 6: the next triple peak occurs in 10789 days.</p>
</li>
</ul>
<ul>
<li>解法一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">input_data = [[0, 0, 0, 0],</div><div class="line">              [0, 0, 0, 100],</div><div class="line">              [5, 20, 34, 325],</div><div class="line">              [4, 5, 6, 7],</div><div class="line">              [283, 102, 23, 320],</div><div class="line">              [203, 301, 203, 40]]</div><div class="line">max_days = 21252</div><div class="line">p_circle = 23</div><div class="line">e_circle = 28</div><div class="line">i_circle = 33</div><div class="line"></div><div class="line">for data in input_data:</div><div class="line">    p = data[0]</div><div class="line">    e = data[1]</div><div class="line">    i = data[2]</div><div class="line">    d = data[3]</div><div class="line">    for day in xrange(d + 1, max_days + 1):</div><div class="line">        if abs(day - p) % p_circle == 0 and abs(day - e) % e_circle == 0 and abs(day - i) % i_circle == 0:</div><div class="line">            print &apos;the next triple peak occurs in %d days.&apos; % (day - d)</div><div class="line">            break</div></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">the next triple peak occurs in 21252 days.</div><div class="line">the next triple peak occurs in 21152 days.</div><div class="line">the next triple peak occurs in 19575 days.</div><div class="line">the next triple peak occurs in 16994 days.</div><div class="line">the next triple peak occurs in 8910 days.</div><div class="line">the next triple peak occurs in 10789 days.</div></pre></td></tr></table></figure>
<ul>
<li>用时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">executed in 32ms</div></pre></td></tr></table></figure>
<p>分析：遍历每一天，得出最终的解。</p>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line">input_data = [[0, 0, 0, 0],</div><div class="line">              [0, 0, 0, 100],</div><div class="line">              [5, 20, 34, 325],</div><div class="line">              [4, 5, 6, 7],</div><div class="line">              [283, 102, 23, 320],</div><div class="line">              [203, 301, 203, 40]]</div><div class="line">max_days = 21252</div><div class="line">p_circle = 23</div><div class="line">e_circle = 28</div><div class="line">i_circle = 33</div><div class="line"></div><div class="line">for data in input_data:</div><div class="line">    p = data[0]</div><div class="line">    e = data[1]</div><div class="line">    i = data[2]</div><div class="line">    d = data[3]</div><div class="line"></div><div class="line">    circles = (max_days - i) // i_circle</div><div class="line">    </div><div class="line">    for circle in xrange(1, circles + 1):</div><div class="line">        day = i + i_circle * circle</div><div class="line">        if (day - p) % p_circle == 0 and (day - e) % e_circle == 0:</div><div class="line">            print &apos;the next triple peak occurs in %d days.&apos; % (day - d)</div><div class="line">            break</div></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">the next triple peak occurs in 21252 days.</div><div class="line">the next triple peak occurs in 21152 days.</div><div class="line">the next triple peak occurs in 19575 days.</div><div class="line">the next triple peak occurs in 16994 days.</div><div class="line">the next triple peak occurs in 8910 days.</div><div class="line">the next triple peak occurs in 10789 days.</div></pre></td></tr></table></figure>
<ul>
<li>用时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">executed in 17ms</div></pre></td></tr></table></figure>
<p>分析：其实中间有许多日子可以跳过。</p>
<p><strong>总结：虽然枚举就是一个个去尝试，但在求解问题时往往不需要尝试每一个可能。通过一些逻辑可以合理的避免一些无用的尝试。从时间上也可以看出时间节省了大约一半。</strong></p>
<p>源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/physical_period.py" target="_blank" rel="external">https://github.com/SnailTyan/programming-and-algorithms/blob/master/physical_period.py</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      枚举——生理周期
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="枚举" scheme="noahsnail.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>枚举——完美立方</title>
    <link href="noahsnail.com/2017/12/18/2017-12-18-%E6%9E%9A%E4%B8%BE%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E7%AB%8B%E6%96%B9/"/>
    <id>noahsnail.com/2017/12/18/2017-12-18-枚举——完美立方/</id>
    <published>2017-12-18T12:32:20.000Z</published>
    <updated>2017-12-27T10:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a> </p>
<h2 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h2><p>枚举是基于逐个尝试答案的一种问题求解策略。</p>
<h2 id="2-完美立方"><a href="#2-完美立方" class="headerlink" title="2. 完美立方"></a>2. 完美立方</h2><p>形如$a^3 = b^3 + c^3 + d^3$的等式被称为完美立方等式。例如$12^3 = 6^3 + 8^3 + 10^3$</p>
<p>问题：编写程序，对任给的正整数N（N&lt;=100），寻找所有的四元组(a, b, c, d)，使得$a^3 = b^3 + c^3 + d^3$，其中a，b，c，d大于1，小于等于N，且b&lt;=c&lt;=d。</p>
<p>输入：一个正整数N（N&lt;=100）。<br>输出：每行输出一个完美立方。输出格式为Cube = a，Triple = (b, c, d)。</p>
<p>求解：</p>
<p><strong>备注：判断条件边界很重要</strong></p>
<ul>
<li>方法一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line"></div><div class="line">import sys</div><div class="line">import math</div><div class="line"></div><div class="line"># n = sys.argv[1]</div><div class="line">n = 24</div><div class="line"></div><div class="line">i = 0</div><div class="line">for a in xrange(2, n + 1):</div><div class="line">    for b in xrange(2, n):</div><div class="line">        for c in xrange(b, n):</div><div class="line">            for d in xrange(c, n):</div><div class="line">                i += 1</div><div class="line">                if math.pow(a, 3) == math.pow(b, 3) + math.pow(c, 3) + math.pow(d, 3):</div><div class="line">                    print &apos;Cube = %d, Triple = (%d, %d, %d)&apos; % (a, b, c, d)</div><div class="line">print &apos;%d iterations.&apos; % i</div></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cube = 6, Triple = (3, 4, 5)</div><div class="line">Cube = 12, Triple = (6, 8, 10)</div><div class="line">Cube = 18, Triple = (2, 12, 16)</div><div class="line">Cube = 18, Triple = (9, 12, 15)</div><div class="line">Cube = 19, Triple = (3, 10, 18)</div><div class="line">Cube = 20, Triple = (7, 14, 17)</div><div class="line">Cube = 24, Triple = (12, 16, 20)</div><div class="line">46552 iterations.</div></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line"></div><div class="line">import sys</div><div class="line">import math</div><div class="line"></div><div class="line"># n = sys.argv[1]</div><div class="line">n = 24</div><div class="line"></div><div class="line">i = 0</div><div class="line">for a in xrange(2, n + 1):</div><div class="line">    for b in xrange(2, a):</div><div class="line">        for c in xrange(b, a):</div><div class="line">            for d in xrange(c, a):</div><div class="line">                i += 1</div><div class="line">                if math.pow(a, 3) == math.pow(b, 3) + math.pow(c, 3) + math.pow(d, 3):</div><div class="line">                    print &apos;Cube = %d, Triple = (%d, %d, %d)&apos; % (a, b, c, d)</div><div class="line">print &apos;%d iterations.&apos; % i</div></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cube = 6, Triple = (3, 4, 5)</div><div class="line">Cube = 12, Triple = (6, 8, 10)</div><div class="line">Cube = 18, Triple = (2, 12, 16)</div><div class="line">Cube = 18, Triple = (9, 12, 15)</div><div class="line">Cube = 19, Triple = (3, 10, 18)</div><div class="line">Cube = 20, Triple = (7, 14, 17)</div><div class="line">Cube = 24, Triple = (12, 16, 20)</div><div class="line">12650 iterations.</div></pre></td></tr></table></figure>
<p>从上面可以看出枚举的边界不同，效率会差将近三倍。</p>
<p>Python源码地址：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/perfect_cubes.py" target="_blank" rel="external">https://github.com/SnailTyan/programming-and-algorithms/blob/master/perfect_cubes.py</a>，记得给个star。</p>
<p>C++源码地址（已在POJ上Accepted）：<a href="https://github.com/SnailTyan/programming-and-algorithms/blob/master/perfect_cubes.cpp" target="_blank" rel="external">https://github.com/SnailTyan/programming-and-algorithms/blob/master/perfect_cubes.cpp</a>，记得给个star。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.icourse163.org/course/PKU-1001894005" target="_blank" rel="external">程序设计与算法（二）算法基础</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      枚举——完美立方
    
    </summary>
    
      <category term="程序设计与算法" scheme="noahsnail.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="枚举" scheme="noahsnail.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概述</title>
    <link href="noahsnail.com/2017/12/16/2017-12-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>noahsnail.com/2017/12/16/2017-12-16-计算机系统概述/</id>
    <published>2017-12-16T12:41:45.000Z</published>
    <updated>2017-12-26T02:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-冯·诺依曼结构的主要思想"><a href="#1-冯·诺依曼结构的主要思想" class="headerlink" title="1. 冯·诺依曼结构的主要思想"></a>1. 冯·诺依曼结构的主要思想</h2><p>1.计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。<br>2.各基本部件的功能：</p>
<ul>
<li>存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据和指令。</li>
<li>控制器应能自动取出指令执行。</li>
<li>运算器应能进行加/减/乘/除四种基本算数运算，并且也能进行一些逻辑运算和附加运算。</li>
<li>操作人员可以通过输入设备、输出设备和主机进行通信。</li>
</ul>
<p>3.内部以二进制表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。<br>4.采用“存储程序”的工作方式。</p>
<h2 id="2-计算机是如何工作的"><a href="#2-计算机是如何工作的" class="headerlink" title="2. 计算机是如何工作的"></a>2. 计算机是如何工作的</h2><ul>
<li>程序执行前<br>数据和指令事先存放在存储器中，每条指令和数据都有地址，指令按顺序存放，指令由OP、ADDR字段组成，程序起始地址放置在PC中</li>
<li>执行程序<br>1.根据PC取指令<br>2.指令译码<br>3.取操作数<br>4.指令执行<br>5.回写结果<br>6.修改PC值<br>7.执行下一条指令</li>
</ul>
<h2 id="3-编译程序和解释程序"><a href="#3-编译程序和解释程序" class="headerlink" title="3. 编译程序和解释程序"></a>3. 编译程序和解释程序</h2><p>编译程序（Compiler）：将高级语言源程序转换为机器级目标程序，执行时只需要启动目标程序即可。</p>
<p>解释程序（Interpreter）：将高级语言语句逐条翻译成机器程序并立即执行，不生成目标文件。</p>
<h2 id="4-典型程序的转换处理过程"><a href="#4-典型程序的转换处理过程" class="headerlink" title="4. 典型程序的转换处理过程"></a>4. 典型程序的转换处理过程</h2><ul>
<li>GCC + Linux<br>hello.c(源程序)经过预处理(cpp)变为hello.i(源程序)，再经过编译(ccl)变为hello.s(汇编指令)，再经过汇编(as)变为hello.o(可重定位目标程序，二进制)，然后链接(ld)printf.o，形成可执行程序(二进制)。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      计算机系统概述
    
    </summary>
    
      <category term="计算机系统" scheme="noahsnail.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="noahsnail.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>非极大值抑制(Non-Maximum Suppression)</title>
    <link href="noahsnail.com/2017/12/13/2017-12-13-%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6(Non-Maximum%20Suppression)/"/>
    <id>noahsnail.com/2017/12/13/2017-12-13-非极大值抑制(Non-Maximum Suppression)/</id>
    <published>2017-12-13T05:19:22.000Z</published>
    <updated>2017-12-21T09:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-什么是非极大值抑制"><a href="#1-什么是非极大值抑制" class="headerlink" title="1. 什么是非极大值抑制"></a>1. 什么是非极大值抑制</h2><p>非极大值抑制，简称为NMS算法，英文为Non-Maximum Suppression。其思想是搜素局部最大值，抑制极大值。NMS算法在不同应用中的具体实现不太一样，但思想是一样的。非极大值抑制，在计算机视觉任务中得到了广泛的应用，例如边缘检测、人脸检测、目标检测（DPM，YOLO，SSD，Faster R-CNN）等。</p>
<h2 id="2-为什么要用非极大值抑制"><a href="#2-为什么要用非极大值抑制" class="headerlink" title="2. 为什么要用非极大值抑制"></a>2. 为什么要用非极大值抑制</h2><p>以目标检测为例：目标检测的过程中在同一目标的位置上会产生大量的候选框，这些候选框相互之间可能会有重叠，此时我们需要利用非极大值抑制找到最佳的目标边界框，消除冗余的边界框。Demo如下图：</p>
<p><img src="http://img.blog.csdn.net/20171216215049280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Object Detection"><br>左图是人脸检测的候选框结果，每个边界框有一个置信度得分(confidence score)，如果不使用非极大值抑制，就会有多个候选框出现。右图是使用非极大值抑制之后的结果，符合我们人脸检测的预期结果。</p>
<h2 id="3-如何使用非极大值抑制"><a href="#3-如何使用非极大值抑制" class="headerlink" title="3. 如何使用非极大值抑制"></a>3. 如何使用非极大值抑制</h2><p><strong>前提：</strong>目标边界框列表及其对应的置信度得分列表，设定阈值，阈值用来删除重叠较大的边界框。<br><strong>IoU</strong>：intersection-over-union，即两个边界框的交集部分除以它们的并集。</p>
<p>非极大值抑制的流程如下：</p>
<ul>
<li><p>根据置信度得分进行排序</p>
</li>
<li><p>选择置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除</p>
</li>
<li><p>计算所有边界框的面积</p>
</li>
<li><p>计算置信度最高的边界框与其它候选框的IoU。</p>
</li>
<li><p>删除IoU大于阈值的边界框</p>
</li>
<li><p>重复上述过程，直至边界框列表为空。</p>
</li>
</ul>
<p>Python代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding: utf-8 _*_</div><div class="line"></div><div class="line"></div><div class="line">import cv2</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"></div><div class="line">&quot;&quot;&quot;</div><div class="line">    Non-max Suppression Algorithm</div><div class="line"></div><div class="line">    @param list  Object candidate bounding boxes</div><div class="line">    @param list  Confidence score of bounding boxes</div><div class="line">    @param float IoU threshold</div><div class="line"></div><div class="line">    @return Rest boxes after nms operation</div><div class="line">&quot;&quot;&quot;</div><div class="line">def nms(bounding_boxes, confidence_score, threshold):</div><div class="line">    # If no bounding boxes, return empty list</div><div class="line">    if len(bounding_boxes) == 0:</div><div class="line">        return [], []</div><div class="line"></div><div class="line">    # Bounding boxes</div><div class="line">    boxes = np.array(bounding_boxes)</div><div class="line"></div><div class="line">    # coordinates of bounding boxes</div><div class="line">    start_x = boxes[:, 0]</div><div class="line">    start_y = boxes[:, 1]</div><div class="line">    end_x = boxes[:, 2]</div><div class="line">    end_y = boxes[:, 3]</div><div class="line"></div><div class="line">    # Confidence scores of bounding boxes</div><div class="line">    score = np.array(confidence_score)</div><div class="line"></div><div class="line">    # Picked bounding boxes</div><div class="line">    picked_boxes = []</div><div class="line">    picked_score = []</div><div class="line"></div><div class="line">    # Compute areas of bounding boxes</div><div class="line">    areas = (end_x - start_x + 1) * (end_y - start_y + 1)</div><div class="line"></div><div class="line">    # Sort by confidence score of bounding boxes</div><div class="line">    order = np.argsort(score)</div><div class="line"></div><div class="line">    # Iterate bounding boxes</div><div class="line">    while order.size &gt; 0:</div><div class="line">        # The index of largest confidence score</div><div class="line">        index = order[-1]</div><div class="line"></div><div class="line">        # Pick the bounding box with largest confidence score</div><div class="line">        picked_boxes.append(bounding_boxes[index])</div><div class="line">        picked_score.append(confidence_score[index])</div><div class="line"></div><div class="line">        # Compute ordinates of intersection-over-union(IOU)</div><div class="line">        x1 = np.maximum(start_x[index], start_x[order[:-1]])</div><div class="line">        x2 = np.minimum(end_x[index], end_x[order[:-1]])</div><div class="line">        y1 = np.maximum(start_y[index], start_y[order[:-1]])</div><div class="line">        y2 = np.minimum(end_y[index], end_y[order[:-1]])</div><div class="line"></div><div class="line">        # Compute areas of intersection-over-union</div><div class="line">        w = np.maximum(0.0, x2 - x1 + 1)</div><div class="line">        h = np.maximum(0.0, y2 - y1 + 1)</div><div class="line">        intersection = w * h</div><div class="line"></div><div class="line">        # Compute the ratio between intersection and union</div><div class="line">        ratio = intersection / (areas[index] + areas[order[:-1]] - intersection)</div><div class="line"></div><div class="line">        left = np.where(ratio &lt; threshold)</div><div class="line">        order = order[left]</div><div class="line"></div><div class="line">    return picked_boxes, picked_score</div><div class="line"></div><div class="line"></div><div class="line"># Image name</div><div class="line">image_name = &apos;nms.jpg&apos;</div><div class="line"></div><div class="line"># Bounding boxes</div><div class="line">bounding_boxes = [(187, 82, 337, 317), (150, 67, 305, 282), (246, 121, 368, 304)]</div><div class="line">confidence_score = [0.9, 0.75, 0.8]</div><div class="line"></div><div class="line"># Read image</div><div class="line">image = cv2.imread(image_name)</div><div class="line"></div><div class="line"># Copy image as original</div><div class="line">org = image.copy()</div><div class="line"></div><div class="line"># Draw parameters</div><div class="line">font = cv2.FONT_HERSHEY_SIMPLEX</div><div class="line">font_scale = 1</div><div class="line">thickness = 2</div><div class="line"></div><div class="line"># IoU threshold</div><div class="line">threshold = 0.4</div><div class="line"></div><div class="line"># Draw bounding boxes and confidence score</div><div class="line">for (start_x, start_y, end_x, end_y), confidence in zip(bounding_boxes, confidence_score):</div><div class="line">    (w, h), baseline = cv2.getTextSize(str(confidence), font, font_scale, thickness)</div><div class="line">    cv2.rectangle(org, (start_x, start_y - (2 * baseline + 5)), (start_x + w, start_y), (0, 255, 255), -1)</div><div class="line">    cv2.rectangle(org, (start_x, start_y), (end_x, end_y), (0, 255, 255), 2)</div><div class="line">    cv2.putText(org, str(confidence), (start_x, start_y), font, font_scale, (0, 0, 0), thickness)</div><div class="line"></div><div class="line"># Run non-max suppression algorithm</div><div class="line">picked_boxes, picked_score = nms(bounding_boxes, confidence_score, threshold)</div><div class="line"></div><div class="line"># Draw bounding boxes and confidence score after non-maximum supression</div><div class="line">for (start_x, start_y, end_x, end_y), confidence in zip(picked_boxes, picked_score):</div><div class="line">    (w, h), baseline = cv2.getTextSize(str(confidence), font, font_scale, thickness)</div><div class="line">    cv2.rectangle(image, (start_x, start_y - (2 * baseline + 5)), (start_x + w, start_y), (0, 255, 255), -1)</div><div class="line">    cv2.rectangle(image, (start_x, start_y), (end_x, end_y), (0, 255, 255), 2)</div><div class="line">    cv2.putText(image, str(confidence), (start_x, start_y), font, font_scale, (0, 0, 0), thickness)</div><div class="line"></div><div class="line"># Show image</div><div class="line">cv2.imshow(&apos;Original&apos;, org)</div><div class="line">cv2.imshow(&apos;NMS&apos;, image)</div><div class="line">cv2.waitKey(0)</div></pre></td></tr></table></figure>
<p>源码下载地址：<a href="https://github.com/SnailTyan/deep-learning-tools/blob/master/nms.py" target="_blank" rel="external">https://github.com/SnailTyan/deep-learning-tools/blob/master/nms.py</a><br>记得给个Star。Demo原图在<code>README.md</code>里。</p>
<p>实验结果：</p>
<ul>
<li>阈值为0.6</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171216214920610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="threshold = 0.6"></p>
<ul>
<li><p>阈值为0.5<br><img src="http://img.blog.csdn.net/20171216215016695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="threshold = 0.5"></p>
</li>
<li><p>阈值为0.4<br><img src="http://img.blog.csdn.net/20171216215049280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="threshold = 0.4"></p>
</li>
</ul>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><p><a href="https://www.pyimagesearch.com/2014/11/17/non-maximum-suppression-object-detection-python/" target="_blank" rel="external">https://www.pyimagesearch.com/2014/11/17/non-maximum-suppression-object-detection-python/</a></p>
</li>
<li><p><a href="http://cs.brown.edu/~pff/papers/lsvm-pami.pdf" target="_blank" rel="external">http://cs.brown.edu/~pff/papers/lsvm-pami.pdf</a></p>
</li>
<li><p><a href="http://blog.csdn.net/shuzfan/article/details/52711706" target="_blank" rel="external">http://blog.csdn.net/shuzfan/article/details/52711706</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/liekkas0626/p/5219244.html" target="_blank" rel="external">http://www.cnblogs.com/liekkas0626/p/5219244.html</a></p>
</li>
<li><p><a href="http://www.tk4479.net/yzhang6_10/article/details/50886747" target="_blank" rel="external">http://www.tk4479.net/yzhang6_10/article/details/50886747</a></p>
</li>
<li><p><a href="http://blog.csdn.net/qq_14845119/article/details/52064928" target="_blank" rel="external">http://blog.csdn.net/qq_14845119/article/details/52064928</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      非极大值抑制(Non-Maximum Suppression)
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Single Shot MultiBox Detector论文翻译——中文版</title>
    <link href="noahsnail.com/2017/12/11/2017-12-11-Single%20Shot%20MultiBox%20Detector%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>noahsnail.com/2017/12/11/2017-12-11-Single Shot MultiBox Detector论文翻译——中文版/</id>
    <published>2017-12-11T07:54:17.000Z</published>
    <updated>2017-12-26T08:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们提出了一种使用单个深度神经网络来检测图像中的目标的方法。我们的方法命名为SSD，将边界框的输出空间离散化为不同长宽比的一组默认框和并缩放每个特征映射的位置。在预测时，网络会在每个默认框中为每个目标类别的出现生成分数，并对框进行调整以更好地匹配目标形状。此外，网络还结合了不同分辨率的多个特征映射的预测，自然地处理各种尺寸的目标。相对于需要目标提出的方法，SSD非常简单，因为它完全消除了提出生成和随后的像素或特征重新采样阶段，并将所有计算封装到单个网络中。这使得SSD易于训练和直接集成到需要检测组件的系统中。PASCAL VOC，COCO和ILSVRC数据集上的实验结果证实，SSD对于利用额外的目标提出步骤的方法具有竞争性的准确性，并且速度更快，同时为训练和推断提供了统一的框架。对于300×300的输入，SSD在VOC2007测试中以59FPS的速度在Nvidia Titan X上达到$74.3\%$的mAP，对于512×512的输入，SSD达到了$76.9\%$的mAP，优于参照的最先进的Faster R-CNN模型。与其他单阶段方法相比，即使输入图像尺寸较小，SSD也具有更高的精度。代码获取：<a href="https://github.com/weiliu89/caffe/tree/ssd" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>目前最先进的目标检测系统是以下方法的变种：假设边界框，每个框重采样像素或特征，并应用一个高质量的分类器。自从选择性搜索[1]通过在PASCAL VOC，COCO和ILSVRC上所有基于Faster R-CNN[2]的检测都取得了当前领先的结果（尽管具有更深的特征如[3]），这种流程在检测基准数据上流行开来。尽管这些方法准确，但对于嵌入式系统而言，这些方法的计算量过大，即使是高端硬件，对于实时应用而言也太慢。通常，这些方法的检测速度是以每帧秒（SPF）度量，甚至最快的高精度检测器，Faster R-CNN，仅以每秒7帧（FPS）的速度运行。已经有很多尝试通过处理检测流程中的每个阶段来构建更快的检测器（参见第4节中的相关工作），但是到目前为止，显著提高的速度仅以显著降低的检测精度为代价。</p>
<p>本文提出了第一个基于深度网络的目标检测器，它不对边界框假设的像素或特征进行重采样，并且与其它方法有一样精确度。这对高精度检测在速度上有显著提高（在VOC2007测试中，59FPS和$74.3\%$的mAP，与Faster R-CNN 7FPS和$73.2\%$的mAP或者YOLO 45 FPS和$63.4\%$的mAP相比）。速度的根本改进来自消除边界框提出和随后的像素或特征重采样阶段。我们并不是第一个这样做的人（查阅[4,5]），但是通过增加一系列改进，我们设法比以前的尝试显著提高了准确性。我们的改进包括使用小型卷积滤波器来预测边界框位置中的目标类别和偏移量，使用不同长宽比检测的单独预测器（滤波器），并将这些滤波器应用于网络后期的多个特征映射中，以执行多尺度检测。通过这些修改——特别是使用多层进行不同尺度的预测——我们可以使用相对较低的分辨率输入实现高精度，进一步提高检测速度。虽然这些贡献可能单独看起来很小，但是我们注意到由此产生的系统将PASCAL VOC实时检测的准确度从YOLO的$63.4\%$的mAP提高到我们的SSD的$74.3\%$的mAP。相比于最近备受瞩目的残差网络方面的工作[3]，在检测精度上这是相对更大的提高。而且，显著提高的高质量检测速度可以扩大计算机视觉使用的设置范围。</p>
<p>我们总结我们的贡献如下：</p>
<ul>
<li><p>我们引入了SSD，这是一种针对多个类别的单次检测器，比先前的先进的单次检测器（YOLO）更快，并且准确得多，事实上，与执行显式区域提出和池化的更慢的技术具有相同的精度（包括Faster R-CNN）。</p>
</li>
<li><p>SSD的核心是预测固定的一系列默认边界框的类别分数和边界框偏移，使用更小的卷积滤波器应用到特征映射上。</p>
</li>
<li><p>为了实现高检测精度，我们根据不同尺度的特征映射生成不同尺度的预测，并通过纵横比明确分开预测。</p>
</li>
<li><p>这些设计功能使得即使在低分辨率输入图像上也能实现简单的端到端训练和高精度，从而进一步提高速度与精度之间的权衡。</p>
</li>
<li><p>实验包括在PASCAL VOC，COCO和ILSVRC上评估具有不同输入大小的模型的时间和精度分析，并与最近的一系列最新方法进行比较。</p>
</li>
</ul>
<h2 id="2-单次检测器-SSD"><a href="#2-单次检测器-SSD" class="headerlink" title="2. 单次检测器(SSD)"></a>2. 单次检测器(SSD)</h2><p>本节描述我们提出的SSD检测框架（2.1节）和相关的训练方法（2.2节）。之后，2.3节介绍了数据集特有的模型细节和实验结果。</p>
<h3 id="2-1-模型"><a href="#2-1-模型" class="headerlink" title="2.1 模型"></a>2.1 模型</h3><p>SSD方法基于前馈卷积网络，该网络产生固定大小的边界框集合，并对这些边界框中存在的目标类别实例进行评分，然后进行非极大值抑制步骤来产生最终的检测结果。早期的网络层基于用于高质量图像分类的标准架构（在任何分类层之前被截断），我们将其称为基础网络。然后，我们将辅助结构添加到网络中以产生具有以下关键特征的检测：</p>
<p><strong>用于检测的多尺度特征映射</strong>。我们将卷积特征层添加到截取的基础网络的末端。这些层在尺寸上逐渐减小，并允许在多个尺度上对检测结果进行预测。用于预测检测的卷积模型对于每个特征层都是不同的（查阅Overfeat[4]和YOLO[5]在单尺度特征映射上的操作）。</p>
<p><strong>用于检测的卷积预测器</strong>。每个添加的特征层（或者任选的来自基础网络的现有特征层）可以使用一组卷积滤波器产生固定的检测预测集合。这些在图2中的SSD网络架构的上部指出。对于具有$p$通道的大小为$m \times n$的特征层，潜在检测的预测参数的基本元素是$3 \times 3 \times p$的<em>小核</em>得到某个类别的分数，或者相对于默认框坐标的形状偏移。在应用卷积核的$m \times n$的每个位置，它会产生一个输出值。边界框偏移输出值是相对每个特征映射位置的相对默认框位置来度量的（查阅YOLO[5]的架构，该步骤使用中间全连接层而不是卷积滤波器）。</p>
<p><img src="http://img.blog.csdn.net/20171216225358544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 2"></p>
<p>图2：两个单次检测模型的比较：SSD和YOLO[5]。我们的SSD模型在基础网络的末端添加了几个特征层，它预测了不同尺度和长宽比的默认边界框的偏移量及其相关的置信度。300×300输入尺寸的SSD在VOC2007 <code>test</code>上的准确度上明显优于448×448的YOLO的准确度，同时也提高了速度。</p>
<p><strong>默认边界框和长宽比</strong>。对于网络顶部的多个特征映射，我们将一组默认边界框与每个特征映射单元相关联。默认边界框以卷积的方式平铺特征映射，以便每个边界框相对于其对应单元的位置是固定的。在每个特征映射单元中，我们预测单元中相对于默认边界框形状的偏移量，以及指出每个边界框中存在的每个类别实例的类别分数。具体而言，对于给定位置处的$k$个边界框中的每一个，我们计算$c$个类别分数和相对于原始默认边界框形状的$4$个偏移量。这导致在特征映射中的每个位置周围应用总共$(c+4)k$个滤波器，对于$m\times n$的特征映射取得$(c+4)kmn$个输出。有关默认边界框的说明，请参见图1。我们的默认边界框与Faster R-CNN[2]中使用的<em>锚边界框</em>相似，但是我们将它们应用到不同分辨率的几个特征映射上。在几个特征映射中允许不同的默认边界框形状让我们有效地离散可能的输出框形状的空间。</p>
<p><img src="http://img.blog.csdn.net/20171216225302641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 1"></p>
<p>图1：SSD框架。（a）在训练期间，SSD仅需要每个目标的输入图像和真实边界框。以卷积方式，我们评估具有不同尺度（例如（b）和（c）中的8×8和4×4）的几个特征映射中每个位置处不同长宽比的默认框的小集合（例如4个）。对于每个默认边界框，我们预测所有目标类别（$(c_1, c_2, \dots, c_p)$）的形状偏移量和置信度。在训练时，我们首先将这些默认边界框与实际的边界框进行匹配。例如，我们已经与猫匹配两个默认边界框，与狗匹配了一个，这被视为积极的，其余的是消极的。模型损失是定位损失（例如，Smooth L1[6]）和置信度损失（例如Softmax）之间的加权和。</p>
<h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2><p>训练SSD和训练使用区域提出的典型检测器之间的关键区别在于，需要将真实信息分配给固定的检测器输出集合中的特定输出。在YOLO[5]的训练中、Faster R-CNN[2]和MultiBox[7]的区域提出阶段，一些版本也需要这样的操作。一旦确定了这个分配，损失函数和反向传播就可以应用端到端了。训练也涉及选择默认边界框集合和缩放进行检测，以及难例挖掘和数据增强策略。</p>
<p><strong>匹配策略</strong>。在训练过程中，我们需要确定哪些默认边界框对应实际边界框的检测，并相应地训练网络。对于每个实际边界框，我们从默认边界框中选择，这些框会在位置，长宽比和尺度上变化。我们首先将每个实际边界框与具有最好的Jaccard重叠（如MultiBox[7]）的边界框相匹配。与MultiBox不同的是，我们将默认边界框匹配到Jaccard重叠高于阈值（0.5）的任何实际边界框。这简化了学习问题，允许网络为多个重叠的默认边界框预测高分，而不是要求它只挑选具有最大重叠的一个边界框。</p>
<p><strong>训练目标函数</strong>。SSD训练目标函数来自于MultiBox目标[7,8]，但扩展到处理多个目标类别。设$x_{ij}^p = \lbrace 1,0 \rbrace$是第$i$个默认边界框匹配到类别$p$的第$j$个实际边界框的指示器。在上面的匹配策略中，我们有$\sum_i x_{ij}^p \geq 1$。总体目标损失函数是定位损失（loc）和置信度损失（conf）的加权和：$$L(x, c, l, g) = \frac{1}{N}(L_{conf}(x, c) + \alpha L_{loc}(x, l, g)) \tag{1}$$其中N是匹配的默认边界框的数量。如果$N=0$，则将损失设为0。定位损失是预测框($l$)与真实框($g$)参数之间的Smooth L1损失[6]。类似于Faster R-CNN[2]，我们回归默认边界框($d$)的中心偏移量($cx, cy$)和其宽度($w$)、高度($h$)的偏移量。$$<br>L_{loc}(x,l,g) = \sum_{i \in Pos}^N \sum_{m \in \lbrace cx, cy, w, h \rbrace} x_{ij}^k \mathtt{smooth}_{L1}(l_{i}^m - \hat{g}_j^m) \\<br>\hat{g}_j^{cx} = (g_j^{cx} - d_i^{cx}) / d_i^w \quad \quad<br>\hat{g}_j^{cy} = (g_j^{cy} - d_i^{cy}) / d_i^h \\<br>\hat{g}_j^{w} = \log\Big(\frac{g_j^{w}}{d_i^w}\Big) \quad \quad<br>\hat{g}_j^{h} = \log\Big(\frac{g_j^{h}}{d_i^h}\Big)<br>\tag{2}<br>$$置信度损失是在多类别置信度($c$)上的softmax损失。<br>$$<br>L_{conf}(x, c) = - \sum_{i\in Pos}^N x_{ij}^p log(\hat{c}_i^p) - \sum_{i\in Neg} log(\hat{c}_i^0)\quad \mathtt{where}\quad\hat{c}_i^p = \frac{\exp(c_i^p)}{\sum_p \exp(c_i^p)}<br>\tag{3}<br>$$<br>通过交叉验证权重项$\alpha$设为1。</p>
<p><strong>为默认边界框选择尺度和长宽比</strong>。为了处理不同的目标尺度，一些方法[4,9]建议处理不同尺寸的图像，然后将结果合并。然而，通过利用单个网络中几个不同层的特征映射进行预测，我们可以模拟相同的效果，同时还可以跨所有目标尺度共享参数。以前的工作[10,11]已经表明，使用低层的特征映射可以提高语义分割的质量，因为低层会捕获输入目标的更多细节。同样，[12]表明，从特征映射上添加全局上下文池化可以有助于平滑分割结果。受这些方法的启发，我们使用较低和较高的特征映射进行检测。图1显示了框架中使用的两个示例性特征映射（8×8和4×4）。在实践中，我们可以使用更多的具有很少计算开支的特征映射。</p>
<p>已知网络中不同层的特征映射具有不同的（经验的）感受野大小[13]。幸运的是，在SSD框架内，默认边界框不需要对应于每层的实际感受野。我们设计平铺默认边界框，以便特定的特征映射学习响应目标的特定尺度。假设我们要使用$m$个特征映射进行预测。每个特征映射默认边界框的尺度计算如下：$$s_k = s_\text{min} + \frac{s_\text{max} - s_\text{min}}{m - 1} (k - 1),\quad k\in [1, m]$$其中$s_\text{min}$为0.2，$s_\text{max}$为0.9，意味着最低层具有0.2的尺度，最高层具有0.9的尺度，并且在它们之间的所有层是规则间隔的。我们为默认边界框添加不同的长宽比，并将它们表示为$a_r \in {1, 2, 3, \frac{1}{2}, \frac{1}{3}}$。我们可以计算每个边界框的宽度($w_k^a = s_k\sqrt{a_r}$)和高度($h_k^a = s_k / \sqrt{a_r}$)。对于长宽比为1，我们还添加了一个默认边界框，其尺度为$s’_k = \sqrt{s_k s_{k+1}}$，在每个特征映射位置得到6个默认边界框。我们将每个默认边界框的中心设置为$(\frac{i+0.5}{|f_k|}, \frac{j+0.5}{|f_k|})$，其中$|f_k|$是第$k$个平方特征映射的大小，$i, j\in [0, |f_k|)$。在实践中，也可以设计默认边界框的分布以最适合特定的数据集。如何设计最佳平铺也是一个悬而未决的问题。</p>
<p>通过将所有默认边界框的预测与许多特征映射所有位置的不同尺度和高宽比相结合，我们有不同的预测集合，涵盖各种输入目标大小和形状。例如，在图1中，狗被匹配到4×4特征映射中的默认边界框，而不是8×8特征映射中的任何默认框。这是因为那些边界框有不同的尺度，不匹配狗的边界框，因此在训练期间被认为是负例。</p>
<p><strong>难例挖掘</strong>。在匹配步骤之后，大多数默认边界框为负例，尤其是当可能的默认边界框数量较多时。这在正的训练实例和负的训练实例之间引入了显著的不平衡。我们不使用所有负例，而是使用每个默认边界框的最高置信度损失来排序它们，并挑选最高的置信度，以便负例和正例之间的比例至多为3:1。我们发现这会导致更快的优化和更稳定的训练。</p>
<p><strong>数据增强</strong>。为了使模型对各种输入目标大小和形状更鲁棒，每张训练图像都是通过以下选项之一进行随机采样的：</p>
<ul>
<li>使用整个原始输入图像。</li>
<li>采样一个图像块，使得与目标之间的<em>最小</em>Jaccard重叠为0.1，0.3，0.5，0.7或0.9。</li>
<li>随机采样一个图像块。</li>
</ul>
<p>每个采样图像块的大小是原始图像大小的[0.1，1]，长宽比在$\frac {1} {2}$和2之间。如果实际边界框的中心在采用的图像块中，我们保留实际边界框与采样图像块的重叠部分。在上述采样步骤之后，除了应用类似于文献[14]中描述的一些光度变形之外，将每个采样图像块调整到固定尺寸并以0.5的概率进行水平翻转。</p>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><p><strong>基础网络</strong>。我们的实验全部基于VGG16[15]，它是在ILSVRC CLS-LOC数据集[16]上预先训练的。类似于DeepLab-LargeFOV[17]，我们将<code>fc6</code>和<code>fc7</code>转换为卷积层，从fc6和fc7中重采样参数，将pool5从$2\times 2-s2$更改为$3\times 3-s1$，并使用空洞算法[18]来填补这个“小洞”。我们删除所有的丢弃层和<code>fc8</code>层。我们使用SGD对得到的模型进行微调，初始学习率为$10^{-3}$，动量为0.9，权重衰减为0.0005，批数据大小为32。每个数据集的学习速率衰减策略略有不同，我们将在后面详细描述。完整的训练和测试代码建立在Caffe[19]上并开源：<a href="https://github.com/weiliu89/caffe/tree/ SSD" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>。</p>
<h3 id="3-1-PASCAL-VOC2007"><a href="#3-1-PASCAL-VOC2007" class="headerlink" title="3.1 PASCAL VOC2007"></a>3.1 PASCAL VOC2007</h3><p>在这个数据集上，我们在VOC2007 <code>test</code>（4952张图像）上比较了Fast R-CNN[6]和FAST R-CNN[2]。所有的方法都在相同的预训练好的VGG16网络上进行微调。</p>
<p>图2显示了SSD300模型的架构细节。我们使用conv4_3，conv7（fc7），conv8_2，conv9_2，conv10_2和conv11_2来预测位置和置信度。我们在conv4_3上设置了尺度为0.1的默认边界框。我们使用“xavier”方法[20]初始化所有新添加的卷积层的参数。对于conv4_3，conv10_2和conv11_2，我们只在每个特征映射位置上关联了4个默认边界框——忽略$\frac {1} {3} $和3的长宽比。对于所有其它层，我们像2.2节描述的那样放置了6个默认边界框。如[12]所指出的，与其它层相比，由于conv4_3具有不同的特征尺度，所以我们使用[12]中引入的L2正则化技术将特征映射中每个位置的特征标准缩放到20，在反向传播过程中学习尺度。对于40k次迭代，我们使用$10^{-3}$的学习率，然后继续用$10^{-4}$和$10^{-5}$的学习率训练10k迭代。当对VOC2007 $\texttt{trainval}$进行训练时，表1显示了我们的低分辨率SSD300模型已经比Fast R-CNN更准确。当我们用更大的$512\times 512$输入图像上训练SSD时，它更加准确，超过了Faster R-CNN $1.7\%$的mAP。如果我们用更多的（即07+12）数据来训练SSD，我们看到SSD300已经比Faster R-CNN好$1.1\%$，SSD512比Faster R-CNN好$3.6\%$。如果我们将SSD512用3.4节描述的COCO $\texttt{trainval35k}$来训练模型并在07+12数据集上进行微调，我们获得了最好的结果：$81.6\%$的mAP。</p>
<p><img src="http://img.blog.csdn.net/20171216224936736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 1"></p>
<p>表1：<strong>PASCAL VOC2007 <code>test</code>检测结果</strong>。Fast和Faster R-CNN都使用最小维度为600的输入图像。两个SSD模型使用完全相同的设置除了它们有不同的输入大小(300×300和512×512)。很明显更大的输入尺寸会导致更好的结果，并且更大的数据同样有帮助。数据：“07”：VOC2007 <code>trainval</code>，“07+12”：VOC2007和VOC2012 <code>trainval</code>的联合。“07+12+COCO”：首先在COCO <code>trainval35k</code>上训练然后在07+12上微调。</p>
<p>为了更详细地了解我们两个SSD模型的性能，我们使用了[21]中的检测分析工具。图3显示了SSD可以检测到高质量（大白色区域）的各种目标类别。它大部分的确信检测是正确的。召回约为$85-90\%$，而“弱”（0.1 Jaccard重叠）标准则要高得多。与R-CNN[22]相比，SSD具有更小的定位误差，表明SSD可以更好地定位目标，因为它直接学习回归目标形状和分类目标类别，而不是使用两个解耦步骤。然而，SSD对类似的目标类别（特别是对于动物）有更多的混淆，部分原因是我们共享多个类别的位置。图4显示SSD对边界框大小非常敏感。换句话说，它在较小目标上比在较大目标上的性能要差得多。这并不奇怪，因为这些小目标甚至可能在顶层没有任何信息。增加输入尺寸（例如从300×300到512×512）可以帮助改进检测小目标，但仍然有很大的改进空间。积极的一面，我们可以清楚地看到SSD在大型目标上的表现非常好。而且对于不同长宽比的目标，它是非常鲁棒的，因为我们使用每个特征映射位置的各种长宽比的默认框。</p>
<p><img src="http://img.blog.csdn.net/20171216225014459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 3"></p>
<p>图3：<strong>SSD512在VOC2007 <code>test</code>中的动物，车辆和家具上的性能可视化</strong>。第一行显示由于定位不佳（Loc），与相似类别（Sim）混淆，与其它（Oth）或背景（BG）相关的正确检测（Cor）或假阳性的累积分数。红色的实线表示随着检测次数的增加，强标准（0.5 Jaccard重叠）下的召回变化。红色虚线是使用弱标准（0.1 Jaccard重叠）。最下面一行显示了排名靠前的假阳性类型的分布。</p>
<p><img src="http://img.blog.csdn.net/20171216225051688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 4"></p>
<p>图4：<strong>使用[21]在VOC2007 <code>test</code>设置上不同目标特性的灵敏度和影响</strong>。左边的图显示了BBox面积对每个类别的影响，右边的图显示了长宽比的影响。关键：BBox区域：XS=超小；S=小；M=中等；L=大；XL=超大。长宽比：XT=超高/窄；T=高；M=中等；W=宽；XW =超宽。</p>
<h3 id="3-2-模型分析"><a href="#3-2-模型分析" class="headerlink" title="3.2 模型分析"></a>3.2 模型分析</h3><p>为了更好地了解SSD，我们进行了控制实验，以检查每个组件如何影响性能。对于所有的实验，我们使用相同的设置和输入大小（300×300），除了指定的设置或组件的更改。</p>
<p><strong>数据增强至关重要</strong>。Fast和Faster R-CNN使用原始图像和水平翻转来训练。我们使用更广泛的抽样策略，类似于YOLO[5]。从表2可以看出，采样策略可以提高$8.8\%$的mAP。我们不知道我们的采样策略将会使Fast和Faster R-CNN受益多少，但是他们可能从中受益较少，因为他们在分类过程中使用了一个特征池化步骤，这对通过设计的目标变换来说相对鲁棒。</p>
<p><img src="http://img.blog.csdn.net/20171216224209114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 2"></p>
<p>表2：<strong>各种设计选择和组件对SSD性能的影响。</strong></p>
<p><strong>更多的默认边界框形状会更好。</strong>如2.2节所述，默认情况下，我们每个位置使用6个默认边界框。如果我们删除长宽比为$\frac {1} {3}$和3的边界框，性能下降了$0.6\%$。通过进一步去除$\frac {1} {2}$和2长宽比的盒子，性能再下降$2.1\%$。使用各种默认边界框形状似乎使网络预测边界框的任务更容易。</p>
<p><strong>Atrous更快</strong>。如第3节所述，我们根据DeepLab-LargeFOV[17]使用子采样的VGG16的空洞版本。如果我们使用完整的VGG16，保持pool5为2×2-s2，并且不从fc6和fc7中子采样参数，并添加conv5_3进行预测，结果大致相同，而速度慢了大约$20\%$。</p>
<p><strong>多个不同分辨率的输出层更好</strong>。SSD的主要贡献是在不同的输出层上使用不同尺度的默认边界框。为了衡量所获得的优势，我们逐步删除层并比较结果。为了公平比较，每次我们删除一层，我们调整默认边界框平铺，以保持类似于最初的边界框的总数（8732）。这是通过在剩余层上堆叠更多尺度的盒子并根据需要调整边界框的尺度来完成的。我们没有详尽地优化每个设置的平铺。表3显示层数较少，精度降低，从74.3单调递减至62.4。当我们在一层上堆叠多尺度的边界框时，很多边界框在图像边界上需要小心处理。我们尝试了在Faster R-CNN[2]中使用这个策略，忽略在边界上的边界框。我们观察到了一些有趣的趋势。例如，如果我们使用非常粗糙的特征映射（例如conv11_2（1×1）或conv10_2（3×3）），它会大大伤害性能。原因可能是修剪后我们没有足够大的边界框来覆盖大的目标。当我们主要使用更高分辨率的特征映射时，性能开始再次上升，因为即使在修剪之后仍然有足够数量的大边界框。如果我们只使用conv7进行预测，那么性能是最糟糕的，这就强化了在不同层上扩展不同尺度的边界框是非常关键的信息。此外，由于我们的预测不像[6]那样依赖于ROI池化，所以我们在低分辨率特征映射中没有折叠组块的问题[23]。SSD架构将来自各种分辨率的特征映射的预测结合起来，以达到与Faster R-CNN相当的精确度，同时使用较低分辨率的输入图像。</p>
<p><img src="http://img.blog.csdn.net/20171216231320942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 3"></p>
<p>表3：<strong>使用多个输出层的影响。</strong></p>
<h3 id="3-3-PASCAL-VOC2012"><a href="#3-3-PASCAL-VOC2012" class="headerlink" title="3.3 PASCAL VOC2012"></a>3.3 PASCAL VOC2012</h3><p>除了我们使用VOC2012 <code>trainval</code>和VOC2007 <code>trainval</code>，<code>test</code>（21503张图像）进行训练，以及在VOC2012 <code>test</code>（10991张图像）上进行测试之外，我们使用与上述基本的VOC2007实验相同的设置。我们用$10^{−3}$的学习率对模型进行60k次的迭代训练，然后使用$10^{−4}$的学习率进行20k次迭代训练。表4显示了我们的SSD300和SSD512模型的结果。我们看到了与我们在VOC2007 <code>test</code>中观察到的相同的性能趋势。我们的SSD300比Fast/Faster R-CNN提高了准确性。通过将训练和测试图像大小增加到512×512，我们比Faster R-CNN的准确率提高了$4.5\%$。与YOLO相比，SSD更精确，可能是由于使用了来自多个特征映射的卷积默认边界框和我们在训练期间的匹配策略。当对从COCO上训练的模型进行微调后，我们的SSD512达到了$80.0\%$的mAP，比Faster R-CNN高了$4.1\%$。</p>
<p><img src="http://img.blog.csdn.net/20171216233141888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 4"></p>
<p>表4： <strong>PASCAL VOC2012 <code>test</code>上的检测结果</strong>. Fast和Faster R-CNN使用最小维度为600的图像，而YOLO的图像大小为448× 48。数据：“07++12”：VOC2007 <code>trainval</code>，<code>test</code>和VOC2012 <code>trainval</code>。“07++12+COCO”：先在COCO <code>trainval135k</code>上训练然后在07++12上微调。</p>
<h3 id="3-4-COCO"><a href="#3-4-COCO" class="headerlink" title="3.4 COCO"></a>3.4 COCO</h3><p>为了进一步验证SSD框架，我们在COCO数据集上对SSD300和SSD512架构进行了训练。由于COCO中的目标往往比PASCAL VOC中的更小，因此我们对所有层使用较小的默认边界框。我们遵循2.2节中提到的策略，但是现在我们最小的默认边界框尺度是0.15而不是0.2，并且conv4_3上的默认边界框尺度是0.07（例如，300×300图像中的21个像素）。</p>
<p>我们使用<code>trainval35k</code>[24]进行训练。我们首先用$10^{−3}$的学习率对模型进行训练，进行160k次迭代，然后继续以$10^{−4}$和$10^{−5}$的学习率各进行40k次迭代。表5显示了<code>test-dev2015</code>的结果。与我们在PASCAL VOC数据集中观察到的结果类似，SSD300在mAP@0.5和mAP@[0.5:0.95]中都优于Fast R-CNN。SSD300与ION 24]和Faster R-CNN[25]具有相似的mAP@0.75，但是mAP@0.5更差。通过将图像尺寸增加到512×512，我们的SSD512在这两个标准中都优于Faster R-CNN[25]。有趣的是，我们观察到SSD512在mAP@0.75中要好$5.3\%$，但是在mAP@0.5中只好$1.2\%$。我们也观察到，对于大型目标，AP（$4.8\%$）和AR（$4.6\%$）的效果要好得多，但对于小目标，AP（$1.3\%$）和AR（$2.0\%$）有相对更少的改进。与ION相比，大型和小型目标的AR改进更为相似（$5.4\%$和$3.9\%$）。我们推测Faster R-CNN在较小的目标上比SSD更具竞争力，因为它在RPN部分和Fast R-CNN部分都执行了两个边界框细化步骤。在图5中，我们展示了SSD512模型在COCO <code>test-dev</code>上的一些检测实例。</p>
<p><img src="http://img.blog.csdn.net/20171218133317075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 5"></p>
<p>表5：<strong>COCO <code>test-dev2015</code>检测结果</strong>。</p>
<p><img src="http://img.blog.csdn.net/20171218134122094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 5"></p>
<p>图5：<strong>SSD512模型在COCO <code>test-dev</code>上的检测实例</strong>。我们展示了分数高于0.6的检测。每种颜色对应一种目标类别。</p>
<h3 id="3-5-初步的ILSVRC结果"><a href="#3-5-初步的ILSVRC结果" class="headerlink" title="3.5 初步的ILSVRC结果"></a>3.5 初步的ILSVRC结果</h3><p>我们将在COCO上应用的相同网络架构应用于ILSVRC DET数据集[16]。我们使用[22]中使用的ILSVRC2014 DET<code>train</code>和<code>val1</code>来训练SSD300模型。我们首先用$10^{−3}$的学习率对模型进行训练，进行了320k次的迭代，然后以$10^{−4}$继续迭代80k次，以$10^{−5}$迭代40k次。我们可以在<code>val2</code>数据集上[22]实现43.4 mAP。再一次证明了SSD是用于高质量实时检测的通用框架。</p>
<h3 id="3-6-为小目标准确率进行数据增强"><a href="#3-6-为小目标准确率进行数据增强" class="headerlink" title="3.6 为小目标准确率进行数据增强"></a>3.6 为小目标准确率进行数据增强</h3><p>SSD没有如Faster R-CNN中后续的特征重采样步骤，小目标的分类任务对SSD来说相对困难，正如我们的分析（见图4）所示。2.2描述的数据增强有助于显著提高性能，特别是在PASCAL VOC等小数据集上。策略产生的随机裁剪可以被认为是“放大”操作，并且可以产生许多更大的训练样本。为了实现创建更多小型训练样本的“缩小”操作，我们首先将图像随机放置在填充了平均值的原始图像大小为16x的画布上，然后再进行任意的随机裁剪操作。因为通过引入这个新的“扩展”数据增强技巧，我们有更多的训练图像，所以我们必须将训练迭代次数加倍。我们已经在多个数据集上看到了一致的$2\%-3\%$的mAP增长，如表6所示。具体来说，图6显示新的增强技巧显著提高了模型在小目标上的性能。这个结果强调了数据增强策略对最终模型精度的重要性。</p>
<p><img src="http://img.blog.csdn.net/20171218145942048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 6"></p>
<p>表6：<strong>我们使用图像扩展数据增强技巧在多个数据集上的结果。</strong>$SSD300^{*}$和$SSD512^{*}$是用新的数据增强训练的模型。</p>
<p><img src="http://img.blog.csdn.net/20171218153833835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 6"></p>
<p>图6：<strong>具有新的数据增强的目标尺寸在[21]中使用的VOC2007<code>test</code>数据集上灵敏度及影响</strong>。最上一行显示了原始SSD300和SSD512模型上每个类别的BBox面积的影响，最下面一行对应使用新的数据增强训练技巧的$SSD300^{*}$和$SSD512^{*}$模型。新的数据增强技巧显然有助于显著检测小目标。</p>
<p>改进SSD的另一种方法是设计一个更好的默认边界框平铺，使其位置和尺度与特征映射上每个位置的感受野更好地对齐。我们将这个留给未来工作。</p>
<h3 id="3-7-推断时间"><a href="#3-7-推断时间" class="headerlink" title="3.7 推断时间"></a>3.7 推断时间</h3><p>考虑到我们的方法产生大量边界框，在推断期间执行非最大值抑制（nms）是必要的。通过使用0.01的置信度阈值，我们可以过滤大部分边界框。然后，我们应用nms，每个类别0.45的Jaccard重叠，并保留每张图像的前200个检测。对于SSD300和20个VOC类别，这个步骤每张图像花费大约1.7毫秒，接近在所有新增层上花费的总时间（2.4毫秒）。我们使用Titan X、cuDNN v4、Intel Xeon E5-2667v3@3.20GHz以及批大小为8来测量速度。</p>
<p>表7显示了SSD，Faster R-CNN[2]和YOLO[5]之间的比较。我们的SSD300和SSD512的速度和精度均优于Faster R-CNN。虽然Fast YOLO[5]可以以155FPS的速度运行，但其准确性却降低了近$22\%$的mAP。就我们所知，SSD300是第一个实现$70\%$以上mAP的实时方法。请注意，大约$80\%$前馈时间花费在基础网络上（本例中为VGG16）。因此，使用更快的基础网络可以进一步提高速度，这也可能使SSD512模型达到实时。</p>
<p><img src="http://img.blog.csdn.net/20171218160629039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 7"></p>
<p>表7：<strong>Pascal VOC2007 <code>test</code>上的结果</strong>。SSD300是唯一可以取得$70\%$以上mAP的实现检测方法。通过使用更大的输入图像，SSD512在精度上超过了所有方法同时保持近似实时的速度。</p>
<h2 id="4-相关工作"><a href="#4-相关工作" class="headerlink" title="4. 相关工作"></a>4. 相关工作</h2><p>在图像中有两种建立的用于目标检测的方法，一种基于滑动窗口，另一种基于区域提出分类。在卷积神经网络出现之前，这两种方法的最新技术——可变形部件模型（DPM）[26]和选择性搜索[1]——具有相当的性能。然而，在R-CNN[22]结合选择性搜索区域提出和基于后分类的卷积网络带来的显著改进后，区域提出目标检测方法变得流行。</p>
<p>最初的R-CNN方法已经以各种方式进行了改进。第一套方法提高了后分类的质量和速度，因为它需要对成千上万的裁剪图像进行分类，这是昂贵和耗时的。SPPnet[9]显著加快了原有的R-CNN方法。它引入了一个空间金字塔池化层，该层对区域大小和尺度更鲁棒，并允许分类层重用多个图像分辨率下生成的特征映射上计算的特征。Fast R-CNN[6]扩展了SPPnet，使得它可以通过最小化置信度和边界框回归的损失来对所有层进行端到端的微调，最初在MultiBox[7]中引入用于学习目标。</p>
<p>第二套方法使用深度神经网络提高了提出生成的质量。在最近的工作MultiBox[7,8]中，基于低级图像特征的选择性搜索区域提出直接被单独的深度神经网络生成的提出所取代。这进一步提高了检测精度，但是导致了一些复杂的设置，需要训练两个具有依赖关系的神经网络。Faster R-CNN[2]将选择性搜索提出替换为区域提出网络（RPN）学习到的区域提出，并引入了一种方法，通过交替两个网络之间的微调共享卷积层和预测层将RPN和Fast R-CNN结合在一起。通过这种方式，使用区域提出池化中级特征，并且最后的分类步骤比较便宜。我们的SSD与Faster R-CNN中的区域提出网络（RPN）非常相似，因为我们也使用一组固定的（默认）边界框进行预测，类似于RPN中的锚边界框。但是，我们不是使用这些来池化特征并评估另一个分类器，而是为每个目标类别在每个边界框中同时生成一个分数。因此，我们的方法避免了将RPN与Fast R-CNN合并的复杂性，并且更容易训练，更快且更直接地集成到其它任务中。</p>
<p>与我们的方法直接相关的另一组方法，完全跳过提出步骤，直接预测多个类别的边界框和置信度。OverFeat[4]是滑动窗口方法的深度版本，在知道了底层目标类别的置信度之后，直接从最顶层的特征映射的每个位置预测边界框。YOLO[5]使用整个最顶层的特征映射来预测多个类别和边界框（这些类别共享）的置信度。我们的SSD方法属于这一类，因为我们没有提出步骤，但使用默认边界框。然而，我们的方法比现有方法更灵活，因为我们可以在不同尺度的多个特征映射的每个特征位置上使用不同长宽比的默认边界框。如果我们只从最顶层的特征映射的每个位置使用一个默认框，我们的SSD将具有与OverFeat[4]相似的架构；如果我们使用整个最顶层的特征映射，并添加一个全连接层进行预测来代替我们的卷积预测器，并且没有明确地考虑多个长宽比，我们可以近似地再现YOLO[5]。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>本文介绍了SSD，一种快速的单次多类别目标检测器。我们模型的一个关键特性是使用网络顶部多个特征映射的多尺度卷积边界框输出。这种表示使我们能够高效地建模可能的边界框形状空间。我们通过实验验证，在给定合适训练策略的情况下，大量仔细选择的默认边界框会提高性能。我们构建的SSD模型比现有的方法至少要多一个数量级的边界框预测采样位置，尺度和长宽比[5,7]。我们证明了给定相同的VGG-16基础架构，SSD在准确性和速度方面与其对应的最先进的目标检测器相比毫不逊色。在PASCAL VOC和COCO上，我们的SSD512模型的性能明显优于最先进的Faster R-CNN[2]，而速度提高了3倍。我们的实时SSD300模型运行速度为59FPS，比目前的实时YOLO[5]更快，同时显著提高了检测精度。</p>
<p>除了单独使用之外，我们相信我们的整体和相对简单的SSD模型为采用目标检测组件的大型系统提供了有用的构建模块。一个有前景的未来方向是探索它作为系统的一部分，使用循环神经网络来同时检测和跟踪视频中的目标。</p>
<h2 id="6-致谢"><a href="#6-致谢" class="headerlink" title="6. 致谢"></a>6. 致谢</h2><p>这项工作是在谷歌的一个实习项目开始的，并在UNC继续。我们要感谢Alex Toshev进行有益的讨论，并感谢Google的Image Understanding和DistBelief团队。我们也感谢Philip Ammirato和Patrick Poirson提供有用的意见。我们感谢NVIDIA提供的GPU，并对NSF 1452851,1446631,1526367,1533771的支持表示感谢。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p>Uijlings, J.R., van de Sande, K.E., Gevers, T., Smeulders, A.W.: Selective search for object recognition. IJCV (2013)</p>
</li>
<li><p>Ren, S., He, K., Girshick, R., Sun, J.: Faster R-CNN: Towards real-time object detection with region proposal networks. In: NIPS. (2015)</p>
</li>
<li><p>He, K., Zhang, X., Ren, S., Sun, J.:Deep residual learning for image recognition. In:CVPR. (2016)</p>
</li>
<li><p>Sermanet, P., Eigen, D., Zhang, X., Mathieu, M., Fergus, R., LeCun, Y.: Overfeat:Integrated recognition, localization and detection using convolutional networks. In: ICLR. (2014)</p>
</li>
<li><p>Redmon, J., Divvala, S., Girshick, R., Farhadi, A.: You only look once: Unified, real-time object detection. In: CVPR. (2016)</p>
</li>
<li><p>Girshick, R.: Fast R-CNN. In: ICCV. (2015)</p>
</li>
<li><p>Erhan, D., Szegedy, C., Toshev, A., Anguelov, D.: Scalable object detection using deep neural networks. In: CVPR. (2014)</p>
</li>
<li><p>Szegedy, C., Reed, S., Erhan, D., Anguelov, D.: Scalable, high-quality object detection. arXiv preprint arXiv:1412.1441 v3 (2015)</p>
</li>
<li><p>He, K., Zhang, X., Ren, S., Sun, J.: Spatial pyramid pooling in deep convolutional networks for visual recognition. In: ECCV. (2014)</p>
</li>
<li><p>Long, J., Shelhamer, E., Darrell, T.: Fully convolutional networks for semantic segmentation. In: CVPR. (2015)</p>
</li>
<li><p>Hariharan, B., Arbeláez, P., Girshick, R., Malik, J.: Hypercolumns for object segmentation and fine-grained localization. In: CVPR. (2015)</p>
</li>
<li><p>Liu, W., Rabinovich, A., Berg, A.C.: ParseNet: Looking wider to see better.In:ILCR.(2016)</p>
</li>
<li><p>Zhou, B., Khosla, A., Lapedriza, A., Oliva, A., Torralba, A.: Object detector semerge in deep scene cnns. In: ICLR. (2015)</p>
</li>
<li><p>Howard, A.G.: Some improvements on deep convolutional neural network based image classification. arXiv preprint arXiv:1312.5402 (2013)</p>
</li>
<li><p>Simonyan, K., Zisserman, A.: Very deep convolutional networks for large-scale image recognition. In: NIPS. (2015)</p>
</li>
<li><p>Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla, A., Bernstein, M., Berg, A.C., Fei-Fei, L.: Imagenet large scale visual recognition challenge. IJCV (2015)</p>
</li>
<li><p>Chen, L.C., Papandreou, G., Kokkinos, I., Murphy, K., Yuille, A.L.: Semantic image segmentation with deep convolutional nets and fully connected crfs. In: ICLR. (2015)</p>
</li>
<li><p>Holschneider, M., Kronland-Martinet, R., Morlet, J., Tchamitchian, P.: Areal-time algorithm for signal analysis with the help of the wavelet transform. In: Wavelets. Springer (1990) 286–297</p>
</li>
<li><p>Jia, Y., Shelhamer, E., Donahue, J., Karayev, S., Long, J., Girshick, R., Guadarrama, S., Darrell, T.: Caffe: Convolutional architecture for fast feature embedding. In: MM. (2014)</p>
</li>
<li><p>Glorot, X., Bengio, Y.: Understanding the difficulty of training deep feedforward neural networks. In: AISTATS. (2010)</p>
</li>
<li><p>Hoiem, D., Chodpathumwan, Y., Dai, Q.: Diagnosing error in object detectors. In: ECCV 2012. (2012)</p>
</li>
<li><p>Girshick, R., Donahue, J., Darrell, T., Malik, J.: Rich feature hierarchies for accurate object detection and semantic segmentation. In: CVPR. (2014)</p>
</li>
<li><p>Zhang, L., Lin, L., Liang, X., He, K.: Is faster r-cnn doing well for pedestrian detection. In: ECCV. (2016)</p>
</li>
<li><p>Bell, S., Zitnick, C.L., Bala, K., Girshick, R.: Inside-outside net:Detecting objects in context with skip pooling and recurrent neural networks. In: CVPR. (2016)</p>
</li>
<li><p>COCO: Common Objects in Context. <a href="http://mscoco.org/dataset/#detections-leaderboard" target="_blank" rel="external">http://mscoco.org/dataset/#detections-leaderboard</a> (2016) [Online; accessed 25-July-2016].</p>
</li>
<li><p>Felzenszwalb, P., McAllester, D., Ramanan, D.: A discriminatively trained, multiscale, deformable part model. In: CVPR. (2008)</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      Single Shot MultiBox Detector论文翻译——中文版
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Single Shot MultiBox Detector论文翻译——中英文对照</title>
    <link href="noahsnail.com/2017/12/11/2017-12-11-Single%20Shot%20MultiBox%20Detector%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"/>
    <id>noahsnail.com/2017/12/11/2017-12-11-Single Shot MultiBox Detector论文翻译——中英文对照/</id>
    <published>2017-12-11T07:53:47.000Z</published>
    <updated>2017-12-27T06:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p><strong>声明：作者翻译论文仅为学习，如有侵权请联系作者删除博文，谢谢！</strong></p>
<h1 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We present a method for detecting objects in images using a single deep neural network. Our approach, named SSD, discretizes the output space of bounding boxes into a set of default boxes over different aspect ratios and scales per feature map location. At prediction time, the network generates scores for the presence of each object category in each default box and produces adjustments to the box to better match the object shape. Additionally, the network combines predictions from multiple feature maps with different resolutions to naturally handle objects of various sizes. SSD is simple relative to methods that require object proposals because it completely eliminates proposal generation and subsequent pixel or feature resampling stages and encapsulates all computation in a single network. This makes SSD easy to train and straightforward to integrate into systems that require a detection component. Experimental results on the PASCAL VOC, COCO, and ILSVRC datasets confirm that SSD has competitive accuracy to methods that utilize an additional object proposal step and is much faster, while providing a unified framework for both training and inference. For 300 × 300 input, SSD achieves $74.3\%$ mAP on VOC2007 test at 59 FPS on a Nvidia Titan X and for 512 × 512 input, SSD achieves $76.9\%$ mAP, outperforming a comparable state-of-the-art Faster R-CNN model. Compared to other single stage methods, SSD has much better accuracy even with a smaller input image size. Code is available at: <a href="https://github.com/weiliu89/caffe/tree/ssd" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>.</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们提出了一种使用单个深度神经网络来检测图像中的目标的方法。我们的方法命名为SSD，将边界框的输出空间离散化为不同长宽比的一组默认框和并缩放每个特征映射的位置。在预测时，网络会在每个默认框中为每个目标类别的出现生成分数，并对框进行调整以更好地匹配目标形状。此外，网络还结合了不同分辨率的多个特征映射的预测，自然地处理各种尺寸的目标。相对于需要目标提出的方法，SSD非常简单，因为它完全消除了提出生成和随后的像素或特征重新采样阶段，并将所有计算封装到单个网络中。这使得SSD易于训练和直接集成到需要检测组件的系统中。PASCAL VOC，COCO和ILSVRC数据集上的实验结果证实，SSD对于利用额外的目标提出步骤的方法具有竞争性的准确性，并且速度更快，同时为训练和推断提供了统一的框架。对于300×300的输入，SSD在VOC2007测试中以59FPS的速度在Nvidia Titan X上达到$74.3\%$的mAP，对于512×512的输入，SSD达到了$76.9\%$的mAP，优于参照的最先进的Faster R-CNN模型。与其他单阶段方法相比，即使输入图像尺寸较小，SSD也具有更高的精度。代码获取：<a href="https://github.com/weiliu89/caffe/tree/ssd" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Current state-of-the-art object detection systems are variants of the following approach: hypothesize bounding boxes, resample pixels or features for each box, and apply a high-quality classifier. This pipeline has prevailed on detection benchmarks since the Selective Search work [1] through the current leading results on PASCAL VOC, COCO, and ILSVRC detection all based on Faster R-CNN[2] albeit with deeper features such as [3]. While accurate, these approaches have been too computationally intensive for embedded systems and, even with high-end hardware, too slow for real-time applications.Often detection speed for these approaches is measured in seconds per frame (SPF), and even the fastest high-accuracy detector, Faster R-CNN, operates at only 7 frames per second (FPS). There have been many attempts to build faster detectors by attacking each stage of the detection pipeline (see related work in Sec. 4), but so far, significantly increased speed comes only at the cost of significantly decreased detection accuracy.</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>目前最先进的目标检测系统是以下方法的变种：假设边界框，每个框重采样像素或特征，并应用一个高质量的分类器。自从选择性搜索[1]通过在PASCAL VOC，COCO和ILSVRC上所有基于Faster R-CNN[2]的检测都取得了当前领先的结果（尽管具有更深的特征如[3]），这种流程在检测基准数据上流行开来。尽管这些方法准确，但对于嵌入式系统而言，这些方法的计算量过大，即使是高端硬件，对于实时应用而言也太慢。通常，这些方法的检测速度是以每帧秒（SPF）度量，甚至最快的高精度检测器，Faster R-CNN，仅以每秒7帧（FPS）的速度运行。已经有很多尝试通过处理检测流程中的每个阶段来构建更快的检测器（参见第4节中的相关工作），但是到目前为止，显著提高的速度仅以显著降低的检测精度为代价。</p>
<p>This paper presents the first deep network based object detector that does not resample pixels or features for bounding box hypotheses and and is as accurate as approaches that do. This results in a significant improvement in speed for high-accuracy detection (59 FPS with mAP $74.3\%$ on VOC2007 test, vs. Faster R-CNN 7 FPS with mAP $73.2\%$ or YOLO 45 FPS with mAP $63.4\%$). The fundamental improvement in speed comes from eliminating bounding box proposals and the subsequent pixel or feature resampling stage. We are not the first to do this (cf [4,5]), but by adding a series of improvements, we manage to increase the accuracy significantly over previous attempts. Our improvements include using a small convolutional filter to predict object categories and offsets in bounding box locations, using separate predictors (filters) for different aspect ratio detections, and applying these filters to multiple feature maps from the later stages of a network in order to perform detection at multiple scales. With these modifications——especially using multiple layers for prediction at different scales——we can achieve high-accuracy using relatively low resolution input, further increasing detection speed. While these contributions may seem small independently, we note that the resulting system improves accuracy on real-time detection for PASCAL VOC from $63.4\%$ mAP for YOLO to $74.3\%$ mAP for our SSD. This is a larger relative improvement in detection accuracy than that from the recent, very high-profile work on residual networks [3]. Furthermore, significantly improving the speed of high-quality detection can broaden the range of settings where computer vision is useful.</p>
<p>本文提出了第一个基于深度网络的目标检测器，它不对边界框假设的像素或特征进行重采样，并且与其它方法有一样精确度。这对高精度检测在速度上有显著提高（在VOC2007测试中，59FPS和$74.3\%$的mAP，与Faster R-CNN 7FPS和$73.2\%$的mAP或者YOLO 45 FPS和$63.4\%$的mAP相比）。速度的根本改进来自消除边界框提出和随后的像素或特征重采样阶段。我们并不是第一个这样做的人（查阅[4,5]），但是通过增加一系列改进，我们设法比以前的尝试显著提高了准确性。我们的改进包括使用小型卷积滤波器来预测边界框位置中的目标类别和偏移量，使用不同长宽比检测的单独预测器（滤波器），并将这些滤波器应用于网络后期的多个特征映射中，以执行多尺度检测。通过这些修改——特别是使用多层进行不同尺度的预测——我们可以使用相对较低的分辨率输入实现高精度，进一步提高检测速度。虽然这些贡献可能单独看起来很小，但是我们注意到由此产生的系统将PASCAL VOC实时检测的准确度从YOLO的$63.4\%$的mAP提高到我们的SSD的$74.3\%$的mAP。相比于最近备受瞩目的残差网络方面的工作[3]，在检测精度上这是相对更大的提高。而且，显著提高的高质量检测速度可以扩大计算机视觉使用的设置范围。</p>
<p>We summarize our contributions as follows:</p>
<ul>
<li><p>We introduce SSD, a single-shot detector for multiple categories that is faster than the previous state-of-the-art for single shot detectors (YOLO), and significantly more accurate, in fact as accurate as slower techniques that perform explicit region proposals and pooling (including Faster R-CNN).</p>
</li>
<li><p>The core of SSD is predicting category scores and box offsets for a fixed set of default bounding boxes using small convolutional filters applied to feature maps.</p>
</li>
<li><p>To achieve high detection accuracy we produce predictions of different scales from feature maps of different scales, and explicitly separate predictions by aspect ratio.</p>
</li>
<li><p>These design features lead to simple end-to-end training and high accuracy, even on low resolution input images, further improving the speed vs accuracy trade-off.</p>
</li>
<li><p>Experiments include timing and accuracy analysis on models with varying input size evaluated on PASCAL VOC, COCO, and ILSVRC and are compared to a range of recent state-of-the-art approaches.</p>
</li>
</ul>
<p>我们总结我们的贡献如下：</p>
<ul>
<li><p>我们引入了SSD，这是一种针对多个类别的单次检测器，比先前的先进的单次检测器（YOLO）更快，并且准确得多，事实上，与执行显式区域提出和池化的更慢的技术具有相同的精度（包括Faster R-CNN）。</p>
</li>
<li><p>SSD的核心是预测固定的一系列默认边界框的类别分数和边界框偏移，使用更小的卷积滤波器应用到特征映射上。</p>
</li>
<li><p>为了实现高检测精度，我们根据不同尺度的特征映射生成不同尺度的预测，并通过纵横比明确分开预测。</p>
</li>
<li><p>这些设计功能使得即使在低分辨率输入图像上也能实现简单的端到端训练和高精度，从而进一步提高速度与精度之间的权衡。</p>
</li>
<li><p>实验包括在PASCAL VOC，COCO和ILSVRC上评估具有不同输入大小的模型的时间和精度分析，并与最近的一系列最新方法进行比较。</p>
</li>
</ul>
<h2 id="2-The-Single-Shot-Detector-SSD"><a href="#2-The-Single-Shot-Detector-SSD" class="headerlink" title="2. The Single Shot Detector (SSD)"></a>2. The Single Shot Detector (SSD)</h2><p>This section describes our proposed SSD framework for detection (Sec. 2.1) and the associated training methodology (Sec. 2.2). Afterwards, Sec. 2.3 presents dataset-specific model details and experimental results.</p>
<h2 id="2-单次检测器-SSD"><a href="#2-单次检测器-SSD" class="headerlink" title="2. 单次检测器(SSD)"></a>2. 单次检测器(SSD)</h2><p>本节描述我们提出的SSD检测框架（2.1节）和相关的训练方法（2.2节）。之后，2.3节介绍了数据集特有的模型细节和实验结果。</p>
<h3 id="2-1-Model"><a href="#2-1-Model" class="headerlink" title="2.1 Model"></a>2.1 Model</h3><p>The SSD approach is based on a feed-forward convolutional network that produces a fixed-size collection of bounding boxes and scores for the presence of object class instances in those boxes, followed by a non-maximum suppression step to produce the final detections. The early network layers are based on a standard architecture used for high quality image classification (truncated before any classification layers), which we will call the base network. We then add auxiliary structure to the network to produce detections with the following key features:</p>
<h3 id="2-1-模型"><a href="#2-1-模型" class="headerlink" title="2.1 模型"></a>2.1 模型</h3><p>SSD方法基于前馈卷积网络，该网络产生固定大小的边界框集合，并对这些边界框中存在的目标类别实例进行评分，然后进行非极大值抑制步骤来产生最终的检测结果。早期的网络层基于用于高质量图像分类的标准架构（在任何分类层之前被截断），我们将其称为基础网络。然后，我们将辅助结构添加到网络中以产生具有以下关键特征的检测：</p>
<p><strong>Multi-scale feature maps for detection</strong> We add convolutional feature layers to the end of the truncated base network. These layers decrease in size progressively and allow predictions of detections at multiple scales. The convolutional model for predicting detections is different for each feature layer (<em>cf</em> Overfeat[4] and YOLO[5] that operate on a single scale feature map).</p>
<p><strong>用于检测的多尺度特征映射</strong>。我们将卷积特征层添加到截取的基础网络的末端。这些层在尺寸上逐渐减小，并允许在多个尺度上对检测结果进行预测。用于预测检测的卷积模型对于每个特征层都是不同的（查阅Overfeat[4]和YOLO[5]在单尺度特征映射上的操作）。</p>
<p><strong>Convolutional predictors for detection</strong> Each added feature layer (or optionally an existing feature layer from the base network) can produce a fixed set of detection predictions using a set of convolutional filters. These are indicated on top of the SSD network architecture in Fig. 2. For a feature layer of size $m \times n$ with $p$ channels, the basic element for predicting parameters of a potential detection is a $3 \times 3 \times p$ <em>small kernel</em> that produces either a score for a category, or a shape offset relative to the default box coordinates. At each of the $m \times n$ locations where the kernel is applied, it produces an output value. The bounding box offset output values are measured relative to a default box position relative to each feature map location (<em>cf</em> the architecture of YOLO[5] that uses an intermediate fully connected layer instead of a convolutional filter for this step).</p>
<p><img src="http://img.blog.csdn.net/20171216225358544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 2"></p>
<p>Fig. 2: A comparison between two single shot detection models: SSD and YOLO [5]. Our SSD model adds several feature layers to the end of a base network, which predict the offsets to default boxes of different scales and aspect ratios and their associated confidences. SSD with a 300 × 300 input size significantly outperforms its 448 × 448 YOLO counterpart in accuracy on VOC2007 <code>test</code> while also improving the speed.</p>
<p><strong>用于检测的卷积预测器</strong>。每个添加的特征层（或者任选的来自基础网络的现有特征层）可以使用一组卷积滤波器产生固定的检测预测集合。这些在图2中的SSD网络架构的上部指出。对于具有$p$通道的大小为$m \times n$的特征层，潜在检测的预测参数的基本元素是$3 \times 3 \times p$的<em>小核</em>得到某个类别的分数，或者相对于默认框坐标的形状偏移。在应用卷积核的$m \times n$的每个位置，它会产生一个输出值。边界框偏移输出值是相对每个特征映射位置的相对默认框位置来度量的（查阅YOLO[5]的架构，该步骤使用中间全连接层而不是卷积滤波器）。</p>
<p><img src="http://img.blog.csdn.net/20171216225358544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 2"></p>
<p>图2：两个单次检测模型的比较：SSD和YOLO[5]。我们的SSD模型在基础网络的末端添加了几个特征层，它预测了不同尺度和长宽比的默认边界框的偏移量及其相关的置信度。300×300输入尺寸的SSD在VOC2007 <code>test</code>上的准确度上明显优于448×448的YOLO的准确度，同时也提高了速度。</p>
<p><strong>Default boxes and aspect ratios</strong> We associate a set of default bounding boxes with each feature map cell, for multiple feature maps at the top of the network. The default boxes tile the feature map in a convolutional manner, so that the position of each box relative to its corresponding cell is fixed. At each feature map cell, we predict the offsets relative to the default box shapes in the cell, as well as the per-class scores that indicate the presence of a class instance in each of those boxes. Specifically, for each box out of $k$ at a given location, we compute $c$ class scores and the $4$ offsets relative to the original default box shape. This results in a total of $(c+4)k$ filters that are applied around each location in the feature map, yielding $(c+4)kmn$ outputs for a $m\times n$ feature map. For an illustration of default boxes, please refer to Fig.1. Our default boxes are similar to the <em>anchor boxes</em> used in Faster R-CNN[2], however we apply them to several feature maps of different resolutions. Allowing different default box shapes in several feature maps let us efficiently discretize the space of possible output box shapes.</p>
<p><img src="http://img.blog.csdn.net/20171216225302641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 1"></p>
<p>Fig. 1: SSD framework. (a) SSD only needs an input image and ground truth boxes for each object during training. In a convolutional fashion, we evaluate a small set (e.g. 4) of default boxes of different aspect ratios at each location in several feature maps with different scales (e.g. 8 × 8 and 4 × 4 in (b) and (c)). For each default box, we predict both the shape offsets and the confidences for all object categories ($(c_1, c_2, \dots, c_p)$). At training time, we first match these default boxes to the ground truth boxes. For example, we have matched two default boxes with the cat and one with the dog, which are treated as positives and the rest as negatives. The model loss is a weighted sum between localization loss (e.g. Smooth L1 [6]) and confidence loss (e.g. Softmax).</p>
<p><strong>默认边界框和长宽比</strong>。对于网络顶部的多个特征映射，我们将一组默认边界框与每个特征映射单元相关联。默认边界框以卷积的方式平铺特征映射，以便每个边界框相对于其对应单元的位置是固定的。在每个特征映射单元中，我们预测单元中相对于默认边界框形状的偏移量，以及指出每个边界框中存在的每个类别实例的类别分数。具体而言，对于给定位置处的$k$个边界框中的每一个，我们计算$c$个类别分数和相对于原始默认边界框形状的$4$个偏移量。这导致在特征映射中的每个位置周围应用总共$(c+4)k$个滤波器，对于$m\times n$的特征映射取得$(c+4)kmn$个输出。有关默认边界框的说明，请参见图1。我们的默认边界框与Faster R-CNN[2]中使用的<em>锚边界框</em>相似，但是我们将它们应用到不同分辨率的几个特征映射上。在几个特征映射中允许不同的默认边界框形状让我们有效地离散可能的输出框形状的空间。</p>
<p><img src="http://img.blog.csdn.net/20171216225302641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 1"></p>
<p>图1：SSD框架。（a）在训练期间，SSD仅需要每个目标的输入图像和真实边界框。以卷积方式，我们评估具有不同尺度（例如（b）和（c）中的8×8和4×4）的几个特征映射中每个位置处不同长宽比的默认框的小集合（例如4个）。对于每个默认边界框，我们预测所有目标类别（$(c_1, c_2, \dots, c_p)$）的形状偏移量和置信度。在训练时，我们首先将这些默认边界框与实际的边界框进行匹配。例如，我们已经与猫匹配两个默认边界框，与狗匹配了一个，这被视为积极的，其余的是消极的。模型损失是定位损失（例如，Smooth L1[6]）和置信度损失（例如Softmax）之间的加权和。</p>
<h2 id="2-2-Training"><a href="#2-2-Training" class="headerlink" title="2.2 Training"></a>2.2 Training</h2><p>The key difference between training SSD and training a typical detector that uses region proposals, is that ground truth information needs to be assigned to specific outputs in the fixed set of detector outputs. Some version of this is also required for training in YOLO[5] and for the region proposal stage of Faster R-CNN[2] and MultiBox[7]. Once this assignment is determined, the loss function and back propagation are applied end-to-end. Training also involves choosing the set of default boxes and scales for detection as well as the hard negative mining and data augmentation strategies.</p>
<h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2><p>训练SSD和训练使用区域提出的典型检测器之间的关键区别在于，需要将真实信息分配给固定的检测器输出集合中的特定输出。在YOLO[5]的训练中、Faster R-CNN[2]和MultiBox[7]的区域提出阶段，一些版本也需要这样的操作。一旦确定了这个分配，损失函数和反向传播就可以应用端到端了。训练也涉及选择默认边界框集合和缩放进行检测，以及难例挖掘和数据增强策略。</p>
<p><strong>Matching strategy</strong> During training we need to determine which default boxes correspond to a ground truth detection and train the network accordingly. For each ground truth box we are selecting from default boxes that vary over location, aspect ratio, and scale. We begin by matching each ground truth box to the default box with the best jaccard overlap (as in MultiBox [7]). Unlike MultiBox, we then match default boxes to any ground truth with jaccard overlap higher than a threshold (0.5). This simplifies the learning problem, allowing the network to predict high scores for multiple overlapping default boxes rather than requiring it to pick only the one with maximum overlap.</p>
<p><strong>匹配策略</strong>。在训练过程中，我们需要确定哪些默认边界框对应实际边界框的检测，并相应地训练网络。对于每个实际边界框，我们从默认边界框中选择，这些框会在位置，长宽比和尺度上变化。我们首先将每个实际边界框与具有最好的Jaccard重叠（如MultiBox[7]）的边界框相匹配。与MultiBox不同的是，我们将默认边界框匹配到Jaccard重叠高于阈值（0.5）的任何实际边界框。这简化了学习问题，允许网络为多个重叠的默认边界框预测高分，而不是要求它只挑选具有最大重叠的一个边界框。</p>
<p><strong>注：Jaccard重叠即IoU。</strong></p>
<p><strong>Training objective</strong> The SSD training objective is derived from the MultiBox objective[7,8] but is extended to handle multiple object categories. Let $x_{ij}^p = \lbrace 1,0 \rbrace$ be an indicator for matching the $i$-th default box to the $j$-th ground truth box of category $p$. In the matching strategy above, we can have $\sum_i x_{ij}^p \geq 1$. The overall objective loss function is a weighted sum of the localization loss (loc) and the confidence loss (conf): $$L(x, c, l, g) = \frac{1}{N}(L_{conf}(x, c) + \alpha L_{loc}(x, l, g)) \tag{1}$$ where N is the number of matched default boxes. If $N = 0$, wet set the loss to 0. The localization loss is a Smooth L1 loss[6] between the predicted box ($l$) and the ground truth box ($g$) parameters. Similar to Faster R-CNN[2], we regress to offsets for the center ($cx, cy$) of the default bounding box ($d$) and for its width ($w$) and height ($h$).<br>$$<br>L_{loc}(x,l,g) = \sum_{i \in Pos}^N \sum_{m \in \lbrace cx, cy, w, h \rbrace} x_{ij}^k \mathtt{smooth}_{L1}(l_{i}^m - \hat{g}_j^m) \\<br>\hat{g}_j^{cx} = (g_j^{cx} - d_i^{cx}) / d_i^w \quad \quad<br>\hat{g}_j^{cy} = (g_j^{cy} - d_i^{cy}) / d_i^h \\<br>\hat{g}_j^{w} = \log\Big(\frac{g_j^{w}}{d_i^w}\Big) \quad \quad<br>\hat{g}_j^{h} = \log\Big(\frac{g_j^{h}}{d_i^h}\Big)<br>\tag{2}<br>$$ The confidence loss is the softmax loss over multiple classes confidences ($c$).<br>$$<br>L_{conf}(x, c) = - \sum_{i\in Pos}^N x_{ij}^p log(\hat{c}_i^p) - \sum_{i\in Neg} log(\hat{c}_i^0)\quad \mathtt{where}\quad\hat{c}_i^p = \frac{\exp(c_i^p)}{\sum_p \exp(c_i^p)}<br>\tag{3}<br>$$ and the weight term $\alpha$ is set to 1 by cross validation.</p>
<p><strong>训练目标函数</strong>。SSD训练目标函数来自于MultiBox目标[7,8]，但扩展到处理多个目标类别。设$x_{ij}^p = \lbrace 1,0 \rbrace$是第$i$个默认边界框匹配到类别$p$的第$j$个实际边界框的指示器。在上面的匹配策略中，我们有$\sum_i x_{ij}^p \geq 1$。总体目标损失函数是定位损失（loc）和置信度损失（conf）的加权和：$$L(x, c, l, g) = \frac{1}{N}(L_{conf}(x, c) + \alpha L_{loc}(x, l, g)) \tag{1}$$其中N是匹配的默认边界框的数量。如果$N=0$，则将损失设为0。定位损失是预测框($l$)与真实框($g$)参数之间的Smooth L1损失[6]。类似于Faster R-CNN[2]，我们回归默认边界框($d$)的中心偏移量($cx, cy$)和其宽度($w$)、高度($h$)的偏移量。$$<br>L_{loc}(x,l,g) = \sum_{i \in Pos}^N \sum_{m \in \lbrace cx, cy, w, h \rbrace} x_{ij}^k \mathtt{smooth}_{L1}(l_{i}^m - \hat{g}_j^m) \\<br>\hat{g}_j^{cx} = (g_j^{cx} - d_i^{cx}) / d_i^w \quad \quad<br>\hat{g}_j^{cy} = (g_j^{cy} - d_i^{cy}) / d_i^h \\<br>\hat{g}_j^{w} = \log\Big(\frac{g_j^{w}}{d_i^w}\Big) \quad \quad<br>\hat{g}_j^{h} = \log\Big(\frac{g_j^{h}}{d_i^h}\Big)<br>\tag{2}<br>$$置信度损失是在多类别置信度($c$)上的softmax损失。<br>$$<br>L_{conf}(x, c) = - \sum_{i\in Pos}^N x_{ij}^p log(\hat{c}_i^p) - \sum_{i\in Neg} log(\hat{c}_i^0)\quad \mathtt{where}\quad\hat{c}_i^p = \frac{\exp(c_i^p)}{\sum_p \exp(c_i^p)}<br>\tag{3}<br>$$<br>通过交叉验证权重项$\alpha$设为1。</p>
<p><strong>Choosing scales and aspect ratios for default boxes</strong> To handle different object scales, some methods [4,9] suggest processing the image at different sizes and combining the results afterwards. However, by utilizing feature maps from several different layers in a single network for prediction we can mimic the same effect, while also sharing parameters across all object scales. Previous works [10,11] have shown that using feature maps from the lower layers can improve semantic segmentation quality because the lower layers capture more fine details of the input objects. Similarly, [12] showed that adding global context pooled from a feature map can help smooth the segmentation results. Motivated by these methods, we use both the lower and upper feature maps for detection. Figure 1 shows two exemplar feature maps (8 × 8 and 4 × 4) which are used in the framework. In practice, we can use many more with small computational overhead.</p>
<p><strong>为默认边界框选择尺度和长宽比</strong>。为了处理不同的目标尺度，一些方法[4,9]建议处理不同尺寸的图像，然后将结果合并。然而，通过利用单个网络中几个不同层的特征映射进行预测，我们可以模拟相同的效果，同时还可以跨所有目标尺度共享参数。以前的工作[10,11]已经表明，使用低层的特征映射可以提高语义分割的质量，因为低层会捕获输入目标的更多细节。同样，[12]表明，从特征映射上添加全局上下文池化可以有助于平滑分割结果。受这些方法的启发，我们使用较低和较高的特征映射进行检测。图1显示了框架中使用的两个示例性特征映射（8×8和4×4）。在实践中，我们可以使用更多的具有很少计算开支的特征映射。</p>
<p>Feature maps from different levels within a network are known to have different (empirical) receptive field sizes [13]. Fortunately, within the SSD framework, the default boxes do not necessary need to correspond to the actual receptive fields of each layer. We design the tiling of default boxes so that specific feature maps learn to be responsive to particular scales of the objects. Suppose we want to use $m$ feature maps for prediction. The scale of the default boxes for each feature map is computed as: $$s_k = s_\text{min} + \frac{s_\text{max} - s_\text{min}}{m - 1} (k - 1),\quad k\in [1, m]$$ where $s_\text{min}$ is 0.2 and $s_\text{max}$ is 0.9, meaning the lowest layer has a scale of 0.2 and the highest layer has a scale of 0.9, and all layers in between are regularly spaced. We impose different aspect ratios for the default boxes, and denote them as $a_r \in {1, 2, 3, \frac{1}{2}, \frac{1}{3}}$. We can compute the width ($w_k^a = s_k\sqrt{a_r}$) and height ($h_k^a = s_k / \sqrt{a_r}$) for each default box. For the aspect ratio of 1, we also add a default box whose scale is $s’_k = \sqrt{s_k s_{k+1}}$, resulting in 6 default boxes per feature map location. We set the center of each default box to $(\frac{i+0.5}{|f_k|}, \frac{j+0.5}{|f_k|})$, where $|f_k|$ is the size of the $k$-th square feature map, $i, j\in [0, |f_k|)$. In practice, one can also design a distribution of default boxes to best fit a specific dataset. How to design the optimal tiling is an open question as well.</p>
<p>已知网络中不同层的特征映射具有不同的（经验的）感受野大小[13]。幸运的是，在SSD框架内，默认边界框不需要对应于每层的实际感受野。我们设计平铺默认边界框，以便特定的特征映射学习响应目标的特定尺度。假设我们要使用$m$个特征映射进行预测。每个特征映射默认边界框的尺度计算如下：$$s_k = s_\text{min} + \frac{s_\text{max} - s_\text{min}}{m - 1} (k - 1),\quad k\in [1, m]$$其中$s_\text{min}$为0.2，$s_\text{max}$为0.9，意味着最低层具有0.2的尺度，最高层具有0.9的尺度，并且在它们之间的所有层是规则间隔的。我们为默认边界框添加不同的长宽比，并将它们表示为$a_r \in {1, 2, 3, \frac{1}{2}, \frac{1}{3}}$。我们可以计算每个边界框的宽度($w_k^a = s_k\sqrt{a_r}$)和高度($h_k^a = s_k / \sqrt{a_r}$)。对于长宽比为1，我们还添加了一个默认边界框，其尺度为$s’_k = \sqrt{s_k s_{k+1}}$，在每个特征映射位置得到6个默认边界框。我们将每个默认边界框的中心设置为$(\frac{i+0.5}{|f_k|}, \frac{j+0.5}{|f_k|})$，其中$|f_k|$是第$k$个平方特征映射的大小，$i, j\in [0, |f_k|)$。在实践中，也可以设计默认边界框的分布以最适合特定的数据集。如何设计最佳平铺也是一个悬而未决的问题。</p>
<p>By combining predictions for all default boxes with different scales and aspect ratios from all locations of many feature maps, we have a diverse set of predictions, covering various input object sizes and shapes. For example, in Fig. 1, the dog is matched to a default box in the 4 × 4 feature map, but not to any default boxes in the 8 × 8 feature map. This is because those boxes have different scales and do not match the dog box, and therefore are considered as negatives during training.</p>
<p>通过将所有默认边界框的预测与许多特征映射所有位置的不同尺度和高宽比相结合，我们有不同的预测集合，涵盖各种输入目标大小和形状。例如，在图1中，狗被匹配到4×4特征映射中的默认边界框，而不是8×8特征映射中的任何默认框。这是因为那些边界框有不同的尺度，不匹配狗的边界框，因此在训练期间被认为是负例。</p>
<p><strong>Hard negative mining</strong> After the matching step, most of the default boxes are negatives, especially when the number of possible default boxes is large. This introduces a significant imbalance between the positive and negative training examples. Instead of using all the negative examples, we sort them using the highest confidence loss for each default box and pick the top ones so that the ratio between the negatives and positives is at most 3:1. We found that this leads to faster optimization and a more stable training.</p>
<p><strong>难例挖掘</strong>。在匹配步骤之后，大多数默认边界框为负例，尤其是当可能的默认边界框数量较多时。这在正的训练实例和负的训练实例之间引入了显著的不平衡。我们不使用所有负例，而是使用每个默认边界框的最高置信度损失来排序它们，并挑选最高的置信度，以便负例和正例之间的比例至多为3:1。我们发现这会导致更快的优化和更稳定的训练。</p>
<p><strong>Data augmentation</strong> To make the model more robust to various input object sizes and shapes, each training image is randomly sampled by one of the following options:</p>
<ul>
<li>Use the entire original input image.</li>
<li>Sample a patch so that the <em>minimum</em> jaccard overlap with the objects is 0.1, 0.3, 0.5, 0.7, or 0.9.</li>
<li>Randomly sample a patch.</li>
</ul>
<p>The size of each sampled patch is [0.1, 1] of the original image size, and the aspect ratio is between $\frac {1} {2}$ and 2. We keep the overlapped part of the ground truth box if the center of it is in the sampled patch. After the aforementioned sampling step, each sampled patch is resized to fixed size and is horizontally flipped with probability of 0.5, in addition to applying some photo-metric distortions similar to those described in [14].</p>
<p><strong>数据增强</strong>。为了使模型对各种输入目标大小和形状更鲁棒，每张训练图像都是通过以下选项之一进行随机采样的：</p>
<ul>
<li>使用整个原始输入图像。</li>
<li>采样一个图像块，使得与目标之间的<em>最小</em>Jaccard重叠为0.1，0.3，0.5，0.7或0.9。</li>
<li>随机采样一个图像块。</li>
</ul>
<p>每个采样图像块的大小是原始图像大小的[0.1，1]，长宽比在$\frac {1} {2}$和2之间。如果实际边界框的中心在采用的图像块中，我们保留实际边界框与采样图像块的重叠部分。在上述采样步骤之后，除了应用类似于文献[14]中描述的一些光度变形之外，将每个采样图像块调整到固定尺寸并以0.5的概率进行水平翻转。</p>
<h2 id="3-Experimental-Results"><a href="#3-Experimental-Results" class="headerlink" title="3. Experimental Results"></a>3. Experimental Results</h2><p><strong>Base network</strong> Our experiments are all based on VGG16[15], which is pre-trained on the ILSVRC CLS-LOC dataset[16]. Similar to DeepLab-LargeFOV[17], we convert fc6 and fc7 to convolutional layers, subsample parameters from fc6 and fc7, change pool5 from $2\times 2-s2$ to $3\times 3-s1$, and use the atrous algorithm[18] to fill the “holes”. We remove all the dropout layers and the fc8 layer. We fine-tune the resulting model using SGD with initial learning rate $10^{-3}$, 0.9 momentum, 0.0005 weight decay, and batch size 32. The learning rate decay policy is slightly different for each dataset, and we will describe details later. The full training and testing code is built on Caffe[19] and is open source at: <a href="https://github.com/weiliu89/caffe/tree/ssd" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>.</p>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h2><p><strong>基础网络</strong>。我们的实验全部基于VGG16[15]，它是在ILSVRC CLS-LOC数据集[16]上预先训练的。类似于DeepLab-LargeFOV[17]，我们将<code>fc6</code>和<code>fc7</code>转换为卷积层，从fc6和fc7中重采样参数，将pool5从$2\times 2-s2$更改为$3\times 3-s1$，并使用空洞算法[18]来填补这个“小洞”。我们删除所有的丢弃层和<code>fc8</code>层。我们使用SGD对得到的模型进行微调，初始学习率为$10^{-3}$，动量为0.9，权重衰减为0.0005，批数据大小为32。每个数据集的学习速率衰减策略略有不同，我们将在后面详细描述。完整的训练和测试代码建立在Caffe[19]上并开源：<a href="https://github.com/weiliu89/caffe/tree/ SSD" target="_blank" rel="external">https://github.com/weiliu89/caffe/tree/ssd</a>。</p>
<h3 id="3-1-PASCAL-VOC2007"><a href="#3-1-PASCAL-VOC2007" class="headerlink" title="3.1 PASCAL VOC2007"></a>3.1 PASCAL VOC2007</h3><p>On this dataset, we compare against Fast R-CNN [6] and Faster R-CNN [2] on VOC2007 <code>test</code> (4952 images). All methods fine-tune on the same pre-trained VGG16 network.</p>
<h3 id="3-1-PASCAL-VOC2007-1"><a href="#3-1-PASCAL-VOC2007-1" class="headerlink" title="3.1 PASCAL VOC2007"></a>3.1 PASCAL VOC2007</h3><p>在这个数据集上，我们在VOC2007 <code>test</code>（4952张图像）上比较了Fast R-CNN[6]和FAST R-CNN[2]。所有的方法都在相同的预训练好的VGG16网络上进行微调。</p>
<p>Figure 2 shows the architecture details of the SSD300 model. We use conv4_3, conv7 (fc7), conv8_2, conv9_2, conv10_2, and conv11_2 to predict both location and confidences. We set default box with scale 0.1 on conv4_3. We initialize the parameters for all the newly added convolutional layers with the “xavier” method [20]. For conv4_3, conv10_2 and conv11_2, we only associate 4 default boxes at each feature map location —— omitting aspect ratios of $\frac{1}{3}$ and 3. For all other layers, we put 6 default boxes as described in Sec. 2.2. Since, as pointed out in [12], conv4_3 has a different feature scale compared to the other layers, we use the L2 normalization technique introduced in [12] to scale the feature norm at each location in the feature map to 20 and learn the scale during back propagation. We use the $10^{-3}$ learning rate for 40k iterations, then continue training for 10k iterations with $10^{-4}$ and $10^{-5}$. When training on VOC2007 $\texttt{trainval}$, Table 1 shows that our low resolution SSD300 model is already more accurate than Fast R-CNN. When we train SSD on a larger $512\times 512$ input image, it is even more accurate, surpassing Faster R-CNN by $1.7\%$ mAP. If we train SSD with more (i.e. 07+12) data, we see that SSD300 is already better than Faster R-CNN by $1.1\%$ and that SSD512 is $3.6\%$ better. If we take models trained on COCO $\texttt{trainval35k}$ as described in Sec. 3.4 and fine-tuning them on the 07+12 dataset with SSD512, we achieve the best results: $81.6\%$ mAP.</p>
<p><img src="http://img.blog.csdn.net/20171216224936736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 1"></p>
<p>Table 1: <strong>PASCAL VOC2007 <code>test</code> detection results</strong>. Both Fast and Faster R-CNN use input images whose minimum dimension is 600. The two SSD models have exactly the same settings except that they have different input sizes (300×300 vs. 512×512). It is obvious that larger input size leads to better results, and more data always helps. Data: ”07”: VOC2007 <code>trainval</code>, ”07+12”: union of VOC2007 and VOC2012 <code>trainval</code>. ”07+12+COCO”: first train on COCO <code>trainval35k</code> then fine-tune on 07+12.</p>
<p>图2显示了SSD300模型的架构细节。我们使用conv4_3，conv7（fc7），conv8_2，conv9_2，conv10_2和conv11_2来预测位置和置信度。我们在conv4_3上设置了尺度为0.1的默认边界框。我们使用“xavier”方法[20]初始化所有新添加的卷积层的参数。对于conv4_3，conv10_2和conv11_2，我们只在每个特征映射位置上关联了4个默认边界框——忽略$\frac {1} {3} $和3的长宽比。对于所有其它层，我们像2.2节描述的那样放置了6个默认边界框。如[12]所指出的，与其它层相比，由于conv4_3具有不同的特征尺度，所以我们使用[12]中引入的L2正则化技术将特征映射中每个位置的特征标准缩放到20，在反向传播过程中学习尺度。对于40k次迭代，我们使用$10^{-3}$的学习率，然后继续用$10^{-4}$和$10^{-5}$的学习率训练10k迭代。当对VOC2007 $\texttt{trainval}$进行训练时，表1显示了我们的低分辨率SSD300模型已经比Fast R-CNN更准确。当我们用更大的$512\times 512$输入图像上训练SSD时，它更加准确，超过了Faster R-CNN $1.7\%$的mAP。如果我们用更多的（即07+12）数据来训练SSD，我们看到SSD300已经比Faster R-CNN好$1.1\%$，SSD512比Faster R-CNN好$3.6\%$。如果我们将SSD512用3.4节描述的COCO $\texttt{trainval35k}$来训练模型并在07+12数据集上进行微调，我们获得了最好的结果：$81.6\%$的mAP。</p>
<p><img src="http://img.blog.csdn.net/20171216224936736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 1"></p>
<p>表1：<strong>PASCAL VOC2007 <code>test</code>检测结果</strong>。Fast和Faster R-CNN都使用最小维度为600的输入图像。两个SSD模型使用完全相同的设置除了它们有不同的输入大小(300×300和512×512)。很明显更大的输入尺寸会导致更好的结果，并且更大的数据同样有帮助。数据：“07”：VOC2007 <code>trainval</code>，“07+12”：VOC2007和VOC2012 <code>trainval</code>的联合。“07+12+COCO”：首先在COCO <code>trainval35k</code>上训练然后在07+12上微调。</p>
<p>To understand the performance of our two SSD models in more details, we used the detection analysis tool from [21]. Figure 3 shows that SSD can detect various object categories with high quality (large white area). The majority of its confident detections are correct. The recall is around $85-90\%$, and is much higher with “weak” (0.1 jaccard overlap) criteria. Compared to R-CNN [22], SSD has less localization error, indicating that SSD can localize objects better because it directly learns to regress the object shape and classify object categories instead of using two decoupled steps. However, SSD has more confusions with similar object categories (especially for animals), partly because we share locations for multiple categories. Figure 4 shows that SSD is very sensitive to the bounding box size. In other words, it has much worse performance on smaller objects than bigger objects. This is not surprising because those small objects may not even have any information at the very top layers. Increasing the input size (e.g. from 300 × 300 to 512 × 512) can help improve detecting small objects, but there is still a lot of room to improve. On the positive side, we can clearly see that SSD performs really well on large objects. And it is very robust to different object aspect ratios because we use default boxes of various aspect ratios per feature map location.</p>
<p><img src="http://img.blog.csdn.net/20171216225014459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 3"></p>
<p>Fig. 3: <strong>Visualization of performance for SSD512 on animals, vehicles, and furniture from VOC2007 <code>test</code></strong>. The top row shows the cumulative fraction of detections that are correct (Cor) or false positive due to poor localization (Loc), confusion with similar categories (Sim), with others (Oth), or with background (BG). The solid red line reflects the change of recall with strong criteria (0.5 jaccard overlap) as the number of detections increases. The dashed red line is using the weak criteria (0.1 jaccard overlap). The bottom row shows the distribution of top-ranked false positive types.</p>
<p><img src="http://img.blog.csdn.net/20171216225051688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 4"></p>
<p>Fig. 4: <strong>Sensitivity and impact of different object characteristics on VOC2007 <code>test</code> set using [21]</strong>. The plot on the left shows the effects of BBox Area per category, and the right plot shows the effect of Aspect Ratio. Key: BBox Area: XS=extra-small; S=small; M=medium; L=large; XL=extra-large. Aspect Ratio: XT=extra-tall/narrow; T=tall; M=medium; W=wide; XW =extra-wide.</p>
<p>为了更详细地了解我们两个SSD模型的性能，我们使用了[21]中的检测分析工具。图3显示了SSD可以检测到高质量（大白色区域）的各种目标类别。它大部分的确信检测是正确的。召回约为$85-90\%$，而“弱”（0.1 Jaccard重叠）标准则要高得多。与R-CNN[22]相比，SSD具有更小的定位误差，表明SSD可以更好地定位目标，因为它直接学习回归目标形状和分类目标类别，而不是使用两个解耦步骤。然而，SSD对类似的目标类别（特别是对于动物）有更多的混淆，部分原因是我们共享多个类别的位置。图4显示SSD对边界框大小非常敏感。换句话说，它在较小目标上比在较大目标上的性能要差得多。这并不奇怪，因为这些小目标甚至可能在顶层没有任何信息。增加输入尺寸（例如从300×300到512×512）可以帮助改进检测小目标，但仍然有很大的改进空间。积极的一面，我们可以清楚地看到SSD在大型目标上的表现非常好。而且对于不同长宽比的目标，它是非常鲁棒的，因为我们使用每个特征映射位置的各种长宽比的默认框。</p>
<p><img src="http://img.blog.csdn.net/20171216225014459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 3"></p>
<p>图3：<strong>SSD512在VOC2007 <code>test</code>中的动物，车辆和家具上的性能可视化</strong>。第一行显示由于定位不佳（Loc），与相似类别（Sim）混淆，与其它（Oth）或背景（BG）相关的正确检测（Cor）或假阳性的累积分数。红色的实线表示随着检测次数的增加，强标准（0.5 Jaccard重叠）下的召回变化。红色虚线是使用弱标准（0.1 Jaccard重叠）。最下面一行显示了排名靠前的假阳性类型的分布。</p>
<p><img src="http://img.blog.csdn.net/20171216225051688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 4"></p>
<p>图4：<strong>使用[21]在VOC2007 <code>test</code>设置上不同目标特性的灵敏度和影响</strong>。左边的图显示了BBox面积对每个类别的影响，右边的图显示了长宽比的影响。关键：BBox区域：XS=超小；S=小；M=中等；L=大；XL=超大。长宽比：XT=超高/窄；T=高；M=中等；W=宽；XW =超宽。</p>
<h3 id="3-2-Model-analysis"><a href="#3-2-Model-analysis" class="headerlink" title="3.2 Model analysis"></a>3.2 Model analysis</h3><p>To understand SSD better, we carried out controlled experiments to examine how each component affects performance. For all the experiments, we use the same settings and input size (300 × 300), except for specified changes to the settings or component(s).</p>
<h3 id="3-2-模型分析"><a href="#3-2-模型分析" class="headerlink" title="3.2 模型分析"></a>3.2 模型分析</h3><p>为了更好地了解SSD，我们进行了控制实验，以检查每个组件如何影响性能。对于所有的实验，我们使用相同的设置和输入大小（300×300），除了指定的设置或组件的更改。</p>
<p><strong>Data augmentation is crucial</strong>. Fast and Faster R-CNN use the original image and the horizontal flip to train. We use a more extensive sampling strategy, similar to YOLO [5]. Table 2 shows that we can improve $8.8\%$ mAP with this sampling strategy. We do not know how much our sampling strategy will benefit Fast and Faster R-CNN, but they are likely to benefit less because they use a feature pooling step during classification that is relatively robust to object translation by design.</p>
<p><img src="http://img.blog.csdn.net/20171216224209114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 2"></p>
<p>Table 2: <strong>Effects of various design choices and components on SSD performance</strong>.</p>
<p><strong>数据增强至关重要</strong>。Fast和Faster R-CNN使用原始图像和水平翻转来训练。我们使用更广泛的抽样策略，类似于YOLO[5]。从表2可以看出，采样策略可以提高$8.8\%$的mAP。我们不知道我们的采样策略将会使Fast和Faster R-CNN受益多少，但是他们可能从中受益较少，因为他们在分类过程中使用了一个特征池化步骤，这对通过设计的目标变换来说相对鲁棒。</p>
<p><img src="http://img.blog.csdn.net/20171216224209114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 2"></p>
<p>表2：<strong>各种设计选择和组件对SSD性能的影响。</strong></p>
<p><strong>More default box shapes is better</strong>. As described in Sec. 2.2, by default we use 6 default boxes per location. If we remove the boxes with $\frac {1} {3}$ and 3 aspect ratios, the performance drops by $0.6\%$. By further removing the boxes with $\frac {1} {2}$ and 2 aspect ratios, the performance drops another $2.1\%$. Using a variety of default box shapes seems to make the task of predicting boxes easier for the network.</p>
<p><strong>更多的默认边界框形状会更好。</strong>如2.2节所述，默认情况下，我们每个位置使用6个默认边界框。如果我们删除长宽比为$\frac {1} {3}$和3的边界框，性能下降了$0.6\%$。通过进一步去除$\frac {1} {2}$和2长宽比的盒子，性能再下降$2.1\%$。使用各种默认边界框形状似乎使网络预测边界框的任务更容易。</p>
<p><strong>Atrous is faster</strong>. As described in Sec. 3, we used the atrous version of a subsampled VGG16, following DeepLab-LargeFOV [17]. If we use the full VGG16, keeping pool5 with 2×2−s2 and not subsampling parameters from fc6 and fc7, and add conv5 3 for prediction, the result is about the same while the speed is about $20\%$ slower.</p>
<p><strong>Atrous更快</strong>。如第3节所述，我们根据DeepLab-LargeFOV[17]使用子采样的VGG16的空洞版本。如果我们使用完整的VGG16，保持pool5为2×2-s2，并且不从fc6和fc7中子采样参数，并添加conv5_3进行预测，结果大致相同，而速度慢了大约$20\%$。</p>
<p><strong>Multiple output layers at different resolutions is better</strong>. A major contribution of SSD is using default boxes of different scales on different output layers. To measure the advantage gained, we progressively remove layers and compare results. For a fair comparison, every time we remove a layer, we adjust the default box tiling to keep the total number of boxes similar to the original (8732). This is done by stacking more scales of boxes on remaining layers and adjusting scales of boxes if needed. We do not exhaustively optimize the tiling for each setting. Table 3 shows a decrease in accuracy with fewer layers, dropping monotonically from 74.3 to 62.4. When we stack boxes of multiple scales on a layer, many are on the image boundary and need to be handled carefully. We tried the strategy used in Faster R-CNN [2], ignoring boxes which are on the boundary. We observe some interesting trends. For example, it hurts the performance by a large margin if we use very coarse feature maps (e.g. conv11_2 (1 × 1) or conv10_2 (3 × 3)). The reason might be that we do not have enough large boxes to cover large objects after the pruning. When we use primarily finer resolution maps, the performance starts increasing again because even after pruning a sufficient number of large boxes remains. If we only use conv7 for prediction, the performance is the worst, reinforcing the message that it is critical to spread boxes of different scales over different layers. Besides, since our predictions do not rely on ROI pooling as in [6], we do not have the collapsing bins problem in low-resolution feature maps [23]. The SSD architecture combines predictions from feature maps of various resolutions to achieve comparable accuracy to Faster R-CNN, while using lower resolution input images.</p>
<p><img src="http://img.blog.csdn.net/20171216231320942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 3"></p>
<p>Table 3: <strong>Effects of using multiple output layers</strong>.</p>
<p><strong>多个不同分辨率的输出层更好</strong>。SSD的主要贡献是在不同的输出层上使用不同尺度的默认边界框。为了衡量所获得的优势，我们逐步删除层并比较结果。为了公平比较，每次我们删除一层，我们调整默认边界框平铺，以保持类似于最初的边界框的总数（8732）。这是通过在剩余层上堆叠更多尺度的盒子并根据需要调整边界框的尺度来完成的。我们没有详尽地优化每个设置的平铺。表3显示层数较少，精度降低，从74.3单调递减至62.4。当我们在一层上堆叠多尺度的边界框时，很多边界框在图像边界上需要小心处理。我们尝试了在Faster R-CNN[2]中使用这个策略，忽略在边界上的边界框。我们观察到了一些有趣的趋势。例如，如果我们使用非常粗糙的特征映射（例如conv11_2（1×1）或conv10_2（3×3）），它会大大伤害性能。原因可能是修剪后我们没有足够大的边界框来覆盖大的目标。当我们主要使用更高分辨率的特征映射时，性能开始再次上升，因为即使在修剪之后仍然有足够数量的大边界框。如果我们只使用conv7进行预测，那么性能是最糟糕的，这就强化了在不同层上扩展不同尺度的边界框是非常关键的信息。此外，由于我们的预测不像[6]那样依赖于ROI池化，所以我们在低分辨率特征映射中没有折叠组块的问题[23]。SSD架构将来自各种分辨率的特征映射的预测结合起来，以达到与Faster R-CNN相当的精确度，同时使用较低分辨率的输入图像。</p>
<p><img src="http://img.blog.csdn.net/20171216231320942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 3"></p>
<p>表3：<strong>使用多个输出层的影响。</strong></p>
<h3 id="3-3-PASCAL-VOC2012"><a href="#3-3-PASCAL-VOC2012" class="headerlink" title="3.3 PASCAL VOC2012"></a>3.3 PASCAL VOC2012</h3><p>We use the same settings as those used for our basic VOC2007 experiments above, except that we use VOC2012 <code>trainval</code> and VOC2007 <code>trainval</code> and <code>test</code> (21503 images) for training, and test on VOC2012 <code>test</code> (10991 images). We train the models with $10^{−3}$ learning rate for 60k iterations, then $10^{−4}$ for 20k iterations. Table 4 shows the results of our SSD300 and SSD512 model. We see the same performance trend as we observed on VOC2007 <code>test</code>. Our SSD300 improves accuracy over Fast/Faster R-CNN. By increasing the training and testing image size to 512 × 512, we are $4.5\%$ more accurate than Faster R-CNN. Compared to YOLO, SSD is significantly more accurate, likely due to the use of convolutional default boxes from multiple feature maps and our matching strategy during training. When fine-tuned from models trained on COCO, our SSD512 achieves $80.0\%$ mAP, which is $4.1\%$ higher than Faster R-CNN.</p>
<p><img src="http://img.blog.csdn.net/20171216233141888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 4"></p>
<p>Table 4: <strong>PASCAL VOC2012 <code>test</code> detection results</strong>. Fast and Faster R-CNN use images with minimum dimension 600, while the image size for YOLO is 448 × 448. data: ”07++12”: union of VOC2007 <code>trainval</code> and <code>test</code> and VOC2012 <code>trainval</code>. ”07++12+COCO”: first train on COCO <code>trainval35k</code> then fine-tune on 07++12.</p>
<h3 id="3-3-PASCAL-VOC2012-1"><a href="#3-3-PASCAL-VOC2012-1" class="headerlink" title="3.3 PASCAL VOC2012"></a>3.3 PASCAL VOC2012</h3><p>除了我们使用VOC2012 <code>trainval</code>和VOC2007 <code>trainval</code>，<code>test</code>（21503张图像）进行训练，以及在VOC2012 <code>test</code>（10991张图像）上进行测试之外，我们使用与上述基本的VOC2007实验相同的设置。我们用$10^{−3}$的学习率对模型进行60k次的迭代训练，然后使用$10^{−4}$的学习率进行20k次迭代训练。表4显示了我们的SSD300和SSD512模型的结果。我们看到了与我们在VOC2007 <code>test</code>中观察到的相同的性能趋势。我们的SSD300比Fast/Faster R-CNN提高了准确性。通过将训练和测试图像大小增加到512×512，我们比Faster R-CNN的准确率提高了$4.5\%$。与YOLO相比，SSD更精确，可能是由于使用了来自多个特征映射的卷积默认边界框和我们在训练期间的匹配策略。当对从COCO上训练的模型进行微调后，我们的SSD512达到了$80.0\%$的mAP，比Faster R-CNN高了$4.1\%$。</p>
<p><img src="http://img.blog.csdn.net/20171216233141888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 4"></p>
<p>表4： <strong>PASCAL VOC2012 <code>test</code>上的检测结果</strong>. Fast和Faster R-CNN使用最小维度为600的图像，而YOLO的图像大小为448× 48。数据：“07++12”：VOC2007 <code>trainval</code>，<code>test</code>和VOC2012 <code>trainval</code>。“07++12+COCO”：先在COCO <code>trainval135k</code>上训练然后在07++12上微调。</p>
<h3 id="3-4-COCO"><a href="#3-4-COCO" class="headerlink" title="3.4 COCO"></a>3.4 COCO</h3><p>To further validate the SSD framework, we trained our SSD300 and SSD512 architectures on the COCO dataset. Since objects in COCO tend to be smaller than PASCAL VOC, we use smaller default boxes for all layers. We follow the strategy mentioned in Sec. 2.2, but now our smallest default box has a scale of 0.15 instead of 0.2, and the scale of the default box on conv4_3 is 0.07 (e.g. 21 pixels for a 300 × 300 image).</p>
<h3 id="3-4-COCO-1"><a href="#3-4-COCO-1" class="headerlink" title="3.4 COCO"></a>3.4 COCO</h3><p>为了进一步验证SSD框架，我们在COCO数据集上对SSD300和SSD512架构进行了训练。由于COCO中的目标往往比PASCAL VOC中的更小，因此我们对所有层使用较小的默认边界框。我们遵循2.2节中提到的策略，但是现在我们最小的默认边界框尺度是0.15而不是0.2，并且conv4_3上的默认边界框尺度是0.07（例如，300×300图像中的21个像素）。</p>
<p>We use the <code>trainval35k</code>[24] for training. We first train the model with $10^{−3}$ learning rate for 160k iterations, and then continue training for 40k iterations with $10^{−4}$ and 40k iterations with $10^{−5}$. Table 5 shows the results on <code>test-dev2015</code>. Similar to what we observed on the PASCAL VOC dataset, SSD300 is better than Fast R-CNN in both mAP@0.5 and mAP@[0.5:0.95]. SSD300 has a similar mAP@0.75 as ION [24] and Faster R-CNN [25], but is worse in mAP@0.5. By increasing the image size to 512 × 512, our SSD512 is better than Faster R-CNN [25] in both criteria. Interestingly, we observe that SSD512 is $5.3\%$ better in mAP@0.75, but is only $1.2\%$ better in mAP@0.5. We also observe that it has much better AP ($4.8\%$) and AR ($4.6\%$) for large objects, but has relatively less improvement in AP ($1.3\%$) and AR ($2.0\%$) for small objects. Compared to ION, the improvement in AR for large and small objects is more similar ($5.4\%$ vs. $3.9\%$). We conjecture that Faster R-CNN is more competitive on smaller objects with SSD because it performs two box refinement steps, in both the RPN part and in the Fast R-CNN part. In Fig. 5, we show some detection examples on COCO <code>test-dev</code> with the SSD512 model.</p>
<p><img src="http://img.blog.csdn.net/20171218133317075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 5"></p>
<p>Table 5: <strong>COCO <code>test-dev2015</code> detection results</strong>.</p>
<p><img src="http://img.blog.csdn.net/20171218134122094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 5"></p>
<p>Fig. 5: <strong>Detection examples on COCO <code>test-dev</code> with SSD512 model</strong>. We show detections with scores higher than 0.6. Each color corresponds to an object category.</p>
<p>我们使用<code>trainval35k</code>[24]进行训练。我们首先用$10^{−3}$的学习率对模型进行训练，进行160k次迭代，然后继续以$10^{−4}$和$10^{−5}$的学习率各进行40k次迭代。表5显示了<code>test-dev2015</code>的结果。与我们在PASCAL VOC数据集中观察到的结果类似，SSD300在mAP@0.5和mAP@[0.5:0.95]中都优于Fast R-CNN。SSD300与ION 24]和Faster R-CNN[25]具有相似的mAP@0.75，但是mAP@0.5更差。通过将图像尺寸增加到512×512，我们的SSD512在这两个标准中都优于Faster R-CNN[25]。有趣的是，我们观察到SSD512在mAP@0.75中要好$5.3\%$，但是在mAP@0.5中只好$1.2\%$。我们也观察到，对于大型目标，AP（$4.8\%$）和AR（$4.6\%$）的效果要好得多，但对于小目标，AP（$1.3\%$）和AR（$2.0\%$）有相对更少的改进。与ION相比，大型和小型目标的AR改进更为相似（$5.4\%$和$3.9\%$）。我们推测Faster R-CNN在较小的目标上比SSD更具竞争力，因为它在RPN部分和Fast R-CNN部分都执行了两个边界框细化步骤。在图5中，我们展示了SSD512模型在COCO <code>test-dev</code>上的一些检测实例。</p>
<p><img src="http://img.blog.csdn.net/20171218133317075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 5"></p>
<p>表5：<strong>COCO <code>test-dev2015</code>检测结果</strong>。</p>
<p><img src="http://img.blog.csdn.net/20171218134122094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 5"></p>
<p>图5：<strong>SSD512模型在COCO <code>test-dev</code>上的检测实例</strong>。我们展示了分数高于0.6的检测。每种颜色对应一种目标类别。</p>
<h3 id="3-5-Preliminary-ILSVRC-results"><a href="#3-5-Preliminary-ILSVRC-results" class="headerlink" title="3.5 Preliminary ILSVRC results"></a>3.5 Preliminary ILSVRC results</h3><p>We applied the same network architecture we used for COCO to the ILSVRC DET dataset [16]. We train a SSD300 model using the ILSVRC2014 DET <code>train</code> and <code>val1</code> as used in [22]. We first train the model with $10^{−3}$ learning rate for 320k iterations, and then continue training for 80k iterations with $10^{−4}$ and 40k iterations with $10^{−5}$. We can achieve 43.4 mAP on the <code>val2</code> set [22]. Again, it validates that SSD is a general framework for high quality real-time detection.</p>
<h3 id="3-5-初步的ILSVRC结果"><a href="#3-5-初步的ILSVRC结果" class="headerlink" title="3.5 初步的ILSVRC结果"></a>3.5 初步的ILSVRC结果</h3><p>我们将在COCO上应用的相同网络架构应用于ILSVRC DET数据集[16]。我们使用[22]中使用的ILSVRC2014 DET<code>train</code>和<code>val1</code>来训练SSD300模型。我们首先用$10^{−3}$的学习率对模型进行训练，进行了320k次的迭代，然后以$10^{−4}$继续迭代80k次，以$10^{−5}$迭代40k次。我们可以在<code>val2</code>数据集上[22]实现43.4 mAP。再一次证明了SSD是用于高质量实时检测的通用框架。</p>
<h3 id="3-6-Data-Augmentation-for-Small-Object-Accuracy"><a href="#3-6-Data-Augmentation-for-Small-Object-Accuracy" class="headerlink" title="3.6 Data Augmentation for Small Object Accuracy"></a>3.6 Data Augmentation for Small Object Accuracy</h3><p>Without a follow-up feature resampling step as in Faster R-CNN, the classification task for small objects is relatively hard for SSD, as demonstrated in our analysis (see Fig. 4). The data augmentation strategy described in Sec. 2.2 helps to improve the performance dramatically, especially on small datasets such as PASCAL VOC. The random crops generated by the strategy can be thought of as a “zoom in” operation and can generate many larger training examples. To implement a “zoom out” operation that creates more small training examples, we first randomly place an image on a canvas of 16× of the original image size filled with mean values before we do any random crop operation. Because we have more training images by introducing this new “expansion” data augmentation trick, we have to double the training iterations. We have seen a consistent increase of $2\%-3\%$ mAP across multiple datasets, as shown in Table 6. In specific, Figure 6 shows that the new augmentation trick significantly improves the performance on small objects. This result underscores the importance of the data augmentation strategy for the final model accuracy.</p>
<p><img src="http://img.blog.csdn.net/20171218145942048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 6"></p>
<p>Table 6: <strong>Results on multiple datasets when we add the image expansion data augmentation trick</strong>. $SSD300^{*}$ and $SSD512^{*}$ are the models that are trained with the new data augmentation.</p>
<p><img src="http://img.blog.csdn.net/20171218153833835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 6"></p>
<p>Fig.6: <strong>Sensitivity and impact of object size with new data augmentation on VOC2007 <code>test</code> set using [21]</strong>. The top row shows the effects of BBox Area per category for the original SSD300 and SSD512 model, and the bottom row corresponds to the $SSD300^{*}$ and $SSD512^{*}$ model trained with the new data augmentation trick. It is obvious that the new data augmentation trick helps detecting small objects significantly.</p>
<h3 id="3-6-为小目标准确率进行数据增强"><a href="#3-6-为小目标准确率进行数据增强" class="headerlink" title="3.6 为小目标准确率进行数据增强"></a>3.6 为小目标准确率进行数据增强</h3><p>SSD没有如Faster R-CNN中后续的特征重采样步骤，小目标的分类任务对SSD来说相对困难，正如我们的分析（见图4）所示。2.2描述的数据增强有助于显著提高性能，特别是在PASCAL VOC等小数据集上。策略产生的随机裁剪可以被认为是“放大”操作，并且可以产生许多更大的训练样本。为了实现创建更多小型训练样本的“缩小”操作，我们首先将图像随机放置在填充了平均值的原始图像大小为16x的画布上，然后再进行任意的随机裁剪操作。因为通过引入这个新的“扩展”数据增强技巧，我们有更多的训练图像，所以我们必须将训练迭代次数加倍。我们已经在多个数据集上看到了一致的$2\%-3\%$的mAP增长，如表6所示。具体来说，图6显示新的增强技巧显著提高了模型在小目标上的性能。这个结果强调了数据增强策略对最终模型精度的重要性。</p>
<p><img src="http://img.blog.csdn.net/20171218145942048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Table 6"></p>
<p>表6：<strong>我们使用图像扩展数据增强技巧在多个数据集上的结果。</strong>$SSD300^{*}$和$SSD512^{*}$是用新的数据增强训练的模型。</p>
<p><img src="http://img.blog.csdn.net/20171218153833835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 6"></p>
<p>图6：<strong>具有新的数据增强的目标尺寸在[21]中使用的VOC2007<code>test</code>数据集上灵敏度及影响</strong>。最上一行显示了原始SSD300和SSD512模型上每个类别的BBox面积的影响，最下面一行对应使用新的数据增强训练技巧的$SSD300^{*}$和$SSD512^{*}$模型。新的数据增强技巧显然有助于显著检测小目标。</p>
<p>An alternative way of improving SSD is to design a better tiling of default boxes so that its position and scale are better aligned with the receptive field of each position on a feature map. We leave this for future work.</p>
<p>改进SSD的另一种方法是设计一个更好的默认边界框平铺，使其位置和尺度与特征映射上每个位置的感受野更好地对齐。我们将这个留给未来工作。</p>
<h3 id="3-7-Inference-time"><a href="#3-7-Inference-time" class="headerlink" title="3.7 Inference time"></a>3.7 Inference time</h3><p>Considering the large number of boxes generated from our method, it is essential to perform non-maximum suppression (nms) efficiently during inference. By using a confidence threshold of 0.01, we can filter out most boxes. We then apply nms with jaccard overlap of 0.45 per class and keep the top 200 detections per image. This step costs about 1.7 msec per image for SSD300 and 20 VOC classes, which is close to the total time (2.4 msec) spent on all newly added layers. We measure the speed with batch size 8 using Titan X and cuDNN v4 with Intel Xeon E5-2667v3@3.20GHz.</p>
<h3 id="3-7-推断时间"><a href="#3-7-推断时间" class="headerlink" title="3.7 推断时间"></a>3.7 推断时间</h3><p>考虑到我们的方法产生大量边界框，在推断期间执行非最大值抑制（nms）是必要的。通过使用0.01的置信度阈值，我们可以过滤大部分边界框。然后，我们应用nms，每个类别0.45的Jaccard重叠，并保留每张图像的前200个检测。对于SSD300和20个VOC类别，这个步骤每张图像花费大约1.7毫秒，接近在所有新增层上花费的总时间（2.4毫秒）。我们使用Titan X、cuDNN v4、Intel Xeon E5-2667v3@3.20GHz以及批大小为8来测量速度。</p>
<p>Table 7 shows the comparison between SSD, Faster R-CNN[2], and YOLO[5]. Both our SSD300 and SSD512 method outperforms Faster R-CNN in both speed and accuracy. Although Fast YOLO[5] can run at 155 FPS, it has lower accuracy by almost $22\%$ mAP. To the best of our knowledge, SSD300 is the first real-time method to achieve above $70\%$ mAP. Note that about $80\%$ of the forward time is spent on the base network (VGG16 in our case). Therefore, using a faster base network could even further improve the speed, which can possibly make the SSD512 model real-time as well.</p>
<p><img src="http://img.blog.csdn.net/20171218160629039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 7"></p>
<p>Table 7: <strong>Results on Pascal VOC2007 <code>test</code></strong>. SSD300 is the only real-time detection method that can achieve above $70\%$ mAP. By using a larger input image, SSD512 outperforms all methods on accuracy while maintaining a close to real-time speed.</p>
<p>表7显示了SSD，Faster R-CNN[2]和YOLO[5]之间的比较。我们的SSD300和SSD512的速度和精度均优于Faster R-CNN。虽然Fast YOLO[5]可以以155FPS的速度运行，但其准确性却降低了近$22\%$的mAP。就我们所知，SSD300是第一个实现$70\%$以上mAP的实时方法。请注意，大约$80\%$前馈时间花费在基础网络上（本例中为VGG16）。因此，使用更快的基础网络可以进一步提高速度，这也可能使SSD512模型达到实时。</p>
<p><img src="http://img.blog.csdn.net/20171218160629039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbmN1bnRpYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 7"></p>
<p>表7：<strong>Pascal VOC2007 <code>test</code>上的结果</strong>。SSD300是唯一可以取得$70\%$以上mAP的实现检测方法。通过使用更大的输入图像，SSD512在精度上超过了所有方法同时保持近似实时的速度。</p>
<h2 id="4-Related-Work"><a href="#4-Related-Work" class="headerlink" title="4. Related Work"></a>4. Related Work</h2><p>There are two established classes of methods for object detection in images, one based on sliding windows and the other based on region proposal classification. Before the advent of convolutional neural networks, the state of the art for those two approaches —— Deformable Part Model (DPM) [26] and Selective Search [1] —— had comparable performance. However, after the dramatic improvement brought on by R-CNN [22], which combines selective search region proposals and convolutional network based post-classification, region proposal object detection methods became prevalent.</p>
<h2 id="4-相关工作"><a href="#4-相关工作" class="headerlink" title="4. 相关工作"></a>4. 相关工作</h2><p>在图像中有两种建立的用于目标检测的方法，一种基于滑动窗口，另一种基于区域提出分类。在卷积神经网络出现之前，这两种方法的最新技术——可变形部件模型（DPM）[26]和选择性搜索[1]——具有相当的性能。然而，在R-CNN[22]结合选择性搜索区域提出和基于后分类的卷积网络带来的显著改进后，区域提出目标检测方法变得流行。</p>
<p>The original R-CNN approach has been improved in a variety of ways. The first set of approaches improve the quality and speed of post-classification, since it requires the classification of thousands of image crops, which is expensive and time-consuming. SPPnet [9] speeds up the original R-CNN approach significantly. It introduces a spatial pyramid pooling layer that is more robust to region size and scale and allows the classification layers to reuse features computed over feature maps generated at several image resolutions. Fast R-CNN [6] extends SPPnet so that it can fine-tune all layers end-to-end by minimizing a loss for both confidences and bounding box regression, which was first introduced in MultiBox [7] for learning objectness.</p>
<p>最初的R-CNN方法已经以各种方式进行了改进。第一套方法提高了后分类的质量和速度，因为它需要对成千上万的裁剪图像进行分类，这是昂贵和耗时的。SPPnet[9]显著加快了原有的R-CNN方法。它引入了一个空间金字塔池化层，该层对区域大小和尺度更鲁棒，并允许分类层重用多个图像分辨率下生成的特征映射上计算的特征。Fast R-CNN[6]扩展了SPPnet，使得它可以通过最小化置信度和边界框回归的损失来对所有层进行端到端的微调，最初在MultiBox[7]中引入用于学习目标。</p>
<p>The second set of approaches improve the quality of proposal generation using deep neural networks. In the most recent works like MultiBox [7,8], the Selective Search region proposals, which are based on low-level image features, are replaced by proposals generated directly from a separate deep neural network. This further improves the detection accuracy but results in a somewhat complex setup, requiring the training of two neural networks with a dependency between them. Faster R-CNN [2] replaces selective search proposals by ones learned from a region proposal network (RPN), and introduces a method to integrate the RPN with Fast R-CNN by alternating between fine-tuning shared convolutional layers and prediction layers for these two networks. This way region proposals are used to pool mid-level features and the final classification step is less expensive. Our SSD is very similar to the region proposal network (RPN) in Faster R-CNN in that we also use a fixed set of (default) boxes for prediction, similar to the anchor boxes in the RPN. But instead of using these to pool features and evaluate another classifier, we simultaneously produce a score for each object category in each box. Thus, our approach avoids the complication of merging RPN with Fast R-CNN and is easier to train, faster, and straightforward to integrate in other tasks.</p>
<p>第二套方法使用深度神经网络提高了提出生成的质量。在最近的工作MultiBox[7,8]中，基于低级图像特征的选择性搜索区域提出直接被单独的深度神经网络生成的提出所取代。这进一步提高了检测精度，但是导致了一些复杂的设置，需要训练两个具有依赖关系的神经网络。Faster R-CNN[2]将选择性搜索提出替换为区域提出网络（RPN）学习到的区域提出，并引入了一种方法，通过交替两个网络之间的微调共享卷积层和预测层将RPN和Fast R-CNN结合在一起。通过这种方式，使用区域提出池化中级特征，并且最后的分类步骤比较便宜。我们的SSD与Faster R-CNN中的区域提出网络（RPN）非常相似，因为我们也使用一组固定的（默认）边界框进行预测，类似于RPN中的锚边界框。但是，我们不是使用这些来池化特征并评估另一个分类器，而是为每个目标类别在每个边界框中同时生成一个分数。因此，我们的方法避免了将RPN与Fast R-CNN合并的复杂性，并且更容易训练，更快且更直接地集成到其它任务中。</p>
<p>Another set of methods, which are directly related to our approach, skip the proposal step altogether and predict bounding boxes and confidences for multiple categories directly. OverFeat [4], a deep version of the sliding window method, predicts a bounding box directly from each location of the topmost feature map after knowing the confidences of the underlying object categories. YOLO [5] uses the whole topmost feature map to predict both confidences for multiple categories and bounding boxes (which are shared for these categories). Our SSD method falls in this category because we do not have the proposal step but use the default boxes. However, our approach is more flexible than the existing methods because we can use default boxes of different aspect ratios on each feature location from multiple feature maps at different scales. If we only use one default box per location from the topmost feature map, our SSD would have similar architecture to OverFeat [4]; if we use the whole topmost feature map and add a fully connected layer for predictions instead of our convolutional predictors, and do not explicitly consider multiple aspect ratios, we can approximately reproduce YOLO [5].</p>
<p>与我们的方法直接相关的另一组方法，完全跳过提出步骤，直接预测多个类别的边界框和置信度。OverFeat[4]是滑动窗口方法的深度版本，在知道了底层目标类别的置信度之后，直接从最顶层的特征映射的每个位置预测边界框。YOLO[5]使用整个最顶层的特征映射来预测多个类别和边界框（这些类别共享）的置信度。我们的SSD方法属于这一类，因为我们没有提出步骤，但使用默认边界框。然而，我们的方法比现有方法更灵活，因为我们可以在不同尺度的多个特征映射的每个特征位置上使用不同长宽比的默认边界框。如果我们只从最顶层的特征映射的每个位置使用一个默认框，我们的SSD将具有与OverFeat[4]相似的架构；如果我们使用整个最顶层的特征映射，并添加一个全连接层进行预测来代替我们的卷积预测器，并且没有明确地考虑多个长宽比，我们可以近似地再现YOLO[5]。</p>
<h2 id="5-Conclusions"><a href="#5-Conclusions" class="headerlink" title="5. Conclusions"></a>5. Conclusions</h2><p>This paper introduces SSD, a fast single-shot object detector for multiple categories. A key feature of our model is the use of multi-scale convolutional bounding box outputs attached to multiple feature maps at the top of the network. This representation allows us to efficiently model the space of possible box shapes. We experimentally validate that given appropriate training strategies, a larger number of carefully chosen default bounding boxes results in improved performance. We build SSD models with at least an order of magnitude more box predictions sampling location, scale, and aspect ratio, than existing methods [5,7]. We demonstrate that given the same VGG-16 base architecture, SSD compares favorably to its state-of-the-art object detector counterparts in terms of both accuracy and speed. Our SSD512 model significantly outperforms the state-of-the-art Faster R-CNN [2] in terms of accuracy on PASCAL VOC and COCO, while being 3× faster. Our real time SSD300 model runs at 59 FPS, which is faster than the current real time YOLO [5] alternative, while producing markedly superior detection accuracy.</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>本文介绍了SSD，一种快速的单次多类别目标检测器。我们模型的一个关键特性是使用网络顶部多个特征映射的多尺度卷积边界框输出。这种表示使我们能够高效地建模可能的边界框形状空间。我们通过实验验证，在给定合适训练策略的情况下，大量仔细选择的默认边界框会提高性能。我们构建的SSD模型比现有的方法至少要多一个数量级的边界框预测采样位置，尺度和长宽比[5,7]。我们证明了给定相同的VGG-16基础架构，SSD在准确性和速度方面与其对应的最先进的目标检测器相比毫不逊色。在PASCAL VOC和COCO上，我们的SSD512模型的性能明显优于最先进的Faster R-CNN[2]，而速度提高了3倍。我们的实时SSD300模型运行速度为59FPS，比目前的实时YOLO[5]更快，同时显著提高了检测精度。</p>
<p>Apart from its standalone utility, we believe that our monolithic and relatively simple SSD model provides a useful building block for larger systems that employ an object detection component. A promising future direction is to explore its use as part of a system using recurrent neural networks to detect and track objects in video simultaneously.</p>
<p>除了单独使用之外，我们相信我们的整体和相对简单的SSD模型为采用目标检测组件的大型系统提供了有用的构建模块。一个有前景的未来方向是探索它作为系统的一部分，使用循环神经网络来同时检测和跟踪视频中的目标。</p>
<h2 id="6-Acknowledgment"><a href="#6-Acknowledgment" class="headerlink" title="6. Acknowledgment"></a>6. Acknowledgment</h2><p>This work was started as an internship project at Google and continued at UNC. We would like to thank Alex Toshev for helpful discussions and are indebted to the Image Understanding and DistBelief teams at Google. We also thank Philip Ammirato and Patrick Poirson for helpful comments. We thank NVIDIA for providing GPUs and acknowledge support from NSF 1452851, 1446631, 1526367, 1533771.</p>
<h2 id="6-致谢"><a href="#6-致谢" class="headerlink" title="6. 致谢"></a>6. 致谢</h2><p>这项工作是在谷歌的一个实习项目开始的，并在UNC继续。我们要感谢Alex Toshev进行有益的讨论，并感谢Google的Image Understanding和DistBelief团队。我们也感谢Philip Ammirato和Patrick Poirson提供有用的意见。我们感谢NVIDIA提供的GPU，并对NSF 1452851,1446631,1526367,1533771的支持表示感谢。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p>Uijlings, J.R., van de Sande, K.E., Gevers, T., Smeulders, A.W.: Selective search for object recognition. IJCV (2013)</p>
</li>
<li><p>Ren, S., He, K., Girshick, R., Sun, J.: Faster R-CNN: Towards real-time object detection with region proposal networks. In: NIPS. (2015)</p>
</li>
<li><p>He, K., Zhang, X., Ren, S., Sun, J.:Deep residual learning for image recognition. In:CVPR. (2016)</p>
</li>
<li><p>Sermanet, P., Eigen, D., Zhang, X., Mathieu, M., Fergus, R., LeCun, Y.: Overfeat:Integrated recognition, localization and detection using convolutional networks. In: ICLR. (2014)</p>
</li>
<li><p>Redmon, J., Divvala, S., Girshick, R., Farhadi, A.: You only look once: Unified, real-time object detection. In: CVPR. (2016)</p>
</li>
<li><p>Girshick, R.: Fast R-CNN. In: ICCV. (2015)</p>
</li>
<li><p>Erhan, D., Szegedy, C., Toshev, A., Anguelov, D.: Scalable object detection using deep neural networks. In: CVPR. (2014)</p>
</li>
<li><p>Szegedy, C., Reed, S., Erhan, D., Anguelov, D.: Scalable, high-quality object detection. arXiv preprint arXiv:1412.1441 v3 (2015)</p>
</li>
<li><p>He, K., Zhang, X., Ren, S., Sun, J.: Spatial pyramid pooling in deep convolutional networks for visual recognition. In: ECCV. (2014)</p>
</li>
<li><p>Long, J., Shelhamer, E., Darrell, T.: Fully convolutional networks for semantic segmentation. In: CVPR. (2015)</p>
</li>
<li><p>Hariharan, B., Arbeláez, P., Girshick, R., Malik, J.: Hypercolumns for object segmentation and fine-grained localization. In: CVPR. (2015)</p>
</li>
<li><p>Liu, W., Rabinovich, A., Berg, A.C.: ParseNet: Looking wider to see better.In:ILCR.(2016)</p>
</li>
<li><p>Zhou, B., Khosla, A., Lapedriza, A., Oliva, A., Torralba, A.: Object detector semerge in deep scene cnns. In: ICLR. (2015)</p>
</li>
<li><p>Howard, A.G.: Some improvements on deep convolutional neural network based image classification. arXiv preprint arXiv:1312.5402 (2013)</p>
</li>
<li><p>Simonyan, K., Zisserman, A.: Very deep convolutional networks for large-scale image recognition. In: NIPS. (2015)</p>
</li>
<li><p>Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla, A., Bernstein, M., Berg, A.C., Fei-Fei, L.: Imagenet large scale visual recognition challenge. IJCV (2015)</p>
</li>
<li><p>Chen, L.C., Papandreou, G., Kokkinos, I., Murphy, K., Yuille, A.L.: Semantic image segmentation with deep convolutional nets and fully connected crfs. In: ICLR. (2015)</p>
</li>
<li><p>Holschneider, M., Kronland-Martinet, R., Morlet, J., Tchamitchian, P.: Areal-time algorithm for signal analysis with the help of the wavelet transform. In: Wavelets. Springer (1990) 286–297</p>
</li>
<li><p>Jia, Y., Shelhamer, E., Donahue, J., Karayev, S., Long, J., Girshick, R., Guadarrama, S., Darrell, T.: Caffe: Convolutional architecture for fast feature embedding. In: MM. (2014)</p>
</li>
<li><p>Glorot, X., Bengio, Y.: Understanding the difficulty of training deep feedforward neural networks. In: AISTATS. (2010)</p>
</li>
<li><p>Hoiem, D., Chodpathumwan, Y., Dai, Q.: Diagnosing error in object detectors. In: ECCV 2012. (2012)</p>
</li>
<li><p>Girshick, R., Donahue, J., Darrell, T., Malik, J.: Rich feature hierarchies for accurate object detection and semantic segmentation. In: CVPR. (2014)</p>
</li>
<li><p>Zhang, L., Lin, L., Liang, X., He, K.: Is faster r-cnn doing well for pedestrian detection. In: ECCV. (2016)</p>
</li>
<li><p>Bell, S., Zitnick, C.L., Bala, K., Girshick, R.: Inside-outside net:Detecting objects in context with skip pooling and recurrent neural networks. In: CVPR. (2016)</p>
</li>
<li><p>COCO: Common Objects in Context. <a href="http://mscoco.org/dataset/#detections-leaderboard" target="_blank" rel="external">http://mscoco.org/dataset/#detections-leaderboard</a> (2016) [Online; accessed 25-July-2016].</p>
</li>
<li><p>Felzenszwalb, P., McAllester, D., Ramanan, D.: A discriminatively trained, multiscale, deformable part model. In: CVPR. (2008)</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      Single Shot MultiBox Detector论文翻译——中英文对照
    
    </summary>
    
      <category term="深度学习" scheme="noahsnail.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="noahsnail.com/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
