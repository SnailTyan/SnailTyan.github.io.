<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailTyan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://noahsnail.com/"/>
  <updated>2022-07-04T05:28:19.768Z</updated>
  <id>http://noahsnail.com/</id>
  
  <author>
    <name>Tyan</name>
    <email>Tyan.Liu.Git@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于机器学习方法的POI品类推荐算法-笔记</title>
    <link href="http://noahsnail.com/2022/07/04/2022-07-04-%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84POI%E5%93%81%E7%B1%BB%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <id>http://noahsnail.com/2022/07/04/2022-07-04-基于机器学习方法的POI品类推荐算法/</id>
    <published>2022-07-04T03:06:38.733Z</published>
    <updated>2022-07-04T05:28:19.768Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在美团商家数据中心（MDC），有超过100w的已校准审核的POI数据（一般将商家标示为POI，POI基础信息包括：门店名称、品类、电话、地址、坐标等）。如何使用这些已校准的POI数据，挖掘出有价值的信息，本文进行了一些尝试：利用机器学习方法，自动标注缺失品类的POI数据。例如，门店名称为“好再来牛肉拉面馆”的POI将自动标注“小吃”品类。</p>
<p>Note：将商家标示为POI，POI基础信息包括：门店名称、品类、电话、地址、坐标等。</p>
<p>机器学习解决问题的一般过程：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-56b13f2f.png" alt="机器学习模型"></p>
<p>本文将按照：1）特征表示；2）特征选择；3）基于Naive Bayes分类模型；4）分类预测，四个部分顺序展开。</p>
<h2 id="2-特征表示"><a href="#2-特征表示" class="headerlink" title="2. 特征表示"></a>2. 特征表示</h2><p>需要先将实际问题转换成计算机可识别的形式。对于POI而言，反应出POI品类的一个重要特征是POI门店名称，那么问题转换成了根据POI门店名称判别POI品类。POI名称字段属于文本特征，传统的文本表示方法是基于向量空间模型(VSM模型)：</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2014/12/18/poi-category-recommendation-algorithm-based-on-machine-learning.html" target="_blank" rel="external">基于机器学习方法的POI品类推荐算法</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      基于机器学习方法的POI品类推荐算法-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>Managing Supply and Demand Balance Through Machine Learning-笔记</title>
    <link href="http://noahsnail.com/2022/06/17/2022-06-17-Managing%20Supply%20and%20Demand%20Balance%20Through%20Machine-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/17/2022-06-17-Managing Supply and Demand Balance Through Machine-笔记/</id>
    <published>2022-06-17T03:20:38.892Z</published>
    <updated>2022-07-04T02:51:58.222Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为DoorDash文章学习的笔记整理。</p>
<h1 id="Managing-Supply-and-Demand-Balance-Through-Machine-Learning"><a href="#Managing-Supply-and-Demand-Balance-Through-Machine-Learning" class="headerlink" title="Managing Supply and Demand Balance Through Machine Learning"></a>Managing Supply and Demand Balance Through Machine Learning</h1><p>At DoorDash, we want our service to be a daily convenience offering timely deliveries and consistent pricing. Achieving these objectives requires a good balance between the supply of Dashers (our term for delivery drivers) and the demand for orders.</p>
<p>DoorDash希望服务能够提供及时交付和一致的定价。实现这些目标需要在Dashers（配送员）供应和订单需求之间取得良好的平衡。</p>
<p>During periods of high demand we generally increase pay, providing an incentive to ensure enough Dashers are available for consumers to receive their orders as quickly as possible. We do not pass through this increased pay to consumers, who will pay the same fees no matter the time of day. </p>
<p>在需求旺盛的时期，通常会增加配送费以确保有足够的Dasher可供消费者尽快收到他们的订单。DoorDash不会将这种增加的报酬转嫁给消费者，无论何时，消费者都会支付相同的费用。</p>
<p>Note:<br>DoorDash在需求旺盛时会提高配送费用，且这种成本没有转嫁给消费者，这意味着配送成本变高，但有更好的用户体验。</p>
<p>Given the complexity of offering Dashers peak demand pay, we built a new mobilization system that allocates incentives ahead of any anticipated supply and demand imbalance. When building this system, we focused on the following things:</p>
<ul>
<li>Defining our supply and demand measurement metrics and project objectives clearly</li>
<li>Generating high-fidelity forecasts for supply and demand</li>
<li>Setting up a new optimization process for incentive allocation under constraints</li>
<li>Managing uncertainty </li>
<li>Improving reliability and maintainability of the system</li>
</ul>
<p>考虑到给予Dashers高峰需求配送费的复杂性，DoorDash建立了一个新的调度系统，在任何预期的供需失衡之前分配奖励。在构建这个系统时，专注于以下几点：</p>
<ul>
<li>明确定义供需度量指标和项目目标</li>
<li>生成高置信度的供需预测</li>
<li>建立约束下激励分配的新优化流程</li>
<li>管理不确定性</li>
<li>提高系统的可靠性和可维护性</li>
</ul>
<h2 id="How-do-we-quantify-supply-and-demand-imbalance"><a href="#How-do-we-quantify-supply-and-demand-imbalance" class="headerlink" title="How do we quantify supply and demand imbalance?"></a>How do we quantify supply and demand imbalance?</h2><p>When outlining the problem of supply and demand imbalance, it is useful to adopt the context of all the affected parties:</p>
<ul>
<li>For consumers, a lack of Dasher availability during peak demand is more likely to lead to order lateness, longer delivery times, or inability to request a delivery and having to opt for pick up. </li>
<li>For Dashers, a lack of orders leads to lower earnings and longer and more frequent shifts in order to hit personal goals.</li>
<li>For merchants, an undersupply of Dashers leads to delayed deliveries, which typically results in cold food and a decreased reorder rate.</li>
</ul>
<p>在概述供需失衡问题时，采用所有受影响方的背景是有用的：</p>
<ul>
<li>对于消费者而言，在需求高峰期间，缺少可用Dasher更有可能导致订单延迟、更长的交付时间、或者无法请求配送并不得不选择(自己)取货。</li>
<li>对于Dasher来说，订单不足会导致收入降低，并且为了实现个人目标而需要更长、更频繁的移动。</li>
<li>对于商家来说，Dasher供应不足会导致延迟交付，这通常会导致食物变凉和复购率下降。</li>
</ul>
<p>With this context, it becomes clear that the ideal scenario would be to have a system that balances supply and demand at a delivery level instead of market level, but this is not realistic when choosing market-measurement metrics. Balancing at the delivery level means every order has a Dasher available at the most optimal time and every Dasher hits their pay-per hour target.</p>
<p>在这种情况下，很明显，理想情况是有一个可以在配送层面而不是市场层面来平衡供需的系统，但这在选择市场度量指标时是不现实的。配送层面的平衡意味着每个订单在最佳时间都有一个可用的Dasher，并且每个Dasher都达到了他们的时薪目标。</p>
<p>In contrast, market-level balance means there are relatively equal numbers of Dashers and orders in a market but there are not necessarily optimal conditions for each of these groups at the delivery level. In practice, the variance level for supply and demand driven by Dasher and consumer preferences and other changing conditions in the environment, such as traffic and weather, make it difficult to balance supply and demand at the delivery level. Hence, we focused on market-level metrics to define the state of each market, even though a delivery-level metric would have provided a more ideal outcome. </p>
<p>相比之下，市场层面的平衡意味着市场中Dasher和订单的数量相对相等，但在交付层面上，这些组中的每一个都不一定存在最佳条件。在实践中，供需差异水平受Dasher和消费者偏好，以及环境中的其他变化条件（如交通和天气）驱动，使得很难在交付层面来平衡供需。因此，DoorDash专注于市场层面的指标来定义每个市场的状态，即使交付层面的指标会提供更理想的结果。</p>
<p>Note:<br>从市场层面来度量供需，即Dashe数量和订单数量。</p>
<p>For our primary supply and demand measurement metric, we looked at the number of hours required to make deliveries while keeping delivery durations low and Dasher busyness high. By focusing on hours, we can account for regional variation driven by traffic conditions, batching rates, and food preparation times. </p>
<p>对于主要的供需度量指标，DoorDash查看了在保持交付持续时间短和Dasher繁忙程度高的情况下，交付所需的小时数。通过关注小时数，可以解释由交通状况、批配送率(多单同时进行)和食物准备时间引起的区域变化。</p>
<p>To understand how this metric would work in practice let’s consider an example. Let’s imagine that it is Sunday at dinner time in New York City, and we estimate that 1,000 Dasher hours are needed to fulfill the expected demand. We might also estimate that unless we provide extra incentives, only 800 hours will likely be provided by Dashers organically. Without mobilization actions we would be undersupplied by about 200 hours.</p>
<p>为了理解这个指标在实际中是如何工作的，考虑一个例子。假设现在是纽约市周日的晚餐时间，估计需要1000 Dasher小时才能满足预期需求。还可以估计，除非提供额外的激励措施，否则Dasher可能只会有组织地提供800小时。如果没有调动行为，将缺乏约200小时。</p>
<p>We generally compute this metric where Dashers sign up to Dash and to time units that can span from hourly durations to daypart units like lunch and dinner. It is very important to not select an aggregation level that can lead to artificial demand and supply smoothing. For example, within a day we might be oversupplied at breakfast and undersupplied at dinner. Optimizing for a full day would lead to smoothing any imbalance and generate incorrect mobilization actions.</p>
<p>通常在Dasher注册Dash时计算这个指标，时间单元可以从按小时的持续时间到午餐和晚餐等时段单元。不要选择可能导致人为需求和供应平滑的聚合级别，这一点非常重要。 例如，在一天之内，可能在早餐时供应过剩，而在晚餐时供应不足。优化一整天会导致平滑任何不平衡并产生不正确的调动行为。</p>
<p>Note:<br>优化特定的时间段，按小时和时间段都可以，但不能优化一整天。</p>
<p>Once we decide on the health metric and the unit at which we take actions, we proceed with balancing supply and demand through adjustments to supply. Our team generally adjusts the supply side of the market by offering incentives to increase Dasher mobilization when there is more demand. Through incentives, we provide Dashers a guarantee that they will earn a fixed amount of money on any delivery they accept in a specific region-time unit. We will describe in the following section how forecasting and optimization plays a role in that.</p>
<p>一旦确定了运行指标和采取行动的时间单元，就会通过调整供应来平衡供需。当需求更多时，通常通过提供激励措施来调整市场的供给端，以增加Dasher的调动。通过激励措施，向Dasher保证，他们将在特定区域时间单元内在任何交付中赚取固定金额的钱。将在下一节中描述预测和优化如何在其中发挥作用。</p>
<h2 id="How-do-we-forecast-supply-and-demand-at-a-localized-level"><a href="#How-do-we-forecast-supply-and-demand-at-a-localized-level" class="headerlink" title="How do we forecast supply and demand at a localized level?"></a>How do we forecast supply and demand at a localized level?</h2><p>Now that we have a metric to measure supply and demand levels, a unit of region/time to take actions, and actions we take to manage supply, we can determine our forecasting requirement details and how we forecast each market’s supply and demand conditions.</p>
<p>现在有了度量供需水平的指标、采取行动的地区/时间单元以及为管理供给而采取的行动，可以确定预测需求细节以及如何预测每个市场的供需状况。</p>
<h3 id="Defining-forecasting-requirements"><a href="#Defining-forecasting-requirements" class="headerlink" title="Defining forecasting requirements"></a>Defining forecasting requirements</h3><p>Given that the forecasts we generate are meant to be used in an automated system, both the algorithm we use for forecasting and the subsequent library ecosystem we would rely on can have a large impact on maintaining automation in the long run. We primarily reformulated the forecasting problem into a regression problem and used gradient boosting through the Microsoft-developed open source LightGBM framework. There are a couple of reasons behind this choice.</p>
<p>由于生成的预测要用于自动化系统中，从长远来看，用于预测的算法和将依赖的后续库生态系统都可能对自动化系统的维护有很大影响。DoorDash主要将预测问题重新表述为回归问题，并通过微软开发的开源LightGBM框架使用梯度提升。这种选择背后有几个原因。</p>
<h4 id="Support-for-multivariate-forecasting"><a href="#Support-for-multivariate-forecasting" class="headerlink" title="Support for multivariate forecasting"></a>Support for multivariate forecasting</h4><p>Many univariate forecasting approaches do not scale well when it comes to generating thousands of regional forecasts with low-level granularity. Our experience strongly supports the thesis that some of the best models are created through a process of rapid prototyping, so we looked for approaches where going from hypothesizing a model improvement to having the final result can be done quickly. LightGBM can be used to train and generate thousands of regional forecasts within a single training run, allowing us to very quickly iterate on model development. </p>
<p>在碰到生成数千个低粒度区域预测时，许多单变量预测方法无法很好地扩展。一些最佳模型是通过快速原型制作过程创建的，DoorDash的经验强烈支持这个论点，因此寻找可以快速完成从假设模型改进到获得最终结果的方法。LightGBM可用于在一次训练运行中训练和生成数千个区域预测，使开发人员能够非常快速地迭代模型开发。</p>
<h4 id="Support-for-extrapolation"><a href="#Support-for-extrapolation" class="headerlink" title="Support for extrapolation"></a>Support for extrapolation</h4><p>As DoorDash expands both nationally and internationally, we need our forecasting system to be able to generate some expectations for how our supply and demand growth would look in places where we don’t currently offer our services. For example, if we launch in a new city, we can still make reasonable projections regarding the supply and demand trajectory even with no historical data. Deep learning and traditional machine learning (ML)-based approaches work particularly well in this case, since latent information that helps with extrapolation can either be learned through embedding vectors or through good feature engineering. Information about population size, general traffic conditions, number of available merchants, climate, and geography can all be used to inform extrapolation.</p>
<p>随着DoorDash在国内和国际上的扩张，DoorDash需要预测系统能够对目前不提供服务的地方的供需增长情况生成一些预期。例如，如果在一个新城市启动服务，即使没有历史数据，DoorDash仍然可以对供需发展轨迹做出合理的预测。在这种情况下，深度学习和基于传统机器学习(ML)的方法效果特别好，因为有助于推断的潜在信息可以通过嵌入向量或良好的特征工程来学习。有关人口规模、一般交通状况、可用商户数量、气候和地理的信息都可用于推断。</p>
<h4 id="Support-for-counterfactuals"><a href="#Support-for-counterfactuals" class="headerlink" title="Support for counterfactuals"></a>Support for counterfactuals</h4><p>Forecasts are used to set an expectation of what will happen but they are also inevitably used to guide the decision-making process. For example, our stakeholders would ask us how conditions would change if we changed incentive levels in our supply forecast model so that we can understand how to make tradeoffs between supply and costs. These types of counterfactuals are very helpful not only in forecasting what we think will happen, but in also estimating the impact of actions we are going to take. In LightGBM, approximate counterfactuals can be generated by changing the inputs that go into the model at inference time.</p>
<p>预测用于设定对将要发生什么的预期，但它们也不可避免地用于指导决策过程。例如，股东会问如果改变供应预测模型中的激励水平，情况会如何变化，以便了解如何在供应和成本之间进行权衡。这些类型的反事实不仅在预测会发生什么方面非常有帮助，而且在评估要采取的行动的影响方面也非常有帮助。在LightGBM中，可以通过在推断时更改进入模型的输入来生成近似反事实。</p>
<h4 id="Small-dependency-footprint"><a href="#Small-dependency-footprint" class="headerlink" title="Small dependency footprint"></a>Small dependency footprint</h4><p>We wanted the forecasting system to have a minimal dependency footprint, meaning that we were not overly reliant on a host of third-party libraries. This requirement immediately removed a lot of the auto-forecasting approaches, where installing one library often meant installing 100-plus additional libraries, or approaches that provided unified toolkits and had a large number of transitive dependencies. A bloated footprint creates compatibility issues, upgrade challenges, and a large exposure area to security vulnerabilities. LightGBM has a very small dependency footprint, and it is relatively painless to perform upgrades. </p>
<p>DoorDash希望预测系统具有极少的依赖资源，这意味着不会过度依赖大量第三方库。这一要求立刻移除了许多自动预测方法，安装一个库经常意味着安装 100多个额外的库，或者提供统一工具包并具有大量传递依赖项的方法。庞大的资源占用会导致兼容性问题、升级挑战以及安全漏洞的大面积暴露。LightGBM的依赖资源非常少，执行升级也相对轻松。</p>
<h4 id="Thriving-community"><a href="#Thriving-community" class="headerlink" title="Thriving community"></a>Thriving community</h4><p>Lastly, we wanted to rely on an ecosystem with a thriving community and a strong core maintainer group. Maintaining an open source library is challenging. A library might be created by a graduate student or one to three core developers working within a company. Nonetheless, folks find new interests, new jobs, switch jobs, find new careers, or abandon careers. Keeping track of issues and bugs related to a library is often not a priority a few years or months down the line. This eventual lack of support then forces users to create internal forks in order to adopt the forecast tooling for their use cases or engage in a complete remodelling exercise. For these reasons, when selecting a tool, we looked at metrics like release cycles, number of stars, and community involvement to ensure there would be good community maintenance into the future. </p>
<p>最后，DoorDash希望依靠一个拥有蓬勃发展的社区和强大的核心维护组的生态系统。维护一个开源库是一项挑战。一个库可能由研究生或公司内的一到三个核心开发人员创建。尽管如此，人们还是会找到新的兴趣、新的工作、换工作、寻找新的职业或放弃职业。跟踪与库相关的问题和错误通常不是几年或几个月后的优先事项。 这种最终缺乏支持会迫使用户创建内部分支，以便为其用例采用预测工具或进行完整的重构练习。出于这些原因，在选择工具时，DoorDash会查看发布周期、Star数和社区参与度等指标，以确保未来有良好的社区维护。</p>
<h3 id="Forecasting-with-ML"><a href="#Forecasting-with-ML" class="headerlink" title="Forecasting with ML"></a>Forecasting with ML</h3><p>Forecasting in the context of a pure regression problem can have it’s challenges, one of which has to do with understanding the data generation process and the causality between the inputs and outputs. For example, Figure 1, below, shows how our incentives relate to the growth in the number of Dasher hours.</p>
<p>在纯回归问题的背景下进行预测可能会遇到挑战，挑战之一与理解数据生成过程以及输入和输出之间的因果关系有关。例如，下面的图1显示了激励措施如何与Dasher工作小时数的增长相关联。</p>
<p><img src="http://noahsnail.com/images/doordash/doordash_incentive.png" alt="Incentive"></p>
<p>Figure 1: This data suggests that there is a non-linear relationship between incentives and mobilization, with higher incentives seeing an increase in Dasher hours and very high incentives related to a dramatic drop in hours. This counterintuitive relationship can often be a sign of either an omitted variable bias or simultaneous causality bias.</p>
<p>图 1：该数据表明，激励和Dasher调动之间存在非线性关系，较高的激励会导致Dasher工作小时数增加，非常高的激励会导致工作小时数急剧下降。 这种违反直觉的关系通常可能是遗漏变量偏差或同时存在因果关系偏差的标志。</p>
<p>If we blindly rely on the model to learn causality through correlations found in the data, we would’ve created a system that would mistakenly assume that providing very high incentive levels would lead to fewer Dashers on the road. A causal interpretation, where high growth incentives would lead to a decrease in mobilization would be nonsensical.</p>
<p>如果盲目地依赖模型通过数据中的相关性来学习因果关系，就会创建一个系统，错误地认为提供非常高的激励水平会导致路上的Dasher数量更少。 高增长激励会导致调动减少的因果解释是荒谬的。</p>
<p>It is more likely that the model is simply missing a confounding variable. For example, in periods associated with bad weather or holidays, Dashers want to spend time inside or with their families. We are more likely to see a decrease in availability during these times, triggering our supply and demand systems to offer higher incentives to keep the market balanced.</p>
<p>这个模型更有可能只是缺少一个混合变量。例如，在涉及恶劣天气或假期的时候，Dasher希望呆在家里或与家人共度时光。在这些时间，更有可能看到可用Dasher数量下降，触发供需系统提供更高的激励措施以保持市场平衡。</p>
<p>A model lacking knowledge of weather or holidays might learn that high incentives lead to fewer Dasher hours, when the causal relationship is simply missing a covariate link. This example illustrates why it becomes important to figure out a way to sometimes constrain relationships found in the data through domain knowledge, or to rely on experimental results to regularize some correlational relationships identified by the model and not blindly apply the algorithm to the available data.</p>
<p>缺乏天气或假期知识的模型可能会学习到高激励会导致更少的Dasher小时数，而因果关系只是缺少协变量链接。这个例子说明了为什么有时通过领域知识找出一种方法来约束数据中发现的关系，或者依靠实验结果来规范模型识别的一些相关关系而不是盲目地将算法应用于可用数据变得很重要。</p>
<p>A second challenge has to do with a common truism found in forecasting, which is that the unit of forecasting needs to match the context at which decisions are made. It can be tempting to forecast even more granularly, but that is generally a bad idea. This can be easily demonstrated through a simulation.</p>
<p>第二个挑战与预测中的一个普遍真理有关，即预测单元需要与做出决策的环境相匹配。进行更精细的预测可能很诱人，但这通常是一个坏主意。通过仿真这可以很容易地证明。</p>
<p>Consider the following three sub-regions describing daily demand by drawing samples, as shown in Figure 2, below, from a normal distribution with a mean of 100 and standard deviation of 25, giving us a coefficient of variation of 25%. When we aggregate these regions, we simply sum the expected mean to get an expected aggregate demand of 300. Nonetheless, the combined standard deviation is not equal with the sum of standard deviations but with the sum of the variances $\sqrt {3*25} = 43.3$, which gives us a coefficient of variation of the combined forecast of 14.4%. By simply aggregating random variables, we were able to reduce variance with respect to the mean by over 40%. </p>
<p>考虑下面三个通过抽取样本来描述每日需求的子区域，如下面的图2所示，它们来自均值为100、标准差为25的正态分布，变异系数为25%。当聚合这些区域时，简单累加预期均值得到期望总需求300。然而，组合的标准差不等于标准差之和，而是等于方差之和$\sqrt {3*25} = 43.3$，组合预测的变异系数为14.4%。通过简单地聚合随机变量，能够将均值的方差减少40%以上。</p>
<p>Although data aggregations can help with getting more accurate global forecasts, actions done on aggregated data can lead to inefficient mobilization. It is best to go for a solution where the unit of forecasting matches the unit of decision making.</p>
<p>尽管数据聚合有助于获得更准确的全局预测，但对聚合数据采取的行动可能会导致动员效率低下。 最好选择预测单位与决策单位相匹配的解决方案。</p>
<p><img src="http://noahsnail.com/images/doordash/doordash_time.png" alt="Time"></p>
<p>Figure 2: The top panel shows demand for three subregions. The bottom panel simply represents the aggregate demand. The relative variance in the bottom panel is reduced by 40% by performing aggregation of random variables.</p>
<p>图2：上部分显示了对三个子区域的需求。下部分仅表示总需求。通过执行随机变量的聚合，下部分的相对方差减少了40%。</p>
<h2 id="Choosing-an-optimizer"><a href="#Choosing-an-optimizer" class="headerlink" title="Choosing an optimizer"></a>Choosing an optimizer</h2><p>One benefit of using ML algorithms is that they provide more accurate expectations of what will happen given the input data. Nonetheless, ML algorithms are often simply a building block in a larger system that consumes predictions and attempts to generate a set of optimal actions. Mixed-integer programming (MIP) or reinforcement learning (RL)-based solutions are great in building systems that focus on reward maximization under specific business constraints.</p>
<p>使用ML算法的一个好处是，在给定输入数据的情况下，它们可以对会发生什么提供更准确地预期。尽管如此，ML算法通常只是更大系统中的一个构建块，系统使用预测并尝试生成一组最佳操作。在构建专注于特定业务约束下实现奖励最大化的系统时，基于混合整数规划(MIP)或强化学习(RL)的解决方案是非常好的。</p>
<p>We decided to pursue a MIP approach given that it was easy to formalize, implement, and explain to stakeholders, and we have a lot of expertise in the domain. The optimizer has a custom objective function of minimizing undersupply with several constraints. The objective itself is very flexible and can be specified to favor either profitability or growth, depending on the business requirements. In the optimizer, we generally encoded a few global constraints:</p>
<ul>
<li>Never allocate more than one incentive in a particular region-time unit.</li>
<li>Never exceed the maximum allowable budget set by our finance and operations partners.</li>
</ul>
<p>DoorDash决定采用MIP方法，因为它易于形式化、实现和向股东解释，而且在该领域有很多专业知识。优化器有一个定制的目标函数，可以在几个约束下最小化供给不足。目标本身非常灵活，可以根据业务需求指定为有利于盈利能力或增长。在优化器中，通常编码一些全局约束：</p>
<ul>
<li>切勿在特定区域时间单元分配多个奖励。</li>
<li>切勿超过财务和运营合作伙伴的最大允许预算。</li>
</ul>
<p>Depending on requirements, we might also have different regional or country constraints, such as having different budgets, custom penalties, exclusion criteria for which units should not be included in the optimization, or incentive constraints that are guided by variability of the inputs.</p>
<p>根据要求，可能还会有不同的区域或国家限制，例如不同的预算、定制惩罚、不应该包括在优化中的单元排除标准，或者由输入变化引导的激励限制。</p>
<h3 id="Dealing-with-uncertainty"><a href="#Dealing-with-uncertainty" class="headerlink" title="Dealing with uncertainty"></a>Dealing with uncertainty</h3><p>Uncertainty in the inputs plays an important role in how the optimizer allocates incentives when resources are limited. To demonstrate, Figure 3, below, displays the distribution of the hypothesized supply and demand imbalance in two cities.</p>
<p>在资源有限时，输入的不确定性在优化器如何分配激励中起着重要作用。为了证实这一点，下面的图3显示了两个城市假设的供需失衡分布。</p>
<p><img src="http://noahsnail.com/images/doordash/doordash_supply_deman.png" alt="Supply Demand"></p>
<p>Figure 3: In City A, we believe that we will be undersupplied and are also generally confident in our prediction. In City B, our mean prediction is that we will be slightly oversupplied, but we are less certain in our estimate and there is some likelihood of experiencing large undersupply.</p>
<p>图3：在A市，DoorDash认为将供给不足，并且对其预测也普遍充满信心。在B市，平均预测是将略微供过于求，但对评估不太确定，并且有可能出现严重的供给不足。</p>
<p>If the optimizer knows nothing about uncertainty, it ends up with two issues. First, it will lack understanding that supply and demand balance can go from a spectrum of extreme undersupply to extreme oversupply. If the optimizer is set up to optimize under some preset thresholds, it would miss the chance to optimize for City B because the mean of the distribution is above zero.</p>
<p>如果优化器对不确定性一无所知，那么最终会出现两个问题。首先，它将缺乏对供需平衡可以从极端供应不足到极端供应过剩的认识。如果优化器设置为在某些预设阈值下进行优化，它将错过为城市B优化的机会，因为分布的均值高于零。</p>
<p>The second issue is that it would end up over-allocating resources in places where our forecasts are uncertain. Our forecasts tend to be noisiest in the long tail of small regions that have few Dashers and few orders. Because the count of these regions is large and they exhibit high variance, if we don’t explicitly account for this uncertainty we are more likely to generate estimates that by chance will have high undersupply, and thus over-allocate incentives to places that exhibit high variance relative to places that have low variance.</p>
<p>第二个问题是，它最终会在预测不确定的地方过度分配资源。在Dasher和订单很少的小区域的长尾，预测往往噪声最强。因为这些地区的数量很大并且它们表现出很大的方差，如果不明确考虑这种不确定性，更有可能产生偶然会严重供应不足的估计，会在表现出高方差的地区(相比于低方差地区)过度分配激励措施。</p>
<p>To address the issue of variance, we generate expected estimates of hours gap from forecasts using a resampling process. By performing resampling, we essentially measure the impact of undersupply in the context of the likelihood of that happening. For example, in Figure 3, above, City B has only a 34% chance of being undersupplied. However, if that happens, we can more accurately estimate the impact of sizable changes in undersupply. Either of these approaches lead to a more optimal decision in incentive allocation instead of simply using mean estimates from upstream forecasting inputs.</p>
<p>为了解决方差问题，使用重采样过程从预测中生成期望的小时差估计值。通过执行重采样，基本上度量了发生供应不足可能性的影响。例如，在上面的图3中，B市供应不足的可能性只有34%。但是，如果发生这种情况，可以更准确地评估在供应不足的地区发生重大变化的影响。这些方法中的任何一种都可以在激励分配中做出更优的决策，而不是简单地使用来自上游预测输入的平均估计。</p>
<h2 id="Reliability-and-maintainability-improvements"><a href="#Reliability-and-maintainability-improvements" class="headerlink" title="Reliability and maintainability improvements"></a>Reliability and maintainability improvements</h2><p>DoorDash has grown tremendously in the last year. More than 70% of the people at DoorDash joined in the 2020-21 period. This generally brought a wave of new engineering, product, platform, and infrastructure-related projects to help with continued growth, expansion, and scalability. For example, we had dozens of internal projects that related to breaking down our monolith and adopting a more microservice oriented architecture. We had hundreds of small and large projects related to product improvements or new vertical launches. Many of these projects came with changes in our data models and in our data generation and collection processes. Unfortunately, ML models can be terribly unreliable when the ecosystem for how data gets produced and exposed is constantly shifting, so we needed to make some changes to enhance the reliability of our system.</p>
<p>DoorDash在去年取得了巨大的增长。DoorDash超过70%的人在2020-21年期间加入。这通常会带来一波新的工程、产品、平台和基础设施相关项目，以帮助实现持续增长、扩张和可扩展性。例如，DoorDash有几十个内部项目，这些项目与打破单体架构并采用更加面向微服务的架构有关。DoorDash有数百个与产品改进或新的垂直发布相关的大小项目。其中许多项目伴随着数据模型、数据生成和收集过程的变化。不幸的是，当数据生成和数据暴露的生态系统不断变化时，ML模型可能非常不可靠，因此需要进行一些更改以增强系统的可靠性。</p>
<h3 id="Decoupling-data-dependency-chains"><a href="#Decoupling-data-dependency-chains" class="headerlink" title="Decoupling data dependency chains"></a>Decoupling data dependency chains</h3><p>We could use many different data sources and encode hundreds of features to build a model that has high performance. Although that choice is very appealing and it does help with creating a model that performs better than one that has a simple data pipeline, in practice it creates a system that lacks reliability and generates a high surface area for feature drift, where the distribution of the inputs changes over time. Hence, when building our forecasting models, we went for simplicity and reliability first. This strategy also helped us move more quickly towards creating an end-to-end mobilization system.</p>
<p>DoorDash可以使用许多不同的数据源并编码数百个特征来构建具有高性能的模型。尽管这种选择非常吸引人，而且它确实有助于创建一个性能比具有简单数据流程的模型更好的模型，但实际上它创建的系统缺乏可靠性并为特征漂移产生了高比表面，其中输入随时间变化。因此，在构建预测模型时，首先追求简单性和可靠性。这一策略还帮助DoorDash更快地创建了端到端的调动系统。</p>
<p><img src="http://noahsnail.com/images/doordash/doordash_pipeline_comparison.png" alt="Pipeline"></p>
<p>Figure 4: Models that have complex data pipelines generally can show their strength in the first weeks of deployment but rapidly deteriorate over time. Simple data pipelines are generally more robust and reduce maintenance and remodeling burden.</p>
<p>图4：具有复杂数据流程的模型通常可以在部署的最初几周显示其优势，但随着时间的推移会迅速恶化。简单的数据流程通常更健壮，并减少维护和改造负担。</p>
<p>To manage complexity and shifts in how data gets exposed, we did two things. First, we decoupled data pipelines from each other into separate business domains. Now, when someone is working on improving the signal for the inputs used in forecasting, they do not need to be overwhelmed by monolithic queries and data pipelines. Instead, a developer works on an isolated pipeline and only needs to ensure that aggregations are done on an appropriate entity.</p>
<p>为了管理数据暴露方式的复杂性和变化，DoorDash做了两件事。首先，将数据流程彼此解耦为单独的业务域。现在，当有人致力于改进用于预测的输入信息时，他们不需要被庞大的查询和数据流程所淹没。相反，开发人员在隔离的流程上工作，只需要确保在合适的实体上完成聚合。</p>
<p>The second thing we did was to remove intermediary data dependencies. We recognized that if our input signals come from ETL jobs with very long dependency chains in their directed acyclic graphs (DAGs), we would increase our surface areas for failures. Hence, we would aspire to rely on primary tables thoroughly vetted by our Business Intelligence team or a copy of production data sources for which the data generation is not hidden behind complex ETLs.</p>
<p>第二件事是移除中间数据依赖。DoorDash认识到，如果输入信息来自ETL任务，ETL任务在有向无环图(DAG)中具有非常长的依赖链，将增加失败的比表面。因此，DoorDash希望依赖由商业智能团队彻底审查过的主表或产品数据源的副本，其数据生成不会隐藏在复杂的ETL后面。</p>
<p><img src="http://noahsnail.com/images/doordash/doordash_etl_pipeline.png" alt="Time"></p>
<p>Figure 5:  In this example, task E is the ML task with data transformations. If the source data for ML models comes from a long dependency chain in the ETL systems (A through D), there is a high risk of experiencing feature drift and data failures if any of the upstream dependencies fail.</p>
<p>图5：在此示例中，任务E是具有数据转换的ML任务。如果ML模型的源数据来自ETL系统中的长依赖链(A到D)，那么如果任何上游依赖项失败，则存在发生特征漂移和数据故障的高风险。</p>
<h3 id="Focus-on-experimentation"><a href="#Focus-on-experimentation" class="headerlink" title="Focus on experimentation"></a>Focus on experimentation</h3><p>One of the best ways to test if our system is maintainable is to simply check on the iteration speed with which we can push new changes and launch experiments without creating bugs or introducing regressions. At DoorDash, we perform many experiments to determine whether a feature is working as intended. This generally means that we put a lot more emphasis on measuring the software quality by how quickly we can extend and deliver on new functionality. Unsurprisingly, if experiments are challenging to launch and new features are difficult to test, we have failed in our goal. </p>
<p>测试系统是否可维护的最好方法之一是简单地检查迭代速度，可以用它推动新的变化和启动实验，而不会产生错误或引入回退。在DoorDash，进行了许多实验来确定某个功能是否按预期工作。这通常意味着更加重视通过扩张和交付新功能的速度来衡量软件质量。不出所料，如果实验难以启动并且新功能难以测试，那么目标就失败了。</p>
<p>Similarly, if a system stays unchanged over a long period of time (e.g., six months or more), it would also be an indication that something is wrong, because it means we created a system that is rigid and does not invite improvements, ideation, and experimentation. Continuous experimentation is a forcing function towards adopting better practices, such as relying on a CI/CD system for automation, setting up library dependency management, decoupling the code into business domains, and adding testing, alerting, and documentation.</p>
<p>同样，如果一个系统在很长一段时间内(例如，六个月或更长时间)保持不变，这也表明出现了问题，因为这意味着创建了一个僵化的系统，不会引起改进、构思和实验。持续的实验是一个强制采用更好实践的功能，例如依靠CI/CD系统实现自动化，设置库依赖管理，将代码解耦到业务域，以及添加测试、警报和文档。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>Implementing this mobilization system let us more accurately allocate incentives to regional-time units that benefited most from the improved supply and demand balance. The system resulted in a better experience for our customers, as our metrics showed reductions in delivery times, cancelations, and extreme lateness. For Dashers, we were able to ensure that incentives are allocated in places where they are needed most. For merchants, we drove the overall order cancellations down. Moreover, due to improvements in forecasting accuracy, we were also able to more reliably hit budget expectations and observed less variability in spending decisions. Because of reliability improvements, we were able to get to a point where our experimentation velocity on the incentive mobilization system rapidly increased.</p>
<p>实现这种调动系统能够更准确地将激励分配给从改善的供需平衡中受益最多的区域时间单位。该系统为客户带来了更好的体验，因为指标显示交付时间、取消订单和极端延迟都减少了。对于Dasher，能够确保将激励措施分配到最需要的地方。对于商家而言，降低了整体订单取消率。此外，由于预测准确性的提高，还能够更可靠地达到预算预期，并观察到支出决策的变动更小。由于可靠性的提高，能够达到激励调用系统的实验速度迅速提高的地步。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Problems that deal with optimizing a system under constraints benefit immensely from aligning on metrics that estimate the impact of actions at an appropriate level of aggregation. If forecasts are done daily, but optimization actions are taken sub-daily, decision making will likely be suboptimal.</p>
<p>处理在约束条件下优化系统的问题极大地受益于在适当的聚合水平上调整估计行动影响的指标。如果每天进行预测，但次日采取优化措施，则决策可能次优的。</p>
<p>Secondly, we generally recommend decoupling forecasting components from decision-making components. Most optimization systems work better if the inputs have stable statistical properties where the forecast predictions are unbiased estimates. For example, it can be tempting to start using an asymmetric loss function in forecasting to align with whether we care more about underpredicting or overpredicting the output. Although this approach is perfect for a variety of problems where the output of an ML model is immediately used to drive the decision, for problems where the ML predictions are simply another input into a broader optimization engine, it is best to generate unbiased predictions. Instead, it is better to let an optimization engine handle tradeoffs.</p>
<p>其次，通常建议将预测组件与决策组件解耦。如果输入具有稳定的统计特性，其中预告预测是无偏估计，则大多数优化系统会工作地更好。例如，为了与更关心低估或高估输出保持一致，开始在预测中使用非对称损失函数可能是很诱人的。尽管这种方法非常适用于ML模型的输出立即用于驱动决策的各种问题，但对于ML预测只是更广泛优化引擎的另一个输入的问题，最好生成无偏预测。相反，最好让优化引擎处理权衡。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://doordash.engineering/2021/06/29/managing-supply-and-demand-balance-through-machine-learning/" target="_blank" rel="external">Managing Supply and Demand Balance Through Machine Learning</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Managing Supply and Demand Balance Through Machine Learning-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>即时配送的ETA问题之亿级样本特征构造实践-笔记</title>
    <link href="http://noahsnail.com/2022/06/13/2022-06-13-%E5%8D%B3%E6%97%B6%E9%85%8D%E9%80%81%E7%9A%84ETA%E9%97%AE%E9%A2%98%E4%B9%8B%E4%BA%BF%E7%BA%A7%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%9E%84%E9%80%A0%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/13/2022-06-13-即时配送的ETA问题之亿级样本特征构造实践-笔记/</id>
    <published>2022-06-13T08:16:31.872Z</published>
    <updated>2022-06-14T10:11:27.451Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>ETA（Estimated time of Arrival，预计送达时间）是外卖配送场景中最重要的变量之一。 对ETA预估的准确度和合理度会对上亿外卖用户的订单体验造成深远影响，这关系到用户的后续行为和留存，是用户后续下单意愿的压舱石。ETA在配送业务架构中也具有重要地位，是配送运单实时调度系统的关键参数。对ETA的准确预估可以提升调度系统的效率，在有限的运力中做到对运单的合理分配。在保障用户体验的同时，对ETA的准确预估也可以帮助线下运营构建有效可行的配送考核指标，保障骑手的体验和收益。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-93353410.png" alt="ETA的业务价值"></p>
<p>ETA在互联网行业中的运用取得了令人瞩目的进展，其中以外卖行业和打车行业最令人关注。ETA在外卖行业中的业务场景更为复杂，外卖行业涉及了三方——骑手、商家、用户，这使得问题的处理难度提升了一个量级。从业务的环节来看，外卖主要分为接单、到店、取餐、送达四个环节，是一个用户、骑手、商家来回交错的场景。这带来了更多的复杂性和不确定性，如骑手操作在各个环节中存在较多的不可控因素，商家可能出餐较慢，此外还有运力规划和天气因素的不确定性等，这就直接导致了外卖ETA采取了端到端（下单到接单）的预估方式，相比于拆分成四个环节单独预估具有更强的容错性。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-dac1a248.png" alt="ETA架构图"></p>
<h2 id="2-相关技术"><a href="#2-相关技术" class="headerlink" title="2. 相关技术"></a>2. 相关技术</h2><p>ETA中比较常用的模型是以GBDT（Gradient Boost Decision Tree，梯度提升决策树）、RF（RandomForest，随机森林）和线性回归为主的回归预测模型。GBDT是利用DT Boosting的思路，通过梯度求解的方式追踪残差，最终达到利用弱分类器（回归器）构造强分类器（回归器）的目的。RF在DT Bagging的基础之上通过加入样本随机和特征随机的方式引入更多的随机性，解决了决策树泛化能力弱的问题。而线性回归作为线性模型，很容易并行化，处理上亿条训练样本不是问题。但线性模型学习能力有限，需要大量特征工程预先分析出有效的特征、特征组合，从而去间接增强线性回归的线性学习能力。</p>
<p>在回归模型中，特征组合非常重要，但只依靠业务理解和人工经验不一定能带来效果提升，这导致在实际应用中存在特征匮乏的问题。所以如何发现、构造、组合有效特征，并弥补人工经验的不足，成了ETA中重要的一环。</p>
<p>Facebook 2014年的文章介绍了通过GBDT解决LR的特征组合问题。GBDT思想对于发现多种有区分性的特征和组合特征具有天然优势，可以用来构造新的组合特征。在Facebook的文章中，会基于样本在GBDT中的输出节点索引位置构造0-1特征，实现特征的丰富化。新构造的0-1特征中，每一个特征对应样本在每棵树中可能的输出位置，它们代表着某些特征的某种逻辑组合。例如一棵树有n个叶子节点，当样本在第k个叶子节点输出时，则第k个特征输出1，其余n-1个特征输出0，如图所示。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-7e5bd36c.png" alt="GBDT(Gradient Boost Decision Tree)特征构造方法"></p>
<p>至于构造新特征的规模，需要由具体业务规模而决定。当GBDT中树的数量较多或树深较深时，构造的特征规模也会大幅增加；当业务中所用的数据规模较小时，大规模的构造新特征会导致后续训练模型存在过拟合的可能。所以构造特征的规模需要足够合理。</p>
<p>在ETA场景中，由于业务场景复杂，所以特征的丰富性决定了ETA最终效果的上限。在目前所拥有的特征中，在特征工程的基础阶段，依靠业务理解、人工分析和经验总结来构造特征。但从特征层面来看仍然存在欠缺，需要让特征更加丰富化，深度挖掘特征之间的潜在价值。</p>
<h3 id="2-1-基础特征构建"><a href="#2-1-基础特征构建" class="headerlink" title="2.1 基础特征构建"></a>2.1 基础特征构建</h3><p>特征作为ETA中的重要部分，决定了ETA的上限。基于人工经验和业务理解构建不同的离线特征和在线特征。<br>(1) 离线特征<br>a. 商户画像：商户平均送达时长、到店时长、取餐时长、出餐状况、单量、种类偏好、客单价、平均配送距离。<br>b. 配送区域画像：区域运力平均水平、骑手规模、单量规模、平均配送距离。<br>(2) 在线特征<br>a. 商家实时特征：商家订单挤压状况、过去N分钟出单量、过去N分钟进单量。<br>b. 区域实时特征：在岗骑手实时规模、区域挤压（未取餐）单量、运力负载状况。<br>c. 订单特征：配送距离、价格、种类、时段。<br>d. 天气数据：温度、气压、降水量。</p>
<p>其中区域实时特征和商家实时特征与配送运力息息相关，运力是决定配送时长和用户体验的重要因素。</p>
<p>Note:<br>在线特征(实时)和离线特征。</p>
<h3 id="2-2-GBDT模型训练和特征构造"><a href="#2-2-GBDT模型训练和特征构造" class="headerlink" title="2.2 GBDT模型训练和特征构造"></a>2.2 GBDT模型训练和特征构造</h3><p>利用基础特征，训练用于构造新特征的GBDT模型。在GBDT中，每次训练一个CART（Classification And Regression Trees）回归树，基于当前轮次CART树的损失函数的逆向梯度，拟合下一个CART树，直到满足要求为止。</p>
<p>(1) 超参数选择<br>a. 首先为了节点分裂时质量和随机性，分裂时所使用的最大特征数目为$\sqrt n$。<br>b. GBDT迭代次数（树的数量）。树的数量决定了后续构造特征的规模，与学习速率相互对应。通常学习速率设置较小，但如果过小，会导致迭代次数大幅增加，使得新构造的特征规模过大。通过GridSearch+CrossValidation可以寻找到最合适的迭代次数+学习速率的超参组合。<br>c. GBDT树深度需要足够合理，通常在4~6较为合适。虽然增加树的数量和深度都可以增加新构造的特征规模。但树深度过大，会造成模型过拟合以及导致新构造特征过于稀疏。</p>
<p>(2) 训练方案<br>将训练数据随机抽样50%，一分为二。前50%用于训练GBDT模型，后50%的数据在通过GBDT输出样本在每棵树中输出的叶子节点索引位置，并记录存储，用于后续的新特征的构造和编码，以及后续模型的训练。如样本x通过GBDT输出后得到的形式如下：$x -&gt; [25,20,22,….,30,28]$，列表中表示样本在GBDT每个树中输出的叶子节点索引位置。</p>
<h3 id="2-3-OneHotEncoder（新特征热编码）"><a href="#2-3-OneHotEncoder（新特征热编码）" class="headerlink" title="2.3 OneHotEncoder（新特征热编码）"></a>2.3 OneHotEncoder（新特征热编码）</h3><p><img src="http://noahsnail.com/images/meituan/meituan-d648422d.png" alt="OneHotEncoder"></p>
<p>由于样本经过GBDT输出后得到的$x -&gt; [25,20,22,….,30,28]$是一组新特征，但由于这组新特征是叶子节点的ID，其值不能直接表达任何信息，故不能直接用于ETA场景的预估。为了解决上述的问题，避免训练过程中无用信息对模型产生的负面影响，需要通过独热码（OneHotEncoder）的编码方式对新特征进行处理，将新特征转化为可用的0-1的特征。</p>
<p>以图中的第一棵树和第二棵树为例，第一棵树共有三个叶子节点，样本会在三个叶子节点的其中之一输出。所以样本在该棵树有会有可能输出三个不同分类的值，需要由3个bit值来表达样本在该树中输出的含义。图中样本在第一棵树的第一个叶子节点输出，独热码表示为{100}；而第二棵树有四个叶子节点，且样本在第三个叶子节点输出，则表示为{0010}。将样本在每棵树的独热码拼接起来，表示为{1000010}，即通过两棵CART树构造了7个特征，构造特征的规模与GBDT中CART树的叶子节点规模直接相关。</p>
<p>基于独热码编码新特征完成后，加上原来的基础特征，特征规模达到1000+以上，实现特征丰富化。</p>
<p>Note:<br>丰富特征，使用了独热编码，编码的是GBDT的叶子节点，没太懂。</p>
<h2 id="3-评估指标"><a href="#3-评估指标" class="headerlink" title="3. 评估指标"></a>3. 评估指标</h2><p>ETA与实际业务深度耦合，所以需要基于业务因素考虑更多的评估指标，以满足各端用户利益。</p>
<ol>
<li>N分钟准确率：订单实际送达时长与预估时长的绝对误差在N分钟内的概率。</li>
</ol>
<p><strong>业务含义</strong></p>
<ul>
<li>在N分钟准确率中，N的判定方法来源于绝对误差与用户满意度的关系曲线。通常绝对误差在一定范围内，用户满意度不会有明显波动。如果发现当误差大于K分钟时，用户满意度出现明显下滑，则可以将K做为N分钟准确率中N的取值依据。</li>
<li>预估时长等同于平台提供给C端用户对送餐快慢的心理预期，如果N分钟准确率越高，证明预估时长愈发接近用户的心理预期，表示C端用户体验越好。</li>
</ul>
<p><strong>计算方法</strong></p>
<ul>
<li>$X_i$：样本$i$的绝对误差=abs(实际送达时长-预估时长)。</li>
<li>计算每个样本的误差的是否在N分钟内，并统计概率$P(X_i &lt;= N)$。</li>
</ul>
<p>判定订单预估是否准确的计算方法<br>$$<br>f(X_i)=<br>\begin{cases}<br>1&amp; (X_i&lt;=N) \\<br>0&amp; (X_i&gt;N)<br>\end{cases}<br>$$<br>N分钟准确率计算方法<br>$$P(X_i&lt;=N)=\frac {\sum_{i=1}^{n}f(X_i)} {n}$$</p>
<ol>
<li>N分钟业务准时率：实际送达时长与预估时长的差值在N分钟内的概率。<br><strong>业务含义</strong> </li>
</ol>
<ul>
<li>N分钟业务准时率中N的判定方法与N分钟准确率类似。 </li>
<li>N分钟业务准时率是一种合理考核骑手以及保障骑手绩效收益的指标。ETA场景与其它回归场景相比，在预估准确的同时，预估合理性同样很重要。N分钟准确率虽然有效地量化C端用户体验指标，但无法衡量R端骑手体验。所以N分钟业务准时率是一个很好的补充指标。<br><strong>计算方法</strong> </li>
<li>$X_i$，样本i的有偏差值=(实际送达时长-预估时长)。 </li>
<li>若$X_i&lt;0$，表示骑手提前送达，等同于业务准时。 </li>
<li>若$0&lt; X_i &lt;= N$，表示骑手在超时N分钟内送达，等同于业务准时；但如果$X_i &gt; N$，表示骑手超时N分钟以上送达，从指标层面看，该订单骑手配送业务超时。</li>
<li>统计订单配送不超时的概率$P(X_i &lt;= N)$，计算方法与N分钟准确率类似。</li>
</ul>
<h2 id="4-实践效果对比"><a href="#4-实践效果对比" class="headerlink" title="4. 实践效果对比"></a>4. 实践效果对比</h2><p>在不增加任何额外特征的情况下，仅通过模型架构的变化进行优化。在对全量订单进行评估对比的同时，对一些高价值和午高峰期间的订单进行重点评估。</p>
<ul>
<li>高价值订单：高价值订单仅占全量订单的5%。这部分订单用户满意度较低、配送体验较差，属于长尾订单范畴，优化难度高于其它类型订单。 </li>
<li>午高峰订单：午高峰运单业务占比高达40%。午高峰期间，商家存在堂食和外卖资源争抢问题，造成出餐时间不稳定，导致业务中存在更多不确定性，预估难度明显大于非高峰期。</li>
</ul>
<p>将GBDT构造特征+Ridge与老版本base model（GBDT）进行对比。从结果上来看，构造新特征后，可以对ETA预估带来更好的效果，其中在高价值订单中，骑手的N分钟业务准时率提升显著。具体结论如下：</p>
<ul>
<li>全量订单：平均偏差(MAE)减少了3.4%，误差率减少1.7个百分点，N分钟准确率提升2.2个百分点，N分钟业务准时率持平。</li>
<li>高价值订单：平均偏差(MAE)减少了2.56%，误差率减少1个百分点，N分钟准确率提升1.6个百分点，N分钟业务准时率提升3.46个百分点。</li>
<li>午高峰订单：平均偏差(MAE)减少了3.1%，误差率减少1.4个百分点，N分钟准确率提升1.7个百分点，N分钟业务准时率持平。</li>
</ul>
<p>从上述效果来看，GBDT构造特征可以给ETA场景带来更多的提升，在线上使用时，也需要在性能和构造特征的规模上做出取舍。考虑到骑手的主观能动性等因素，通常上线后，线上效果比线下试验效果要更加乐观。</p>
<p>ETA作为是外卖配送场景中最重要变量之一，是一个复杂程度较高的机器学习问题，其特征的丰富性决定了ETA的上限。在业务特征相对匮乏的情况下，GBDT+OneHotEncoder可以实现特征的丰富化，深度挖掘出特征的潜在价值。实验结果显示，在特征丰富化的情况下，ETA的准确度明显提高。</p>
<p>时序关系也是ETA场景的重要特征，尝试将该关系特征化加入到目前的模型和策略中，改善特征质量，提高ETA的预估能力上限。同时引入深度学习和增强学习，在提高上限的同时，用更好的模型去接近这个新的预估上限。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2017/11/24/gbdt.html" target="_blank" rel="external">即时配送的ETA问题之亿级样本特征构造实践</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      即时配送的ETA问题之亿级样本特征构造实践-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>深度学习在美团配送ETA预估中的探索与实践-笔记</title>
    <link href="http://noahsnail.com/2022/06/13/2022-06-13-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BE%8E%E5%9B%A2%E9%85%8D%E9%80%81ETA%E9%A2%84%E4%BC%B0%E4%B8%AD%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/13/2022-06-13-深度学习在美团配送ETA预估中的探索与实践-笔记/</id>
    <published>2022-06-13T03:22:47.978Z</published>
    <updated>2022-06-13T07:34:41.471Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>ETA（Estimated Time of Arrival，“预计送达时间”），即用户下单后，配送人员在多长时间内将外卖送达到用户手中。送达时间预测的结果，将会以”预计送达时间”的形式，展现在用户的客户端页面上，是配送系统中非常重要的参数，直接影响了用户的下单意愿、运力调度、骑手考核，进而影响用户和骑手体验，以及配送系统的整体效率。</p>
<p>对于整个配送系统而言，ETA既是配送系统的入口和全局约束，又是系统的调节中枢。具体体现在：</p>
<ul>
<li>ETA在用户下单时刻就需要被展现，这个预估时长继而会贯穿整个订单生命周期，首先在用户侧给予准时性的承诺，接着被调度系统用作订单指派的依据及约束，而骑手则会参考ETA时间作为考核时间执行订单的配送。</li>
<li>ETA作为系统的调节中枢，需要平衡用户-骑手-商家-配送效率。从用户的诉求出发，尽可能快和准时，从骑手的角度出发，ETA太短会增大其配送难度。从调度角度出发，太长或太短都会影响配送效率。而从商家角度出发，都希望订单被尽可能派发出去，因为这关系到商家的收入。</li>
</ul>
<p><img src="http://noahsnail.com/images/meituan/meituan-78c72ddb8941aba1298cc30221f1d696287706.png" alt="ETA在配送系统中的作用"></p>
<p>外卖场景的ETA面临如下的挑战：</p>
<ul>
<li>外卖场景中ETA是对客户履约承诺的重要组成部分，无论是用户还是骑手，对于ETA准确性的要求非常高。</li>
<li>由于外卖ETA承担着承诺履约的责任，因此是否能够按照ETA准时送达，也是外卖骑手考核的指标、配送系统整体的重要指标；承诺一旦给出，系统调度和骑手都要尽力保证准时送达。因此过短的ETA会给骑手带来困难，并降低调度合单能力、降低配送效率；过长的ETA又会很大程度影响用户体验。</li>
<li>外卖场景中ETA包含更多环节，骑手全程完成履约过程，其中包括到达商家、商家出餐、等待取餐、路径规划、不同楼宇交付等较多的环节，且较高的合单率使得订单间的流程互相耦合，不确定性很大，做出合理的估计也有更高难度。</li>
</ul>
<p>下图是骑手履约全过程的时间轴，过程中涉及各种时长参数，可以看到有十几个节点，其中关键时长达到七个。对于ETA建模，不光是简单一个时间的预估，更需要的是全链路的时间预估，同时更需要兼顾”单量-运力-用户体验”之间的平衡。配送ETA的演变包括了数据、特征层面的持续改进，也包括了模型层面一路从LR-XGB-FM-DeepFM-自定义结构的演变。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-044ae6809b5aebe72a06dfffd78cb6d7288610.png" alt="ETA的探索与演变"></p>
<p>Note:<br>ETA一旦展示给用户，就意味着对用户进行了承诺，影响范围是巨大的。系统调度和骑手，都要尽力保证准时送达。</p>
<h2 id="2-业务流程迭代中的模型改进"><a href="#2-业务流程迭代中的模型改进" class="headerlink" title="2. 业务流程迭代中的模型改进"></a>2. 业务流程迭代中的模型改进</h2><h3 id="2-1-基础模型迭代及选择"><a href="#2-1-基础模型迭代及选择" class="headerlink" title="2.1 基础模型迭代及选择"></a>2.1 基础模型迭代及选择</h3><p>与大部分CTR模型的迭代路径相似，配送ETA模型的业务迭代经历了LR-&gt;树模型-&gt;Embedding-&gt;DeepFM-&gt;针对性结构修改的路径。特征层面也进行不断迭代和丰富。</p>
<ul>
<li>模型维度从最初考虑特征线性组合，到树模型做稠密特征的融合，到Embedding考虑ID类特征的融合，以及FM机制低秩分解后二阶特征组合，最终通过业务指标需求，对模型进行针对性调整。</li>
<li>特征维度逐步丰富到地址特征/轨迹特征/区域特征/时间特征/时序特征/订单特征等维度。</li>
</ul>
<p>目前，版本模型在比较了Wide &amp;Deep、DeepFM、AFM等常用模型后，考虑到计算性能及效果，最终选择了DeepFM作为初步的Base模型。整个DeepFM模型特征Embedding化后，在FM（Factorization Machine）基础上，进一步加入deep部分，分别针对稀疏及稠密特征做针对性融合。FM部分通过隐变量内积方式考虑一阶及二阶的特征融合，DNN部分通过Feed-Forward学习高阶特征融合。模型训练过程中采取了Learning Decay/Clip Gradient/求解器选择/Dropout/激活函数选择等。</p>
<p>Note:<br>ETA预测选择了DeepFM作为深度学习Base模型。</p>
<h3 id="2-2-损失函数"><a href="#2-2-损失函数" class="headerlink" title="2.2 损失函数"></a>2.2 损失函数</h3><p>在ETA预估场景下，准时率及置信度是比较重要的业务指标。初步尝试将Square的损失函数换成Absolute的损失函数，从直观上更为切合MAE相比ME更为严苛的约束。在适当Learning Decay下，结果收敛且稳定。</p>
<p>在迭代中考虑到相同的ETA承诺时间下，在前后N分钟限制下，预估偏短1min的用户、骑手体验明显差于预估偏长1分钟的体验。因此损失函数的设计需要考虑到偏短偏长的差异。适当降低偏长部分的损失，提高偏短部分的损失。进行多次调试设计后，最终确定以前后N分钟以及原点作为3个分段点。在原先absolute函数优化的基础上，在前段设计1.2倍斜率absolute函数，后段设计1.8倍斜率absolute函数，以便让结果整体往中心收敛，且更倾向于适度偏长预估，保障用户和骑手体验，对于ETA各项指标均有较大幅度提升。</p>
<p>Note:<br>这个损失函数是为深度学习模型设计的，其它模型不一定适用，但考虑偏短偏长差异的思想可以借鉴。</p>
<h3 id="2-3-业务规则融入模型"><a href="#2-3-业务规则融入模型" class="headerlink" title="2.3 业务规则融入模型"></a>2.3 业务规则融入模型</h3><p>目前的业务架构是“模型+规则”，在模型预估一个ETA值之后，针对特定业务场景，会有特定业务规则时间叠加以满足特定场景需求，例如在冬至时饺子品类的需求暴增，模型可能捕捉不到这样的异常点，因此需要规则对异常情况做时间保护。各项规则由业务指标多次迭代产生。在模型时间和规则时间分开优化后，即模型训练时并不能考虑到规则时间的影响，而规则时间在一年之中不同时间段，会产生不同的浮动，在经过一段时间重复迭代后，会加大割裂程度。</p>
<p>Note:<br>业务架构：模型+规则，ETA与业务是紧密结合的，模型是一个初步的结果，不同的场景需要根据业务进行适当的调整。</p>
<p>在尝试了不同方案后，最终将整体规则写入到了TF模型中，在TF模型内部调整整体规则参数。</p>
<ul>
<li>对于简单的(a<em>b+c)</em>d等规则，可以将规则逻辑直接用TF的OP算子来实现，比如当b、d为定值时，则a、c为可学习的参数。</li>
<li>对于过于复杂的规则部分，则可以借助一定的模型结构，通过模型的拟合来代替，过多复杂OP算子嵌套并不容易同时优化。</li>
</ul>
<p>通过调节不同的拟合部分及参数，将多个规则完全在TF模型中实现。最终对业务指标具备很大提升效果，且通过对部分定值参数的更改，具备部分人工干涉模型、对骑手体验做兜底保障的能力。整体架构简化为多目标预估的架构，这里采用多任务架构中常用的Shared Parameters的结构，训练时按比例采取不同的交替训练策略。结构上从最下面的模型中间融合层出发，分别在TF内实现常规预测结构及多个规则时间结构，而其对应的Label则仍然从常规的历史值和规则时间值中来，这样考虑了以下几点：</p>
<ul>
<li>模型预估时，已充分考虑到规则对整体结果的影响（例如多个规则的叠加效应），作为整体一起考虑。</li>
<li>规则时间作为辅助Label传入模型，对于模型收敛及Regularization，起到进一步作用。</li>
<li>针对不同的目标预估，采取不同的Loss，方便进行针对性优化，进一步提升效果。</li>
</ul>
<p><img src="http://noahsnail.com/images/meituan/meituan-296608dfa70b7015c00cf60feddb799530899.png" alt="多目标补时结构"></p>
<p>Note:<br>初期可以使用模型+规则，后期规则融合进深度模型，会有大的提升。</p>
<h3 id="2-4-缺失值处理"><a href="#2-4-缺失值处理" class="headerlink" title="2.4 缺失值处理"></a>2.4 缺失值处理</h3><p>对于特征x进入TF模型，进行判断，如果是缺失值，则设置w1参数，如果不是缺失值则进入模型数值为w2 *x，这里将w1和w2作为可学习参数，同时放入网络进行训练。以此方法来代替均值/零值等作为缺失值的方法。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-0f7731c215d6089660796e5a29f6c31310388.png" alt="缺失值处理"></p>
<h2 id="3-长尾问题优化"><a href="#3-长尾问题优化" class="headerlink" title="3. 长尾问题优化"></a>3. 长尾问题优化</h2><h3 id="3-1-模型预估结果-长尾规则补时"><a href="#3-1-模型预估结果-长尾规则补时" class="headerlink" title="3.1 模型预估结果+长尾规则补时"></a>3.1 模型预估结果+长尾规则补时</h3><p>基础模型学习的是整体的统计分布，但对于一些长尾情形的学习并不充分，体现在长尾情形下预估时间偏短（由于骑手的考核时间参考ETA制定，ETA预估偏短会增大骑手的配送难度）。故将长尾拆解成两部分来分析：</p>
<ul>
<li>业务长尾，即整体样本分布造成的长尾。主要体现在距离、价格等维度。距离越远，价格越高，实际送达时间越长，但样本占比越少，模型在这一部分上的表现可能偏短。</li>
<li>模型长尾，即由于模型自身对预估值的不确定性造成的长尾。模型学习的是整体的统计分布，但不是对每个样本的预估都有“信心”。实践中采用RF多棵决策树输出的标准差来衡量不确定性。RF模型生成的决策树是独立的，每棵树都可以看成是一个专家，多个专家共同打分，打分的标准差实际上就衡量了专家们的“分歧”程度（以及对预估的“信心”程度）。随着RF标准差的增加，模型的置信度和准时率均在下降。</li>
</ul>
<p>在上述拆解下，采用补时规则来解决长尾预估偏短的问题：长尾规则补时为 &lt;业务长尾因子 , 模型长尾因子&gt; 组合。其中业务长尾因子为距离、价格等业务因素，模型长尾因子为RF标准差。最终的ETA策略即为模型预估结果+长尾规则补时,较好的保证了长尾情况的骑手体验。</p>
<p>Note:<br>在模型预估结果的基础上，加上长尾规则补时来解决长尾预测时间偏短问题。</p>
<h2 id="4-工程开发实践"><a href="#4-工程开发实践" class="headerlink" title="4. 工程开发实践"></a>4. 工程开发实践</h2><h3 id="4-1-训练部分实践"><a href="#4-1-训练部分实践" class="headerlink" title="4.1 训练部分实践"></a>4.1 训练部分实践</h3><p><strong>整体训练流程</strong><br>对于线下训练，采取如下训练流程：<br>Spark原始数据整合 -&gt; Spark生成TFRecord -&gt; 数据并行训练 -&gt; TensorFlow Serving线下GPU评估 -&gt; CPU Inference线上预测</p>
<p><strong>数据并行训练方式</strong><br>整个模型的训练在平台上进行，先后尝试分布式方案及单机多卡方案。线上模型生产采用单机多卡方案进行例行训练。</p>
<p><strong>TF模型集成预处理</strong></p>
<p>为了简化工程开发中的难度，在模型训练时，考虑将所有的预处理文件写入TF计算图之中，每次在线预测只要输入最原始的特征，不经过工程预处理，直接可得到结果。</p>
<h3 id="4-2-TF模型线上预测"><a href="#4-2-TF模型线上预测" class="headerlink" title="4.2 TF模型线上预测"></a>4.2 TF模型线上预测</h3><p>略</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2019/02/21/meituan-delivery-eta-estimation-in-the-practice-of-deep-learning.html" target="_blank" rel="external">深度学习在美团配送ETA预估中的探索与实践</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      深度学习在美团配送ETA预估中的探索与实践-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>机器学习在美团配送系统的实践：用技术还原真实世界-笔记</title>
    <link href="http://noahsnail.com/2022/06/10/2022-06-10-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BE%8E%E5%9B%A2%E9%85%8D%E9%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BC%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E8%BF%98%E5%8E%9F%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/10/2022-06-10-机器学习在美团配送系统的实践：用技术还原真实世界-笔记/</id>
    <published>2022-06-10T03:07:30.813Z</published>
    <updated>2022-06-10T08:57:32.397Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-美团“超脑”配送系统的由来"><a href="#1-美团“超脑”配送系统的由来" class="headerlink" title="1. 美团“超脑”配送系统的由来"></a>1. 美团“超脑”配送系统的由来</h2><p>美团内部把配送的AI系统，简称为“超脑”配送系统。</p>
<h2 id="2-即时配送在全球快速发展"><a href="#2-即时配送在全球快速发展" class="headerlink" title="2. 即时配送在全球快速发展"></a>2. 即时配送在全球快速发展</h2><p>以外卖为依托，即时配送业务在全球范围内掀起了一波快速发展的浪潮，两个问题：</p>
<ul>
<li>“懒”是人类的天性。平价、方便、快捷的服务是人类的普遍需求，尤其是在“吃”这个事情上，外卖成为了一种高频的刚需。</li>
<li>外卖的商业模式完全可行。以美团外卖为例，2018年上半年整体收入160亿，同步增长90%。根据Uber公布的数据，Uber Eats在2018第一季度占整体营业的13%。</li>
</ul>
<h2 id="3-即时配送的业务模型"><a href="#3-即时配送的业务模型" class="headerlink" title="3. 即时配送的业务模型"></a>3. 即时配送的业务模型</h2><p>即时配送，是一种配送时长1小时以内，平均配送时长约30分钟的快速配送业务。如此快速的配送时效，将传统的线上电商交易与线下物流配送（传统划分比较明确的两条业务）整合为统一整体，形成了用户、商户、骑手和平台互相交错的四元关系。</p>
<p>以外卖搜索和排序为例，在下午时段，在用户搜索和推荐中可以看到更多的商家，因为此时运力充分，可以提供更远距离的配送服务，不仅能更好满足用户的需求，提高商家的单量，而且能够增加骑手的收入。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-a1f21309.png" alt="业务模型"></p>
<p>即时配送的核心指标是效率、成本、体验，这三者也形成了即时配送的商业模型。简单来说可以分为以下几步：</p>
<p>首先配送效率提升，让骑手在单位时间内配送更多订单，产生更多价值。然后配送成本下降，更高的效率，一方面让骑手收入增加，一方面也让订单平均成本下降。然后用户体验提升，低成本能够让用户（商户）以更低的价格享受更好的配送服务，从而保证更好的用户体验。进一步提升效率并形成循环，更好的用户体验，让更多用户（商户）聚集过来，提升规模和密度，进一步提升配送效率。</p>
<h2 id="4-美团“超脑”配送系统"><a href="#4-美团“超脑”配送系统" class="headerlink" title="4. 美团“超脑”配送系统"></a>4. 美团“超脑”配送系统</h2><p><img src="http://noahsnail.com/images/meituan/meituan-b550a85f.png" alt="美团“超脑”配送系统"></p>
<p>美团“超脑”配送系统，包含以下几个方面：</p>
<ul>
<li>大数据处理和计算能力<ul>
<li>算法数据和计算平台：包括实时特征计算、离线数据处理、机器学习平台等。</li>
</ul>
</li>
<li>建立对世界深度感知<ul>
<li>LBS系统：提供正确位置（用户/商户/骑手）以及两点之间正确的骑行导航。</li>
<li>多传感器：提供室内定位以、精细化场景刻画、骑手运动状态识别</li>
</ul>
</li>
<li>正确理解和准确预测<ul>
<li>时间预估：提供所有配送环节时间的准确预估</li>
<li>其他预估：销量预估、运力预估等</li>
</ul>
</li>
<li>完成复杂决策<ul>
<li>调度系统：多人多点实时调度系统，完成派单决策：谁来送？怎么送？</li>
<li>定价系统：实时动态定价系统，完成定价决策：用户收多少钱？给骑手多少钱？</li>
<li>规划系统：配送网络规划系统，完成规划决策：站点如何划分？运力如何运营？</li>
</ul>
</li>
</ul>
<h2 id="5-机器学习技术挑战"><a href="#5-机器学习技术挑战" class="headerlink" title="5. 机器学习技术挑战"></a>5. 机器学习技术挑战</h2><p>如何构建一个在真实物理世界运行的AI系统，是最大的挑战。具体到机器学习方向而言，挑战包括以下几个方面：</p>
<ul>
<li>精度足够高、粒度足够细<ul>
<li>时间要求：一方面是周期性变化，比如早午晚，工作假日，季节变化；一方面是分钟级的精细度，比如一个商圈单量和运力的实时变化。</li>
<li>空间要求：一方面是不同商圈独有特性，比如CBD区域；一方面是要实现楼栋和楼层的精度，比如1楼和20楼，就是完全不同的配送难度。</li>
<li>鲁棒性要求：处理各种不确定的能力，比如天气变化、交通变化等等。</li>
</ul>
</li>
<li>线下数据质量的巨大挑战<ul>
<li>大噪音：比如GPS定位漂移，尤其是在高楼附近，更不要说在室内GPS基本不可用。</li>
<li>不完备：比如商家后厨数据、堂食数据、其他平台数据，都极难获得。</li>
<li>高复杂：配送场景多样而且不稳定，随着时间、天气、路况等在不断变化。</li>
</ul>
</li>
</ul>
<h2 id="6-配送系统的核心参数ETA"><a href="#6-配送系统的核心参数ETA" class="headerlink" title="6. 配送系统的核心参数ETA"></a>6. 配送系统的核心参数ETA</h2><p>ETA（Estimated Time of Arrival，时间送达预估）是配送系统中非常重要参数，与用户体验、配送成本有直接关系，而且会直接影响调度系统和定价系统的最终决策。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-424a9243.png" alt="ETA"></p>
<p>通过机器学习方法，将外卖配送几乎所有环节都进行了精准预估预测。</p>
<p>Note:<br>ETA关联了调度系统与定价系统，对所有时间环节都进行预测。</p>
<h2 id="7-精准到楼宇和楼层的预估：交付时长"><a href="#7-精准到楼宇和楼层的预估：交付时长" class="headerlink" title="7. 精准到楼宇和楼层的预估：交付时长"></a>7. 精准到楼宇和楼层的预估：交付时长</h2><p>交付时长是指骑手到达用户后，将外卖交付到用户手中并离开的时间，实际是需要考虑三维空间内计算（上楼-下楼）。交付时间精准预估，有两点重要的意义，首先是客观的衡量配送难度，给骑手合理补贴；其次，考虑对骑手身上后续订单的影响，防止调度不合理，导致其他订单超时。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-a6de9e20.png" alt="交付时长"></p>
<p>交付时长的目标是，做到楼宇和楼层的精准颗粒度，具体可以拆解为以下几步：</p>
<ol>
<li>地址的精准解析（精确到楼宇/单元/楼层）<ul>
<li>地址精度需要在5级之上（4级：街道，5级：楼宇），国内拥有这个级别精细化数据的公司屈指可数。</li>
<li>数据的安全级别很高，我们做了很多脱敏工作，做了各种数据保护与隔离，保证用户隐私和数据安全。</li>
<li>地址信息的多种表达方式、各种变形，需要较强的NLU技术能力。</li>
</ul>
</li>
<li>交付时长预估<ul>
<li>通过骑手轨迹进行“入客-离客”识别，并进行大量数据清洗工作。</li>
<li>统计各个粒度的交付时长，通过树形模型实现快速搜索各个粒度的数据。</li>
<li>因为预估精度是楼宇和楼层，数据很稀疏，很难直接进行统计，需要通过各种数据平滑和回归预估，处理数据稀疏和平滑的问题。</li>
</ul>
</li>
<li>下游业务应用<ul>
<li>给调度和定价业务，提供楼宇+楼层维度的交付时长。从上图可以看到，在不同楼宇，不同楼层交付时长的区分度还是很明显的。</li>
<li>尤其是楼层与交付时长并不是线性相关，还具体调研过骑手决策行为，发现骑手会考虑等电梯的时间，低楼层骑手倾向于走楼梯，高楼层则坐电梯。</li>
</ul>
</li>
</ol>
<p>Note:<br>交付时长是一个特别精细的工作，从美团的文章来看，交付时长非常重要，还有一篇单独的文章来介绍这个工作。</p>
<h2 id="8-配送中最重要的数据之一：地图"><a href="#8-配送中最重要的数据之一：地图" class="headerlink" title="8. 配送中最重要的数据之一：地图"></a>8. 配送中最重要的数据之一：地图</h2><p><img src="http://noahsnail.com/images/meituan/meituan-38a8ad0d.png" alt="ETA"></p>
<p>配送地图的目标可以概括为以下两点：</p>
<ul>
<li>正确的位置<ul>
<li>实时部分：骑手实时位置。</li>
<li>静态部分：用户和商户准确的地址和位置。</li>
</ul>
</li>
<li>正确的导航<ul>
<li>两点之间正确的距离和路线。</li>
<li>突发情况的快速反应（封路、限行）。</li>
</ul>
</li>
</ul>
<p>在即时配送业务中，骑行地图的重要性非常之高，同时很多问题确实非常具有行业特色，通过驾车地图的技术无法很有效的解决。</p>
<p>Note:<br>地图是一个非常庞大的业务，需要有充足的资源再考虑。</p>
<h2 id="9-基于签到数据的位置校正：交付点"><a href="#9-基于签到数据的位置校正：交付点" class="headerlink" title="9. 基于签到数据的位置校正：交付点"></a>9. 基于签到数据的位置校正：交付点</h2><p>目前主要问题：用户位置信息有很多错误，比如：</p>
<ul>
<li>用户选择错误，在订单发送到配送系统的时候，需要做一次用户坐标纠正，引导骑手到达正确的位置。</li>
<li>POI数据不精细，用户选择了比较粗的位置信息。现实中在一个小区里面，找到一个具体xx栋楼还是非常困难的。造成这种原因，一方面可能是用户选择不精细，还有一种可能，就是地图上没有具体楼栋的POI信息。</li>
</ul>
<p>在实际配送中，会要求骑手在完成交付后进行签到，这样就会积累大量的上报数据，对于后续进行精细化挖掘非常有帮助。这其中蕴含着极高的价值，具体来说有三方面：</p>
<ul>
<li>数据量大<ul>
<li>每天几千万订单，几十亿的轨迹数据。</li>
<li>可以充分覆盖每一个小区/楼栋/单元门。</li>
</ul>
</li>
<li>维度多样<ul>
<li>除了骑手签到和轨迹数据，我们还有大量的用户、商户和地图数据。</li>
<li>多种数据维度可以交叉验证，有效避免数据的噪音，提高挖掘结果精度。</li>
</ul>
</li>
<li>数据完备<ul>
<li>在局部（用户和商户）数据足够稠密，置信度比较高。</li>
</ul>
</li>
</ul>
<p>Note:<br>要求骑手完成订单签到是一种非常棒的操作，可以收集完整的订单信息（订单完成时间），修正用户位置。</p>
<h2 id="10-交付点挖掘的技术实战：挑战"><a href="#10-交付点挖掘的技术实战：挑战" class="headerlink" title="10. 交付点挖掘的技术实战：挑战"></a>10. 交付点挖掘的技术实战：挑战</h2><p>在数据挖掘实际过程中，整个挖掘过程，分为以下几个步骤：（1）基于地址分组；（2）数据去噪；（3）数据聚合；（4）置信度打分。其中主要技术挑战，主要在各种场景中保证数据挖掘质量和覆盖率，具体来说主要有三个挑战：</p>
<ul>
<li>数据去噪<ul>
<li>数据噪音来源比较多样，包括GPS的漂移、骑手误操作、违规操作等各种。一方面是针对噪音原因进行特殊处理（比如一些作弊行为），另一方面要充分发挥数据密度和数据量的优势，在保证尽量去除Outlier后，依然保持可观的数据量。能够同时使用其他维度的数据进行验证，也是非常重要的，甚至可以说数据多样性和正交性，决定了我们能做事情的上限。</li>
</ul>
</li>
<li>数据聚合<ul>
<li>不同区域的楼宇密度完全不一样，具有极强的Local属性，使用常规聚类方法，比较难做到参数统一，需要找到一种不过分依赖样本集合大小，以及对去噪不敏感的聚类算法。</li>
</ul>
</li>
<li>重名问题<ul>
<li>这个属于POI融合的一个子问题，判断两个POI信息是否应该合并。这个在用户地址中比较常见，用户提供的地址信息一样，但实际是两个地方。这种情况下，我们的处理原则是一方面要求纠正后坐标更符合骑手签到情况，另一方面新坐标的签到数据要足够稠密。</li>
</ul>
</li>
</ul>
<p>交付点挖掘的技术实战：效果</p>
<p>目前效果上看还是非常明显的。包括几个方面：</p>
<ul>
<li>骑手交付距离明显降低</li>
<li>单元门级别的高精度位置</li>
<li>目前的问题以及后续的优化点<br>如何提升其作为POI挖掘和发现手段的准确率？这里面有很多优化点，比如去重（交付点-位置信息的一一映射），POI信息补全和更新。<br>如何扩大数据渠道并做到信息整合？目前主要渠道还是骑手签到和轨迹数据，这个明显有更大的想象空间，毕竟每天在全国大街小巷，有几十万骑手在进行配送，除了前面（以及后面）提到的通过手机被动采集的数据，让骑手主动采集数据，也是不错的建设思路。只不过想要做好的话，需要建立一个相对闭环数据系统，包括上报、采集、清洗、加工、监控等等。</li>
</ul>
<p>Note:<br>这是一个很精细的工作，初期不太用考虑。</p>
<h2 id="11-更精细化的配送场景识别：感知"><a href="#11-更精细化的配送场景识别：感知" class="headerlink" title="11. 更精细化的配送场景识别：感知"></a>11. 更精细化的配送场景识别：感知</h2><p>地图技术，只能解决在室外场景的位置和导航问题。但配送在商家侧（到店、取餐）和用户侧（到客、交付）两个场景中，其实是发生在室内环境。在室内的骑手位置是在哪里、在做什么以及用户和商家在做什么，如果了解这些，就能解决很多实际问题。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d31c38f3.png" alt="问题"></p>
<p>“情景感知”具体方向：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-b067a0fc.png" alt="情景感知"></p>
<p>情景感知的目标就是做到场景的精细刻画（上图的上半部分），包含两个方面工作：</p>
<ol>
<li>配送节点的精确刻画<br>在ETA预估中已经展示过一些，不过之前主要还是基于骑手上报数据，这显然无法做到很高精确，必须引入更客观的数据进行描述。目前，我们选择的是WIFI和蓝牙的地理围栏技术作为主要辅助。</li>
<li>配送过程的精确刻画<br>骑手在配送过程中经常会切换方式，比如可能某个小区不让骑电动车，那骑手必须步行，再比如骑手在商家发生长时间驻留，那应该是发生了等餐的情况（用户侧同理）。目前，选择使用基于传感器的运动状态识别作为主要辅助。</li>
</ol>
<p>Note:<br>这是属于一个锦上添花的功能，初期不太用考虑。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2018/12/13/machine-learning-in-distribution-practice.html" target="_blank" rel="external">机器学习在美团配送系统的实践：用技术还原真实世界</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      机器学习在美团配送系统的实践：用技术还原真实世界-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>配送交付时间轻量级预估实践-笔记</title>
    <link href="http://noahsnail.com/2022/06/09/2022-06-09-%E9%85%8D%E9%80%81%E4%BA%A4%E4%BB%98%E6%97%B6%E9%97%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%A2%84%E4%BC%B0%E5%AE%9E%E8%B7%B5-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/09/2022-06-09-配送交付时间轻量级预估实践-笔记/</id>
    <published>2022-06-09T09:33:52.596Z</published>
    <updated>2022-06-10T06:24:02.248Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在点外卖的过程中，骑手的交付时间，即骑手到达用户附近下车后多久能送到用户手中，是一个非常重要的环节。下图是一个订单在整个配送链路的时间构成，时间轴最右部分描述了交付环节在整个配送环节中的位置。交付时间衡量的是骑手送餐时的交付难度，包括从骑手到达用户楼宇附近，到将餐品交付到用户手中的整个时间。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-e6cd38a4838c0e8e9b65eaf30abcd36374072.png" alt="配送链路的时间构成"></p>
<p>交付时间的衡量是非常有挑战的一件事，因为骑手在送餐交付到用户手中时会碰到不同的问题，例如：骑手一次送餐给楼宇内多个用户，骑手对于特定楼宇寻址特别困难，骑手在交付楼宇附近只能步行，老旧小区没有电梯，写字楼无法上楼，或者难以等到电梯等等。交付时间预估需要具备刻画交付难度的能力，在定价、调度等多个场景中被广泛使用。例如根据交付难度来确定是否调节骑手邮资，根据交付难度来确定是否调节配送运单的顺序，从而避免超时等等。总的来说，交付时间预估是配送业务基础服务的重要一环。</p>
<p>Note:<br>预估订单交付难度，根据难度调节骑手工资，对交付难度预估模型的准确度有很高要求，因为直接涉及骑手的收入，也涉及到公司的运营成本。</p>
<p>交付时间预估存在如下的困难：</p>
<ul>
<li>输入信息较少，且多为非数值型数据，目前能够被用来预估的仅有如下维度特征：交付地址、交付点的经纬度、区域、城市，适配常规机器学习模型需要重新整理且容易丢失信息。</li>
<li>计算性能要求很高。由于是基础服务，会被大量的服务调用，要求很高的性能，其中包括数据处理及RPC的时间。且该标准为CPU环境下的性能要求，而非GPU下的性能要求。</li>
</ul>
<p>总结起来，交付时间预估的问题，在于需要使用轻量级的解决方案来处理多种数据形式的非数值型数据，并提取有效信息量，得到相对准确的结果。在相同效果的前提下，更倾向于性能更优的方案。</p>
<p>Note:<br>时间预测要求性能高，更更倾向于性能更优的方案。</p>
<p>交付时间预估迭代了三个版本，分别为基于地址结构的树模型、向量召回方案以及轻量级的End-to-End的深度学习网络。同时介绍了如何在性能和指标之间取舍，以及模型策略迭代的中间历程。</p>
<h2 id="2-技术迭代路径"><a href="#2-技术迭代路径" class="headerlink" title="2. 技术迭代路径"></a>2. 技术迭代路径</h2><h3 id="2-1-树模型"><a href="#2-1-树模型" class="headerlink" title="2.1 树模型"></a>2.1 树模型</h3><p><strong>技术选型</strong><br>最早也是最容易被考虑到的是利用规则，核心思路是利用树结构衡量地址相似性，尽可能在相似的交付地址上积聚结构化数据，然后利用局部的回归策略，得到相对充裕的回归逻辑，而未能达到回归策略要求的则走兜底的策略。</p>
<p>观察用户填写地址以及联系实际中地址的层级结构，不难发现，一个地址可以由四级结构组成：地址主干词（addr）、楼宇号（building）、单元号（unit）、楼层（floor）。其中的地址主干词在实际中可能对应于小区名或者学校名等地标名称。通过分析，实际交付时长与楼层高低呈正相关关系，且不同交付地址的交付时长随楼层增加的变化幅度也有所区别，所以可以使用线性回归模型拟合楼层信息和交付时长的关系，而地址主干词、楼宇号、单元号作为其层级索引。但用户填写的地址中并不一定包含完整的四级结构，就会存在一定比例的缺失，所以利用这样的层级结构构建成一棵树，然后充分利用上一层已知的信息进行预估。预测时，只需根据结点的分支找到对应的模型即可，如果缺失，使用上一层结构进行预测。对于没有达到训练模型要求数据量的地址，使用其所在的区域平均交付时长作为交付时长的预估结果，这部分也可以看作区域信息，作为树结构的根节点。</p>
<p>Note:<br>从用户的角度来预估交付时间，聚类地址相似用户。</p>
<p><strong>迭代路径</strong><br>整体的思路是基于离散特征训练树模型，在树的结点上基于楼层训练线性回归模型。树结点训练分裂规则：（1）数据量大于阈值；（2）分裂后MAE（平均绝对误差）的和小于分裂前。考虑到数据的时效性，采用加权线性回归增加近期数据的权重。</p>
<h3 id="2-2-树模型-向量召回方案"><a href="#2-2-树模型-向量召回方案" class="headerlink" title="2.2 树模型+向量召回方案"></a>2.2 树模型+向量召回方案</h3><p><strong>技术选型</strong><br>向量召回作为主流的召回方案之一，被业界广泛使用，在使用LSH、PQ乘积量化等常用开源工具基础上，高维向量召回性能通常在毫秒量级。</p>
<p>而从算法上考虑，树模型中NLP地址解析结果能够达到模型使用要求的仅为70%+，剩余20%+的地址无法通过训练得到的模型从而只能走降级策略。利用高维向量来表达语义相似性，即利用向量来表达地址相似性，从而用相似数据对应的模型来替代相似但未被召回数据，将地址主干词进行Embedding后，摆脱主干词完全匹配的低鲁棒性。</p>
<p><strong>迭代路径</strong><br>整个技术路径较为清晰简单，即利用Word2Vec将charLevel字符进行Embedding，获得该地址的向量表示，并且融入GPS位置信息，设计相应兜底策略。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-aef4282e33391aa61343fd7d9ac0217691932.png" alt="向量召回方案决策路径"></p>
<p><strong>最终效果</strong></p>
<p>比较大地提升了整体策略的召回率，提升了12.20pp，对于未被上一版本树模型召回的地址，指标有了显著的提升，其中ME下降87.14s，MAE下降38.13s，1min绝对偏差率减小14.01pp，2min绝对偏差率减小18.45pp，3min绝对偏差率减小15.90pp。</p>
<h3 id="2-3-End-to-End轻量化深度学习方案"><a href="#2-3-End-to-End轻量化深度学习方案" class="headerlink" title="2.3 End-to-End轻量化深度学习方案"></a>2.3 End-to-End轻量化深度学习方案</h3><p><strong>技术选型</strong><br>在树模型的基础上，迭代到向量召回方案，整个模型的召回率有了较大幅度的增长，但仍然不是100%。分析发现，召回率提升的障碍在于NLP对于地址解析的覆盖率。</p>
<p>整个方案的出发点：<br>从模型复杂度考虑，同样仅仅使用地址信息的话，在提升模型VC维的基础上，使用其他的模型方案至少可以持平树模型的效果，如果在这基础上还能融入其他信息，那么对于原模型的基线，还能有进一步的提升。</p>
<p>考虑到不仅仅需要使用地址数据，同时需要使用GPS数据、大量ID类的Embedding，对于各类非数值类型的处理灵活性考虑，采用深度学习的方案，来保证多源且多类型特征能在同一个优化体系下优化学习。</p>
<p>工程上需要考虑的点：<br>交付模型作为基础模型，被广泛应用在路径构造、定价、ETA等各个业务中频繁调用，在树模型版本中，对于性能的要求为平均响应时间5ms，本方案需要考虑沿袭原业务的性能，不能显著增加计算耗时。</p>
<p>交付模型的难点在于非数值型特征多，信息获取形式的多样化，当前的瓶颈并不在于模型的复杂度低。如果可以轻量地获取信息及融合，没必要对Fusion后的信息做较重的处理方案。</p>
<p>所以整体的设计思路为：利用深度学习融合非数值型特征，在简单Fusion的基础上，直接得到输出结构，对于组件的选择，尽可能选用Flops较低的设计。该设计背后意图是，在充分使用原始输入信息，在尽可能避免信息损失的基础上，将非数值型的信息融入进去。并将信息充分融合，直接对接所需要的目标。而选用的融合组件结构尽可能保证高性能，且具备较高学习效率。这里分别针对地址选用了较为Robust的LSTM，针对GPS选用了自定义的双线性Embedding，兼顾性能和效果。</p>
<p><strong>迭代路径</strong><br>开始采用端到端的深度学习模型，这里首先需要解决的是覆盖率问题，直接采用LSTM读取charLevel的地址数据，经过全连接层直接输出交付时间。作为第一版本的数据，该版本数据基本持平树模型效果，但对于树模型未召回的20%数据，有了较大的提升。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-9fc27066166a8db5993839f41d047f7529437.png" alt="地址信息输入charLevel模型"></p>
<p>在采用charLevel的地址奏效后，开始采用加入用户地址GPS的信息，由于GPS为经纬度信息，非数值型数据，我们使用一种基于地理位置格点的双线性插值方法进行Embedding。该方案具备一定的扩展性，对不同的GPS均能合理得到Embedding向量，同时具备平滑特性，对于多对偏移较小的GPS点能够很好的进行支持。</p>
<p>最终方案将地址Embedding后，以及GPS点的Embedding化后，加入下单时间、城市ID、区域ID等特征后，再进行特征融合及变换，得到交付模型的时间预估输出。整个模型是一个端到端的训练，所有参数均为Trainable。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-96448d5a15db4dbc21db912e99c2a235132817.png" alt="模型结构示意图"></p>
<p>Note:<br>这个方案相对复杂很多，适合规模较大时使用，初期不太适合。</p>
<p><strong>扩展组件</strong></p>
<p>在证实End-to-End路径可行后，我们开始进行扩展组件建设，包括自定义损失函数、数据采样修正、全国模型统一等操作，得到一系列正向效果，并开发上线。</p>
<p><strong>特征重要性分析</strong></p>
<p>对于深度学习模型，我们有一系列特征重要性评估方案，这里采用依次进行Feature Permutation的方式，作为评估模型特征重要性的方式。</p>
<p>本方案的特征重要性：用户地址&gt;GPS经纬度&gt;其它特征。</p>
<p>注：在配送的其他案例中，商户GPS的经纬度重要性&gt;用户地址重要性&gt;用户GPS的经纬度重要性，不同学习目标下可能会有比较明显差别。</p>
<p><strong>最终效果</strong></p>
<p>End-to-End深度学习模型的最终效果较为显著：对于树模型及向量召回方案的最痛点，覆盖率得到彻底解决，覆盖率提升到100%。ME下降4.96s，MAE下降8.17s，1min绝对偏差率减小2.38pp，2min绝对偏差率减小5.08pp，3min绝对偏差率减小3.46pp。同时，对于之前树模型及向量召回方案未能覆盖到的运单，提升则更为明显。</p>
<h2 id="3-模型相关分析"><a href="#3-模型相关分析" class="headerlink" title="3. 模型相关分析"></a>3. 模型相关分析</h2><p>主要是对向量召回方案及深度学习方案进行了相应的性能分析，以便在线下确认性能指标，最终保证上线后性能均达到要求。</p>
<h3 id="3-1-向量召回性能"><a href="#3-1-向量召回性能" class="headerlink" title="3.1 向量召回性能"></a>3.1 向量召回性能</h3><p>最近邻搜索（Nearest Neighbor Search）指的是在高维度空间内找到与查询点最近点的问题。在数据样本小的时候，通过线性搜索就能满足需求，但随着数据量的增加，如达到上百万、上亿点时候，倾向于将数据结构化表示来更加精确地表达向量信息。</p>
<p>此时近似最近邻搜索ANN（Approximate Nearest Neighbor）是一个可参考的技术，它能在近似召回一部分之后，再进行线性搜索，平衡效率和精度。目前大体上有以下3类主流方法：基于树的方法，如K-D树等；基于哈希的方法，例如LSH；基于矢量量化的方法，例如PQ乘积量化。在工业检索系统中，乘积量化是使用较多的一种索引方法。</p>
<p>针对向量召回的工具，存在大量的开源实现，在技术选型的过程中，可以参照<a href="http://ann-benchmarks.com/" target="_blank" rel="external">ANN-Benchmarks</a>以及<a href="https://github.com/erikbern/ann-benchmarks/" target="_blank" rel="external">Erikbern/ANN-Benchmarks</a>中的性能评测结果。</p>
<h3 id="3-2-序列模块性能"><a href="#3-2-序列模块性能" class="headerlink" title="3.2 序列模块性能"></a>3.2 序列模块性能</h3><p>为了评测深度学习交付模型的性能瓶颈，首先对整个模型进行Profile，其中整个计算大部分消耗在序列模块处理部分。需要对序列模块的计算性能进行OP算子的加速。</p>
<h3 id="3-3-向量效果分析"><a href="#3-3-向量效果分析" class="headerlink" title="3.3 向量效果分析"></a>3.3 向量效果分析</h3><p>将向量召回与深度学习模型进行横向比较，二者中间过程均生成了高维向量。相较于向量召回，深度学习模型带来的提升主要来自于哪里？有监督的lstm学习到的Embedding向量与自监督的Word2Vec得到的向量在地址相似性计算中有多大差别，孰优孰劣？</p>
<p><strong>首先，我们分析第一个问题，End-to-End模型提升主要来自哪里？</strong><br>经过测试可知，深度学习模型带来的提升主要来自对地址中冗余信息（相较于向量召回）的利用，其次是多个新特征的加入。另外，对比两个End-to-End模型的效果，地址附属信息中也包含着对匹配地址有用的信息。</p>
<p><strong>针对第二个问题，有监督的End-to-End学习到的Embedding向量，与自监督的Word2Vec得到的向量在地址相似性计算中有多大差别，孰优孰劣？</strong><br>采用地址主干词代替完整地址，作为End-to-End模型的输入进行训练，其他信息均保持不变。使用地址主干词训练得到的Embedding向量，套用到向量召回方案中。</p>
<p>从评估结果来看，对于不同的阈值，End-to-End的表现差异相对Word2Vec较小。相同阈值下，End-to-End召回率更高，但是效果不如Word2Vec。</p>
<p>从相似计算结果看，End-to-End模型会把一些语义不相关但是交付时间相近的地址，映射到同一个向量空间，而Word2Vec则是学习一个更通用的文本向量表示。</p>
<p>如果想要针对更为复杂的目标和引入更多信息，可以使用End-to-End框架；只是计算文本相似性，从实验结果看，Word2Vec更好一些。同时，通过查看Case也可以发现，End-to-End更关注结果相似性，从而召回一部分语义上完全不相关的向量。两个模型目标上的不同，从而导致了结果的差异。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2019/10/10/distribution-time-prediction-practice.html" target="_blank" rel="external">配送交付时间轻量级预估实践</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      配送交付时间轻量级预估实践-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>即时配送的订单分配策略：从建模和优化-笔记</title>
    <link href="http://noahsnail.com/2022/06/07/2022-06-07-%E5%8D%B3%E6%97%B6%E9%85%8D%E9%80%81%E7%9A%84%E8%AE%A2%E5%8D%95%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E4%BB%8E%E5%BB%BA%E6%A8%A1%E5%92%8C%E4%BC%98%E5%8C%96-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/07/2022-06-07-即时配送的订单分配策略-从建模和优化-笔记/</id>
    <published>2022-06-07T07:13:09.856Z</published>
    <updated>2022-06-09T09:27:38.564Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>外卖平台中，配送时效、准时率作为履约环节的重要指标，是外卖平台的核心竞争力之一。要提升用户的配送时效和准时率，最直接的方法是配备较多的配送员，扩大运力规模，然而这也意味着配送成本会很高。怎么在配送体验和配送成本之间取得最佳的平衡，是即时配送平台生存的根基和关键所在。在用户满意度持续提升的同时，降低配送成本、提高骑手满意度、驱动配送系统的自动化和智能化，是外卖配送团队要解决的难题。</p>
<p>Note:<br>招募更多的配送员，配送成本很高，应该想办法减少成本，即用更少的骑手配送更多的订单。</p>
<h2 id="2-即时配送智能调度系统"><a href="#2-即时配送智能调度系统" class="headerlink" title="2. 即时配送智能调度系统"></a>2. 即时配送智能调度系统</h2><p><strong>措施</strong></p>
<ol>
<li>首先通过优化设定配送费以及预计送达时间来调整订单结构；</li>
<li>在接收订单之后，考虑骑手位置、在途订单情况、骑手能力、商家出餐、交付难度、天气、地理路况、未来单量等因素，在正确的时间将订单分配给最合适的骑手，并在骑手执行过程中随时预判订单超时情况并动态触发改派操作，实现订单和骑手的动态最优匹配；</li>
<li>系统派单后，为骑手提示该商家的预计出餐时间和合理的配送线路，并通过语音方式和骑手实现高效交互；</li>
<li>在骑手送完订单后，系统根据订单需求预测和运力分布情况，告知骑手不同商圈的运力需求情况，实现闲时的运力调度。</li>
</ol>
<p><strong>结果</strong><br>通过上述技术和模式的引入，持续改善了用户体验和配送成本：</p>
<ol>
<li>订单的平均配送时长从2015年的41分钟，下降到32分钟，进一步缩短至28分钟；</li>
<li>另一方面，在骑手薪资稳步提升的前提下，单均配送成本也有了20%以上的缩减。</li>
</ol>
<p>Note:</p>
<ul>
<li>缩短配送时间，如果配送时间本来就很短，可以考虑稍微牺牲配送时间，提高其它指标</li>
<li>降低配送成本，在保证订单完成率的情况下减少配送骑手，骑手多单配送并行，减少每单配送成本</li>
</ul>
<h2 id="3-订单分配问题"><a href="#3-订单分配问题" class="headerlink" title="3. 订单分配问题"></a>3. 订单分配问题</h2><h3 id="3-1-订单分配的发展"><a href="#3-1-订单分配的发展" class="headerlink" title="3.1 订单分配的发展"></a>3.1 订单分配的发展</h3><p>外卖订单的分配问题一般可建模为带有若干复杂约束的DVRP（Dynamic Vehicle Routing Problem）问题。这类问题一般可表述为：有一定数量的骑手，每名骑手身上有若干订单正在配送过程中，在过去一段时间（如1分钟）内产生了一批新订单，已知骑手的行驶速度、任意两点间的行驶距离、每个订单的出餐时间和交付时间（骑手到达用户所在地之后将订单交付至用户所需的时间），那么如何将这批新订单在正确的时间分配至正确的骑手，使得用户体验得到保证的同时，骑手的配送效率最高。</p>
<p>订单和服务提供方的匹配问题是一个非常关键的问题。在外卖行业发展初期主要依赖骑手抢单模式和人工派单模式。</p>
<ul>
<li>抢单模式<br>抢单模式的优势是开发难度低，服务提供者（如司机、骑手）的自由度较高，可以按照自身的需要进行抢单，但其缺点也很明显：骑手/司机只考虑自身的场景需求，做出一个局部近优的选择，然而由于每个骑手掌握的信息有限又只从自身利益出发来决策，导致配送整体效率低下，从用户端来看，还存在大量订单无人抢或者抢了之后造成服务质量无法保证（因为部分骑手无法准确预判自己的配送服务能力）的场景，用户体验比较差。</li>
<li>人工派单模式<br>人工派单的方式，从订单分配的结果上来看，<strong>一般优于抢单模式</strong>。在订单量、骑手数相对比较少的情形下，有经验的调度员可以根据订单的属性特点、骑手的能力、骑手已接单情况、环境因素等，在骑手中逐个比对，根据若干经验规则挑选一个比较合适的骑手来配送。一般而言，人工调度一个订单往往至少需要半分钟左右的时间才能完成。然而，随着外卖订单规模的日益增长，在热门商圈（方圆3公里左右）的高峰时段，1分钟的时间内可能会有50单以上，在这种情况下，要求人工调度员每1-2秒钟做出一次合理的调度决策，显然是不可能的。另一方面，由于即时配送过程的复杂性，要做出合理的匹配决策，要求调度员对配送范围内各商家的出餐速度、各用户地址的配送难度（例如有的写字楼午高峰要等很长时间的电梯）、各骑手自身的配送工具/熟悉的商家和用户范围/工作习惯等等要有非常深入的了解，在此基础上具备统筹优化能力，考虑未来进单量、减少空驶等因素，做出全局近优的选择，这对人工调度员而言，又是一项极其艰巨的任务。</li>
</ul>
<p>系统派单具备如下优势：</p>
<ul>
<li>系统可以在全局层面上掌握和配送有关的骑手、商家、用户、订单等各类信息，在此基础上，可以做出全局较优的方案，从而提升配送效率和配送体验，减少配送成本； </li>
<li>显著减轻人工调度员的工作，从而降低人工成本，人工调度员只需要在一些意外场景（如配送员出现紧急情况无法继续配送等）发生的时候进行干预即可。</li>
</ul>
<p>Note:<br>派单模式与抢单模式并存，派单一般优于抢单</p>
<h3 id="3-2-即时配送大数据平台"><a href="#3-2-即时配送大数据平台" class="headerlink" title="3.2 即时配送大数据平台"></a>3.2 即时配送大数据平台</h3><p>美团外卖每天产生巨量的订单配送日志、行驶轨迹数据。通过对配送大数据进行分析、挖掘，会得到每个用户、楼宇、商家、骑手、地理区域的个性化信息，以及有关各地理区块骑行路径的有效数据，那么订单智能分配系统的目标就是基于大数据平台，根据订单的配送需求、地理环境以及每名骑手的个性化特点，实现订单与骑手的高效动态最优匹配，从而为每个用户和商家提供最佳的配送服务，并降低配送成本。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-238de0c6.png" alt="订单分配系统"></p>
<p>即时配送大数据平台实现对骑手轨迹数据、配送业务数据、特征数据、指标数据的全面管理和监控，并通过模型平台、特征平台支持相关算法策略的快速迭代和优化。</p>
<ul>
<li><strong>机器学习模块</strong>负责从数据中寻求规律和知识，例如对商家的出餐时间、到用户所在楼宇上下楼的时间、未来的订单、骑行速度、红绿灯耗时、骑行导航路径等因素进行准确预估，为调度决策提供准确的基础信息；</li>
<li><strong>运筹优化模块</strong>则在即时配送大数据平台以及机器学习的预测数据基础上，采用最优化理论、强化学习等优化策略进行计算，做出全局最优的分配决策，并和骑手高效互动，处理执行过程中的问题，实现动态最优化。</li>
</ul>
<h3 id="3-3-订单分配问题建模"><a href="#3-3-订单分配问题建模" class="headerlink" title="3.3 订单分配问题建模"></a>3.3 订单分配问题建模</h3><p>准确建模是实际决策优化项目的第一步，也是最关键的一步。准确建模，包括两个方面的问题：</p>
<ul>
<li>正确理解了实际业务场景的优化问题，并且通过某种形式化语言进行了准确描述；</li>
<li>建立的模型中，涉及的各类参数和数据，能够准确得获取。</li>
</ul>
<p>在上述两个前提下，采用相应的高效优化算法求解模型所得到的最优解，就是符合实际场景需求的最优决策方案。第一个问题，一般是通过业务调研、分析并结合建模工具来得到；而解决第二个问题，则更多地需要依赖数据分析、机器学习、数据挖掘技术结合领域知识，对模型进行精确的量化表达。</p>
<p>一个决策优化问题的数学模型，一般包括三个要素：</p>
<ul>
<li>决策变量，决策变量说明了希望算法来帮助做哪些决策</li>
<li>优化目标，优化目标则是指通过调整决策变量，使得哪些指标得到优化</li>
<li>约束条件，约束条件则是在优化决策的过程中所考虑的各类限制性因素</li>
</ul>
<p>即时配送场景下的订单分配问题，符号定义：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-019f9815.png" alt="符号定义"></p>
<p>在即时配送调度场景下，决策变量包括各个订单需要分配的骑手，以及骑手的建议行驶路线：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c9a81df3.png" alt="决策变量"></p>
<p>优化目标一般包括希望用户的单均配送时长尽量短、骑手付出的劳动尽量少、超时率尽量低等。可表述为：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d418f611.png" alt="优化目标"></p>
<p>实际场景下的订单分配问题，设置目标函数是一个较为复杂的问题。</p>
<ol>
<li>该优化问题是多目标的，且各个目标在不同时段、不同环境下会有差别。</li>
<li>缺乏有助于量化优化目标的数据。针对该难题，首先通过深入调研业务痛点和目标，在此基础上，采用机理和数据相结合的办法，由人工设定目标函数的结构，通过仿真系统和实际数据去设定目标函数的参数，来确定最终采用的目标函数形态。</li>
</ol>
<p>即时配送调度问题的约束条件类型：</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-a47cd4c2.png" alt="约束条件类型"></p>
<p>除了以上约束外，有时还需要考虑部分订单只能由具备某些特点的骑手来配送、载具的容量限制等。</p>
<p>Note:<br>载具容量限制，订单类型要求订单只能单独配送，不能与其它订单混合在一起。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d2ce29cb.png" alt="建模"></p>
<p>以上只是针对给定的一批订单进行匹配决策的优化问题在建模时所需考虑的部分因素。在外卖配送场景中，希望的不是单次决策的最优，而是策略在一段时间应用后的累积收益最大。不追求某一个订单的指派是最优的，而是希望一天下来，所有的订单指派结果整体上是全局最优的。在进行决策的时候，既需要考虑已确定的订单，还需要考虑未来的尚未确定的订单。运筹优化领域中的马尔可夫决策过程描述的就是这样的一类在不确定、信息不完备环境下的序贯决策优化问题。</p>
<p>Note:<br>最简单的方法是贪心，追求当前订单最优指派，实现简单，但可能不是全局最优的。追求全局最优复杂，不一定比局部最优好，只有全局最优明显优于局部最优时，才值得上。</p>
<p>即时配送订单分配场景下的数据包括两类：</p>
<ul>
<li>直接通过业务系统采集可获取的数据，例如订单数据、骑手负载数据、骑手状态数据等。</li>
<li>无法直接采集得到，需要预测或统计才能获取的数据，如商户出餐时间、用户驻留时间（骑手到达用户处将订单交付给用户的时间）、骑手配送能力等。</li>
</ul>
<p>第一类数据的获取一般由业务系统、骑手端App直接给出，其精度通过提升工程质量或操作规范可有效保证；而第二类数据的获取是即时配送调度的关键难点之一。</p>
<p>在订单的配送过程中，骑手在商家、用户处的取餐和交付时间会占到整个订单配送时长的一半以上。商家出餐时间的长短，跟品类、时段、天气等因素都有关，而交付时间更为复杂，用户在几楼，是否处于午高峰时段，有没有电梯等等，都会影响骑手交付订单给用户的时间。为解决这些问题，利用机器学习工具，利用历史的骑手到店、等餐、取餐的数据，并充分考虑天气等外部因素的影响，建立全面反映出餐能力的预测模型，并通过实时维度的特征进行修正，可以得到准确的出餐/交付时间估计。</p>
<p>Note:<br>骑手在路上的时间比较简单，也比较好估计，就是距离/骑手速度。但等餐、取餐时间，用户交付时间涉及的因素比较多，也比较杂。例如商户的订单积压情况，用户的楼层、电梯情况等。这也是将配送时间分成多段预测的原因之一。整体预测可能偏差较大，分成几部分，其中一部分的时间可以更准确的预测。</p>
<p>优化算法的作用则是在构建的解空间里找到最优的策略。配送调度问题属于典型的NP-Hard优化问题，解空间巨大。如何设计好的优化算法，从庞大的解空间中搜索得到一个满意解是一个很大的挑战，即时配送对于优化算法的另一个要求是高实时性。</p>
<p>针对此难题，采用了两个关键思路。一是问题特征分析。针对配送调度的场景，这个问题可以被分解为两个层次：骑手路径优化和订单分配方案的优化。骑手路径优化问题要解决的问题是：在新订单分配至骑手后，确定骑手的最佳配送线路；而订单分配优化问题要解决的问题是：把一批订单分配至相应的骑手，使得关注的指标（如配送时长、准时率、骑手的行驶距离等）达到最优。这两个问题的关系是：通过订单分配优化算法进行初始的订单分配，然后通过骑手路径优化算法获取各骑手的最佳行驶路线，进而，订单分配优化算法根据骑手路径优化结果调整分配方案。这两个层次不断反复迭代，最终获得比较满意的解。第二个思路是跨学科结合。订单分配问题在业内有两类方法，第一类方法是把订单分配问题转换成图论中的二分图匹配问题来解决。这种做法是一个不错的近似方案，优点是实现简单计算速度快，但它的缺点是会损失一部分满意解。第二类方法是直接采用个性化的算法进行订单分配方案的优化，优点是不损失获得满意解的可能性，但实际做起来难度较大。结合领域知识、优化算法、机器学习策略以及相关图论算法，基于分解协调思想，设计了骑手路径优化算法和订单分配优化算法。进一步，利用强化学习的思想，引入了离线学习和在线优化相结合的机制，离线学习得到策略模型，在线通过策略迭代，不断寻求更优解。通过不断地改进算法，在耗时下降的同时，算法的优化效果提升50%以上。为了有效降低算法运行时间，对优化算法进行并行化，并利用并行计算集群进行快速处理。</p>
<p>Note:<br>批量分配算法，二分图匹配问题，简单速度快，第2种需要集群。</p>
<p>即时配送过程的一个突出特点是线下的突发因素多、影响大，突发事件造成的一个恶劣结果是，虽然在指派订单的时刻，所指派的骑手是合理的，然而过了一段时间之后，由于骑手、订单等状态发生了变化，会变得不够合理。现有方法主要通过人工来完成，即：配送站长/调度员在配送信息系统里，查看各个骑手的位置、手中订单的状态及商户/用户的位置/期望送达时间等信息，同时接听骑手的电话改派请求，在此基础上，分析哪些订单应该改派，以及应该改派给哪位骑手，并执行操作。</p>
<p>Note:<br>突发事件需要人工介入(2017年)。</p>
<p>针对即时配送的不确定性特点，提出了两点创新：一是延迟调度策略，即在某些场景订单可以不被指派出去，在不影响订单超时的情况下，延迟做出决策；二是系统自动改派策略，即订单即便已经派给了骑手，后台的智能算法仍然会实时评估各个骑手的位置、订单情况，并帮助骑手进行分析，判断是否存在超时风险。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-7612e7e6.png" alt="随机性应对"></p>
<p>针对即时配送场景，建立了相应的仿真模型，开发了配送仿真系统。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-2d610033.png" alt="仿真系统"></p>
<p>Note:<br>算法需要在仿真系统上进行测试，调整。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2017/10/11/o2o-intelligent-distribution.html" target="_blank" rel="external">即时配送的订单分配策略：从建模和优化</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      即时配送的订单分配策略：从建模和优化-笔记
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>美团智能配送系统的运筹优化实战-笔记</title>
    <link href="http://noahsnail.com/2022/06/07/2022-06-07-%E7%BE%8E%E5%9B%A2%E6%99%BA%E8%83%BD%E9%85%8D%E9%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0/"/>
    <id>http://noahsnail.com/2022/06/07/2022-06-07-美团智能配送系统的运筹优化实战-笔记/</id>
    <published>2022-06-07T01:29:46.250Z</published>
    <updated>2022-06-09T09:27:39.916Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<p>本文为美团文章学习的笔记整理。</p>
<h2 id="1-美团智能配送系统架构"><a href="#1-美团智能配送系统架构" class="headerlink" title="1. 美团智能配送系统架构"></a>1. 美团智能配送系统架构</h2><p>美团配送业务场景复杂，单量规模大。在大规模的业务场景下，配送智能化就变得非常重要，而智能配送的核心就是做资源的优化配置。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-4d342ea038cfd9edcb3a741f247057df199909.png" alt="资源优化配置"></p>
<p>外卖配送既有线上的业务，也有线下的复杂运营。配送连接订单需求和运力供给。为了达到需求和供给的平衡，不仅要在线下运营商家、运营骑手，还要在线上将这些需求和运力供给做合理的配置，其目的是提高整体的效率。只有将配送效率最大化，才能带来良好的顾客体验，实现较低的配送成本。资源优化配置的过程，实际上是有分层的。在美团的理解中，可以分为三层：</p>
<ol>
<li>基础层是结构优化，它直接决定了配送系统效率的上限。这种基础结构的优化，周期比较长，频率比较低，包括配送网络规划、运力结构规划等等。</li>
<li>中间层是市场调节，相对来说是中短期的，主要通过定价或者营销手段，使供需达到一个相对理想的平衡状态。</li>
<li>再上层是实时匹配，通过调度做实时的资源最优匹配。 实时匹配的频率是最高的，决策的周期也最短。</li>
</ol>
<p>Note:</p>
<ul>
<li>基础层：例如调整运力，周期较长，频率较低，运力调整需要考虑的因素较多</li>
<li>中间层：动态定价，营销活动等，可以提前预估一定时间范围内的单量和运力，提前进行运力调度或动态定价</li>
<li>更高层：骑手的实时调度、实时订单分配</li>
</ul>
<p><img src="http://noahsnail.com/images/meituan/meituan-4d342ea038cfd9edcb3a741f247057df199909.png" alt="智能配送系统架构"></p>
<p>如上图所示，右边三个子系统分别对应这三层体系，最底层是规划系统，中间层是定价系统，最上层是调度系统。运筹优化是调度系统、定价系统、规划系统的核心技术。</p>
<p>Note:</p>
<ul>
<li>机器学习系统：例如ETA预估</li>
<li>调度系统：根据订单进行骑手的分配</li>
<li>LBS系统：路径规划</li>
<li>定价系统：根据时间、天气、运力情况进行动态定价</li>
<li>规划系统：可以使用行政区域划分，在此基础上再进行调整</li>
</ul>
<h2 id="2-实战业务项目"><a href="#2-实战业务项目" class="headerlink" title="2. 实战业务项目"></a>2. 实战业务项目</h2><h3 id="2-1-智能区域规划"><a href="#2-1-智能区域规划" class="headerlink" title="2.1 智能区域规划"></a>2.1 智能区域规划</h3><p><img src="http://noahsnail.com/images/meituan/meituan-357307a272f9223942b98515c2934ea7462635.png" alt="配送网络基本概念"></p>
<p>配送连接的是商家、顾客、骑手三方，配送网络决定了这三方的连接关系。当用户打开App，查看哪些商家可以点餐，这由<strong>商家配送范围</strong>决定，每个商家的配送范围不一样。用户在美团点外卖，为他服务的骑手是谁呢？又是怎么确定的呢？这些是由<strong>配送区域边界</strong>来决定的，配送区域边界指的是一些商家集合所对应的范围。</p>
<p>Note:</p>
<ul>
<li>商家：商家配送范围</li>
<li>骑手：配送区域边界</li>
</ul>
<p>在传统物流中，影响末端配送效率最关键的点，是配送员对他所负责区域的熟悉程度。越熟悉，配送效率就会越高。即时配送场景也类似，每个骑手需要尽量固定地去熟悉一片商家或者配送区域。对于管理而言，站点的管理范围也比较明确。如果有新商家上线，也很容易确定由哪个配送站来提供服务。所以，这个问题有很多运营管理的诉求在其中。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-08860973ff368a440b77ddbd16d07eb5994870.png" alt="区域规划影响配送效率"></p>
<p>区域规划项目要解决的问题：1.配送区域里的商家不聚合；2.区域奇形怪状，空驶严重；3.站点的大小不合理。什么是好的区域规划方案？基于统计分析的优化目标设定。</p>
<p>优化的三要素是：目标、约束、决策变量。</p>
<ol>
<li>首先要确定优化目标。区域规划影响的主要是骑手的顺路性、空驶率，也就是骑手平均为每一单付出的路程成本。所以，将问题的业务目标定为优化骑手的单均行驶距离。基于现有的大量区域和站点积累的数据，做大量的统计分析后，可以定义出这样几个指标：商家聚合度、订单的聚合度、订单重心和商家重心的偏离程度。数据分析结果说明，这几个指标和单均行驶距离的相关性很强。经过这一层的建模转化，问题明确为优化这三个指标。</li>
<li>梳理业务约束。区域单量有上限和下限；区域之间不能有重合，不能有商家归多个区域负责；所有的AOI(area of interest)不能有遗漏，都要被某个区域覆盖到，不能出现商家没有站点的服务；区域边界必须沿路网。</li>
</ol>
<p>在目标和约束条件确定了之后，整体技术方案分成三部分：</p>
<ol>
<li>首先，根据三个目标函数，确定商家最优集合。</li>
<li>配送团队和美团地图团队进行合作。先利用路网信息，把城市切成若干互不重叠的多边形，然后根据计算几何，将一批商家对应的多边形拼成完整的区域边界。</li>
<li>最后，用美团自主研发的配送仿真系统进行仿真评测。</li>
</ol>
<p>在区域规划过程中，人工介入还是非常必要的。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c0b3063d64e2d96176ad35dfe6bd3e03819986.png" alt="落地应用"></p>
<h3 id="2-2-智能骑手排班"><a href="#2-2-智能骑手排班" class="headerlink" title="2.2 智能骑手排班"></a>2.2 智能骑手排班</h3><p><img src="http://noahsnail.com/images/meituan/meituan-e5f5eff5a89854c0bbf6c67ea3873140188458.png" alt="外卖订单"></p>
<p>外卖配送场景的订单“峰谷效应”非常明显。上图是一个实际的进单曲线。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-d1992cc627da30c9647319e10296a3c7106485.png" alt="排班方案选型"></p>
<p>配送团队最终选用的是按组排班的方式，把所有骑手分成几组，规定每个组的开工时段。然后大家可以按组轮岗，每个人的每个班次都会轮到。算法要有自己的优化目标，为了解决这个问题，首先要做设计决策变量，把时间做了离散化，以半小时为粒度。对于一天来讲，只有48个时间单元，决策空间大幅缩减。然后，目标定为运力需求满足订单量的时间单元最多。在建模层面，标准化和通用的模型才是最优选。美团把人数做了归一化，算法分配每个班次的骑手比例，但不分人数。在算法决策的时候，不决策人数、只决策比例，这样也可以把单量进行归一化。每个时间单元的进单量除以每天峰值时间单元的单量，也变成了0~1之间的数字。如果某个时间单元内人数比例大于单量比例，叫作运力得到满足。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-9b22391d9f14336717e2f4a032ae0114152458.png" alt="决策变量及目标设计"></p>
<p>算法核心思想：基于约束条件，根据启发式算法构造初始方案，再用局部搜索迭代优化。</p>
<h3 id="2-3-骑手路径规划"><a href="#2-3-骑手路径规划" class="headerlink" title="2.3 骑手路径规划"></a>2.3 骑手路径规划</h3><p>骑手的路径规划问题，不是简单的路线规划，一个骑手身上有很多配送任务，这些配送任务存在各种约束，怎样选择最优配送顺序去完成所有任务，这是一个NP难问题。当有5个订单、10个任务点的时候，就存在11万多条可能的顺序。系统派单、系统改派，都依赖路径规划算法。在骑手端，给每个骑手推荐任务执行顺序。路径规划算法核心的诉求是优化效果必须是稳定的好。不能这次的优化结果好，下次就不好。另外，运行时间一定要短。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-c65652c6f08d6c73770e9de9288a348b154474.png" alt="核心设计思想"></p>
<p>求解路径规划这类问题经历过的阶段：起初，采用类似遗传算法的迭代搜索算法，但是随着业务的单量变大，发现算法耗时太慢，根本不可接受。然后，改为大规模邻域搜索算法，但算法依然有很强的随机性，因为没有随机性在就没办法得到比较好的解。而这种基于随机迭代的搜索策略，带来很强的不确定性，在问题规模大的场景会出现非常多的Bad Case。另外，迭代搜索耗时太长了。在这个项目中，基本可以确定这样的技术路线。首先，只能做启发式定向搜索，不能在算法中加随机扰动。不能允许同样的输入在不同运行时刻给出不一样的优化结果。然后，不能用普通迭代搜索，必须把这个问题结构特性挖掘出来，做基于知识的定制化搜索。</p>
<p>美团认为，最重要的是看待这个问题的视角。这里的路径规划问题，对应的经典问题模型，是开环TSP问题，或是开环VRP的变种么？可以是，也可以不是。美团做了一个有意思的建模转换，把它看作流水线调度问题：每个订单可以认为是job；一个订单的两个任务取餐和送餐，可以认为是一个job的operation。任意两个任务点之间的通行时间，可以认为是序列相关的准备时间。每一单承诺的送达时间，包括预订单和即时单，可以映射到流水线调度问题中的提前和拖期惩罚上。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-325594bc4c7e9dde88c0c05ac8723ac2138345.png" alt="问题建模转换"></p>
<p>美团把一个经典的基于问题特征的启发式算法做了适当适配和改进，得到了非常好的效果。相比于之前的算法，耗时下降70%，优化效果不错。</p>
<h3 id="2-4-订单智能调度"><a href="#2-4-订单智能调度" class="headerlink" title="2.4 订单智能调度"></a>2.4 订单智能调度</h3><p>配送调度场景，可以用数学语言描述。它不仅是一个业务问题，更是一个标准的组合优化问题，并且是一个马尔可夫决策过程。并非对于某个时刻的一批订单做最优分配就足够，还需要考虑整个时间窗维度，每一次指派对后面的影响。要考虑长周期的优化，而不是一个静态优化问题。</p>
<p><img src="http://noahsnail.com/images/meituan/meituan-30e6df539239ed15cb77f5e67fec4d69454401.png" alt="调度问题的数学描述"></p>
<p>这个问题的挑战：</p>
<ol>
<li>性能要求极高，要做到万单对万人的秒级求解。</li>
<li>动态性。作为一个MDP问题，需要考虑动态优化场景，这涉及大量的预估环节。目前的思路，是通过其它的建模转换手段进行解决。</li>
<li>配送业务的随机因素多。比如商家的出餐时间，也许是很长时间内都无法解决的随机性。就连历史每一个已完成订单，商家出餐时间的真值都很难获得。商家出餐时刻不确定，这个随机因素永远存在，并且非常制约配送效率的提升。另外，在顾客位置交付的时间也不确定。写字楼工作日的午高峰，上电梯、下电梯的时间，很难准确进行预估。对于骑手来说，平台没法规定每个骑手的任务执行顺序。骑手在配送过程中可以自由发挥，所以骑手执行顺序的不确定性也一直存在。</li>
</ol>
<p><img src="http://noahsnail.com/images/meituan/meituan-e89cfca4ff8c3881050a9016298a5542134543.png" alt="问题挑战"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tech.meituan.com/2020/02/20/meituan-delivery-operations-research.html" target="_blank" rel="external">美团智能配送系统的运筹优化实战</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      美团智能配送系统的运筹优化实战
    
    </summary>
    
      <category term="外卖相关" scheme="http://noahsnail.com/categories/%E5%A4%96%E5%8D%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="外卖" scheme="http://noahsnail.com/tags/%E5%A4%96%E5%8D%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1528. Shuffle String</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1528-Shuffle-String/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1528-Shuffle-String/</id>
    <published>2022-05-07T06:17:12.453Z</published>
    <updated>2022-05-07T06:37:40.666Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Shuffle_String.png" alt="Shuffle String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，根据要求，按顺序将字母填到对应位置即可。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></div><div class="line">        res = [<span class="string">'0'</span>] * len(s)</div><div class="line">        <span class="keyword">for</span> index, pos <span class="keyword">in</span> enumerate(indices):</div><div class="line">            res[pos] = s[index]</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/shuffle-string/" target="_blank" rel="external">https://leetcode.com/problems/shuffle-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1528. Shuffle String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1323. Maximum 69 Number</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1323-Maximum-69-Number/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-1323-Maximum-69-Number/</id>
    <published>2022-05-07T05:49:40.505Z</published>
    <updated>2022-05-07T06:01:26.099Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_69_Number.png" alt="Maximum 69 Number"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，从左到右，找到第一个<code>6</code>，将其改为<code>9</code>，返回更改之后的数字。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> <span class="params">(self, num: int)</span> -&gt; int:</span></div><div class="line">        digits = list(str(num))</div><div class="line">        <span class="keyword">for</span> index, digit <span class="keyword">in</span> enumerate(digits):</div><div class="line">            <span class="keyword">if</span> digit == <span class="string">'6'</span>:</div><div class="line">                digits[index] = <span class="string">'9'</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(digits))</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> <span class="params">(self, num: int)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> int(str(num).replace(<span class="string">'6'</span>, <span class="string">'9'</span>, <span class="number">1</span>))</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-69-number/" target="_blank" rel="external">https://leetcode.com/problems/maximum-69-number/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1323. Maximum 69 Number
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 2078. Two Furthest Houses With Different Colors</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2078-Two-Furthest-Houses-With-Different-Colors/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2078-Two-Furthest-Houses-With-Different-Colors/</id>
    <published>2022-05-07T03:08:03.317Z</published>
    <updated>2022-05-07T05:41:37.983Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Two_Furthest_Houses_With_Different_Colors.png" alt="Two Furthest Houses With Different Colors"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> colors[i] != colors[j]:</div><div class="line">                    distance = max(distance, j - i)</div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，贪心算法，从右往左找与左边第一个不同颜色的房子，从左往右找与右边第一个不同颜色的房子，取距离最大的一个，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> colors[i] != colors[<span class="number">0</span>]:</div><div class="line">                distance = max(distance, i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> colors[i] != colors[length - <span class="number">1</span>]:</div><div class="line">                distance = max(distance, length - <span class="number">1</span> - i)</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 3，Version 2的另一个版本，通过一次循环完成，O(N)。</p>
<ul>
<li>Version 3</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, colors: List[int])</span> -&gt; int:</span></div><div class="line">        distance = <span class="number">0</span></div><div class="line">        length = len(colors)</div><div class="line">        <span class="keyword">for</span> index, color <span class="keyword">in</span> enumerate(colors):</div><div class="line">            <span class="keyword">if</span> color != colors[<span class="number">0</span>]:</div><div class="line">                distance = max(distance, index)</div><div class="line">            <span class="keyword">if</span> color != colors[length<span class="number">-1</span>]:</div><div class="line">                distance = max(distance, length - <span class="number">1</span> - index)</div><div class="line">        <span class="keyword">return</span> distance</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/two-furthest-houses-with-different-colors/" target="_blank" rel="external">https://leetcode.com/problems/two-furthest-houses-with-different-colors/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 2078. Two Furthest Houses With Different Colors
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 2016. Maximum Difference Between Increasing Elements</title>
    <link href="http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2016-Maximum-Difference-Between-Increasing-Elements/"/>
    <id>http://noahsnail.com/2022/05/07/2022-05-07-Leetcode-2016-Maximum-Difference-Between-Increasing-Elements/</id>
    <published>2022-05-07T01:31:35.994Z</published>
    <updated>2022-05-07T05:40:43.075Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Difference_Between_Increasing_Elements.png" alt="Maximum Difference Between Increasing Elements"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        length = len(nums)</div><div class="line">        diff = <span class="number">-1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</div><div class="line">                    diff = max(diff, nums[j] - nums[i])</div><div class="line">        <span class="keyword">return</span> diff</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，从左向右遍历，<code>minimum</code>始终保持左半部分最小值，如果当前数字<code>num</code>比<code>minimum</code>大，求二者的<code>difference</code>，取<code>difference</code>最大值，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        length = len(nums)</div><div class="line">        diff = <span class="number">-1</span></div><div class="line">        minimum = nums[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            <span class="keyword">if</span> num &gt; minimum:</div><div class="line">                diff = max(diff, num - minimum)</div><div class="line">            minimum = min(minimum, num)</div><div class="line">        <span class="keyword">return</span> diff</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-difference-between-increasing-elements/" target="_blank" rel="external">https://leetcode.com/problems/maximum-difference-between-increasing-elements/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 2016. Maximum Difference Between Increasing Elements
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1464. Maximum Product of Two Elements in an Array</title>
    <link href="http://noahsnail.com/2022/05/05/2022-05-05-Leetcode-1464-Maximum-Product-of-Two-Elements-in-an-Array/"/>
    <id>http://noahsnail.com/2022/05/05/2022-05-05-Leetcode-1464-Maximum-Product-of-Two-Elements-in-an-Array/</id>
    <published>2022-05-05T03:31:45.599Z</published>
    <updated>2022-05-07T05:40:46.498Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Product_of_Two_Elements_in_an_Array.png" alt="Maximum Product of Two Elements in an Array"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，两层循环遍历，O(N^2)。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        product = <span class="number">0</span></div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                product = max(product, (nums[i] - <span class="number">1</span>) * (nums[j] - <span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> product</div></pre></td></tr></table></figure>
<p><strong>解析：</strong>Version 2，找到数组里最大的两个元素即可，O(N)。</p>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        x1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        x2 = min(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">2</span>:]:</div><div class="line">            <span class="keyword">if</span> num &gt;= x1:</div><div class="line">                x2 = x1</div><div class="line">                x1 = num</div><div class="line">            <span class="keyword">elif</span> num &gt; x2:</div><div class="line">                x2 = num</div><div class="line">        product = (x1 - <span class="number">1</span>) * (x2 - <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> product</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/" target="_blank" rel="external">https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1464. Maximum Product of Two Elements in an Array
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1031. Maximum Sum of Two Non-Overlapping Subarrays</title>
    <link href="http://noahsnail.com/2021/09/02/2021-09-02-Leetcode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/"/>
    <id>http://noahsnail.com/2021/09/02/2021-09-02-Leetcode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/</id>
    <published>2021-09-02T06:31:49.035Z</published>
    <updated>2021-09-02T08:30:27.403Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Maximum_Sum_of_Two_Non-Overlapping_Subarrays.png" alt="Maximum Sum of Two Non-Overlapping Subarrays"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，先分别计算两个数组对应长度的连续子数组和，然后枚举所有符合条件的可能组合，找出最大和。Version 2使用前缀和，遍历前缀和，分别假设第一个子数组和在前和第二个子数组在前，求其最大值，即<code>first</code>和<code>second</code>，求第一个子数组的前缀和与当前的第二个子数组前缀和、第二个子数组的前缀和与当前的第一个子数组前缀和、之前最大和之间的最大值。为了便于计算以及索引校正，前缀和数组长度加<code>1</code>，初始值为<code>0</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, nums: List[int], firstLen: int, secondLen: int)</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        sum1 = <span class="number">0</span></div><div class="line">        sum2 = <span class="number">0</span></div><div class="line">        first = []</div><div class="line">        second = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> i &lt; firstLen:</div><div class="line">                sum1 += nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                first.append(sum1)</div><div class="line">                sum1 = sum1 + nums[i] - nums[i - firstLen]</div><div class="line">            <span class="keyword">if</span> i &lt; secondLen:</div><div class="line">                sum2 += nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                second.append(sum2)</div><div class="line">                sum2 = sum2 + nums[i] - nums[i - secondLen]</div><div class="line">        first.append(sum1)</div><div class="line">        second.append(sum2)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(first)):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + firstLen, len(second)):</div><div class="line">                maximum = max(maximum, first[i] + second[j])</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(second)):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j + secondLen, len(first)):</div><div class="line">                maximum = max(maximum, first[i] + second[j])</div><div class="line">        <span class="keyword">return</span> maximum</div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, nums: List[int], firstLen: int, secondLen: int)</span> -&gt; int:</span></div><div class="line">        n = len(nums)</div><div class="line">        maximum = <span class="number">0</span></div><div class="line">        prefix = [<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            prefix.append(prefix[<span class="number">-1</span>] + nums[i])</div><div class="line">        first = <span class="number">0</span></div><div class="line">        second = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(firstLen + secondLen, len(prefix)):</div><div class="line">            first = max(first, prefix[i - secondLen] - prefix[i - firstLen - secondLen])</div><div class="line">            second = max(second, prefix[i - firstLen] - prefix[i - firstLen - secondLen])</div><div class="line">            maximum = max(maximum, prefix[i] - prefix[i - secondLen] + first, prefix[i] - prefix[i - firstLen] + second)</div><div class="line">        <span class="keyword">return</span> maximum</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/" target="_blank" rel="external">https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1031. Maximum Sum of Two Non-Overlapping Subarrays
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 1512. Number of Good Pairs</title>
    <link href="http://noahsnail.com/2021/08/31/2021-08-31-Leetcode-1512-Number-of-Good-Pairs/"/>
    <id>http://noahsnail.com/2021/08/31/2021-08-31-Leetcode-1512-Number-of-Good-Pairs/</id>
    <published>2021-08-31T03:01:57.066Z</published>
    <updated>2021-09-02T00:52:13.191Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Number_of_Good_Pairs.png" alt="Number of Good Pairs"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，最容易想到的就是统计重复元素的个数，然后在此基础上进行数值对的统计，注意一个数只能构成<code>0</code>对，两个数只能构成<code>1</code>对，累加时应从<code>0</code>累加到<code>n-1</code>，<code>n</code>是重复元素的个数。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        stat = collections.defaultdict(int)</div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            count += stat[num]</div><div class="line">            stat[num] += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/number-of-good-pairs/" target="_blank" rel="external">https://leetcode.com/problems/number-of-good-pairs/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 1512. Number of Good Pairs
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 459. Repeated Substring Pattern</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-459-Repeated-Substring-Pattern/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-459-Repeated-Substring-Pattern/</id>
    <published>2021-08-30T08:49:45.689Z</published>
    <updated>2021-08-31T03:08:02.645Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Repeated_Substring_Pattern.png" alt="Repeated Substring Pattern"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，字符串是子串的重复，则字符串的结尾字符为子串的结尾字符，且至少存在两个重复的子串，因此寻找子串时，阈值应为<code>n // 2</code>，找到与结尾字符相等的字符，设开始到结尾字符的子串为候选子串，遍历<code>s</code>，其如果满足条件，返回<code>True</code>，如果始终没找到，返回<code>False</code>。Version 2进行了进一步优化，利用了重复子串的性质，即拆下第一部分放到末尾仍等于字符串<code>s</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s)</div><div class="line">        end = s[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</div><div class="line">            <span class="keyword">if</span> s[i] == end:</div><div class="line">                pattern = s[:i+<span class="number">1</span>]</div><div class="line">                flag = <span class="keyword">True</span></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s), len(pattern)):</div><div class="line">                    <span class="keyword">if</span> s[i:i+len(pattern)] != pattern:</div><div class="line">                        flag = <span class="keyword">False</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">if</span> flag:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s)</div><div class="line">        end = s[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</div><div class="line">            <span class="keyword">if</span> s[i] == end <span class="keyword">and</span> s == s[i+<span class="number">1</span>:] + s[:i+<span class="number">1</span>]:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/repeated-substring-pattern/" target="_blank" rel="external">https://leetcode.com/problems/repeated-substring-pattern/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 459. Repeated Substring Pattern
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 392. Is Subsequence</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-392-Is-Subsequence/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-392-Is-Subsequence/</id>
    <published>2021-08-30T05:17:27.507Z</published>
    <updated>2021-08-30T05:35:03.698Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Is_Subsequence.png" alt="Is Subsequence"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，依次比较字符串<code>s</code>和<code>t</code>中的字符。Version 2，为Leetcode 792做铺垫，先将<code>t</code>中的字符以及对应的索引保存到字典中，相同字符对应的索引构成一个有序序列，然后依次<code>s</code>中的每个字符，在<code>t</code>中查找其对应的字符索引位置，如果字符在<code>t</code>中不存在，直接返回<code>False</code>，<code>pre</code>表示单词中前一个字符在<code>t</code>中的索引位置，每次查找使用二分查找，如果返回的序列索引位置等于序列的长度，即<code>pre</code>位置之后的<code>t</code>中没找到对应的当前字符，则返回<code>False</code>，否则，更新<code>pre</code>为当前字符在<code>t</code>中的索引位置。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> j &lt; len(t):</div><div class="line">            <span class="keyword">if</span> s[i] == t[j]:</div><div class="line">                i += <span class="number">1</span></div><div class="line">                j += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i == len(s):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></div><div class="line">        stat = collections.defaultdict(list)</div><div class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(t):</div><div class="line">            stat[ch].append(i)</div><div class="line">        pre = <span class="number">-1</span></div><div class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stat:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            index = bisect.bisect(stat[ch], pre)</div><div class="line">            <span class="keyword">if</span> index == len(stat[ch]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pre = stat[ch][index]</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/is-subsequence/" target="_blank" rel="external">https://leetcode.com/problems/is-subsequence/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 392. Is Subsequence
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 792. Number of Matching Subsequences</title>
    <link href="http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-792-Number-of-Matching-Subsequences/"/>
    <id>http://noahsnail.com/2021/08/30/2021-08-30-Leetcode-792-Number-of-Matching-Subsequences/</id>
    <published>2021-08-30T01:43:28.916Z</published>
    <updated>2021-08-30T05:23:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Number_of_Matching_Subsequences.png" alt="Number of Matching Subsequences"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，每个单词都与<code>s</code>进行遍历比较，超时。Version 2，先将<code>s</code>中的字符以及对应的索引保存到字典中，相同字符对应的索引构成一个有序序列，然后依次遍历每个单词的每个字符，在<code>s</code>中查找其对应的字符索引位置，如果字符在<code>s</code>中不存在，直接跳出循环，<code>pre</code>表示单词中前一个字符在<code>s</code>中的索引位置，每次查找使用二分查找，如果返回的序列索引位置等于序列的长度，即<code>pre</code>位置之后的<code>s</code>中没找到对应的当前字符，否则，更新<code>pre</code>为当前字符在<code>s</code>中的索引位置，<code>flag</code>表示是否满足条件，初始设为<code>True</code>，当不满足条件跳出循环时，设为<code>False</code>，每个单词根据<code>flag</code>的值来统计满足条件的单词个数。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        n = len(s)</div><div class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">            m = len(word)</div><div class="line">            <span class="keyword">if</span> m &gt; n:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            i = <span class="number">0</span></div><div class="line">            j = <span class="number">0</span></div><div class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</div><div class="line">                <span class="keyword">if</span> s[i] == word[j]:</div><div class="line">                    i += <span class="number">1</span></div><div class="line">                    j += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    i += <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> m - j - <span class="number">1</span> &gt; n - i - <span class="number">1</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> j == m:</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<ul>
<li>Version 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        stat = collections.defaultdict(list)</div><div class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</div><div class="line">            stat[ch].append(i)</div><div class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">            flag = <span class="keyword">True</span></div><div class="line">            pre = <span class="number">-1</span></div><div class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</div><div class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stat:</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                index = bisect.bisect(stat[ch], pre)</div><div class="line">                <span class="keyword">if</span> index == len(stat[ch]):</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pre = stat[ch][index]</div><div class="line">            <span class="keyword">if</span> flag:</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/number-of-matching-subsequences/" target="_blank" rel="external">https://leetcode.com/problems/number-of-matching-subsequences/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 792. Number of Matching Subsequences
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 567. Permutation in String</title>
    <link href="http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-567-Permutation-in-String/"/>
    <id>http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-567-Permutation-in-String/</id>
    <published>2021-08-27T06:56:30.160Z</published>
    <updated>2021-08-27T06:58:03.067Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Permutation_in_String.png" alt="Permutation in String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，此题与leetcode 438非常类似，思路是一样的。判断<code>s2</code>是否包含<code>s1</code>的变换，可以采用字典的方法，即每个字母的个数及类型相等。先统计字符串<code>s1</code>的字母个数并记录其长度在<code>stat</code>中，遍历字符串<code>s2</code>，如果字母在<code>stat</code>中，则将其记录到字典<code>subs</code>中，否则重置<code>subs</code>，当<code>subs[&#39;length&#39;] = stat[&#39;length&#39;]</code>时，比较二者是否相等，如果相等，直接返回<code>True</code>，否则，字符串继续遍历，为保证<code>subs</code>长度与<code>stat</code>长度一致，此时，<code>subs</code>中移除<code>s2[index - n + 1]</code>字符，同时长度减<code>1</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></div><div class="line">        n = len(s1)</div><div class="line">        stat = collections.Counter(s1)</div><div class="line">        stat[<span class="string">'length'</span>] = n</div><div class="line">        subs = collections.defaultdict(int)</div><div class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> enumerate(s2):</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> stat:</div><div class="line">                subs[ch] += <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                subs = collections.defaultdict(int)</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> subs[<span class="string">'length'</span>] == stat[<span class="string">'length'</span>]:</div><div class="line">                <span class="keyword">if</span> stat == subs:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                subs[s2[index - n + <span class="number">1</span>]] -= <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="external">https://leetcode.com/problems/permutation-in-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 567. Permutation in String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 438. Find All Anagrams in a String</title>
    <link href="http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-438-Find-All-Anagrams-in-a-String/"/>
    <id>http://noahsnail.com/2021/08/27/2021-08-27-Leetcode-438-Find-All-Anagrams-in-a-String/</id>
    <published>2021-08-27T06:37:22.477Z</published>
    <updated>2021-08-27T06:45:28.077Z</updated>
    
    <content type="html"><![CDATA[<p>文章作者：Tyan<br>博客：<a href="http://noahsnail.com">noahsnail.com</a> &nbsp;|&nbsp; <a href="http://blog.csdn.net/quincuntial" target="_blank" rel="external">CSDN</a> &nbsp;|&nbsp; <a href="http://www.jianshu.com/users/7731e83f3a4e/latest_articles" target="_blank" rel="external">简书</a></p>
<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description"></a>1. Description</h2><p><img src="http://noahsnail.com/images/leetcode/Find_All_Anagrams_in_a_String.png" alt="Find All Anagrams in a String"></p>
<h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p><strong>解析：</strong>Version 1，判断两个字符串是否是Anagrams，可以采用字典的方法，即每个字母的个数及类型相等。先统计字符串<code>p</code>的字母个数并记录其长度在<code>stat</code>中，遍历字符串<code>s</code>，如果字母在<code>stat</code>中，则将其记录到字典<code>subs</code>中，否则重置<code>subs</code>，当<code>subs[&#39;length&#39;] = stat[&#39;length&#39;]</code>时，比较二者是否相等，如果相等，则记录索引<code>index - n + 1</code>到结果列表中，此时字符串继续遍历，为保证<code>subs</code>长度与<code>stat</code>长度一致，此时，<code>subs</code>中移除<code>s[index - n + 1]</code>字符，同时长度减<code>1</code>。</p>
<ul>
<li>Version 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></div><div class="line">        stat = collections.Counter(p)</div><div class="line">        n = len(p)</div><div class="line">        stat[<span class="string">'length'</span>] = n</div><div class="line">        result = []</div><div class="line">        subs = collections.defaultdict(int)</div><div class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> enumerate(s):</div><div class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> stat:</div><div class="line">                subs[ch] += <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                subs = collections.defaultdict(int)</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> subs[<span class="string">'length'</span>] == stat[<span class="string">'length'</span>]:</div><div class="line">                <span class="keyword">if</span> stat == subs:</div><div class="line">                    result.append(index - n + <span class="number">1</span>)</div><div class="line">                subs[s[index - n + <span class="number">1</span>]] -= <span class="number">1</span></div><div class="line">                subs[<span class="string">'length'</span>] -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="external">https://leetcode.com/problems/find-all-anagrams-in-a-string/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Leetcode 438. Find All Anagrams in a String
    
    </summary>
    
      <category term="基础算法" scheme="http://noahsnail.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://noahsnail.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
